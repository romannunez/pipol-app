{"file_contents":{"add-multimedia-columns.js":{"content":"import { createClient } from '@supabase/supabase-js';\nimport 'dotenv/config';\n\nconst supabaseUrl = process.env.SUPABASE_URL;\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\nif (!supabaseUrl || !supabaseServiceKey) {\n  console.error('Missing Supabase environment variables');\n  process.exit(1);\n}\n\nconst supabase = createClient(supabaseUrl, supabaseServiceKey);\n\nasync function addMultimediaColumns() {\n  try {\n    console.log('Adding multimedia columns to events table...');\n    \n    // Add multimedia columns one by one\n    const columns = [\n      'photo_url text',\n      'video_url text', \n      'media_items text',\n      'main_media_type text',\n      'main_media_url text'\n    ];\n    \n    for (const column of columns) {\n      const { data, error } = await supabase.rpc('exec_sql', {\n        sql: `ALTER TABLE events ADD COLUMN IF NOT EXISTS ${column};`\n      });\n      \n      if (error) {\n        // Try alternative approach using raw SQL\n        const { data: altData, error: altError } = await supabase\n          .from('_raw_sql')\n          .select('*')\n          .eq('query', `ALTER TABLE events ADD COLUMN IF NOT EXISTS ${column};`);\n        \n        if (altError) {\n          console.log(`Column ${column.split(' ')[0]} may already exist or added successfully`);\n        } else {\n          console.log(`Added column: ${column.split(' ')[0]}`);\n        }\n      } else {\n        console.log(`Added column: ${column.split(' ')[0]}`);\n      }\n    }\n    \n    console.log('Multimedia columns setup complete');\n    \n    // Verify columns exist by checking table schema\n    const { data: tableInfo, error: schemaError } = await supabase\n      .from('information_schema.columns')\n      .select('column_name')\n      .eq('table_name', 'events')\n      .in('column_name', ['photo_url', 'video_url', 'media_items', 'main_media_type', 'main_media_url']);\n    \n    if (!schemaError && tableInfo) {\n      console.log('Found multimedia columns:', tableInfo.map(col => col.column_name));\n    }\n    \n  } catch (error) {\n    console.error('Error adding multimedia columns:', error);\n  }\n}\n\naddMultimediaColumns();","size_bytes":2120},"check-database-state.js":{"content":"import { createClient } from '@supabase/supabase-js';\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nconst supabaseUrl = process.env.SUPABASE_URL;\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\nconst supabase = createClient(supabaseUrl, supabaseServiceKey);\n\nasync function checkDatabaseState() {\n  console.log('Checking actual database state...');\n\n  // Check what columns exist in events table\n  try {\n    const { data: columns, error } = await supabase\n      .from('information_schema.columns')\n      .select('column_name, data_type')\n      .eq('table_name', 'events')\n      .eq('table_schema', 'public');\n\n    if (columns && columns.length > 0) {\n      console.log('Events table columns:');\n      columns.sort((a, b) => a.column_name.localeCompare(b.column_name)).forEach(col => {\n        console.log(`  - ${col.column_name} (${col.data_type})`);\n      });\n    } else {\n      console.log('No columns found or error:', error?.message);\n    }\n  } catch (err) {\n    console.log('Error checking columns:', err.message);\n  }\n\n  // Check what tables exist\n  try {\n    const { data: tables, error } = await supabase\n      .from('information_schema.tables')\n      .select('table_name')\n      .eq('table_schema', 'public');\n\n    if (tables) {\n      console.log('Existing tables:', tables.map(t => t.table_name).sort());\n    }\n  } catch (err) {\n    console.log('Error checking tables:', err.message);\n  }\n\n  // Try to access events table directly\n  try {\n    const { data, error } = await supabase\n      .from('events')\n      .select('id, title, category, privacy_type')\n      .limit(1);\n    \n    console.log('Events table query result:', { success: !error, error: error?.message });\n  } catch (err) {\n    console.log('Direct events query error:', err.message);\n  }\n}\n\ncheckDatabaseState();","size_bytes":1805},"create-db-tables.js":{"content":"import postgres from 'postgres';\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nconst createTables = async () => {\n  const sql = postgres(process.env.DATABASE_URL);\n  \n  try {\n    console.log('Creating database tables...');\n    \n    // Create users table first\n    await sql`\n      CREATE TABLE IF NOT EXISTS users (\n        id SERIAL PRIMARY KEY,\n        username TEXT NOT NULL UNIQUE,\n        email TEXT NOT NULL UNIQUE,\n        password TEXT,\n        name TEXT NOT NULL,\n        bio TEXT,\n        avatar TEXT,\n        supabase_id TEXT UNIQUE,\n        stripe_customer_id TEXT,\n        stripe_subscription_id TEXT,\n        created_at TIMESTAMP DEFAULT NOW() NOT NULL,\n        updated_at TIMESTAMP DEFAULT NOW() NOT NULL\n      )\n    `;\n    \n    console.log('Users table created successfully');\n    \n    await sql.end();\n    return true;\n  } catch (error) {\n    console.error('Error creating tables:', error);\n    await sql.end();\n    return false;\n  }\n};\n\ncreateTables().then(success => {\n  console.log(success ? 'Database setup complete' : 'Database setup failed');\n  process.exit(success ? 0 : 1);\n});","size_bytes":1104},"create-event-attendees-table.js":{"content":"import { createClient } from '@supabase/supabase-js';\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nconst supabaseUrl = process.env.SUPABASE_URL;\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\nif (!supabaseUrl || !supabaseServiceKey) {\n  console.error('Missing Supabase credentials');\n  process.exit(1);\n}\n\nconst supabase = createClient(supabaseUrl, supabaseServiceKey);\n\nasync function createEventAttendeesTable() {\n  try {\n    console.log('Creating event_attendees table...');\n    \n    // First, create the attendee_status enum if it doesn't exist\n    const { error: enumError } = await supabase.rpc('create_enum_if_not_exists', {\n      enum_name: 'attendee_status',\n      enum_values: ['pending', 'approved', 'rejected']\n    });\n    \n    if (enumError) {\n      console.log('Enum creation result:', enumError.message);\n    }\n    \n    // Create the table using raw SQL\n    const createTableSQL = `\n      CREATE TABLE IF NOT EXISTS event_attendees (\n        id SERIAL PRIMARY KEY,\n        event_id INTEGER NOT NULL REFERENCES events(id),\n        user_id INTEGER NOT NULL REFERENCES users(id),\n        status attendee_status DEFAULT 'approved' NOT NULL,\n        payment_status TEXT DEFAULT 'pending',\n        payment_intent_id TEXT,\n        created_at TIMESTAMP DEFAULT NOW() NOT NULL,\n        UNIQUE(event_id, user_id)\n      );\n    `;\n    \n    const { data, error } = await supabase.rpc('exec_sql', { \n      sql: createTableSQL \n    });\n    \n    if (error) {\n      console.error('Error creating table:', error);\n      \n      // Try alternative approach with direct query\n      const { error: directError } = await supabase\n        .from('event_attendees')\n        .select('*')\n        .limit(1);\n        \n      if (directError && directError.code === '42P01') {\n        console.log('Table does not exist, attempting to create with service key...');\n        // We need to create this table through Supabase dashboard or use a different approach\n        console.log('Please create the event_attendees table manually in Supabase dashboard with this SQL:');\n        console.log(createTableSQL);\n      }\n    } else {\n      console.log('✓ event_attendees table created successfully');\n    }\n    \n  } catch (error) {\n    console.error('Error:', error);\n  }\n}\n\ncreateEventAttendeesTable();","size_bytes":2305},"create-notifications-supabase.js":{"content":"import { createClient } from '@supabase/supabase-js';\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nconst supabaseUrl = process.env.SUPABASE_URL;\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.SUPABASE_ANON_KEY;\n\nif (!supabaseUrl || !supabaseServiceKey) {\n  console.error('Missing Supabase credentials');\n  process.exit(1);\n}\n\nconst supabase = createClient(supabaseUrl, supabaseServiceKey);\n\nasync function createNotificationsTable() {\n  try {\n    console.log('🔧 Creating notification_type enum...');\n    \n    // Create enum type first\n    const { error: enumError } = await supabase.rpc('exec_sql', {\n      sql: `\n        DO $$ BEGIN\n          CREATE TYPE notification_type AS ENUM ('new_request', 'request_approved', 'request_rejected');\n        EXCEPTION\n          WHEN duplicate_object THEN null;\n        END $$;\n      `\n    });\n\n    if (enumError) {\n      console.error('Error creating enum:', enumError);\n    } else {\n      console.log('✅ notification_type enum created/exists');\n    }\n\n    console.log('🔧 Creating notifications table...');\n    \n    // Create notifications table\n    const { error: tableError } = await supabase.rpc('exec_sql', {\n      sql: `\n        CREATE TABLE IF NOT EXISTS notifications (\n          id SERIAL PRIMARY KEY,\n          user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n          type notification_type NOT NULL,\n          title TEXT NOT NULL,\n          message TEXT NOT NULL,\n          event_id INTEGER REFERENCES events(id) ON DELETE CASCADE,\n          request_id INTEGER,\n          is_read BOOLEAN DEFAULT FALSE,\n          created_at TIMESTAMPTZ DEFAULT NOW(),\n          updated_at TIMESTAMPTZ DEFAULT NOW()\n        );\n        \n        CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON notifications(user_id);\n        CREATE INDEX IF NOT EXISTS idx_notifications_created_at ON notifications(created_at);\n        CREATE INDEX IF NOT EXISTS idx_notifications_is_read ON notifications(is_read);\n      `\n    });\n\n    if (tableError) {\n      console.error('Error creating notifications table:', tableError);\n    } else {\n      console.log('✅ notifications table created successfully');\n    }\n\n    // Verify table exists\n    const { data: tables, error: verifyError } = await supabase\n      .from('information_schema.tables')\n      .select('table_name')\n      .eq('table_schema', 'public')\n      .eq('table_name', 'notifications');\n\n    if (verifyError) {\n      console.error('Error verifying table:', verifyError);\n    } else if (tables && tables.length > 0) {\n      console.log('✅ notifications table verified in database');\n    } else {\n      console.log('❌ notifications table not found after creation');\n    }\n\n  } catch (error) {\n    console.error('Exception creating notifications table:', error);\n  }\n}\n\ncreateNotificationsTable().then(() => {\n  console.log('🎉 Notifications table setup complete');\n  process.exit(0);\n}).catch(error => {\n  console.error('Failed to create notifications table:', error);\n  process.exit(1);\n});","size_bytes":3043},"create-notifications-table-direct.js":{"content":"import { createClient } from '@supabase/supabase-js';\nimport 'dotenv/config';\n\nconsole.log('Environment check:');\nconsole.log('SUPABASE_URL:', process.env.SUPABASE_URL ? 'Set' : 'Missing');\nconsole.log('SUPABASE_ANON_KEY:', process.env.SUPABASE_ANON_KEY ? 'Set' : 'Missing');\n\nconst supabase = createClient(\n  process.env.SUPABASE_URL,\n  process.env.SUPABASE_ANON_KEY\n);\n\nasync function createNotificationsTable() {\n  console.log('🔧 Creating notifications table directly...');\n\n  // First, let's try to create the enum type using raw SQL\n  try {\n    console.log('Creating notification_type enum...');\n    const { data: enumData, error: enumError } = await supabase\n      .rpc('exec_sql', {\n        sql: \"CREATE TYPE notification_type AS ENUM ('request_approved', 'request_rejected', 'new_request');\"\n      });\n      \n    if (enumError && !enumError.message.includes('already exists')) {\n      console.error('Error creating enum:', enumError);\n    } else {\n      console.log('✅ Enum ready');\n    }\n  } catch (error) {\n    console.log('Enum might already exist, continuing...');\n  }\n\n  // Now create the table\n  try {\n    console.log('Creating notifications table...');\n    const { data, error } = await supabase\n      .rpc('exec_sql', {\n        sql: `\n        CREATE TABLE IF NOT EXISTS notifications (\n          id SERIAL PRIMARY KEY,\n          user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n          type notification_type NOT NULL,\n          title TEXT NOT NULL,\n          message TEXT NOT NULL,\n          event_id INTEGER REFERENCES events(id) ON DELETE CASCADE,\n          request_id INTEGER REFERENCES event_attendees(id) ON DELETE CASCADE,\n          is_read BOOLEAN DEFAULT FALSE NOT NULL,\n          created_at TIMESTAMP DEFAULT NOW() NOT NULL\n        );\n        `\n      });\n      \n    if (error) {\n      console.error('❌ Error creating table:', error);\n    } else {\n      console.log('✅ Table creation command executed');\n    }\n\n    // Test access\n    const { data: testData, error: testError } = await supabase\n      .from('notifications')\n      .select('*')\n      .limit(1);\n\n    if (testError) {\n      console.error('❌ Table test failed:', testError);\n    } else {\n      console.log('✅ Notifications table is accessible and ready');\n    }\n\n  } catch (error) {\n    console.error('❌ Unexpected error:', error);\n  }\n}\n\ncreateNotificationsTable();","size_bytes":2386},"create-remaining-tables.sh":{"content":"#!/bin/bash\n\n# Create remaining tables for Pipol application\nexport PGPASSWORD=\"${DATABASE_PASSWORD}\"\n\npsql -h aws-0-sa-east-1.pooler.supabase.com -p 6543 -U postgres.pbvkjkjdtwftjetpreai -d postgres << 'EOF'\n\n-- Create events table\nCREATE TABLE IF NOT EXISTS public.events (\n    id BIGSERIAL PRIMARY KEY,\n    title TEXT NOT NULL,\n    description TEXT,\n    category TEXT NOT NULL,\n    date TIMESTAMP WITH TIME ZONE NOT NULL,\n    latitude NUMERIC(10, 8) NOT NULL,\n    longitude NUMERIC(11, 8) NOT NULL,\n    location_name TEXT NOT NULL,\n    location_address TEXT NOT NULL,\n    payment_type TEXT NOT NULL DEFAULT 'free',\n    price NUMERIC(10, 2),\n    max_capacity INTEGER,\n    privacy_type TEXT NOT NULL DEFAULT 'public',\n    organizer_id BIGINT NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,\n    media_items JSONB DEFAULT '[]'::jsonb,\n    main_media_url TEXT,\n    main_media_type TEXT,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL\n);\n\n-- Create attendees table\nCREATE TABLE IF NOT EXISTS public.attendees (\n    id BIGSERIAL PRIMARY KEY,\n    event_id BIGINT NOT NULL REFERENCES public.events(id) ON DELETE CASCADE,\n    user_id BIGINT NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,\n    status TEXT NOT NULL DEFAULT 'confirmed',\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,\n    UNIQUE(event_id, user_id)\n);\n\n-- Create messages table\nCREATE TABLE IF NOT EXISTS public.messages (\n    id BIGSERIAL PRIMARY KEY,\n    event_id BIGINT NOT NULL REFERENCES public.events(id) ON DELETE CASCADE,\n    user_id BIGINT NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,\n    content TEXT NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL\n);\n\n-- Create indexes for better performance\nCREATE INDEX IF NOT EXISTS idx_events_organizer_id ON public.events(organizer_id);\nCREATE INDEX IF NOT EXISTS idx_events_date ON public.events(date);\nCREATE INDEX IF NOT EXISTS idx_events_category ON public.events(category);\nCREATE INDEX IF NOT EXISTS idx_events_location ON public.events(latitude, longitude);\n\nCREATE INDEX IF NOT EXISTS idx_attendees_event_id ON public.attendees(event_id);\nCREATE INDEX IF NOT EXISTS idx_attendees_user_id ON public.attendees(user_id);\n\nCREATE INDEX IF NOT EXISTS idx_messages_event_id ON public.messages(event_id);\nCREATE INDEX IF NOT EXISTS idx_messages_user_id ON public.messages(user_id);\n\n-- Enable RLS on all tables\nALTER TABLE public.events ENABLE ROW LEVEL SECURITY;\nALTER TABLE public.attendees ENABLE ROW LEVEL SECURITY;\nALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;\n\n-- Verify all tables exist\nSELECT 'All tables created successfully' as result;\nSELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_type = 'BASE TABLE';\n\nEOF\n\necho \"All database tables created successfully\"","size_bytes":2874},"create-schema.js":{"content":"// Script para crear el esquema de la base de datos usando pgSQL\nimport pkg from 'pg';\nconst { Client } = pkg;\n\nasync function createSchema() {\n  try {\n    const client = new Client({\n      connectionString: process.env.DATABASE_URL\n    });\n    \n    await client.connect();\n    \n    console.log('Conectado a la base de datos');\n    \n    // Crear los tipos ENUM\n    await client.query(`\n      DO $$ BEGIN\n        CREATE TYPE event_category AS ENUM (\n          'social', 'music', 'spiritual', 'education', 'sports', 'food', 'art', 'technology',\n          'games', 'outdoor', 'networking', 'workshop', 'conference', 'party', 'fair', 'exhibition'\n        );\n      EXCEPTION\n        WHEN duplicate_object THEN null;\n      END $$;\n    `);\n    \n    await client.query(`\n      DO $$ BEGIN\n        CREATE TYPE privacy_type AS ENUM ('public', 'private');\n      EXCEPTION\n        WHEN duplicate_object THEN null;\n      END $$;\n    `);\n    \n    await client.query(`\n      DO $$ BEGIN\n        CREATE TYPE private_access_type AS ENUM ('solicitud', 'postulacion', 'paga');\n      EXCEPTION\n        WHEN duplicate_object THEN null;\n      END $$;\n    `);\n    \n    await client.query(`\n      DO $$ BEGIN\n        CREATE TYPE payment_type AS ENUM ('free', 'paid');\n      EXCEPTION\n        WHEN duplicate_object THEN null;\n      END $$;\n    `);\n    \n    await client.query(`\n      DO $$ BEGIN\n        CREATE TYPE multimedia_type AS ENUM ('photo', 'video');\n      EXCEPTION\n        WHEN duplicate_object THEN null;\n      END $$;\n    `);\n    \n    await client.query(`\n      DO $$ BEGIN\n        CREATE TYPE attendee_status AS ENUM ('pending', 'approved', 'rejected');\n      EXCEPTION\n        WHEN duplicate_object THEN null;\n      END $$;\n    `);\n    \n    console.log('Tipos ENUM creados');\n    \n    // Crear tabla users\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS users (\n        id SERIAL PRIMARY KEY,\n        username TEXT NOT NULL UNIQUE,\n        email TEXT NOT NULL UNIQUE,\n        password TEXT NOT NULL,\n        name TEXT NOT NULL,\n        bio TEXT,\n        avatar TEXT,\n        stripe_customer_id TEXT,\n        stripe_subscription_id TEXT,\n        created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n        updated_at TIMESTAMP NOT NULL DEFAULT NOW()\n      );\n    `);\n    \n    console.log('Tabla users creada');\n    \n    // Crear tabla events\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS events (\n        id SERIAL PRIMARY KEY,\n        title TEXT NOT NULL,\n        description TEXT NOT NULL,\n        category event_category NOT NULL,\n        date TIMESTAMP NOT NULL,\n        latitude DECIMAL(10, 6) NOT NULL,\n        longitude DECIMAL(10, 6) NOT NULL,\n        location_name TEXT NOT NULL,\n        location_address TEXT NOT NULL,\n        payment_type payment_type NOT NULL DEFAULT 'free',\n        price DECIMAL(10, 2),\n        max_capacity INTEGER,\n        privacy_type privacy_type NOT NULL DEFAULT 'public',\n        private_access_type private_access_type,\n        application_questions TEXT,\n        photo_url TEXT,\n        photo_urls TEXT,\n        video_url TEXT,\n        video_urls TEXT,\n        media_items TEXT,\n        main_media_type multimedia_type DEFAULT 'photo',\n        main_media_url TEXT,\n        organizer_id INTEGER NOT NULL REFERENCES users(id),\n        created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n        updated_at TIMESTAMP NOT NULL DEFAULT NOW()\n      );\n    `);\n    \n    console.log('Tabla events creada');\n    \n    // Crear tabla event_attendees\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS event_attendees (\n        id SERIAL PRIMARY KEY,\n        event_id INTEGER NOT NULL REFERENCES events(id),\n        user_id INTEGER NOT NULL REFERENCES users(id),\n        status attendee_status NOT NULL DEFAULT 'approved',\n        payment_status TEXT DEFAULT 'pending',\n        payment_intent_id TEXT,\n        created_at TIMESTAMP NOT NULL DEFAULT NOW()\n      );\n    `);\n    \n    console.log('Tabla event_attendees creada');\n    \n    // Crear tabla user_interests\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS user_interests (\n        id SERIAL PRIMARY KEY,\n        user_id INTEGER NOT NULL REFERENCES users(id),\n        category event_category NOT NULL,\n        created_at TIMESTAMP NOT NULL DEFAULT NOW()\n      );\n    `);\n    \n    console.log('Tabla user_interests creada');\n    \n    // Crear tabla sessions (Para autenticación)\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS sessions (\n        sid VARCHAR NOT NULL PRIMARY KEY,\n        sess JSON NOT NULL,\n        expire TIMESTAMP NOT NULL\n      );\n      \n      CREATE INDEX IF NOT EXISTS IDX_session_expire ON sessions (expire);\n    `);\n    \n    console.log('Tabla sessions creada');\n    \n    await client.end();\n    \n    console.log('Esquema de base de datos creado exitosamente');\n    \n  } catch (error) {\n    console.error('Error al crear el esquema:', error);\n    process.exit(1);\n  }\n}\n\ncreateSchema();","size_bytes":4916},"create-table-direct-sql.js":{"content":"import { createClient } from '@supabase/supabase-js';\nimport dotenv from 'dotenv';\ndotenv.config();\n\nconst supabaseUrl = process.env.SUPABASE_URL;\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\nif (!supabaseUrl || !supabaseServiceKey) {\n  console.error('Missing Supabase credentials');\n  process.exit(1);\n}\n\nconst supabase = createClient(supabaseUrl, supabaseServiceKey, {\n  auth: {\n    autoRefreshToken: false,\n    persistSession: false\n  }\n});\n\nasync function createUserInterestsTable() {\n  try {\n    console.log('Creating user_interests table using direct SQL...');\n    \n    // Create the table\n    const createTableSQL = `\n      CREATE TABLE IF NOT EXISTS user_interests (\n        id SERIAL PRIMARY KEY,\n        user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n        category TEXT NOT NULL,\n        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n        UNIQUE(user_id, category)\n      );\n    `;\n    \n    // Use the SQL editor endpoint directly\n    const response = await fetch(`${supabaseUrl}/rest/v1/rpc/exec_sql`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${supabaseServiceKey}`,\n        'apikey': supabaseServiceKey,\n        'Prefer': 'return=representation'\n      },\n      body: JSON.stringify({\n        query: createTableSQL\n      })\n    });\n\n    if (!response.ok) {\n      console.log('Direct SQL approach failed, trying alternative...');\n      \n      // Alternative: Use pg client\n      const pg = await import('pg');\n      const { Client } = pg.default;\n      \n      // Extract connection details from Supabase URL\n      const dbUrl = process.env.DATABASE_URL;\n      if (dbUrl) {\n        const client = new Client({ connectionString: dbUrl });\n        \n        try {\n          await client.connect();\n          console.log('Connected to database via pg client');\n          \n          await client.query(createTableSQL);\n          console.log('Table created successfully via pg client');\n          \n          // Test the table\n          const result = await client.query('SELECT COUNT(*) FROM user_interests');\n          console.log('Table verification successful - user_interests table exists!');\n          \n          await client.end();\n          return;\n        } catch (pgError) {\n          console.error('PG client error:', pgError.message);\n          await client.end();\n        }\n      }\n    } else {\n      console.log('Table created successfully via Supabase SQL endpoint');\n    }\n\n    // Test if we can access the table\n    const { data, error } = await supabase\n      .from('user_interests')\n      .select('count', { count: 'exact' });\n    \n    if (error) {\n      console.error('Table verification failed:', error.message);\n      console.log('\\nPlease manually create the table in Supabase SQL Editor:');\n      console.log(createTableSQL);\n    } else {\n      console.log('Table verification successful - user_interests table exists!');\n    }\n\n  } catch (error) {\n    console.error('Error creating table:', error.message);\n    console.log('\\nPlease manually create the table in Supabase SQL Editor:');\n    console.log(`\nCREATE TABLE IF NOT EXISTS user_interests (\n  id SERIAL PRIMARY KEY,\n  user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n  category TEXT NOT NULL,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  UNIQUE(user_id, category)\n);\n    `);\n  }\n}\n\ncreateUserInterestsTable();","size_bytes":3558},"create-table-direct.js":{"content":"import { createClient } from '@supabase/supabase-js';\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nconst supabaseUrl = process.env.SUPABASE_URL;\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\nif (!supabaseUrl || !supabaseServiceKey) {\n  console.error('Missing Supabase credentials');\n  process.exit(1);\n}\n\n// Create admin client with service role key\nconst supabase = createClient(supabaseUrl, supabaseServiceKey, {\n  auth: { persistSession: false },\n  db: { schema: 'public' }\n});\n\nasync function createTableDirect() {\n  try {\n    console.log('Creating event_attendees table via REST API...');\n    \n    // First, check what tables exist\n    const { data: tables, error: tablesError } = await supabase\n      .from('information_schema.tables')\n      .select('table_name')\n      .eq('table_schema', 'public');\n      \n    if (!tablesError) {\n      console.log('Existing tables:', tables.map(t => t.table_name));\n    }\n    \n    // Try to create the enum using a different approach\n    const response = await fetch(`${supabaseUrl}/rest/v1/rpc/exec`, {\n      method: 'POST',\n      headers: {\n        'apikey': supabaseServiceKey,\n        'Authorization': `Bearer ${supabaseServiceKey}`,\n        'Content-Type': 'application/json',\n        'Prefer': 'return=minimal'\n      },\n      body: JSON.stringify({\n        sql: `\n          DO $$ BEGIN\n              CREATE TYPE attendee_status AS ENUM ('pending', 'approved', 'rejected');\n          EXCEPTION\n              WHEN duplicate_object THEN null;\n          END $$;\n          \n          CREATE TABLE IF NOT EXISTS event_attendees (\n              id SERIAL PRIMARY KEY,\n              event_id INTEGER NOT NULL REFERENCES events(id) ON DELETE CASCADE,\n              user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n              status attendee_status DEFAULT 'approved' NOT NULL,\n              payment_status TEXT DEFAULT 'pending',\n              payment_intent_id TEXT,\n              created_at TIMESTAMP DEFAULT NOW() NOT NULL,\n              UNIQUE(event_id, user_id)\n          );\n          \n          CREATE INDEX IF NOT EXISTS idx_event_attendees_event_id ON event_attendees(event_id);\n          CREATE INDEX IF NOT EXISTS idx_event_attendees_user_id ON event_attendees(user_id);\n        `\n      })\n    });\n    \n    const result = await response.text();\n    console.log('SQL execution response:', response.status, result);\n    \n    // Test if table was created by trying to query it\n    const { data: testData, error: testError } = await supabase\n      .from('event_attendees')\n      .select('id')\n      .limit(1);\n      \n    if (testError) {\n      console.error('Table creation failed:', testError);\n      console.log('\\nPlease manually execute this SQL in Supabase Dashboard:');\n      console.log(`\nDO $$ BEGIN\n    CREATE TYPE attendee_status AS ENUM ('pending', 'approved', 'rejected');\nEXCEPTION\n    WHEN duplicate_object THEN null;\nEND $$;\n\nCREATE TABLE IF NOT EXISTS event_attendees (\n    id SERIAL PRIMARY KEY,\n    event_id INTEGER NOT NULL REFERENCES events(id) ON DELETE CASCADE,\n    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    status attendee_status DEFAULT 'approved' NOT NULL,\n    payment_status TEXT DEFAULT 'pending',\n    payment_intent_id TEXT,\n    created_at TIMESTAMP DEFAULT NOW() NOT NULL,\n    UNIQUE(event_id, user_id)\n);\n\nCREATE INDEX IF NOT EXISTS idx_event_attendees_event_id ON event_attendees(event_id);\nCREATE INDEX IF NOT EXISTS idx_event_attendees_user_id ON event_attendees(user_id);\n      `);\n    } else {\n      console.log('✓ event_attendees table created successfully!');\n    }\n    \n  } catch (error) {\n    console.error('Error:', error);\n  }\n}\n\ncreateTableDirect();","size_bytes":3708},"create-table-via-supabase-api.js":{"content":"import fetch from 'node-fetch';\n\nconst createUsersTable = async () => {\n  const supabaseUrl = process.env.SUPABASE_URL;\n  const supabaseKey = process.env.SUPABASE_ANON_KEY;\n  \n  console.log('Creating users table via Supabase REST API...');\n  \n  const sql = `\n    CREATE TABLE IF NOT EXISTS public.users (\n        id BIGSERIAL PRIMARY KEY,\n        username TEXT NOT NULL UNIQUE,\n        email TEXT NOT NULL UNIQUE,\n        password TEXT,\n        name TEXT NOT NULL,\n        bio TEXT,\n        avatar TEXT,\n        supabase_id TEXT UNIQUE,\n        stripe_customer_id TEXT,\n        stripe_subscription_id TEXT,\n        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,\n        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL\n    );\n\n    CREATE INDEX IF NOT EXISTS idx_users_email ON public.users(email);\n    CREATE INDEX IF NOT EXISTS idx_users_username ON public.users(username);\n    CREATE INDEX IF NOT EXISTS idx_users_supabase_id ON public.users(supabase_id);\n\n    ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;\n\n    CREATE POLICY IF NOT EXISTS \"Enable insert for registration\" ON public.users\n        FOR INSERT WITH CHECK (true);\n\n    CREATE POLICY IF NOT EXISTS \"Users can view own data\" ON public.users\n        FOR SELECT USING (auth.uid()::text = supabase_id);\n\n    CREATE POLICY IF NOT EXISTS \"Users can update own data\" ON public.users\n        FOR UPDATE USING (auth.uid()::text = supabase_id);\n  `;\n\n  try {\n    const response = await fetch(`${supabaseUrl}/rest/v1/rpc/exec_sql`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'apikey': supabaseKey,\n        'Authorization': `Bearer ${supabaseKey}`\n      },\n      body: JSON.stringify({ sql })\n    });\n\n    if (!response.ok) {\n      console.log('Direct SQL execution not available, checking table existence...');\n      \n      // Check if table exists by querying it\n      const checkResponse = await fetch(`${supabaseUrl}/rest/v1/users?select=id&limit=1`, {\n        headers: {\n          'apikey': supabaseKey,\n          'Authorization': `Bearer ${supabaseKey}`\n        }\n      });\n\n      if (checkResponse.status === 404 || checkResponse.status === 406) {\n        console.log('Users table does not exist - manual creation required');\n        return false;\n      } else if (checkResponse.ok) {\n        console.log('Users table already exists');\n        return true;\n      } else {\n        console.log('Unable to verify table status');\n        return false;\n      }\n    }\n\n    const result = await response.json();\n    console.log('Table creation result:', result);\n    return true;\n\n  } catch (error) {\n    console.error('Error creating table:', error);\n    return false;\n  }\n};\n\ncreateUsersTable().then(success => {\n  if (success) {\n    console.log('Users table is ready - registration should work');\n  } else {\n    console.log('Table creation incomplete - run SQL manually in Supabase dashboard');\n  }\n  process.exit(0);\n});","size_bytes":2955},"create-tables-direct.js":{"content":"import { createClient } from '@supabase/supabase-js';\n\nconst supabaseUrl = process.env.SUPABASE_URL;\nconst supabaseKey = process.env.SUPABASE_ANON_KEY;\n\nconsole.log('Creating Supabase client...');\nconst supabase = createClient(supabaseUrl, supabaseKey);\n\nconst createTables = async () => {\n  console.log('Creating users table...');\n  \n  const createUsersTableSQL = `\n    CREATE TABLE IF NOT EXISTS public.users (\n        id BIGSERIAL PRIMARY KEY,\n        username TEXT NOT NULL UNIQUE,\n        email TEXT NOT NULL UNIQUE,\n        password TEXT,\n        name TEXT NOT NULL,\n        bio TEXT,\n        avatar TEXT,\n        supabase_id TEXT UNIQUE,\n        stripe_customer_id TEXT,\n        stripe_subscription_id TEXT,\n        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,\n        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL\n    );\n\n    CREATE INDEX IF NOT EXISTS idx_users_email ON public.users(email);\n    CREATE INDEX IF NOT EXISTS idx_users_username ON public.users(username);\n    CREATE INDEX IF NOT EXISTS idx_users_supabase_id ON public.users(supabase_id);\n  `;\n\n  try {\n    // Use the service role key for admin operations if available\n    const { data, error } = await supabase.rpc('exec_sql', { \n      sql: createUsersTableSQL \n    });\n    \n    if (error) {\n      console.log('RPC failed, checking if table exists via query...');\n      \n      // Test if table exists by trying a simple select\n      const { data: testData, error: testError } = await supabase\n        .from('users')\n        .select('id')\n        .limit(1);\n        \n      if (testError) {\n        console.error('Table does not exist and could not be created:', testError);\n        return false;\n      } else {\n        console.log('Users table is accessible');\n        return true;\n      }\n    } else {\n      console.log('Users table created successfully');\n      return true;\n    }\n  } catch (error) {\n    console.error('Error:', error);\n    return false;\n  }\n};\n\ncreateTables().then(success => {\n  if (success) {\n    console.log('Database setup complete - registration should now work');\n  } else {\n    console.log('Database setup incomplete - manual SQL execution required');\n  }\n  process.exit(0);\n});","size_bytes":2205},"create-tables-final.js":{"content":"import { createClient } from '@supabase/supabase-js';\n\nconst supabaseUrl = process.env.SUPABASE_URL;\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\n// Use service role key if available, otherwise use anon key\nconst supabaseKey = supabaseServiceKey || process.env.SUPABASE_ANON_KEY;\n\nconst supabase = createClient(supabaseUrl, supabaseKey);\n\nconst createTablesDirectly = async () => {\n  console.log('Creating database tables using direct SQL...');\n  \n  // Create the users table using raw SQL through Supabase\n  const createUsersSQL = `\n    CREATE TABLE IF NOT EXISTS public.users (\n        id BIGSERIAL PRIMARY KEY,\n        username TEXT NOT NULL UNIQUE,\n        email TEXT NOT NULL UNIQUE,\n        password TEXT,\n        name TEXT NOT NULL,\n        bio TEXT,\n        avatar TEXT,\n        supabase_id TEXT UNIQUE,\n        stripe_customer_id TEXT,\n        stripe_subscription_id TEXT,\n        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,\n        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL\n    );\n  `;\n\n  const createIndexesSQL = `\n    CREATE INDEX IF NOT EXISTS idx_users_email ON public.users(email);\n    CREATE INDEX IF NOT EXISTS idx_users_username ON public.users(username);\n    CREATE INDEX IF NOT EXISTS idx_users_supabase_id ON public.users(supabase_id);\n  `;\n\n  const enableRLSSQL = `\n    ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;\n  `;\n\n  const createPoliciesSQL = `\n    CREATE POLICY IF NOT EXISTS \"Enable insert for registration\" ON public.users\n        FOR INSERT WITH CHECK (true);\n    \n    CREATE POLICY IF NOT EXISTS \"Users can view own data\" ON public.users\n        FOR SELECT USING (auth.uid()::text = supabase_id);\n    \n    CREATE POLICY IF NOT EXISTS \"Users can update own data\" ON public.users\n        FOR UPDATE USING (auth.uid()::text = supabase_id);\n  `;\n\n  try {\n    // Try to execute each SQL command\n    console.log('Creating users table...');\n    const { data: createData, error: createError } = await supabase.rpc('query', { \n      query: createUsersSQL \n    });\n    \n    if (createError) {\n      console.log('RPC not available, attempting alternative...');\n      \n      // Alternative: Check if we can insert a test user to trigger table creation\n      const testUser = {\n        username: 'test_user_' + Date.now(),\n        email: 'test_' + Date.now() + '@example.com',\n        name: 'Test User',\n        supabase_id: 'test_' + Date.now()\n      };\n      \n      const { data: insertData, error: insertError } = await supabase\n        .from('users')\n        .insert([testUser])\n        .select();\n        \n      if (insertError) {\n        if (insertError.code === '42P01') {\n          console.log('Table does not exist. Manual creation required in Supabase dashboard.');\n          return false;\n        } else if (insertError.code === '23505') {\n          console.log('Table exists but has constraint violations (expected)');\n          // Clean up test user if it was inserted\n          await supabase.from('users').delete().eq('username', testUser.username);\n          return true;\n        } else {\n          console.log('Table exists and is accessible');\n          // Clean up test user\n          await supabase.from('users').delete().eq('username', testUser.username);\n          return true;\n        }\n      } else {\n        console.log('Table created and test user inserted successfully');\n        // Clean up test user\n        await supabase.from('users').delete().eq('username', testUser.username);\n        return true;\n      }\n    } else {\n      console.log('Users table created via RPC');\n      return true;\n    }\n  } catch (error) {\n    console.error('Error creating tables:', error);\n    return false;\n  }\n};\n\ncreateTablesDirectly().then(success => {\n  if (success) {\n    console.log('Database setup complete - registration should now work');\n  } else {\n    console.log('Database setup requires manual intervention');\n  }\n  process.exit(0);\n});","size_bytes":3941},"create-tables-postgres.js":{"content":"import postgres from 'postgres';\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nconst createTables = async () => {\n  const sql = postgres(process.env.DATABASE_URL);\n  \n  try {\n    console.log('Creating users table...');\n    \n    await sql`\n      CREATE TABLE IF NOT EXISTS public.users (\n          id BIGSERIAL PRIMARY KEY,\n          username TEXT NOT NULL UNIQUE,\n          email TEXT NOT NULL UNIQUE,\n          password TEXT,\n          name TEXT NOT NULL,\n          bio TEXT,\n          avatar TEXT,\n          supabase_id TEXT UNIQUE,\n          stripe_customer_id TEXT,\n          stripe_subscription_id TEXT,\n          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,\n          updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL\n      )\n    `;\n\n    console.log('Creating indexes...');\n    \n    await sql`CREATE INDEX IF NOT EXISTS idx_users_email ON public.users(email)`;\n    await sql`CREATE INDEX IF NOT EXISTS idx_users_username ON public.users(username)`;\n    await sql`CREATE INDEX IF NOT EXISTS idx_users_supabase_id ON public.users(supabase_id)`;\n\n    console.log('Setting up RLS...');\n    \n    await sql`ALTER TABLE public.users ENABLE ROW LEVEL SECURITY`;\n\n    console.log('Creating policies...');\n    \n    await sql`\n      CREATE POLICY IF NOT EXISTS \"Enable insert for registration\" ON public.users\n          FOR INSERT WITH CHECK (true)\n    `;\n\n    console.log('Users table created successfully');\n    \n    await sql.end();\n    return true;\n    \n  } catch (error) {\n    console.error('Error creating tables:', error);\n    await sql.end();\n    return false;\n  }\n};\n\ncreateTables().then(success => {\n  console.log(success ? 'Database setup complete' : 'Database setup failed');\n  process.exit(success ? 0 : 1);\n});","size_bytes":1745},"create-tables.js":{"content":"// Script to create database schema in Supabase using direct SQL\nimport { createClient } from '@supabase/supabase-js';\nimport dotenv from 'dotenv';\nimport fs from 'fs';\n\n// Load environment variables\ndotenv.config();\n\n// Get Supabase credentials\nconst supabaseUrl = process.env.SUPABASE_URL;\nconst supabaseKey = process.env.SUPABASE_ANON_KEY;\n\nconsole.log('Setting up Supabase database tables...');\nconsole.log('Using Supabase URL:', supabaseUrl);\n\n// Create Supabase client\nconst supabase = createClient(supabaseUrl, supabaseKey);\n\n// Function to execute SQL via Supabase REST API\nasync function createSchema() {\n  try {\n    // Try to create just the users table to test if SQL execution works\n    const { data, error } = await supabase.from('users').insert({\n      username: 'test_user',\n      email: 'test@example.com',\n      name: 'Test User',\n      password: 'password',\n      created_at: new Date(),\n      updated_at: new Date()\n    }).select();\n\n    if (error) {\n      if (error.code === '42P01') {\n        console.log('Users table does not exist, attempting to create it...');\n        \n        // Create users table using REST API\n        const { data: createData, error: createError } = await supabase.rpc('create_users_table');\n        \n        if (createError) {\n          console.error('Error creating users table:', createError);\n          console.log('Please create database tables manually using the SQL in supabase-setup.sql');\n        } else {\n          console.log('Created users table successfully!', createData);\n        }\n      } else {\n        console.error('Error testing users table:', error);\n      }\n    } else {\n      console.log('Users table already exists and is working properly!');\n      console.log('Test user created:', data);\n    }\n    \n    console.log('\\nDatabase setup process completed.');\n    console.log('If tables were not created automatically, please run the SQL from supabase-setup.sql');\n    console.log('in the Supabase SQL Editor to create the necessary database schema.');\n  } catch (error) {\n    console.error('Error setting up database:', error);\n  }\n}\n\n// Run the setup\ncreateSchema();","size_bytes":2135},"create-user-interests-db.js":{"content":"import { db } from './db/index.ts';\nimport { sql } from 'drizzle-orm';\n\nasync function createUserInterestsTable() {\n  try {\n    console.log('Creating user_interests table...');\n    \n    // Create the table using Drizzle's raw SQL execution\n    await db.execute(sql`\n      CREATE TABLE IF NOT EXISTS user_interests (\n        id SERIAL PRIMARY KEY,\n        user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n        category TEXT NOT NULL,\n        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n        UNIQUE(user_id, category)\n      );\n    `);\n    \n    console.log('user_interests table created successfully');\n    \n    // Test the table by checking if it exists\n    const result = await db.execute(sql`\n      SELECT COUNT(*) as count FROM user_interests;\n    `);\n    \n    console.log('Table verification successful - user_interests table exists!');\n    \n    // Add sample data for user ID 2 (facu)\n    await db.execute(sql`\n      INSERT INTO user_interests (user_id, category) \n      VALUES (2, 'music'), (2, 'technology') \n      ON CONFLICT (user_id, category) DO NOTHING;\n    `);\n    \n    console.log('Sample interests added for testing');\n    \n  } catch (error) {\n    console.error('Error creating user_interests table:', error);\n    if (error.message.includes('already exists')) {\n      console.log('Table already exists, that\\'s fine!');\n    }\n  }\n}\n\ncreateUserInterestsTable();","size_bytes":1461},"create-user-interests-table.js":{"content":"import { createClient } from '@supabase/supabase-js';\nimport dotenv from 'dotenv';\n\n// Load environment variables\ndotenv.config();\n\nconst supabaseUrl = process.env.SUPABASE_URL;\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\nif (!supabaseUrl || !supabaseServiceKey) {\n  console.error('Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY');\n  process.exit(1);\n}\n\nconst supabase = createClient(supabaseUrl, supabaseServiceKey);\n\nasync function createUserInterestsTable() {\n  try {\n    console.log('Creating user_interests table...');\n    \n    // Create the table using raw SQL\n    const { data, error } = await supabase.rpc('exec', {\n      sql: `\n        CREATE TABLE IF NOT EXISTS user_interests (\n          id SERIAL PRIMARY KEY,\n          user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n          category TEXT NOT NULL,\n          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n          updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n          UNIQUE(user_id, category)\n        );\n      `\n    });\n\n    if (error) {\n      console.error('Error creating user_interests table with rpc:', error);\n      \n      // Try direct SQL approach\n      console.log('Trying direct SQL execution...');\n      \n      const createTableQuery = `\n        CREATE TABLE IF NOT EXISTS user_interests (\n          id SERIAL PRIMARY KEY,\n          user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n          category TEXT NOT NULL,\n          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n          updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n          UNIQUE(user_id, category)\n        );\n      `;\n      \n      // Use fetch for direct SQL execution\n      const response = await fetch(`${supabaseUrl}/rest/v1/rpc/exec`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${supabaseServiceKey}`,\n          'apikey': supabaseServiceKey\n        },\n        body: JSON.stringify({ sql: createTableQuery })\n      });\n      \n      if (response.ok) {\n        console.log('Table created successfully using direct SQL');\n      } else {\n        const errorText = await response.text();\n        console.log('Direct SQL response:', errorText);\n        \n        // Fallback: Try using SQL editor approach\n        console.log('Attempting to insert into supabase directly...');\n        const { data: insertData, error: insertError } = await supabase\n          .from('user_interests')\n          .insert([])\n          .select();\n          \n        if (insertError) {\n          console.log('Table does not exist yet, this is expected:', insertError.message);\n        }\n      }\n    } else {\n      console.log('Table created successfully:', data);\n    }\n\n    // Test if we can query the table\n    console.log('Testing table access...');\n    const { data: testData, error: testError } = await supabase\n      .from('user_interests')\n      .select('*')\n      .limit(1);\n    \n    if (testError) {\n      console.error('Table verification failed:', testError);\n      console.log('Please create the user_interests table manually in Supabase SQL editor with:');\n      console.log(`\nCREATE TABLE IF NOT EXISTS user_interests (\n  id SERIAL PRIMARY KEY,\n  user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n  category TEXT NOT NULL,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  UNIQUE(user_id, category)\n);\n      `);\n    } else {\n      console.log('Table verification successful - user_interests table exists!');\n    }\n\n  } catch (error) {\n    console.error('Unexpected error:', error);\n  }\n}\n\ncreateUserInterestsTable();","size_bytes":3684},"create-with-service-key.js":{"content":"import { createClient } from '@supabase/supabase-js';\n\nconst supabaseUrl = process.env.SUPABASE_URL;\nconst serviceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\nconst supabase = createClient(supabaseUrl, serviceKey);\n\nconst createUsersTable = async () => {\n  console.log('Creating users table with service role key...');\n  \n  try {\n    // Create the table using direct SQL execution with service role\n    const { data, error } = await supabase\n      .from('_schema')\n      .select('*')\n      .limit(1);\n\n    // If that fails, try creating via insert which will auto-create the table structure\n    const testUser = {\n      username: 'admin_test',\n      email: 'admin@test.com',\n      name: 'Admin Test',\n      supabase_id: 'admin_test_id'\n    };\n\n    const { data: insertData, error: insertError } = await supabase\n      .from('users')\n      .insert([testUser])\n      .select();\n\n    if (insertError) {\n      if (insertError.code === '42P01') {\n        console.log('Table does not exist, creating manually...');\n        \n        // Use service role to execute raw SQL\n        const { data: sqlData, error: sqlError } = await supabase.rpc('query', {\n          query: `\n            CREATE TABLE IF NOT EXISTS public.users (\n                id BIGSERIAL PRIMARY KEY,\n                username TEXT NOT NULL UNIQUE,\n                email TEXT NOT NULL UNIQUE,\n                password TEXT,\n                name TEXT NOT NULL,\n                bio TEXT,\n                avatar TEXT,\n                supabase_id TEXT UNIQUE,\n                stripe_customer_id TEXT,\n                stripe_subscription_id TEXT,\n                created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,\n                updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL\n            );\n            \n            CREATE INDEX IF NOT EXISTS idx_users_email ON public.users(email);\n            CREATE INDEX IF NOT EXISTS idx_users_username ON public.users(username);\n            CREATE INDEX IF NOT EXISTS idx_users_supabase_id ON public.users(supabase_id);\n            \n            ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;\n            \n            CREATE POLICY IF NOT EXISTS \"Enable insert for registration\" ON public.users\n                FOR INSERT WITH CHECK (true);\n                \n            CREATE POLICY IF NOT EXISTS \"Users can view own data\" ON public.users\n                FOR SELECT USING (auth.uid()::text = supabase_id);\n                \n            CREATE POLICY IF NOT EXISTS \"Users can update own data\" ON public.users\n                FOR UPDATE USING (auth.uid()::text = supabase_id);\n          `\n        });\n\n        if (sqlError) {\n          console.error('SQL execution failed:', sqlError);\n          return false;\n        } else {\n          console.log('Table created via SQL execution');\n          return true;\n        }\n      } else {\n        console.log('Table exists, insert failed for other reason:', insertError);\n        return true;\n      }\n    } else {\n      console.log('Table exists and working, cleaning up test user...');\n      await supabase.from('users').delete().eq('username', 'admin_test');\n      return true;\n    }\n  } catch (error) {\n    console.error('Error:', error);\n    return false;\n  }\n};\n\ncreateUsersTable().then(success => {\n  console.log(success ? 'Database ready for registration' : 'Manual table creation required');\n  process.exit(0);\n});","size_bytes":3384},"debug-event-data.js":{"content":"import { createClient } from '@supabase/supabase-js';\nimport 'dotenv/config';\n\nconst supabaseUrl = process.env.SUPABASE_URL;\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\nconst supabase = createClient(supabaseUrl, supabaseServiceKey);\n\nasync function debugEventData() {\n  try {\n    // Get event 2 data directly from database\n    const { data: event2, error } = await supabase\n      .from('events')\n      .select('*')\n      .eq('id', 2)\n      .single();\n    \n    if (error) {\n      console.error('Error:', error);\n      return;\n    }\n    \n    console.log('Event 2 raw database data:');\n    console.log('ID:', event2.id);\n    console.log('Title:', event2.title);\n    console.log('media_items:', event2.media_items);\n    console.log('main_media_url:', event2.main_media_url);\n    console.log('main_media_type:', event2.main_media_type);\n    \n    // Parse media items if it exists\n    if (event2.media_items) {\n      try {\n        const mediaItems = JSON.parse(event2.media_items);\n        console.log('Parsed media_items:', mediaItems);\n      } catch (e) {\n        console.log('Failed to parse media_items:', e.message);\n      }\n    }\n    \n  } catch (error) {\n    console.error('Debug error:', error);\n  }\n}\n\ndebugEventData();","size_bytes":1244},"debug-token-flow.js":{"content":"// Debug script to test token persistence directly\nconsole.log('=== Token Persistence Debug ===');\n\n// Test 1: Basic localStorage functionality\nconsole.log('\\n1. Testing localStorage functionality:');\ntry {\n  localStorage.setItem('test_key', 'test_value');\n  const retrieved = localStorage.getItem('test_key');\n  localStorage.removeItem('test_key');\n  console.log('localStorage test:', retrieved === 'test_value' ? 'PASSED' : 'FAILED');\n} catch (error) {\n  console.log('localStorage test: FAILED -', error.message);\n}\n\n// Test 2: Token storage simulation\nconsole.log('\\n2. Testing token storage:');\nconst mockToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.test';\nconst TOKEN_KEY = 'pipol_auth_token';\n\ntry {\n  // Store token\n  localStorage.setItem(TOKEN_KEY, mockToken);\n  console.log('Token stored successfully');\n  \n  // Retrieve token immediately\n  const retrievedToken = localStorage.getItem(TOKEN_KEY);\n  console.log('Token retrieved:', retrievedToken === mockToken ? 'SUCCESS' : 'FAILED');\n  \n  // Clean up\n  localStorage.removeItem(TOKEN_KEY);\n} catch (error) {\n  console.log('Token storage failed:', error.message);\n}\n\n// Test 3: Check current token state\nconsole.log('\\n3. Current token state:');\nconst currentToken = localStorage.getItem('pipol_auth_token');\nconsole.log('Current pipol_auth_token:', currentToken ? 'EXISTS' : 'NOT_FOUND');\n\n// Test 4: Login API test\nconsole.log('\\n4. Testing login API:');\nfetch('/api/auth/login', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n  },\n  body: JSON.stringify({\n    email: 'facundoroman203@gmail.com',\n    password: '123456'\n  }),\n})\n.then(response => response.json())\n.then(data => {\n  console.log('Login API response:', data.message);\n  if (data.token) {\n    console.log('Token received:', data.token.substring(0, 30) + '...');\n    \n    // Test immediate storage\n    localStorage.setItem('pipol_auth_token', data.token);\n    const stored = localStorage.getItem('pipol_auth_token');\n    console.log('Immediate storage test:', stored === data.token ? 'SUCCESS' : 'FAILED');\n    \n    // Test auth endpoint\n    return fetch('/api/auth/me', {\n      headers: {\n        'Authorization': `Bearer ${data.token}`,\n        'Content-Type': 'application/json'\n      }\n    });\n  }\n})\n.then(response => {\n  if (response) {\n    console.log('Auth verification status:', response.status);\n    return response.json();\n  }\n})\n.then(userData => {\n  if (userData) {\n    console.log('Auth verification result:', userData.name ? 'SUCCESS' : 'FAILED');\n  }\n})\n.catch(error => {\n  console.error('Test failed:', error.message);\n});","size_bytes":2588},"direct-sql-create.js":{"content":"import { createClient } from '@supabase/supabase-js';\n\nconst supabaseUrl = process.env.SUPABASE_URL;\nconst serviceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\nconst adminClient = createClient(supabaseUrl, serviceKey, {\n  auth: {\n    autoRefreshToken: false,\n    persistSession: false\n  }\n});\n\nconst createUsersTableDirect = async () => {\n  console.log('Attempting direct table creation...');\n  \n  try {\n    // First, try to directly create a user record which will auto-create the table\n    const testUser = {\n      id: 999999,\n      username: 'system_admin',\n      email: 'system@admin.com',\n      name: 'System Admin',\n      supabase_id: 'system_admin_id_' + Date.now()\n    };\n\n    // Use upsert with explicit schema definition\n    const { data, error } = await adminClient\n      .from('users')\n      .upsert(testUser, { \n        onConflict: 'id',\n        ignoreDuplicates: false \n      })\n      .select();\n\n    if (error) {\n      console.log('Table creation via upsert failed:', error.message);\n      \n      // Try alternative: use the schema builder API if available\n      const { error: schemaError } = await adminClient\n        .from('_supabase_migrations')\n        .select('*')\n        .limit(1);\n        \n      if (schemaError) {\n        console.log('Database schema not accessible');\n        return false;\n      }\n      \n      return false;\n    } else {\n      console.log('Table created successfully via upsert');\n      \n      // Clean up the test user\n      await adminClient\n        .from('users')\n        .delete()\n        .eq('id', 999999);\n        \n      return true;\n    }\n  } catch (error) {\n    console.error('Direct creation error:', error);\n    return false;\n  }\n};\n\ncreateUsersTableDirect().then(success => {\n  console.log(success ? 'Users table is ready' : 'Manual SQL execution required');\n  process.exit(0);\n});","size_bytes":1835},"drizzle.config.ts":{"content":"import { defineConfig } from \"drizzle-kit\";\n\nif (!process.env.DATABASE_URL) {\n  throw new Error(\"DATABASE_URL, ensure the database is provisioned\");\n}\n\nexport default defineConfig({\n  out: \"./db/migrations\",\n  schema: \"./shared/schema.ts\",\n  dialect: \"postgresql\",\n  dbCredentials: {\n    url: process.env.DATABASE_URL,\n  },\n  verbose: true,\n});\n","size_bytes":345},"fix-both-issues.js":{"content":"import { createClient } from '@supabase/supabase-js';\nimport 'dotenv/config';\n\nconst supabaseUrl = process.env.SUPABASE_URL;\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\nif (!supabaseUrl || !supabaseServiceKey) {\n  console.error('Missing Supabase environment variables');\n  process.exit(1);\n}\n\nconst supabase = createClient(supabaseUrl, supabaseServiceKey);\n\nasync function fixBothIssues() {\n  try {\n    console.log('Fixing organizer recognition and multimedia display issues...');\n    \n    // First, check current table schema\n    const { data: currentColumns, error: schemaError } = await supabase\n      .from('information_schema.columns')\n      .select('column_name, data_type')\n      .eq('table_name', 'events')\n      .order('ordinal_position');\n    \n    if (schemaError) {\n      console.error('Error checking schema:', schemaError);\n    } else {\n      console.log('Current events table columns:');\n      currentColumns.forEach(col => console.log(`- ${col.column_name}: ${col.data_type}`));\n    }\n    \n    // Check if multimedia columns exist\n    const multimediaColumns = ['photo_url', 'video_url', 'media_items', 'main_media_type', 'main_media_url'];\n    const existingMultimediaColumns = currentColumns ? currentColumns.filter(col => \n      multimediaColumns.includes(col.column_name)\n    ) : [];\n    \n    console.log('\\nExisting multimedia columns:', existingMultimediaColumns.map(col => col.column_name));\n    \n    // Test event retrieval to see current data structure\n    const { data: events, error: eventsError } = await supabase\n      .from('events')\n      .select('*')\n      .limit(5);\n    \n    if (eventsError) {\n      console.error('Error fetching events:', eventsError);\n    } else {\n      console.log('\\nSample event data structure:');\n      if (events && events.length > 0) {\n        console.log('Keys:', Object.keys(events[0]));\n        console.log('Event 1 organizer_id:', events[0].organizer_id, typeof events[0].organizer_id);\n      }\n    }\n    \n    // Test organizer recognition by checking event 2\n    const { data: event2, error: event2Error } = await supabase\n      .from('events')\n      .select('*')\n      .eq('id', 2)\n      .single();\n    \n    if (event2Error) {\n      console.error('Error fetching event 2:', event2Error);\n    } else {\n      console.log('\\nEvent 2 details:');\n      console.log('organizer_id:', event2.organizer_id, typeof event2.organizer_id);\n      console.log('Has multimedia fields:', {\n        photo_url: event2.photo_url !== undefined,\n        video_url: event2.video_url !== undefined,\n        media_items: event2.media_items !== undefined,\n        main_media_type: event2.main_media_type !== undefined,\n        main_media_url: event2.main_media_url !== undefined\n      });\n    }\n    \n  } catch (error) {\n    console.error('Error in diagnosis:', error);\n  }\n}\n\nfixBothIssues();","size_bytes":2853},"fix-chat-access.js":{"content":"import { createClient } from '@supabase/supabase-js';\nimport 'dotenv/config';\n\nconst supabaseUrl = process.env.SUPABASE_URL;\nconst supabaseKey = process.env.SUPABASE_ANON_KEY;\n\nif (!supabaseUrl || !supabaseKey) {\n  console.error('Missing Supabase environment variables');\n  process.exit(1);\n}\n\nconst supabase = createClient(supabaseUrl, supabaseKey);\n\nasync function fixChatAccess() {\n  try {\n    console.log('🔍 Checking event 26 details...');\n    \n    // Get event details\n    const { data: event, error: eventError } = await supabase\n      .from('events')\n      .select('id, title, organizer_id')\n      .eq('id', 26)\n      .single();\n    \n    if (eventError) {\n      console.error('Error fetching event:', eventError);\n      return;\n    }\n    \n    console.log('Event details:', event);\n    \n    // Check if organizer is already an attendee\n    const { data: attendee, error: attendeeError } = await supabase\n      .from('event_attendees')\n      .select('*')\n      .eq('event_id', 26)\n      .eq('user_id', event.organizer_id)\n      .single();\n    \n    if (attendeeError && attendeeError.code !== 'PGRST116') {\n      console.error('Error checking attendee:', attendeeError);\n      return;\n    }\n    \n    if (attendee) {\n      console.log('✅ Organizer is already an attendee');\n      return;\n    }\n    \n    // Add organizer as attendee\n    console.log('➕ Adding organizer as attendee...');\n    const { data: newAttendee, error: insertError } = await supabase\n      .from('event_attendees')\n      .insert({\n        event_id: 26,\n        user_id: event.organizer_id,\n        status: 'confirmed',\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n      })\n      .select()\n      .single();\n    \n    if (insertError) {\n      console.error('Error inserting attendee:', insertError);\n      return;\n    }\n    \n    console.log('✅ Successfully added organizer as attendee:', newAttendee);\n    \n  } catch (error) {\n    console.error('❌ Unexpected error:', error);\n  }\n}\n\nfixChatAccess();","size_bytes":2027},"fix-database-multimedia.js":{"content":"import { createClient } from '@supabase/supabase-js';\nimport 'dotenv/config';\n\nconst supabaseUrl = process.env.SUPABASE_URL;\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\nconst supabase = createClient(supabaseUrl, supabaseServiceKey);\n\nasync function fixDatabaseMultimedia() {\n  try {\n    console.log('Adding sample multimedia data to demonstrate functionality...');\n    \n    // Add sample multimedia data to event 2 to demonstrate the feature\n    const sampleMediaItems = JSON.stringify([\n      {\n        type: 'photo',\n        url: '/uploads/sample-event-photo.jpg',\n        order: 0,\n        isMain: true\n      }\n    ]);\n    \n    const { data: updatedEvent, error } = await supabase\n      .from('events')\n      .update({\n        media_items: sampleMediaItems,\n        main_media_type: 'photo',\n        main_media_url: '/uploads/sample-event-photo.jpg'\n      })\n      .eq('id', 2)\n      .select()\n      .single();\n    \n    if (error) {\n      console.error('Error updating event:', error);\n    } else {\n      console.log('Event 2 updated with sample multimedia data');\n      console.log('Updated event:', updatedEvent);\n    }\n    \n    // Verify the update\n    const { data: verifyEvent, error: verifyError } = await supabase\n      .from('events')\n      .select('id, title, media_items, main_media_type, main_media_url')\n      .eq('id', 2)\n      .single();\n    \n    if (verifyError) {\n      console.error('Error verifying update:', verifyError);\n    } else {\n      console.log('Verification - Event 2 multimedia data:');\n      console.log('- media_items:', verifyEvent.media_items);\n      console.log('- main_media_type:', verifyEvent.main_media_type);\n      console.log('- main_media_url:', verifyEvent.main_media_url);\n    }\n    \n  } catch (error) {\n    console.error('Error in multimedia fix:', error);\n  }\n}\n\nfixDatabaseMultimedia();","size_bytes":1858},"fix-database-schema.js":{"content":"import { createClient } from '@supabase/supabase-js';\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nconst supabaseUrl = process.env.SUPABASE_URL;\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\nif (!supabaseUrl || !supabaseServiceKey) {\n  console.error('Missing Supabase credentials');\n  process.exit(1);\n}\n\nconst supabase = createClient(supabaseUrl, supabaseServiceKey, {\n  auth: { persistSession: false }\n});\n\nasync function fixDatabaseSchema() {\n  console.log('Fixing database schema...');\n\n  // Step 1: Create enum types\n  const enums = [\n    {\n      name: 'event_category',\n      values: ['social', 'music', 'spiritual', 'education', 'sports', 'food', 'art', 'technology', 'games', 'outdoor', 'networking', 'workshop', 'conference', 'party', 'fair', 'exhibition']\n    },\n    {\n      name: 'privacy_type',\n      values: ['public', 'private']\n    },\n    {\n      name: 'private_access_type',\n      values: ['solicitud', 'postulacion', 'paga']\n    },\n    {\n      name: 'payment_type',\n      values: ['free', 'paid']\n    },\n    {\n      name: 'multimedia_type',\n      values: ['photo', 'video']\n    },\n    {\n      name: 'attendee_status',\n      values: ['pending', 'approved', 'rejected']\n    }\n  ];\n\n  for (const enumDef of enums) {\n    try {\n      const enumSQL = `\n        DO $$ BEGIN\n          CREATE TYPE ${enumDef.name} AS ENUM (${enumDef.values.map(v => `'${v}'`).join(', ')});\n        EXCEPTION\n          WHEN duplicate_object THEN null;\n        END $$;\n      `;\n      \n      const { error } = await supabase.rpc('exec', { sql: enumSQL });\n      if (error) {\n        console.log(`Enum ${enumDef.name}:`, error.message.includes('already exists') ? 'exists' : error.message);\n      } else {\n        console.log(`✓ Enum ${enumDef.name} created`);\n      }\n    } catch (err) {\n      console.log(`Enum ${enumDef.name}: attempting creation`);\n    }\n  }\n\n  // Step 2: Add missing columns to events table\n  const alterColumns = [\n    'ADD COLUMN IF NOT EXISTS private_access_type private_access_type',\n    'ADD COLUMN IF NOT EXISTS application_questions TEXT',\n    'ADD COLUMN IF NOT EXISTS photo_urls TEXT',\n    'ADD COLUMN IF NOT EXISTS video_urls TEXT',\n    'ADD COLUMN IF NOT EXISTS media_items TEXT',\n    'ADD COLUMN IF NOT EXISTS main_media_type multimedia_type DEFAULT \\'photo\\'',\n    'ADD COLUMN IF NOT EXISTS main_media_url TEXT'\n  ];\n\n  for (const column of alterColumns) {\n    try {\n      const { error } = await supabase.rpc('exec', { \n        sql: `ALTER TABLE events ${column};` \n      });\n      if (error) {\n        console.log(`Column update:`, error.message.includes('already exists') ? 'exists' : error.message);\n      } else {\n        console.log(`✓ Column added: ${column.split(' ')[5]}`);\n      }\n    } catch (err) {\n      console.log(`Attempting to add column: ${column.split(' ')[5]}`);\n    }\n  }\n\n  // Step 3: Create event_attendees table\n  const createEventAttendeesSQL = `\n    CREATE TABLE IF NOT EXISTS event_attendees (\n      id SERIAL PRIMARY KEY,\n      event_id INTEGER NOT NULL REFERENCES events(id) ON DELETE CASCADE,\n      user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n      status attendee_status DEFAULT 'approved' NOT NULL,\n      payment_status TEXT DEFAULT 'pending',\n      payment_intent_id TEXT,\n      created_at TIMESTAMP DEFAULT NOW() NOT NULL,\n      UNIQUE(event_id, user_id)\n    );\n  `;\n\n  try {\n    const { error } = await supabase.rpc('exec', { sql: createEventAttendeesSQL });\n    if (error) {\n      console.log('event_attendees table:', error.message.includes('already exists') ? 'exists' : error.message);\n    } else {\n      console.log('✓ event_attendees table created');\n    }\n  } catch (err) {\n    console.log('Attempting to create event_attendees table');\n  }\n\n  // Step 4: Create user_interests table\n  const createUserInterestsSQL = `\n    CREATE TABLE IF NOT EXISTS user_interests (\n      id SERIAL PRIMARY KEY,\n      user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n      category event_category NOT NULL,\n      created_at TIMESTAMP DEFAULT NOW() NOT NULL\n    );\n  `;\n\n  try {\n    const { error } = await supabase.rpc('exec', { sql: createUserInterestsSQL });\n    if (error) {\n      console.log('user_interests table:', error.message.includes('already exists') ? 'exists' : error.message);\n    } else {\n      console.log('✓ user_interests table created');\n    }\n  } catch (err) {\n    console.log('Attempting to create user_interests table');\n  }\n\n  // Step 5: Test if tables exist by querying them\n  console.log('\\nTesting database schema...');\n  \n  // Test event_attendees\n  try {\n    const { data, error } = await supabase.from('event_attendees').select('id').limit(1);\n    console.log('✓ event_attendees table accessible');\n  } catch (err) {\n    console.log('❌ event_attendees table not accessible');\n  }\n\n  // Test events columns\n  try {\n    const { data, error } = await supabase.from('events').select('private_access_type').limit(1);\n    console.log('✓ events.private_access_type column accessible');\n  } catch (err) {\n    console.log('❌ events.private_access_type column not accessible');\n  }\n\n  console.log('\\nDatabase schema fix completed.');\n}\n\nfixDatabaseSchema().catch(console.error);","size_bytes":5221},"fix-end-time-column.js":{"content":"import { createClient } from '@supabase/supabase-js';\n\nconst supabaseUrl = process.env.SUPABASE_URL;\nconst supabaseKey = process.env.SUPABASE_ANON_KEY;\n\nif (!supabaseUrl || !supabaseKey) {\n  console.error('Missing Supabase credentials');\n  process.exit(1);\n}\n\nconst supabase = createClient(supabaseUrl, supabaseKey);\n\nasync function addEndTimeColumn() {\n  try {\n    console.log('Checking if end_time column exists...');\n    \n    // First, let's check the current table structure\n    const { data: tableInfo, error: tableError } = await supabase\n      .from('events')\n      .select('*')\n      .limit(1);\n    \n    if (tableError) {\n      console.error('Error checking table:', tableError);\n      return;\n    }\n    \n    // Check if we can query end_time\n    const { data: testData, error: testError } = await supabase\n      .from('events')\n      .select('end_time')\n      .limit(1);\n    \n    if (testError && testError.message.includes('end_time')) {\n      console.log('end_time column is missing. This is expected.');\n      console.log('The column needs to be added manually in the Supabase dashboard.');\n      console.log('Go to your Supabase project dashboard:');\n      console.log('1. Navigate to Table Editor');\n      console.log('2. Select the \"events\" table');\n      console.log('3. Click \"Add Column\"');\n      console.log('4. Name: end_time');\n      console.log('5. Type: timestamptz (timestamp with time zone)');\n      console.log('6. Allow nullable: true');\n      console.log('7. Save the column');\n      return;\n    }\n    \n    console.log('end_time column exists or can be queried');\n    console.log('Test data:', testData);\n    \n  } catch (err) {\n    console.error('Exception:', err);\n  }\n}\n\naddEndTimeColumn();","size_bytes":1720},"fix-missing-table.js":{"content":"import { createClient } from '@supabase/supabase-js';\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nconst supabaseUrl = process.env.SUPABASE_URL;\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\nif (!supabaseUrl || !supabaseServiceKey) {\n  console.error('Missing Supabase credentials');\n  process.exit(1);\n}\n\nconst supabase = createClient(supabaseUrl, supabaseServiceKey, {\n  auth: { persistSession: false }\n});\n\nasync function createMissingTable() {\n  try {\n    console.log('Creating missing event_attendees table...');\n    \n    // Create the attendee_status enum first\n    const enumSQL = `\n      DO $$ BEGIN\n          CREATE TYPE attendee_status AS ENUM ('pending', 'approved', 'rejected');\n      EXCEPTION\n          WHEN duplicate_object THEN null;\n      END $$;\n    `;\n    \n    // Create the table\n    const tableSQL = `\n      CREATE TABLE IF NOT EXISTS event_attendees (\n          id SERIAL PRIMARY KEY,\n          event_id INTEGER NOT NULL REFERENCES events(id) ON DELETE CASCADE,\n          user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n          status attendee_status DEFAULT 'approved' NOT NULL,\n          payment_status TEXT DEFAULT 'pending',\n          payment_intent_id TEXT,\n          created_at TIMESTAMP DEFAULT NOW() NOT NULL,\n          UNIQUE(event_id, user_id)\n      );\n      \n      CREATE INDEX IF NOT EXISTS idx_event_attendees_event_id ON event_attendees(event_id);\n      CREATE INDEX IF NOT EXISTS idx_event_attendees_user_id ON event_attendees(user_id);\n    `;\n    \n    // Execute enum creation\n    const { data: enumData, error: enumError } = await supabase.rpc('sql', { \n      query: enumSQL \n    });\n    \n    if (enumError) {\n      console.log('Enum creation status:', enumError.message);\n    } else {\n      console.log('✓ Enum created successfully');\n    }\n    \n    // Execute table creation\n    const { data: tableData, error: tableError } = await supabase.rpc('sql', { \n      query: tableSQL \n    });\n    \n    if (tableError) {\n      console.error('Table creation error:', tableError);\n      // Try with a simpler approach - check if we can insert test data\n      const { error: testError } = await supabase\n        .from('event_attendees')\n        .select('id')\n        .limit(1);\n        \n      if (testError && testError.code === '42P01') {\n        console.log('\\n❌ Table still does not exist.');\n        console.log('Please execute this SQL in Supabase Dashboard > SQL Editor:');\n        console.log('\\n' + enumSQL + '\\n' + tableSQL);\n      } else {\n        console.log('✓ Table appears to exist now');\n      }\n    } else {\n      console.log('✓ Table created successfully');\n    }\n    \n  } catch (error) {\n    console.error('Unexpected error:', error);\n  }\n}\n\ncreateMissingTable();","size_bytes":2761},"fix-registration.js":{"content":"import { supabase } from './server/supabase-client.js';\n\nconst fixRegistration = async () => {\n  console.log('Attempting to create users table via Supabase admin...');\n  \n  try {\n    // Try to create the table using Supabase's admin capabilities\n    const { data, error } = await supabase.rpc('exec_sql', {\n      sql: `\n        CREATE TABLE IF NOT EXISTS public.users (\n            id BIGSERIAL PRIMARY KEY,\n            username TEXT NOT NULL UNIQUE,\n            email TEXT NOT NULL UNIQUE,\n            password TEXT,\n            name TEXT NOT NULL,\n            bio TEXT,\n            avatar TEXT,\n            supabase_id TEXT UNIQUE,\n            stripe_customer_id TEXT,\n            stripe_subscription_id TEXT,\n            created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,\n            updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL\n        );\n      `\n    });\n\n    if (error) {\n      console.log('Admin table creation failed, using alternative method...');\n      \n      // Alternative: Try to use Supabase's schema builder\n      const { error: createError } = await supabase\n        .schema('public')\n        .createTable('users', (table) => {\n          table.bigSerial('id').primary();\n          table.text('username').notNull().unique();\n          table.text('email').notNull().unique();\n          table.text('password');\n          table.text('name').notNull();\n          table.text('bio');\n          table.text('avatar');\n          table.text('supabase_id').unique();\n          table.text('stripe_customer_id');\n          table.text('stripe_subscription_id');\n          table.timestamptz('created_at').defaultNow().notNull();\n          table.timestamptz('updated_at').defaultNow().notNull();\n        });\n\n      if (createError) {\n        console.error('Table creation failed:', createError);\n        return false;\n      }\n    }\n\n    console.log('Users table created successfully');\n    return true;\n    \n  } catch (error) {\n    console.error('Error during table creation:', error);\n    return false;\n  }\n};\n\nfixRegistration().then(success => {\n  console.log(success ? 'Registration fix complete' : 'Manual intervention required');\n  process.exit(0);\n});","size_bytes":2178},"fix-user-password.js":{"content":"import postgres from 'postgres';\nimport bcrypt from 'bcrypt';\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nasync function fixUserPassword() {\n  const connectionString = process.env.DATABASE_URL;\n  console.log('Connecting to database with URL:', connectionString.replace(/:[^@]*@/, ':***@'));\n  \n  const client = postgres(connectionString, {\n    ssl: 'require',\n    max: 1,\n    connect_timeout: 10\n  });\n  \n  try {\n    console.log('Checking user...');\n    \n    // Check if user exists and password status\n    const users = await client`SELECT id, email, username, name, password FROM users WHERE email = 'facundoroman203@gmail.com'`;\n    \n    if (users.length === 0) {\n      console.log('User not found');\n      return;\n    }\n    \n    const user = users[0];\n    console.log('User found:', {\n      id: user.id,\n      email: user.email,\n      username: user.username,\n      name: user.name,\n      hasPassword: !!user.password\n    });\n    \n    if (!user.password) {\n      console.log('Setting temporary password \"123456\" for user...');\n      \n      // Set password '123456' for this user\n      const hashedPassword = await bcrypt.hash('123456', 10);\n      await client`UPDATE users SET password = ${hashedPassword} WHERE email = 'facundoroman203@gmail.com'`;\n      \n      console.log('✅ Password set successfully! You can now login with:');\n      console.log('  Email: facundoroman203@gmail.com');  \n      console.log('  Password: 123456');\n    } else {\n      console.log('✅ User already has a password set');\n    }\n  } catch (error) {\n    console.error('❌ Database error:', error.message);\n  } finally {\n    await client.end();\n  }\n}\n\nfixUserPassword();","size_bytes":1659},"init-db.js":{"content":"import { supabase } from './server/supabase-client.js';\n\nconst createDatabaseTables = async () => {\n  console.log('Creating database tables...');\n\n  // Create users table\n  const { error: usersError } = await supabase\n    .from('users')\n    .select('id')\n    .limit(1);\n\n  if (usersError && usersError.code === 'PGRST116') {\n    // Table doesn't exist, create it using SQL\n    const { error: createError } = await supabase.rpc('exec_sql', {\n      sql: `\n        CREATE TABLE IF NOT EXISTS users (\n          id SERIAL PRIMARY KEY,\n          username TEXT NOT NULL UNIQUE,\n          email TEXT NOT NULL UNIQUE,\n          password TEXT,\n          name TEXT NOT NULL,\n          bio TEXT,\n          avatar TEXT,\n          supabase_id TEXT UNIQUE,\n          stripe_customer_id TEXT,\n          stripe_subscription_id TEXT,\n          created_at TIMESTAMP DEFAULT NOW() NOT NULL,\n          updated_at TIMESTAMP DEFAULT NOW() NOT NULL\n        );\n        \n        CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);\n        CREATE INDEX IF NOT EXISTS idx_users_username ON users(username);\n        CREATE INDEX IF NOT EXISTS idx_users_supabase_id ON users(supabase_id);\n      `\n    });\n\n    if (createError) {\n      console.error('Error creating users table:', createError);\n      return false;\n    }\n    console.log('Users table created successfully');\n  } else {\n    console.log('Users table already exists');\n  }\n\n  return true;\n};\n\n// Initialize database\ncreateDatabaseTables()\n  .then(success => {\n    console.log(success ? 'Database initialization complete' : 'Database initialization failed');\n    process.exit(0);\n  })\n  .catch(error => {\n    console.error('Database initialization error:', error);\n    process.exit(1);\n  });","size_bytes":1730},"map-view-backup.tsx":{"content":"import React, { useState, useEffect, useRef } from \"react\";\nimport SearchBar from \"@/components/search/search-bar\";\nimport GooglePlacesSearch from \"@/components/search/google-places-search\";\nimport EventFilters from \"@/components/events/event-filters\";\nimport { Circle, MapPin, MapIcon, PinIcon, Plus, Pin, MapPinned, Check, X, Compass, Filter } from \"lucide-react\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { Card } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport EventPin from \"./event-pin\";\nimport { CategoryPin } from \"./category-icons\";\nimport mapboxgl, { LngLat } from 'mapbox-gl';\nimport { initializeMap, getUserLocation, defaultMapConfig, searchLocations, reverseGeocode } from \"@/lib/mapbox\";\n// Para debugging - importar también funciones de google\nimport { reverseGeocode as googleReverseGeocode, findNearbyPlaces } from \"@/lib/google-maps\";\nimport { createRoot } from 'react-dom/client';\n\n// Import required types\ntype Event = {\n  id: number;\n  title: string;\n  description: string;\n  category: string;\n  date: string;\n  latitude: string | number;\n  longitude: string | number;\n  locationName: string;\n  locationAddress: string;\n  paymentType: string;\n  price?: string | number;\n  maxCapacity?: number;\n  privacyType: string;\n  organizerId: number;\n  organizer: {\n    id: number;\n    name: string;\n    avatar?: string;\n  };\n  attendees: Array<{\n    id: number;\n    user: {\n      id: number;\n      name: string;\n      avatar?: string;\n    };\n  }>;\n};\n\ntype MapViewProps = {\n  onEventSelect: (event: Event) => void;\n  onCreateEventClick: (locationData?: { \n    latitude: number, \n    longitude: number, \n    locationAddress: string, \n    locationName: string \n  }) => void;\n  filters?: {\n    category?: string[];\n    paymentType?: string[];\n    date?: string;\n  };\n  resetLocationOnFormClose?: boolean;\n};\n\n\n\nconst MapView = ({ onEventSelect, onCreateEventClick, filters, resetLocationOnFormClose }: MapViewProps) => {\n  const [filtersVisible, setFiltersVisible] = useState(false);\n  const [searchTerm, setSearchTerm] = useState(\"\");\n  const [locationMode, setLocationMode] = useState(false);\n  const [eventsPanelVisible, setEventsPanelVisible] = useState(false);\n  const [tempLocationMarker, setTempLocationMarker] = useState<mapboxgl.Marker | null>(null);\n  const [tempLocationData, setTempLocationData] = useState<{\n    latitude: number;\n    longitude: number;\n    locationAddress: string;\n    locationName: string;\n  } | null>(null);\n  \n  // Estado para mostrar botones de acción en ubicación actual\n  const [showActionsForLocation, setShowActionsForLocation] = useState(false);\n  \n  // Estado para guardar las coordenadas y datos de la ubicación actual del mapa\n  const [currentLocation, setCurrentLocation] = useState<{\n    lng: number;\n    lat: number;\n    locationName?: string;\n    locationAddress?: string;\n  } | null>(null);\n  \n  // Estado para guardar eventos filtrados por una ubicación específica\n  const [locationFilteredEvents, setLocationFilteredEvents] = useState<Event[]>([]);\n  \n  const { toast } = useToast();\n  const mapContainerRef = useRef<HTMLDivElement>(null);\n  const mapRef = useRef<mapboxgl.Map | null>(null);\n  const markersRef = useRef<mapboxgl.Marker[]>([]);\n  const popupsRef = useRef<mapboxgl.Popup[]>([]);\n  \n  // Fetch events from API\n  const { data: eventsData, isLoading, error } = useQuery({\n    queryKey: ['/api/events'],\n    refetchOnWindowFocus: true,\n  });\n\n  // Use fetched events or empty array if no data yet\n  const events: Event[] = Array.isArray(eventsData) ? eventsData : [];\n\n  // Filter events based on search and filters\n  const filteredEvents = events.filter((event: Event) => {\n    // Search filter\n    if (searchTerm && !event.title.toLowerCase().includes(searchTerm.toLowerCase())) {\n      return false;\n    }\n    \n    // Category filter\n    if (filters?.category?.length && !filters.category.includes(event.category)) {\n      return false;\n    }\n    \n    // Payment type filter\n    if (filters?.paymentType?.length && !filters.paymentType.includes(event.paymentType)) {\n      return false;\n    }\n    \n    // Date filter handling\n    if (filters?.date && filters.date !== 'all') {\n      const eventDate = new Date(event.date);\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n      \n      const tomorrow = new Date(today);\n      tomorrow.setDate(tomorrow.getDate() + 1);\n      \n      const nextWeekStart = new Date(today);\n      nextWeekStart.setDate(nextWeekStart.getDate() + 7);\n      \n      const nextWeekEnd = new Date(nextWeekStart);\n      nextWeekEnd.setDate(nextWeekEnd.getDate() + 7);\n      \n      // Get the current day of the week (0 = Sunday, 6 = Saturday)\n      const currentDay = today.getDay();\n      \n      // Calculate days until next weekend (Friday and Saturday)\n      const daysUntilFriday = (5 - currentDay + 7) % 7;\n      const daysUntilSunday = (7 - currentDay) % 7;\n      \n      // Calculate next weekend dates\n      const nextFriday = new Date(today);\n      nextFriday.setDate(today.getDate() + daysUntilFriday);\n      \n      const nextSunday = new Date(today);\n      nextSunday.setDate(today.getDate() + daysUntilSunday);\n      \n      switch (filters.date) {\n        case 'today':\n          // Event date must be today\n          return eventDate.toDateString() === today.toDateString();\n          \n        case 'tomorrow':\n          // Event date must be tomorrow\n          return eventDate.toDateString() === tomorrow.toDateString();\n          \n        case 'this_week':\n          // Event must be within the current week (next 7 days)\n          return eventDate >= today && eventDate < nextWeekStart;\n          \n        case 'next_week':\n          // Event must be within the next week (8-14 days from now)\n          return eventDate >= nextWeekStart && eventDate < nextWeekEnd;\n          \n        case 'weekend':\n          // Event must be on the upcoming weekend (Friday to Sunday)\n          return eventDate >= nextFriday && eventDate <= nextSunday;\n          \n        default:\n          return true;\n      }\n    }\n    \n    return true;\n  });\n\n  // Estado para controlar el menú contextual\n  const [contextMenu, setContextMenu] = useState<{\n    visible: boolean;\n    x: number;\n    y: number;\n    lngLat: mapboxgl.LngLat | null;\n  }>({\n    visible: false,\n    x: 0,\n    y: 0,\n    lngLat: null\n  });\n  \n  // Efecto principal para manejar los clics en el mapa (siempre activo)\n  useEffect(() => {\n    // Esta función se ejecutará cada vez que el usuario haga clic en el mapa\n    function handleMapClick(e: mapboxgl.MapMouseEvent) {\n      console.log(\"Clic en el mapa detectado\", locationMode ? \"en modo ubicación\" : \"en modo normal\");\n      \n      // Detener la propagación para evitar que otros handlers cierren nuestro menú\n      e.originalEvent.stopPropagation();\n      \n      // Limpiar cualquier marcador temporal previo\n      if (tempLocationMarker) {\n        tempLocationMarker.remove();\n        setTempLocationMarker(null);\n      }\n      \n      // SIEMPRE mostrar el menú contextual sin importar el modo\n      console.log(\"Abriendo menú contextual en\", e.lngLat);\n      \n      // IMPORTANTE: Activar el modo de ubicación al hacer clic en el mapa\n      // Esto permite que el menú contextual se muestre sin tener que hacer clic en \"Crear un evento\" primero\n      if (!locationMode) {\n        console.log(\"Activando modo de ubicación automáticamente\");\n        setLocationMode(true);\n      }\n      \n      // Crear un nuevo marcador en la ubicación del clic\n      if (mapRef.current) {\n        // Crear el marcador\n        const marker = new mapboxgl.Marker({\n          color: '#f43f5e', // Color rosa/rojo\n          draggable: false\n        })\n          .setLngLat(e.lngLat)\n          .addTo(mapRef.current);\n          \n        // Guardar referencia del marcador\n        setTempLocationMarker(marker);\n        \n        // PASO CRUCIAL: Mostrar el menú contextual INMEDIATAMENTE\n        const point = mapRef.current.project(e.lngLat);\n        \n        // Actualizar en un solo paso para evitar renders parciales que causen problemas\n        setContextMenu({\n          visible: true,\n          x: point.x,\n          y: point.y - 20, // Posicionar por encima del marcador\n          lngLat: e.lngLat\n        });\n        \n        // También guardar los datos de ubicación temporales\n        setTempLocationData({\n          latitude: e.lngLat.lat,\n          longitude: e.lngLat.lng,\n          locationName: \"Ubicación seleccionada\", \n          locationAddress: \"Cargando dirección...\"\n        });\n      }\n      \n      // Usar ambos servicios en paralelo para obtener resultados más completos\n      const mapboxPromise = reverseGeocode(e.lngLat.lng, e.lngLat.lat);\n      const googlePromise = googleReverseGeocode(e.lngLat.lng, e.lngLat.lat);\n      const nearbyPlacesPromise = findNearbyPlaces(e.lngLat.lat, e.lngLat.lng, 100);\n      \n      // Procesar todos los resultados\n      Promise.all([mapboxPromise, googlePromise, nearbyPlacesPromise])\n        .then(([mapboxAddress, googleAddress, nearbyPlaces]) => {\n          console.log(\"Geocode results:\", { mapboxAddress, googleAddress });\n          console.log(\"Nearby places:\", nearbyPlaces);\n          \n          // Extraer nombre del lugar - primero comprobar si hay establecimientos cercanos\n          let locationName;\n          let address;\n          \n          // Prioridad 1: Si encontramos lugares importantes (parques, plazas, etc.) usar esos nombres\n          // Identificar posibles lugares importantes (parques, puntos de interés, etc.)\n          const importantPlaces = Array.isArray(nearbyPlaces) \n            ? nearbyPlaces.filter(place => \n                // Buscar parques, puntos de interés, atracciones, locales marcados, etc.\n                ['park', 'point_of_interest', 'establishment', 'premise', 'neighborhood', 'natural_feature']\n                  .some(type => place.types && place.types.includes(type))\n              )\n            : [];\n          \n          if (importantPlaces.length > 0) {\n            const place = importantPlaces[0]; // Usar el lugar más relevante\n            locationName = place.name || \"Lugar del evento\";\n            \n            // Para la dirección completa, usar el resultado de geocodificación inversa\n            if (googleAddress && googleAddress !== \"Dirección no encontrada\" && googleAddress !== \"Error al obtener dirección\") {\n              address = googleAddress;\n            } else {\n              address = mapboxAddress;\n            }\n            \n            console.log(\"Usando nombre de lugar importante:\", locationName);\n          } \n          // Prioridad 2: Cualquier establecimiento cercano\n          else if (Array.isArray(nearbyPlaces) && nearbyPlaces.length > 0) {\n            const place = nearbyPlaces[0];\n            locationName = place.name || \"Lugar del evento\";\n            \n            // Para la dirección completa, usar el resultado de geocodificación inversa\n            if (googleAddress && googleAddress !== \"Dirección no encontrada\" && googleAddress !== \"Error al obtener dirección\") {\n              address = googleAddress;\n            } else {\n              address = mapboxAddress;\n            }\n            \n            console.log(\"Usando nombre de establecimiento cercano:\", locationName);\n          } \n          // Prioridad 3: Usar los resultados de geocodificación inversa de Google\n          else if (googleAddress && googleAddress !== \"Dirección no encontrada\" && googleAddress !== \"Error al obtener dirección\") {\n            // Buscar un nombre significativo que no sea solo una dirección\n            // Primero verificar si hay algo como \"Parque X\" o \"Plaza Y\" en la dirección\n            const specialPlaceMatch = googleAddress.match(/(Parque|Plaza|Museo|Estadio|Monumento|Jardín|Biblioteca|Universidad|Teatro|Centro)\\s+([^,]+)/i);\n            \n            if (specialPlaceMatch) {\n              // Usamos el nombre del lugar especial si lo encontramos\n              locationName = specialPlaceMatch[0];\n            } else {\n              // Si no, usamos la primera parte de la dirección\n              const placeNameMatch = googleAddress.match(/^([^,]+)/);\n              locationName = placeNameMatch ? placeNameMatch[0] : \"Lugar del evento\";\n            }\n            \n            address = googleAddress;\n            console.log(\"Usando dirección de Google:\", address);\n          } \n          // Última opción: MapBox como fallback\n          else {\n            // Buscar un nombre significativo que no sea solo una dirección\n            const specialPlaceMatch = mapboxAddress.match(/(Parque|Plaza|Museo|Estadio|Monumento|Jardín|Biblioteca|Universidad|Teatro|Centro)\\s+([^,]+)/i);\n            \n            if (specialPlaceMatch) {\n              // Usamos el nombre del lugar especial si lo encontramos\n              locationName = specialPlaceMatch[0];\n            } else {\n              // Si no, usamos la primera parte de la dirección\n              const placeNameMatch = mapboxAddress.match(/^([^,]+)/);\n              locationName = placeNameMatch ? placeNameMatch[0] : \"Lugar del evento\";\n            }\n            \n            address = mapboxAddress;\n            console.log(\"Usando dirección de MapBox (fallback):\", address);\n          }\n          \n          // Store location data\n          const locationData = {\n            latitude: e.lngLat.lat,\n            longitude: e.lngLat.lng,\n            locationAddress: address,\n            locationName: locationName\n          };\n          \n          console.log(\"Guardando datos de ubicación:\", locationData);\n          setTempLocationData(locationData);\n          \n          toast({\n            title: \"Ubicación seleccionada\",\n            description: `${locationName}`,\n          });\n        })\n        .catch(error => {\n          console.error(\"Error getting address or nearby places:\", error);\n          toast({\n            title: \"Error\",\n            description: \"No se pudo obtener la dirección. Por favor, intenta de nuevo.\",\n            variant: \"destructive\",\n          });\n        });\n    }\n\n    if (mapRef.current) {\n      console.log(\"Configurando manejador de clics en el mapa\");\n      \n      // Primero eliminar cualquier manejador existente para evitar duplicados\n      mapRef.current.off('click', handleMapClick);\n      \n      // Luego añadir el manejador de clics\n      mapRef.current.on('click', handleMapClick);\n      \n      // Return cleanup function\n      return () => {\n        if (mapRef.current) {\n          console.log(\"Eliminando manejador de clics del mapa\");\n          mapRef.current.off('click', handleMapClick);\n        }\n      };\n    }\n  }, [toast, tempLocationMarker]); // Removed locationMode from dependencies to ensure the click handler stays consistent\n  \n  // Initialize map on component mount and center on user's location\n  useEffect(() => {\n    if (!mapContainerRef.current || mapRef.current) return;\n\n    console.log(\"Inicializando mapa y configurando eventos globales\");\n\n    // Initialize the map with default config\n    mapRef.current = initializeMap(mapContainerRef.current);\n    \n    // Add controls\n    mapRef.current.addControl(new mapboxgl.NavigationControl(), 'top-right');\n\n    // Try to center on user's location automatically\n    navigator.geolocation.getCurrentPosition(\n      (position) => {\n        const { longitude, latitude } = position.coords;\n        \n        if (mapRef.current) {\n          mapRef.current.setCenter([longitude, latitude]);\n          mapRef.current.setZoom(13);\n          \n          // Add a marker for the user's current position\n          new mapboxgl.Marker({ color: '#1DA1F2' })\n            .setLngLat([longitude, latitude])\n            .addTo(mapRef.current);\n            \n          // Try to get the city name for a better user experience\n          reverseGeocode(longitude, latitude)\n            .then(address => {\n              toast({\n                title: \"Ubicación detectada\",\n                description: `Te mostramos eventos cercanos a tu ubicación`,\n              });\n            })\n            .catch(err => console.error(\"Error getting address:\", err));\n        }\n      },\n      (error) => {\n        console.warn(\"Error getting location:\", error);\n        // Fallback to default location (centered on a major city)\n        if (mapRef.current) {\n          // Center on Buenos Aires by default (more relevant for Spanish-speaking users)\n          mapRef.current.setCenter([-58.3816, -34.6037]);\n          mapRef.current.setZoom(12);\n        }\n      },\n      { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }\n    );\n\n    return () => {\n      console.log(\"Limpiando el mapa al desmontar componente\");\n      \n      // Clean up on unmount\n      if (mapRef.current) {\n        try {\n          // Limpiar los marcadores y popups primero\n          markersRef.current.forEach(marker => marker.remove());\n          popupsRef.current.forEach(popup => popup.remove());\n          markersRef.current = [];\n          popupsRef.current = [];\n          \n          // Eliminar cualquier marcador temporal\n          if (tempLocationMarker) {\n            tempLocationMarker.remove();\n            setTempLocationMarker(null);\n          }\n          \n          // Eliminar el mapa\n          mapRef.current.remove();\n          mapRef.current = null;\n        } catch (error) {\n          console.error(\"Error limpiando recursos del mapa:\", error);\n        }\n      }\n    };\n  }, []);\n\n  // Efecto para cerrar el menú contextual y limpiar marcadores temporales al hacer clic en cualquier parte de la aplicación \n  // que no sea el mapa o los botones de acción\n  useEffect(() => {\n    function handleClickOutside(e: MouseEvent) {\n      const target = e.target as Element;\n      \n      // Comprobar si es un clic dentro del mapa\n      const isMapClick = target.closest('.mapboxgl-canvas-container');\n      \n      // Comprobar si es un clic en los botones de acción\n      const isActionButton = target.closest('button') && (\n        target.textContent?.includes('Buscar eventos aquí') || \n        target.textContent?.includes('Crear un evento aquí') ||\n        target.textContent?.includes('Ver eventos cercanos') ||\n        target.textContent?.includes('Crear evento aquí')\n      );\n      \n      // Comprobar si es un clic en el menú contextual\n      const isContextMenuClick = target.closest('.context-menu');\n      \n      // IMPORTANTE: Evitamos cerrar el menú contextual con clicks outside\n      // Solo cerramos en casos muy específicos, por ejemplo si se hace clic en otra parte \n      // de la aplicación que no sea el mapa, el menú o los botones de acción\n      // Agregamos un log para depuración\n      if (contextMenu.visible) {\n        console.log(\"Click outside detectado - contextMenu visible, analizando objetivo:\", {\n          isMapClick,\n          isContextMenuClick,\n          isActionButton\n        });\n        \n        // Solo cerramos si no es ninguno de los elementos permitidos\n        if (!isMapClick && !isContextMenuClick && !isActionButton) {\n          console.log(\"Cerrando menú contextual por clic fuera de elementos permitidos\");\n          closeContextMenu();\n        } else {\n          console.log(\"Manteniendo menú contextual visible\");\n        }\n      }\n      \n      // Limpiar el marcador temporal y ocultar botones de acción si el clic no fue en:\n      // - El mapa\n      // - Los botones de acción específicos\n      // - La barra de búsqueda\n      // - Controles del mapa\n      if (showActionsForLocation && \n          !isMapClick && \n          !isActionButton && \n          !target.closest('.google-places-search') && \n          !target.closest('.mapboxgl-ctrl')) {\n        \n        console.log(\"Clic fuera de la ubicación seleccionada, ocultando botones de acción\");\n        \n        // Ocultar botones de acciones específicas\n        setShowActionsForLocation(false);\n        \n        // Limpiar el marcador temporal si existe\n        if (tempLocationMarker) {\n          tempLocationMarker.remove();\n          setTempLocationMarker(null);\n        }\n      }\n    }\n    \n    document.addEventListener('click', handleClickOutside);\n    \n    return () => {\n      document.removeEventListener('click', handleClickOutside);\n    };\n  }, [contextMenu.visible, showActionsForLocation, tempLocationMarker]);\n  \n  // Efecto para detectar cuando se cierra el formulario de creación de evento\n  useEffect(() => {\n    if (resetLocationOnFormClose) {\n      console.log(\"Detectada señal de cierre de formulario, limpiando marcadores temporales\");\n      cleanupTempMarkers();\n    }\n  }, [resetLocationOnFormClose]);\n\n  // Add event markers when events or filters change\n  useEffect(() => {\n    if (!mapRef.current) return;\n    \n    // Clear existing markers and popups\n    markersRef.current.forEach(marker => marker.remove());\n    popupsRef.current.forEach(popup => popup.remove());\n    markersRef.current = [];\n    popupsRef.current = [];\n    \n    // Add markers for filtered events\n    filteredEvents.forEach((event: Event) => {\n      if (!mapRef.current) return;\n      \n      // Create custom React element for the marker\n      const el = document.createElement('div');\n      el.className = \"custom-marker-container\";\n\n      // Render React component to the element\n      const root = createRoot(el);\n      root.render(<EventPin category={event.category} />);\n      \n      // Create popup\n      const popup = new mapboxgl.Popup({ offset: 25 })\n        .setHTML(`\n          <div class=\"popup-content\">\n            <h3 class=\"font-bold\">${event.title}</h3>\n            <p class=\"text-sm\">${event.locationName}</p>\n            <p class=\"text-xs text-gray-500\">\n              ${new Date(event.date).toLocaleDateString('es-ES', { \n                month: 'short', \n                day: 'numeric',\n                hour: '2-digit',\n                minute: '2-digit'\n              })}\n            </p>\n          </div>\n        `);\n      \n      // Validar y convertir coordenadas\n      const lng = typeof event.longitude === 'string' ? parseFloat(event.longitude) : event.longitude;\n      const lat = typeof event.latitude === 'string' ? parseFloat(event.latitude) : event.latitude;\n      \n      // Verificar que las coordenadas sean números válidos\n      if (isNaN(lng) || isNaN(lat)) {\n        console.error('Coordenadas inválidas para el evento:', event.id, event.title, {\n          longitude: event.longitude,\n          latitude: event.latitude\n        });\n        return; // Saltar este evento si las coordenadas no son válidas\n      }\n      \n      // Crear marcador solo si las coordenadas son válidas\n      const marker = new mapboxgl.Marker(el)\n        .setLngLat([lng, lat])\n        .setPopup(popup)\n        .addTo(mapRef.current);\n      \n      // Add event listener to marker\n      el.addEventListener('click', () => {\n        onEventSelect(event);\n      });\n      \n      // Track markers and popups for cleanup\n      markersRef.current.push(marker);\n      popupsRef.current.push(popup);\n    });\n  }, [filteredEvents, onEventSelect]);\n\n  // Handle search functionality\n  const handleSearch = (term: string) => {\n    setSearchTerm(term);\n  };\n  \n  // Función para limpiar los marcadores temporales y resetear el estado relacionado\n  const cleanupTempMarkers = () => {\n    console.log(\"Ejecutando limpieza forzada de marcadores temporales\");\n    \n    // Limpiar el marcador temporal si existe\n    if (tempLocationMarker) {\n      console.log(\"Eliminando marcador temporal existente\");\n      tempLocationMarker.remove();\n      setTempLocationMarker(null);\n    }\n    \n    // También limpiar los datos de ubicación temporal\n    setTempLocationData(null);\n    \n    // Resetear el modo de ubicación si está activo\n    if (locationMode) {\n      console.log(\"Desactivando modo de ubicación\");\n      setLocationMode(false);\n    }\n    \n    // Ocultar los botones de acción\n    setShowActionsForLocation(false);\n    \n    // Cerrar cualquier menú contextual abierto\n    setContextMenu({\n      visible: false,\n      x: 0,\n      y: 0,\n      lngLat: null\n    });\n    \n    // Forzar limpieza de cualquier otro marcador que podría haberse quedado\n    // Este enfoque es más agresivo pero asegura que no queden marcadores huérfanos\n    if (mapRef.current) {\n      // Obtener todos los marcadores del mapa\n      const markers = Array.from(document.querySelectorAll('.mapboxgl-marker'));\n      if (markers.length > 0) {\n        console.log(`Limpiando ${markers.length} marcadores encontrados en el DOM`);\n        \n        // Eliminar solo los marcadores temporales (para evitar eliminar los de eventos)\n        markers.forEach(markerElement => {\n          // Los marcadores de eventos tienen la clase custom-marker-container como hijo\n          const isEventMarker = markerElement.querySelector('.custom-marker-container');\n          if (!isEventMarker) {\n            console.log(\"Eliminando marcador huérfano\");\n            markerElement.remove();\n          }\n        });\n      }\n    }\n  };\n  \n  // Función para cerrar el menú contextual \n  const closeContextMenu = () => {\n    // Asegurarse de que el menú contextual se cierre correctamente\n    setContextMenu({\n      visible: false,\n      x: 0,\n      y: 0,\n      lngLat: null\n    });\n    \n    // También ocultar los botones de acción que podrían estar visibles\n    setShowActionsForLocation(false);\n    \n    // Siempre limpiar el marcador temporal para que no quede visible en el mapa\n    // Esto asegura que al hacer clic en Cancelar, siempre se elimine el marcador\n    if (tempLocationMarker) {\n      console.log(\"Eliminando marcador temporal al cerrar/cancelar acción\");\n      tempLocationMarker.remove();\n      setTempLocationMarker(null);\n      setTempLocationData(null);\n    }\n    \n    // Al cerrar el menú contextual con Cancelar, además de eliminar el marcador,\n    // también salimos del modo de ubicación si estamos en él \n    // y regresamos al estado normal con los botones principales\n    if (locationMode) {\n      console.log(\"Saliendo del modo de ubicación al cancelar\");\n      setLocationMode(false);\n    }\n  };\n  \n  // Función para crear un evento en la ubicación del menú contextual\n  const handleCreateEventAtLocation = async () => {\n    if (contextMenu.lngLat) {\n      const { lng, lat } = contextMenu.lngLat;\n      \n      try {\n        // Obtener información sobre la ubicación seleccionada\n        const mapboxPromise = reverseGeocode(lng, lat);\n        const googlePromise = googleReverseGeocode(lng, lat);\n        const nearbyPlacesPromise = findNearbyPlaces(lat, lng, 100);\n        \n        // Procesar resultados\n        const [mapboxAddress, googleAddress, nearbyPlaces] = await Promise.all([\n          mapboxPromise, googlePromise, nearbyPlacesPromise\n        ]);\n        \n        // Determinar el nombre y dirección del lugar\n        let locationName;\n        let address;\n        \n        // Prioridad 1: Si encontramos lugares importantes (parques, plazas, etc.) usar esos nombres\n        // Identificar posibles lugares importantes (parques, puntos de interés, etc.)\n        const importantPlaces = Array.isArray(nearbyPlaces) \n          ? nearbyPlaces.filter(place => \n              // Buscar parques, puntos de interés, atracciones, locales marcados, etc.\n              ['park', 'point_of_interest', 'establishment', 'premise', 'neighborhood', 'natural_feature']\n                .some(type => place.types && place.types.includes(type))\n            )\n          : [];\n        \n        if (importantPlaces.length > 0) {\n          const place = importantPlaces[0]; // Usar el lugar más relevante\n          locationName = place.name || \"Lugar del evento\";\n          \n          // Para la dirección completa, usar el resultado de geocodificación inversa\n          address = googleAddress || mapboxAddress;\n          \n          console.log(\"Usando nombre de lugar importante (menú contextual):\", locationName);\n        } \n        // Prioridad 2: Cualquier establecimiento cercano\n        else if (Array.isArray(nearbyPlaces) && nearbyPlaces.length > 0) {\n          locationName = nearbyPlaces[0].name || \"Lugar del evento\";\n          \n          // Para la dirección completa usamos geocodificación inversa\n          address = googleAddress || mapboxAddress;\n          \n          console.log(\"Usando nombre de establecimiento cercano (menú contextual):\", locationName);\n        } \n        // Prioridad 3: Buscar nombres significativos en los resultados de geocodificación\n        else if (googleAddress && googleAddress !== \"Dirección no encontrada\") {\n          address = googleAddress;\n          \n          // Buscar si hay algo como \"Parque X\" o \"Plaza Y\" en la dirección\n          const specialPlaceMatch = address.match(/(Parque|Plaza|Museo|Estadio|Monumento|Jardín|Biblioteca|Universidad|Teatro|Centro)\\s+([^,]+)/i);\n          \n          if (specialPlaceMatch) {\n            // Usamos el nombre del lugar especial si lo encontramos\n            locationName = specialPlaceMatch[0];\n            console.log(\"Encontrado nombre de lugar en dirección Google:\", locationName);\n          } else {\n            // Si no, usamos la primera parte de la dirección\n            const namePart = googleAddress.split(',')[0];\n            locationName = namePart || \"Lugar del evento\";\n          }\n        }\n        // Última opción: MapBox como fallback\n        else {\n          address = mapboxAddress;\n          \n          // Buscar si hay algo como \"Parque X\" o \"Plaza Y\" en la dirección\n          const specialPlaceMatch = address.match(/(Parque|Plaza|Museo|Estadio|Monumento|Jardín|Biblioteca|Universidad|Teatro|Centro)\\s+([^,]+)/i);\n          \n          if (specialPlaceMatch) {\n            // Usamos el nombre del lugar especial si lo encontramos\n            locationName = specialPlaceMatch[0];\n            console.log(\"Encontrado nombre de lugar en dirección MapBox:\", locationName);\n          } else {\n            // Si no, usamos la primera parte de la dirección\n            const namePart = mapboxAddress.split(',')[0];\n            locationName = namePart || \"Lugar del evento\";\n          }\n        }\n        \n        // Crear objeto de ubicación\n        const locationData = {\n          latitude: lat,\n          longitude: lng,\n          locationAddress: address,\n          locationName: locationName\n        };\n        \n        // Cerrar menú contextual\n        closeContextMenu();\n        \n        // Iniciar creación de evento con esta ubicación\n        onCreateEventClick(locationData);\n      }\n      catch (error) {\n        console.error(\"Error al obtener información de la ubicación:\", error);\n        toast({\n          title: \"Error\",\n          description: \"No se pudo obtener información sobre esta ubicación. Inténtalo de nuevo.\",\n          variant: \"destructive\"\n        });\n      }\n    }\n  };\n  \n  // Función para buscar eventos cercanos desde una ubicación específica\n  const handleSearchNearbyEvents = (lngLat: mapboxgl.LngLat) => {\n    if (mapRef.current) {\n      // Obtener las coordenadas\n      const lng = lngLat.lng;\n      const lat = lngLat.lat;\n      \n      console.log(\"Buscando eventos cerca de:\", { lng, lat });\n      \n      // Centrar el mapa en la ubicación seleccionada\n      mapRef.current.flyTo({\n        center: [lng, lat],\n        zoom: 15,\n        essential: true,\n        duration: 1000\n      });\n      \n      // Mostrar un toast para indicar que se están buscando eventos\n      toast({\n        title: \"Buscando eventos\",\n        description: \"Buscando eventos cercanos a esta ubicación...\",\n      });\n      \n      // Actualizar el estado con la ubicación actual y mostrar panel de filtros\n      setCurrentLocation({\n        lng: lng,\n        lat: lat,\n        locationName: \"Ubicación seleccionada\",\n        locationAddress: \"\"\n      });\n      \n      // Mostrar panel de eventos\n      setEventsPanelVisible(true);\n      \n      // Aquí se podrían hacer otras acciones como cargar eventos desde la API\n    }\n  };\n  \n  // Función para buscar eventos cercanos a la ubicación del menú contextual\n  const handleFindNearbyEvents = () => {\n    if (contextMenu.lngLat && mapRef.current) {\n      // Guardar las coordenadas antes de cerrar el menú contextual\n      const lng = contextMenu.lngLat.lng;\n      const lat = contextMenu.lngLat.lat;\n      \n      // Cerrar menú contextual primero\n      closeContextMenu();\n      \n      // Centrar el mapa en la ubicación seleccionada\n      mapRef.current.flyTo({\n        center: [lng, lat],\n        zoom: 15,\n        essential: true,\n        duration: 1000\n      });\n      \n      // FILTROS ACTIVADOS: cargar eventos cercanos a las coordenadas seleccionadas\n      \n      // Actualizar el estado con la ubicación actual\n      setCurrentLocation({\n        lng: lng,\n        lat: lat,\n        locationName: \"Ubicación seleccionada\",\n        locationAddress: \"\"\n      });\n      \n      // Filtrar eventos por cercanía a estas coordenadas\n      const nearbyEvents = events.filter((event: Event) => {\n        // Verificar distancia (si hay coordenadas válidas)\n        let distanceMatch = false;\n        const eventLat = typeof event.latitude === 'string' ? parseFloat(event.latitude) : event.latitude;\n        const eventLng = typeof event.longitude === 'string' ? parseFloat(event.longitude) : event.longitude;\n        \n        if (!isNaN(eventLat) && !isNaN(eventLng)) {\n          const distance = calculateDistance(\n            lat, \n            lng, \n            eventLat, \n            eventLng\n          );\n          distanceMatch = distance <= 2; // Radio de 2 km\n        }\n        \n        return distanceMatch;\n      });\n      \n      // Actualizar el estado con los eventos filtrados\n      setLocationFilteredEvents(nearbyEvents);\n      \n      // Mostrar panel de eventos\n      setEventsPanelVisible(true);\n      \n      // Eliminar cualquier marcador temporal previo\n      cleanupTempMarkers();\n      \n      // Crear un nuevo marcador en la ubicación seleccionada\n      if (mapRef.current) {\n        const marker = new mapboxgl.Marker({\n          color: '#1DA1F2'\n        })\n          .setLngLat([lng, lat])\n          .addTo(mapRef.current);\n          \n        // Guardar la referencia del marcador para poder eliminarlo después\n        setTempLocationMarker(marker);\n        \n        // Programar la eliminación automática del marcador después de 5 segundos\n        setTimeout(() => {\n          if (marker) {\n            marker.remove();\n            setTempLocationMarker(null);\n          }\n        }, 5000);\n      }\n      \n      // Mostrar notificación según el número de eventos encontrados\n      if (nearbyEvents.length > 0) {\n        toast({\n          title: `${nearbyEvents.length} eventos encontrados`,\n          description: \"Mostrando eventos cercanos a este lugar\",\n        });\n      } else {\n        toast({\n          title: \"No se encontraron eventos\",\n          description: \"No hay eventos cerca de esta ubicación\",\n          variant: \"destructive\"\n        });\n      }\n    }\n  };\n\n  // Function to toggle location selection mode\n  const toggleLocationMode = () => {\n    // If we're exiting location mode, clean up\n    if (locationMode) {\n      resetLocationSelection();\n    } else {\n      // Enter location selection mode\n      toast({\n        title: \"Modo de selección activado\",\n        description: \"Haz clic en el mapa o busca un lugar para seleccionar la ubicación del evento\",\n      });\n      \n      // Asegurarnos de que se limpie cualquier menú contextual abierto\n      setContextMenu({\n        visible: false,\n        x: 0,\n        y: 0,\n        lngLat: null\n      });\n      \n      // Limpiar cualquier marcador temporal que pueda existir\n      if (tempLocationMarker) {\n        tempLocationMarker.remove();\n        setTempLocationMarker(null);\n      }\n    }\n    \n    // Toggle mode - esta variable controla si estamos en modo de crear evento específicamente\n    setLocationMode(!locationMode);\n  };\n  \n  // Function to handle place selection from the search bar\n  const handlePlaceSelect = async (place: {\n    latitude: number;\n    longitude: number;\n    locationName: string;\n    locationAddress: string;\n  }) => {\n    console.log(\"Lugar seleccionado en la búsqueda:\", place);\n    \n    // Si no estamos en modo de selección de ubicación, simplemente centrar el mapa\n    if (!locationMode && mapRef.current) {\n      const longitude = typeof place.longitude === 'string' ? parseFloat(place.longitude) : place.longitude;\n      const latitude = typeof place.latitude === 'string' ? parseFloat(place.latitude) : place.latitude;\n      \n      // Centrar el mapa en la ubicación seleccionada\n      mapRef.current.flyTo({\n        center: [longitude, latitude],\n        zoom: 15,\n        essential: true,\n        duration: 1000\n      });\n      \n      // Opcional: Añadir un marcador temporal\n      if (tempLocationMarker) {\n        tempLocationMarker.remove();\n      }\n      \n      const marker = new mapboxgl.Marker({\n        color: '#1DA1F2'\n      })\n        .setLngLat([longitude, latitude])\n        .addTo(mapRef.current);\n      \n      // Guardamos la referencia del marcador temporal\n      setTempLocationMarker(marker);\n      \n      // Guardar la ubicación actual para los botones de acción\n      setCurrentLocation({\n        lng: longitude,\n        lat: latitude,\n        locationName: place.locationName,\n        locationAddress: place.locationAddress\n      });\n      \n      // Mostrar los botones de acción para esta ubicación\n      setShowActionsForLocation(true);\n      \n      // Mostrar toast con información\n      toast({\n        title: place.locationName,\n        description: place.locationAddress,\n      });\n      \n      return;\n    }\n    \n    // Si estamos en modo de selección de ubicación, procesar normalmente\n    if (locationMode && mapRef.current) {\n      // Remove previous marker if exists\n      if (tempLocationMarker) {\n        tempLocationMarker.remove();\n      }\n      \n      // Asegurar que las coordenadas sean números\n      const latitude = typeof place.latitude === 'string' ? parseFloat(place.latitude) : place.latitude;\n      const longitude = typeof place.longitude === 'string' ? parseFloat(place.longitude) : place.longitude;\n      \n      console.log(\"Coordenadas recibidas:\", {\n        latitude,\n        longitude,\n        tipo_lat: typeof latitude,\n        tipo_lng: typeof longitude\n      });\n      \n      const coordinates: [number, number] = [longitude, latitude];\n      \n      // Create a new marker\n      const marker = new mapboxgl.Marker({\n        color: '#FF385C',\n        draggable: true\n      })\n        .setLngLat(coordinates)\n        .addTo(mapRef.current);\n      \n      // Fly to the location\n      mapRef.current.flyTo({\n        center: coordinates,\n        zoom: 15,\n        essential: true,\n        duration: 1000\n      });\n      \n      // Store the marker reference\n      setTempLocationMarker(marker);\n      \n      // Intentar utilizar geocodificación inversa de Google Maps para mejor consistencia\n      try {\n        console.log(\"Solicitando geocodificación inversa de Google para:\", longitude, latitude);\n        const googleAddress = await googleReverseGeocode(longitude, latitude);\n        console.log(\"Google devolvió la dirección:\", googleAddress);\n        \n        const locationData = {\n          latitude: parseFloat(String(latitude)),\n          longitude: parseFloat(String(longitude)),\n          // Usar la dirección completa de Google para la dirección\n          locationAddress: googleAddress || place.locationAddress,\n          // IMPORTANTE: Mantener el nombre original del lugar que el usuario seleccionó\n          locationName: place.locationName\n        };\n        \n        console.log(\"Guardando datos de ubicación (Google):\", locationData);\n        setTempLocationData(locationData);\n        \n        toast({\n          title: \"Ubicación seleccionada\",\n          description: googleAddress || place.locationAddress,\n        });\n      } catch (error) {\n        console.error(\"Error obteniendo dirección de Google:\", error);\n        \n        // Fallback a la dirección original\n        const fallbackData = {\n          latitude: parseFloat(String(latitude)),\n          longitude: parseFloat(String(longitude)),\n          locationAddress: place.locationAddress,\n          locationName: place.locationName\n        };\n        \n        console.log(\"Guardando datos de ubicación (fallback):\", fallbackData);\n        setTempLocationData(fallbackData);\n        \n        toast({\n          title: \"Ubicación seleccionada\",\n          description: place.locationAddress,\n        });\n      }\n      \n      // Add dragend event to update data when marker is dragged\n      marker.on('dragend', async () => {\n        const lngLat = marker.getLngLat();\n        \n        // Intentar obtener dirección usando Google primero para mantener consistencia\n        try {\n          const googleAddress = await googleReverseGeocode(lngLat.lng, lngLat.lat);\n          \n          const updatedData = {\n            latitude: parseFloat(String(lngLat.lat)),\n            longitude: parseFloat(String(lngLat.lng)),\n            locationAddress: googleAddress,\n            locationName: googleAddress.split(',')[0] || \"Ubicación seleccionada\"\n          };\n          \n          console.log(\"Actualizando ubicación tras arrastrar (Google):\", updatedData);\n          setTempLocationData(updatedData);\n          \n          toast({\n            title: \"Ubicación actualizada\",\n            description: googleAddress,\n          });\n        } catch (error) {\n          console.error(\"Error obteniendo dirección de Google al arrastrar:\", error);\n          \n          // Fallback a MapBox si Google falla\n          try {\n            const mapboxAddress = await reverseGeocode(lngLat.lng, lngLat.lat);\n            \n            const fallbackData = {\n              latitude: parseFloat(String(lngLat.lat)),\n              longitude: parseFloat(String(lngLat.lng)),\n              locationAddress: mapboxAddress,\n              locationName: mapboxAddress.split(',')[0] || \"Ubicación seleccionada\"\n            };\n            \n            console.log(\"Actualizando ubicación tras arrastrar (Mapbox):\", fallbackData);\n            setTempLocationData(fallbackData);\n            \n            toast({\n              title: \"Ubicación actualizada\",\n              description: mapboxAddress,\n            });\n          } catch (mapboxError) {\n            console.error(\"Error también con Mapbox:\", mapboxError);\n            \n            // Último recurso si ambos fallan\n            const basicData = {\n              latitude: parseFloat(String(lngLat.lat)),\n              longitude: parseFloat(String(lngLat.lng)),\n              locationAddress: \"Dirección desconocida\",\n              locationName: \"Lugar del evento\"\n            };\n            \n            console.log(\"Actualizando ubicación con datos básicos:\", basicData);\n            setTempLocationData(basicData);\n            \n            toast({\n              title: \"Ubicación actualizada\",\n              description: \"No se pudo obtener la dirección exacta\",\n              variant: \"destructive\"\n            });\n          }\n        }\n      });\n    }\n  };\n  \n  // Function to reset location selection - Simplified and improved version\n  const resetLocationSelection = () => {\n    console.log(\"Reseteando selección de ubicación\");\n    \n    // Limpiar el marcador temporal si existe\n    if (tempLocationMarker) {\n      tempLocationMarker.remove();\n      setTempLocationMarker(null);\n    }\n    \n    // Limpiar datos de ubicación temporal\n    setTempLocationData(null);\n    \n    // Asegurarse de que el menú contextual esté cerrado\n    setContextMenu({\n      visible: false,\n      x: 0,\n      y: 0,\n      lngLat: null\n    });\n    \n    // Resetear el modo de ubicación (si está activo)\n    if (locationMode) {\n      console.log(\"Limpiando modo de ubicación\");\n      setLocationMode(false);\n    }\n    \n    // Resetear cualquier otro estado relacionado con la selección de ubicación\n    setShowActionsForLocation(false);\n    \n    // Limpiar cualquier marcador huérfano que pueda haber quedado\n    console.log(\"Limpiando marcadores huérfanos del DOM\");\n    document.querySelectorAll('.mapboxgl-marker').forEach(element => {\n      element.remove();\n    });\n  };\n  \n  // Function to confirm location selection\n  const confirmLocationSelection = async () => {\n    if (tempLocationData) {\n      console.log(\"Confirmando ubicación original (Mapbox):\", tempLocationData);\n      \n      try {\n        // Intentar obtener la dirección usando Google Maps para consistencia\n        const googleAddress = await googleReverseGeocode(\n          tempLocationData.longitude, \n          tempLocationData.latitude\n        );\n        \n        // Crear objeto de ubicación con formato correcto para Google Maps\n        // Garantizamos explícitamente que las coordenadas son números\n        const locationData = {\n          latitude: Number(tempLocationData.latitude),\n          longitude: Number(tempLocationData.longitude),\n          // Usar la dirección de Google para la dirección completa pero mantener el nombre original\n          locationAddress: googleAddress || tempLocationData.locationAddress,\n          // Mantener el nombre original del lugar en vez de usar la primera parte de la dirección\n          locationName: tempLocationData.locationName\n        };\n        \n        console.log('COORDENADAS CONFIRMADAS:', {\n          latitude: locationData.latitude,\n          longitude: locationData.longitude,\n          tipoLat: typeof locationData.latitude,\n          tipoLon: typeof locationData.longitude\n        });\n        \n        console.log(\"Ubicación reformateada para Google Maps:\", locationData);\n        \n        // Call the function provided by parent to create event with the selected location\n        onCreateEventClick(locationData);\n        \n        // Clean up\n        resetLocationSelection();\n        setLocationMode(false);\n        \n        toast({\n          title: \"Ubicación confirmada\",\n          description: \"Ahora puedes completar los detalles del evento\",\n        });\n      } catch (error) {\n        console.error(\"Error al convertir coordenadas para Google Maps:\", error);\n        \n        // Usar datos originales de Mapbox como fallback\n        const fallbackLocationData = {\n          latitude: Number(tempLocationData.latitude),\n          longitude: Number(tempLocationData.longitude),\n          locationAddress: tempLocationData.locationAddress,\n          locationName: tempLocationData.locationName\n        };\n        \n        console.log('COORDENADAS FALLBACK:', {\n          latitude: fallbackLocationData.latitude,\n          longitude: fallbackLocationData.longitude,\n          tipoLat: typeof fallbackLocationData.latitude,\n          tipoLon: typeof fallbackLocationData.longitude\n        });\n        \n        console.log(\"Usando ubicación de fallback:\", fallbackLocationData);\n        onCreateEventClick(fallbackLocationData);\n        \n        resetLocationSelection();\n        setLocationMode(false);\n        \n        toast({\n          title: \"Ubicación confirmada\",\n          description: \"Ahora puedes completar los detalles del evento\",\n        });\n      }\n    } else {\n      toast({\n        title: \"No hay ubicación seleccionada\",\n        description: \"Haz clic en el mapa para seleccionar la ubicación del evento\",\n        variant: \"destructive\",\n      });\n    }\n  };\n  \n  // Función para calcular la distancia entre dos puntos de coordenadas en km (fórmula de Haversine)\n  const calculateDistance = (lat1: number, lon1: number, lat2: number, lon2: number): number => {\n    const R = 6371; // Radio de la Tierra en km\n    const dLat = (lat2 - lat1) * (Math.PI / 180);\n    const dLon = (lon2 - lon1) * (Math.PI / 180);\n    const a = \n      Math.sin(dLat/2) * Math.sin(dLat/2) +\n      Math.cos(lat1 * (Math.PI / 180)) * Math.cos(lat2 * (Math.PI / 180)) * \n      Math.sin(dLon/2) * Math.sin(dLon/2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n    const distance = R * c; // Distancia en km\n    return distance;\n  };\n  \n  // Función para buscar eventos cercanos a la ubicación actual\n  const handleSearchEventsAtLocation = () => {\n    if (currentLocation && mapRef.current) {\n      // Centrar el mapa en la ubicación seleccionada\n      mapRef.current.flyTo({\n        center: [currentLocation.lng, currentLocation.lat],\n        zoom: 15,\n        essential: true,\n        duration: 1000\n      });\n      \n      // Filtrar eventos por cercanía y por nombre\n      if (currentLocation.locationName) {\n        // Convertir a minúsculas para comparar\n        const placeName = currentLocation.locationName.toLowerCase();\n        \n        console.log(\"Buscando eventos relacionados con:\", placeName);\n        \n        // Filtrar eventos cercanos (radio de 2 km) o que contengan el nombre del lugar\n        const nearbyEvents = events.filter((event: Event) => {\n          // Verificar si la ubicación está en el nombre o descripción del evento\n          const nameMatch = event.title.toLowerCase().includes(placeName) || \n                          (event.description && event.description.toLowerCase().includes(placeName)) ||\n                          (event.locationName && event.locationName.toLowerCase().includes(placeName));\n          \n          // Verificar distancia (si hay coordenadas válidas)\n          let distanceMatch = false;\n          const eventLat = typeof event.latitude === 'string' ? parseFloat(event.latitude) : event.latitude;\n          const eventLng = typeof event.longitude === 'string' ? parseFloat(event.longitude) : event.longitude;\n          \n          if (!isNaN(eventLat) && !isNaN(eventLng)) {\n            const distance = calculateDistance(\n              currentLocation.lat, \n              currentLocation.lng, \n              eventLat, \n              eventLng\n            );\n            distanceMatch = distance <= 2; // Radio de 2 km\n            \n            if (distanceMatch) {\n              console.log(`Evento \"${event.title}\" está a ${distance.toFixed(2)} km`);\n            }\n          }\n          \n          // El evento coincide si está cerca o si contiene el nombre del lugar\n          return nameMatch || distanceMatch;\n        });\n        \n        console.log(\"Eventos cercanos o relacionados con\", currentLocation.locationName, \":\", nearbyEvents.length);\n        \n        // Actualizar el estado con los eventos filtrados\n        setLocationFilteredEvents(nearbyEvents);\n        \n        // Si hay eventos, mostrar notificación con el número\n        if (nearbyEvents.length > 0) {\n          toast({\n            title: `${nearbyEvents.length} eventos encontrados`,\n            description: `Eventos cerca de ${currentLocation.locationName}`,\n          });\n        } else {\n          toast({\n            title: \"No se encontraron eventos\",\n            description: `No hay eventos cerca de ${currentLocation.locationName}`,\n            variant: \"destructive\"\n          });\n        }\n      } else {\n        // Si no hay nombre de ubicación, usar todos los eventos\n        setLocationFilteredEvents(events);\n      }\n      \n      // Mostrar panel de eventos\n      setEventsPanelVisible(true);\n      \n      // Ocultar botones de acción\n      setShowActionsForLocation(false);\n      \n      // Limpiar marcadores\n      cleanupTempMarkers();\n      \n      // Importante: añadir un pequeño retraso para asegurar que no se quede el marcador\n      // Este enfoque asegura que cualquier otro marcador que pudiera ser generado\n      // por otras funciones también se elimine.\n      setTimeout(() => {\n        cleanupTempMarkers();\n      }, 100);\n    }\n  };\n  \n  // Función para crear un evento en la ubicación actual\n  const handleCreateEventAtCurrentLocation = async () => {\n    if (currentLocation) {\n      try {\n        // Intentar obtener más información sobre la ubicación\n        const googleAddress = await googleReverseGeocode(\n          currentLocation.lng, \n          currentLocation.lat\n        );\n        \n        // Crear objeto de ubicación con el formato esperado\n        const locationData = {\n          latitude: currentLocation.lat,\n          longitude: currentLocation.lng,\n          locationAddress: currentLocation.locationAddress || googleAddress || \"Dirección desconocida\",\n          locationName: currentLocation.locationName || googleAddress?.split(',')[0] || \"Lugar del evento\"\n        };\n        \n        // Iniciar creación de evento\n        onCreateEventClick(locationData);\n        \n        // Resetear estados\n        resetLocationSelection();\n        setShowActionsForLocation(false);\n      }\n      catch (error) {\n        console.error(\"Error al preparar la ubicación para el evento:\", error);\n        \n        // Usar los datos disponibles como fallback\n        const fallbackData = {\n          latitude: currentLocation.lat,\n          longitude: currentLocation.lng,\n          locationAddress: currentLocation.locationAddress || \"Dirección desconocida\",\n          locationName: currentLocation.locationName || \"Lugar del evento\"\n        };\n        \n        onCreateEventClick(fallbackData);\n        \n        // Resetear estados\n        resetLocationSelection();\n        setShowActionsForLocation(false);\n      }\n    }\n  };\n  \n  // Handle going to user's current location\n  const handleGoToCurrentLocation = async () => {\n    if (!mapRef.current) return;\n    \n    try {\n      const position = await getUserLocation(mapRef.current);\n      const { longitude, latitude } = position.coords;\n      \n      console.log(\"Obtenida ubicación actual:\", {\n        latitude,\n        longitude,\n        tipo_lat: typeof latitude,\n        tipo_lng: typeof longitude\n      });\n      \n      mapRef.current.flyTo({\n        center: [longitude, latitude],\n        zoom: 15,\n        essential: true\n      });\n      \n      // If in location selection mode, set this as the location\n      if (locationMode) {\n        // Remove existing marker if any\n        if (tempLocationMarker) {\n          tempLocationMarker.remove();\n        }\n        \n        // Create marker at current location\n        const marker = new mapboxgl.Marker({ \n          color: '#FF5A5F',\n          draggable: true \n        })\n          .setLngLat([longitude, latitude])\n          .addTo(mapRef.current);\n        \n        setTempLocationMarker(marker);\n        \n        // Intentar obtener la dirección usando Google Maps para mejor consistencia\n        try {\n          console.log(\"Solicitando dirección de Google para ubicación actual\");\n          const googleAddress = await googleReverseGeocode(longitude, latitude);\n          console.log(\"Google devolvió dirección para ubicación actual:\", googleAddress);\n          \n          // Extract place name\n          const locationName = googleAddress.split(',')[0] || \"Lugar del evento\";\n          \n          // Store location data\n          const locationData = {\n            latitude: parseFloat(String(latitude)),\n            longitude: parseFloat(String(longitude)),\n            locationAddress: googleAddress,\n            locationName: locationName\n          };\n          \n          console.log(\"Guardando datos de ubicación actual (Google):\", locationData);\n          setTempLocationData(locationData);\n          \n          toast({\n            title: \"Ubicación seleccionada\",\n            description: googleAddress,\n          });\n        } catch (googleError) {\n          console.error(\"Error obteniendo dirección de Google para ubicación actual:\", googleError);\n          \n          // Fallback a Mapbox si Google falla\n          try {\n            console.log(\"Intentando obtener dirección con Mapbox\");\n            const mapboxAddress = await reverseGeocode(longitude, latitude);\n            \n            // Extract place name\n            const locationName = mapboxAddress.split(',')[0] || \"Lugar del evento\";\n            \n            // Store location data\n            const fallbackData = {\n              latitude: parseFloat(String(latitude)),\n              longitude: parseFloat(String(longitude)),\n              locationAddress: mapboxAddress,\n              locationName: locationName\n            };\n            \n            console.log(\"Guardando datos de ubicación actual (Mapbox):\", fallbackData);\n            setTempLocationData(fallbackData);\n            \n            toast({\n              title: \"Ubicación seleccionada\",\n              description: mapboxAddress,\n            });\n          } catch (mapboxError) {\n            console.error(\"También falló Mapbox:\", mapboxError);\n            \n            // Último recurso: datos básicos sin dirección\n            const basicData = {\n              latitude: parseFloat(String(latitude)),\n              longitude: parseFloat(String(longitude)),\n              locationAddress: \"Dirección desconocida\",\n              locationName: \"Lugar del evento\"\n            };\n            \n            console.log(\"Guardando datos de ubicación básicos:\", basicData);\n            setTempLocationData(basicData);\n            \n            toast({\n              title: \"Ubicación seleccionada\",\n              description: \"No se pudo obtener la dirección. La ubicación ha sido seleccionada, pero sin dirección.\",\n              variant: \"destructive\",\n            });\n          }\n        }\n      } else {\n        // Just add a marker for current location if not in selection mode\n        new mapboxgl.Marker({ color: '#1DA1F2' })\n          .setLngLat([longitude, latitude])\n          .addTo(mapRef.current);\n        \n        toast({\n          title: \"Ubicación Actualizada\",\n          description: \"Mapa centrado en tu ubicación actual\",\n        });\n      }\n    } catch (error) {\n      console.error('Error getting location:', error);\n      toast({\n        title: \"Error de Ubicación\",\n        description: \"No se pudo acceder a tu ubicación\",\n        variant: \"destructive\",\n      });\n    }\n  };\n\n  return (\n    <div className=\"relative flex-1 h-full w-full bg-neutral-100 overflow-hidden\">\n      {/* Real Mapbox Map Container */}\n      <div \n        ref={mapContainerRef}\n        id=\"map-container\" \n        className=\"absolute top-0 left-0 right-0 bottom-0 z-0 map-container\"\n      ></div>\n      \n      {/* Events Panel - Only visible when eventsPanelVisible is true */}\n      {eventsPanelVisible && (\n        <div className=\"absolute bottom-20 left-0 right-0 max-h-72 overflow-y-auto z-20 bg-white rounded-t-xl shadow-lg p-4\">\n          <div className=\"flex items-center justify-between mb-4\">\n            <h2 className=\"text-lg font-bold\">\n              {currentLocation \n                ? `Eventos cerca de ${currentLocation.locationName || 'esta ubicación'}`\n                : 'Eventos cercanos'\n              }\n            </h2>\n            <button \n              onClick={() => {\n                setEventsPanelVisible(false);\n                cleanupTempMarkers();\n              }}\n              className=\"p-1 rounded-full hover:bg-gray-100\"\n            >\n              <X size={20} />\n            </button>\n          </div>\n          \n          {isLoading ? (\n            <div className=\"flex justify-center items-center py-8\">\n              <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-primary\"></div>\n            </div>\n          ) : locationFilteredEvents.length > 0 ? (\n            <div className=\"grid grid-cols-1 gap-3 pb-1\">\n              {locationFilteredEvents.map((event: Event) => (\n                <Card \n                  key={event.id} \n                  className=\"p-3 shadow-sm cursor-pointer hover:shadow-md transition-shadow flex flex-row gap-3 items-center\"\n                  onClick={() => {\n                    // Asegurarse de que latitude y longitude sean números antes de pasar el evento\n                    const formattedEvent = {\n                      ...event,\n                      latitude: typeof event.latitude === 'string' ? parseFloat(event.latitude) : event.latitude,\n                      longitude: typeof event.longitude === 'string' ? parseFloat(event.longitude) : event.longitude\n                    };\n                    \n                    onEventSelect(formattedEvent);\n                    setEventsPanelVisible(false);\n                  }}\n                >\n                  <div className=\"flex-shrink-0\">\n                    <div className=\"w-12 h-12 rounded-full bg-gray-100 flex items-center justify-center\">\n                      <CategoryPin category={event.category} size={24} />\n                    </div>\n                  </div>\n                  <div className=\"flex-1 min-w-0\">\n                    <div className=\"text-xs font-semibold uppercase text-gray-500 mb-1\">\n                      {event.category}\n                    </div>\n                    <h3 className=\"font-bold text-sm truncate\">{event.title}</h3>\n                    <p className=\"text-xs text-gray-600 truncate\">{event.locationName}</p>\n                    <p className=\"text-xs text-gray-500\">\n                      {new Date(event.date).toLocaleDateString('es-ES', { \n                        month: 'short', \n                        day: 'numeric', \n                        hour: '2-digit', \n                        minute: '2-digit' \n                      })}\n                    </p>\n                  </div>\n                </Card>\n              ))}\n            </div>\n          ) : currentLocation ? (\n            <div className=\"w-full text-center py-8 text-gray-500\">\n              <p>No hay eventos cerca de {currentLocation.locationName || 'esta ubicación'}</p>\n              <p className=\"text-sm\">Prueba con otra ubicación o crea un evento aquí</p>\n            </div>\n          ) : filteredEvents.length > 0 ? (\n            <div className=\"grid grid-cols-1 gap-3 pb-1\">\n              {filteredEvents.map((event: Event) => (\n                <Card \n                  key={event.id} \n                  className=\"p-3 shadow-sm cursor-pointer hover:shadow-md transition-shadow flex flex-row gap-3 items-center\"\n                  onClick={() => {\n                    // Asegurarse de que latitude y longitude sean números antes de pasar el evento\n                    const formattedEvent = {\n                      ...event,\n                      latitude: typeof event.latitude === 'string' ? parseFloat(event.latitude) : event.latitude,\n                      longitude: typeof event.longitude === 'string' ? parseFloat(event.longitude) : event.longitude\n                    };\n                    \n                    onEventSelect(formattedEvent);\n                    setEventsPanelVisible(false);\n                  }}\n                >\n                  <div className=\"flex-shrink-0\">\n                    <div className=\"w-12 h-12 rounded-full bg-gray-100 flex items-center justify-center\">\n                      <CategoryPin category={event.category} size={24} />\n                    </div>\n                  </div>\n                  <div className=\"flex-1 min-w-0\">\n                    <div className=\"text-xs font-semibold uppercase text-gray-500 mb-1\">\n                      {event.category}\n                    </div>\n                    <h3 className=\"font-bold text-sm truncate\">{event.title}</h3>\n                    <p className=\"text-xs text-gray-600 truncate\">{event.locationName}</p>\n                    <p className=\"text-xs text-gray-500\">\n                      {new Date(event.date).toLocaleDateString('es-ES', { \n                        month: 'short', \n                        day: 'numeric', \n                        hour: '2-digit', \n                        minute: '2-digit' \n                      })}\n                    </p>\n                  </div>\n                </Card>\n              ))}\n            </div>\n          ) : (\n            <div className=\"w-full text-center py-8 text-gray-500\">\n              <p>No hay eventos que coincidan con tus filtros</p>\n              <p className=\"text-sm\">Intenta con otros filtros o cambia de ubicación</p>\n            </div>\n          )}\n        </div>\n      )}\n      \n      {/* Search Bars */}\n      <div className=\"absolute top-4 left-4 right-4 z-10 flex flex-col gap-2\">\n        {/* Barra de búsqueda principal con filtros */}\n        <div className=\"flex items-center gap-2\">\n          <div className=\"flex-1\">\n            <GooglePlacesSearch \n              onPlaceSelect={handlePlaceSelect}\n              placeholder=\"Buscar lugares con Google Maps...\"\n            />\n          </div>\n          <Button \n            variant=\"outline\" \n            size=\"icon\" \n            className=\"h-11 w-11 rounded-full bg-white\"\n            onClick={() => setFiltersVisible(!filtersVisible)}\n          >\n            <Filter className=\"h-5 w-5\" />\n          </Button>\n        </div>\n        \n        {/* Barra de búsqueda de MapBox como fallback (temporal) */}\n        {false && (\n          <SearchBar \n            onSearch={handleSearch} \n            onFilterClick={() => setFiltersVisible(!filtersVisible)}\n            onPlaceSelect={locationMode ? handlePlaceSelect : undefined}\n          />\n        )}\n      </div>\n      \n      {/* Filters Panel */}\n      {filtersVisible && (\n        <EventFilters \n          onClose={() => setFiltersVisible(false)} \n          onApply={(newFilters) => {\n            // Apply the new filters to the parent component\n            if (filters && typeof filters === 'object') {\n              // Update category filter\n              if (newFilters.categories.length > 0) {\n                filters.category = newFilters.categories;\n              } else {\n                delete filters.category;\n              }\n              \n              // Update payment type filter\n              if (newFilters.paymentTypes.length > 0) {\n                filters.paymentType = newFilters.paymentTypes;\n              } else {\n                delete filters.paymentType;\n              }\n              \n              // Update date filter (will need date processing logic)\n              if (newFilters.dateFilter !== \"all\") {\n                filters.date = newFilters.dateFilter;\n              } else {\n                delete filters.date;\n              }\n            }\n            \n            // Close the filters panel\n            setFiltersVisible(false);\n            toast({\n              title: \"Filtros aplicados\",\n              description: \"Los eventos han sido filtrados según tus preferencias\",\n            });\n          }}\n        />\n      )}\n      \n      {/* Location Selection Mode Indicator */}\n      {locationMode && (\n        <div className=\"absolute top-16 left-0 right-0 z-20 flex justify-center\">\n          <div className=\"bg-primary text-white px-4 py-2 rounded-full shadow-lg\">\n            <span className=\"text-sm font-medium\">\n              Selecciona la ubicación para el evento\n            </span>\n          </div>\n        </div>\n      )}\n      \n      {/* Menú contextual cuando se hace clic en el mapa - ESTILO ANTIGUO tipo menú flotante */}\n      {/* Menú contextual - Siempre renderizamos pero usamos visibility para mostrar/ocultar */}\n      <div \n        className=\"absolute z-50 bg-white rounded-lg shadow-lg p-2 min-w-[180px] max-w-[300px] context-menu\"\n        style={{\n          visibility: contextMenu.visible ? 'visible' : 'hidden',\n          top: contextMenu.y - 100, // Ajustar para que aparezca sobre el marcador\n          left: contextMenu.x,\n          transform: 'translate(-50%, -50%)', // Centrar en el punto del click\n          pointerEvents: contextMenu.visible ? 'auto' : 'none' // Solo recibe eventos cuando es visible\n        }}\n        onClick={(e) => {\n          // Evitar cualquier cierre automático del menú contextual\n          e.stopPropagation();\n          e.preventDefault();\n          console.log(\"Click en el menú contextual capturado y detenido\");\n        }}\n        onMouseDown={(e) => {\n          // También prevenir mousedown para evitar problemas de propagación de eventos\n          e.stopPropagation();\n        }}\n      >\n        <div className=\"flex flex-col\">\n          {/* Título */}\n          <div className=\"p-2 text-center border-b border-gray-200\">\n            <span className=\"text-sm font-medium\">¿Qué quieres hacer?</span>\n          </div>\n          \n          {/* Opciones */}\n          <button \n            className=\"p-2 text-left hover:bg-gray-100 text-sm flex items-center gap-2\"\n            onClick={handleCreateEventAtLocation}\n          >\n            <Plus size={16} />\n            Crear evento aquí\n          </button>\n          \n          <button \n            className=\"p-2 text-left hover:bg-gray-100 text-sm flex items-center gap-2\"\n            onClick={() => {\n              closeContextMenu(); // Primero cerramos el menú\n              // Luego buscamos eventos cerca de la ubicación seleccionada\n              if (contextMenu.lngLat) {\n                handleSearchNearbyEvents(contextMenu.lngLat);\n              }\n            }}\n          >\n            <Compass size={16} />\n            Buscar eventos cerca\n          </button>\n          \n          <button \n            className=\"p-2 text-left hover:bg-gray-100 text-sm flex items-center gap-2\"\n            onClick={closeContextMenu}\n          >\n            <X size={16} />\n            Cancelar\n          </button>\n        </div>\n      )}\n      \n      {/* Solo mostramos el encabezado de selección sin la tarjeta de información */}\n      \n      {/* Current Location Button - Always visible */}\n      <button \n        className=\"absolute bottom-16 right-4 p-3 bg-white rounded-full shadow-lg text-neutral-700 border border-neutral-200 hover:bg-gray-50 flex items-center justify-center z-20\"\n        onClick={handleGoToCurrentLocation}\n        title=\"Ir a mi ubicación\"\n        aria-label=\"Ir a mi ubicación actual\"\n      >\n        <Circle size={24} />\n      </button>\n      \n      {/* Main action buttons - Centered at bottom - SIEMPRE VISIBLES */}\n      <div className=\"absolute bottom-6 left-0 right-0 z-20 flex justify-center gap-4 px-6\">\n        {showActionsForLocation ? (\n          // Botones específicos para la ubicación buscada\n          <>\n            {/* Buscar Eventos Cercanos */}\n            <button \n              className=\"flex-1 py-3 bg-white rounded-xl shadow-lg text-neutral-700 border border-neutral-200 flex items-center justify-center gap-2 font-medium\"\n              onClick={handleSearchEventsAtLocation}\n            >\n              <Compass size={20} />\n              Buscar eventos aquí\n            </button>\n            \n            {/* Crear Evento Aquí */}\n            <button \n              className=\"flex-1 py-3 bg-primary rounded-xl shadow-lg text-white flex items-center justify-center gap-2 font-medium\"\n              onClick={handleCreateEventAtCurrentLocation}\n            >\n              <Plus size={20} />\n              Crear un evento aquí\n            </button>\n          </>\n        ) : !locationMode ? (\n          // Botones normales - Modo estándar\n          <>\n            {/* Discover Events Button */}\n            <button \n              className=\"flex-1 py-3 bg-white rounded-xl shadow-lg text-neutral-700 border border-neutral-200 flex items-center justify-center gap-2 font-medium\"\n              onClick={() => setEventsPanelVisible(!eventsPanelVisible)}\n            >\n              <Compass size={20} />\n              Descubrir eventos\n            </button>\n            \n            {/* Create Event Button */}\n            <button \n              className=\"flex-1 py-3 bg-primary rounded-xl shadow-lg text-white flex items-center justify-center gap-2 font-medium\"\n              onClick={toggleLocationMode}\n            >\n              <Plus size={20} />\n              Crear un evento\n            </button>\n          </>\n        ) : (\n          // Botones para modo de selección de ubicación\n          <>\n            {/* Cancel Location Selection */}\n            <button \n              className=\"flex-1 py-3 bg-white rounded-xl shadow-lg text-red-600 border border-neutral-200 flex items-center justify-center gap-2 font-medium\"\n              onClick={() => {\n                setLocationMode(false);\n                resetLocationSelection();\n              }}\n            >\n              <X size={20} />\n              Cancelar\n            </button>\n            \n            {/* Confirm Location Button */}\n            <button \n              className=\"flex-1 py-3 bg-primary rounded-xl shadow-lg text-white flex items-center justify-center gap-2 font-medium\"\n              onClick={confirmLocationSelection}\n              disabled={!tempLocationData}\n            >\n              <Check size={20} />\n              Crear un evento aquí\n            </button>\n          </>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default MapView;\n","size_bytes":72899},"media-patch.js":{"content":"// Este parche es para solucionar el problema de pérdida de archivos multimedia al editar eventos\n// Buscar la sección donde se procesan los mediaItems antes de guardar en la base de datos\n// Alrededor de las líneas 1985-1992 en server/routes.ts\n\n// ANTES DE ACTUALIZAR:\nconsole.log(\"Datos de multimedia a guardar:\");\nconsole.log(\"- mediaItems:\", mediaItems);\nconsole.log(\"- mainMediaType:\", mainMediaType);\nconsole.log(\"- mainMediaUrl:\", mainMediaUrl);\n\n// Si mediaItems está vacío pero el evento tenía mediaItems antes de esta actualización\n// esto indica un error del cliente al enviar los datos\nif (mediaItems.length === 0 && event.mediaItems && event.mediaItems !== \"[]\") {\n  try {\n    // Intentar recuperar los mediaItems originales\n    const originalMediaItems = JSON.parse(event.mediaItems);\n    if (Array.isArray(originalMediaItems) && originalMediaItems.length > 0) {\n      console.log(\"🔒 PRESERVANDO MEDIOS ORIGINALES: Se detectó pérdida de datos multimedia\");\n      console.log(`Evento tenía ${originalMediaItems.length} elementos multimedia antes de la actualización`);\n      console.log(\"Conservando los elementos multimedia originales del evento\");\n      \n      // Restaurar los mediaItems originales\n      mediaItems = originalMediaItems;\n      \n      // Restaurar también el elemento principal\n      const mainItem = originalMediaItems.find(item => item.isMain);\n      if (mainItem) {\n        mainMediaUrl = mainItem.url;\n        mainMediaType = mainItem.type;\n        console.log(`Restaurando elemento principal: ${mainMediaType} - ${mainMediaUrl}`);\n      } else if (originalMediaItems.length > 0) {\n        // Si no hay un elemento principal marcado, usar el primero\n        mainMediaUrl = originalMediaItems[0].url;\n        mainMediaType = originalMediaItems[0].type;\n        originalMediaItems[0].isMain = true;\n        console.log(`Estableciendo primer elemento como principal: ${mainMediaType} - ${mainMediaUrl}`);\n      }\n      \n      // Actualizar también el updateData con estos valores\n      updateData.mediaItems = JSON.stringify(mediaItems);\n      updateData.mainMediaUrl = mainMediaUrl;\n      updateData.mainMediaType = mainMediaType;\n      \n      console.log(\"Datos de multimedia ACTUALIZADOS para guardar:\");\n      console.log(\"- mediaItems:\", mediaItems);\n      console.log(\"- mainMediaType:\", mainMediaType);\n      console.log(\"- mainMediaUrl:\", mainMediaUrl);\n    }\n  } catch (e) {\n    console.error(\"Error al intentar recuperar mediaItems originales:\", e);\n  }\n}","size_bytes":2515},"migrate-application-answers.js":{"content":"import { createClient } from '@supabase/supabase-js';\n\nconst supabaseUrl = process.env.SUPABASE_URL || \"https://pbvkjkjdtwftjetpreai.supabase.co\";\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY || \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBidmtqa2pkdHdmdGpldHByZWFpIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTczODgxNjc2OSwiZXhwIjoyMDU0MzkyNzY5fQ.jckYD_TEuV0Z-1lPSWdL0lINmAc5EKaZwC-k_-IX1oA\";\n\nconst supabase = createClient(supabaseUrl, supabaseServiceKey);\n\nasync function addApplicationAnswersColumn() {\n  try {\n    console.log('🔄 Checking current event_attendees table structure...');\n    \n    // First, check if the column already exists by testing a simple query\n    const { data: testData, error: testError } = await supabase\n      .from('event_attendees')\n      .select('application_answers')\n      .limit(1);\n\n    if (!testError) {\n      console.log('✅ Column application_answers already exists in event_attendees table');\n      console.log('Migration completed successfully - no changes needed');\n      return;\n    }\n\n    console.log('🔄 Column does not exist, adding it now...');\n    \n    // Use a direct raw SQL query through the Supabase SQL editor approach\n    // Since we can't use execute_sql RPC, we'll need to handle this differently\n    \n    console.log('❌ Cannot add column via Supabase client. Please add the column manually:');\n    console.log('ALTER TABLE event_attendees ADD COLUMN application_answers TEXT;');\n    console.log('The system will work without this column for now, but private event applications may have limited functionality.');\n    \n  } catch (error) {\n    console.error('❌ Migration failed:', error.message);\n    process.exit(1);\n  }\n}\n\naddApplicationAnswersColumn();","size_bytes":1763},"postcss.config.js":{"content":"export default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}\n","size_bytes":80},"psql-create.sh":{"content":"#!/bin/bash\n\n# Create users table using psql directly\nexport PGPASSWORD=\"${DATABASE_PASSWORD}\"\n\npsql -h aws-0-sa-east-1.pooler.supabase.com -p 6543 -U postgres.pbvkjkjdtwftjetpreai -d postgres << 'EOF'\n\n-- Create users table\nCREATE TABLE IF NOT EXISTS public.users (\n    id BIGSERIAL PRIMARY KEY,\n    username TEXT NOT NULL UNIQUE,\n    email TEXT NOT NULL UNIQUE,\n    password TEXT,\n    name TEXT NOT NULL,\n    bio TEXT,\n    avatar TEXT,\n    supabase_id TEXT UNIQUE,\n    stripe_customer_id TEXT,\n    stripe_subscription_id TEXT,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL\n);\n\n-- Create indexes\nCREATE INDEX IF NOT EXISTS idx_users_email ON public.users(email);\nCREATE INDEX IF NOT EXISTS idx_users_username ON public.users(username);\nCREATE INDEX IF NOT EXISTS idx_users_supabase_id ON public.users(supabase_id);\n\n-- Enable RLS\nALTER TABLE public.users ENABLE ROW LEVEL SECURITY;\n\n-- Create policies\nCREATE POLICY IF NOT EXISTS \"Enable insert for registration\" ON public.users\n    FOR INSERT WITH CHECK (true);\n\nCREATE POLICY IF NOT EXISTS \"Users can view own data\" ON public.users\n    FOR SELECT USING (auth.uid()::text = supabase_id);\n\nCREATE POLICY IF NOT EXISTS \"Users can update own data\" ON public.users\n    FOR UPDATE USING (auth.uid()::text = supabase_id);\n\n-- Verify table creation\nSELECT 'Users table created successfully' as result;\n\nEOF\n\necho \"Database setup complete\"","size_bytes":1464},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"flask-dance>=7.1.0\",\n    \"flask-login>=0.6.3\",\n    \"flask-wtf>=1.2.2\",\n    \"oauthlib>=3.2.2\",\n    \"pyjwt>=2.10.1\",\n]\n","size_bytes":264},"replit.md":{"content":"# Overview\n\nPipol is a full-stack social event discovery and coordination platform that enables users to create, find, and attend events based on location and interests. The application features real-time messaging, multimedia support, user authentication, and an interactive map-based interface for event exploration.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Frontend Architecture\n- **Framework**: React with TypeScript using Vite as the build tool\n- **Routing**: wouter for lightweight client-side routing\n- **UI Components**: shadcn/ui components built on Radix UI primitives with Tailwind CSS\n- **State Management**: TanStack Query for server state management and React hooks for local state\n- **Maps Integration**: Mapbox GL for interactive map functionality\n- **Real-time Communication**: WebSocket client for chat messaging\n- **Authentication**: Context-based auth management with session persistence\n\n## Backend Architecture\n- **Framework**: Express.js with TypeScript\n- **Database ORM**: Drizzle ORM with PostgreSQL schema definitions\n- **Authentication**: Dual authentication system supporting both Supabase Auth and session-based authentication\n- **File Upload**: Multer middleware for handling multimedia file uploads\n- **Real-time Features**: WebSocket server for chat functionality\n- **API Design**: RESTful API with dedicated route modules for different features\n\n## Database Design\n- **Primary Database**: PostgreSQL with comprehensive schema including users, events, attendees, and chat messages\n- **ORM**: Drizzle ORM with type-safe schema definitions\n- **Key Tables**: users, events, event_attendees, chat_messages, notifications, user_interests\n- **Enums**: Strongly typed enums for event categories, privacy types, payment types, and multimedia types\n\n## Authentication & Authorization\n- **Dual Auth System**: Supports both Supabase authentication and session-based authentication\n- **Session Management**: Express sessions with passport.js integration\n- **Authorization**: Role-based access control for event organizers vs attendees\n- **Security**: Password hashing with bcrypt, secure session configuration\n\n## File Storage & Media Management\n- **Upload Strategy**: Multer-based file upload system with configurable storage destinations\n- **Media Types**: Support for photos and videos with automatic type detection\n- **File Organization**: Structured file storage in public/uploads/events directory\n- **Media Processing**: Comprehensive media item management with main media selection\n\n## Real-time Features\n- **WebSocket Server**: Custom WebSocket implementation for chat functionality\n- **Room Management**: Event-based chat rooms with user authentication\n- **Message Types**: Support for different message types including replies\n- **Connection Management**: Client tracking and room subscription management\n\n# External Dependencies\n\n## Database Services\n- **Supabase**: PostgreSQL database hosting with real-time capabilities and authentication services\n- **Connection**: Environment-based configuration for Supabase URL and API keys\n\n## Map Services\n- **Mapbox**: Interactive mapping functionality with custom markers and user location services\n- **Configuration**: Mapbox GL with custom styling and event visualization\n\n## Payment Processing\n- **Stripe**: Payment gateway integration (currently disabled in configuration)\n- **Implementation**: Stripe customer and subscription management infrastructure in place\n\n## Development Tools\n- **Vite**: Frontend build tool with HMR and development server\n- **TypeScript**: Full TypeScript implementation across frontend and backend\n- **Tailwind CSS**: Utility-first CSS framework with custom component styling\n\n## Authentication Services\n- **Supabase Auth**: User authentication and authorization with JWT token management\n- **Passport.js**: Session-based authentication fallback with local strategy\n\n## Real-time Infrastructure\n- **WebSocket**: Native WebSocket implementation for chat features\n- **Event Broadcasting**: Real-time event updates and notifications\n\n## File Upload & Storage\n- **Multer**: Multipart file upload handling with validation and processing\n- **File System**: Local file storage with organized directory structure","size_bytes":4276},"routes-backup-2.ts":{"content":"import express, { Express, Request, Response } from \"express\";\nimport { createServer, type Server } from \"http\";\nimport { storage } from \"./storage\";\nimport bcrypt from \"bcrypt\";\nimport passport from \"passport\";\nimport { loginUserSchema, insertUserSchema, insertEventSchema, insertEventAttendeeSchema } from \"@shared/schema\";\nimport { z } from \"zod\";\nimport Stripe from \"stripe\";\nimport { WebSocketServer } from 'ws';\nimport { WebSocket } from 'ws';\nimport multer from 'multer';\nimport path from 'path';\nimport fs from 'fs';\n\nif (!process.env.SESSION_SECRET) {\n  console.warn(\"No SESSION_SECRET provided, using default secret. This is insecure!\");\n}\n\n// Payment functionality is disabled for this app\nconsole.log(\"Payment functionality is disabled in this version of the app.\");\n\n// Set stripe to null - all events will be free\nconst stripe = null;\n\n// Configurar almacenamiento para multer\nconst storage_uploads = multer.diskStorage({\n  destination: function (req, file, cb) {\n    // Definir el directorio según el tipo de archivo\n    let uploadPath = 'public/uploads/events';\n    \n    // Asegurarse de que el directorio existe\n    if (!fs.existsSync(uploadPath)) {\n      fs.mkdirSync(uploadPath, { recursive: true });\n    }\n    \n    cb(null, uploadPath);\n  },\n  filename: function (req, file, cb) {\n    // Generar un nombre de archivo único\n    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\n    const extension = path.extname(file.originalname);\n    cb(null, 'event-' + uniqueSuffix + extension);\n  }\n});\n\n// Filtrar archivos por tipo y validar condiciones\nconst fileFilter = (req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {\n  console.log(`Procesando archivo: ${file.fieldname}, tipo: ${file.mimetype}`);\n  \n  // Categorizar el archivo según el campo\n  const isImageField = file.fieldname === 'eventPhoto' || file.fieldname === 'photos' || file.fieldname.startsWith('photos[');\n  const isVideoField = file.fieldname === 'eventVideo' || file.fieldname === 'videos' || file.fieldname.startsWith('videos[');\n  const isMainMediaField = file.fieldname === 'mainMediaFile' || file.fieldname === 'mainMedia';\n  const isMediaManagerField = file.fieldname.startsWith('mediaFile_');\n  \n  // Verificar tipo de contenido\n  const isImage = file.mimetype.startsWith('image/');\n  const isVideo = file.mimetype.startsWith('video/');\n  \n  // Validar según tipo de campo\n  if (isImageField) {\n    if (!isImage) {\n      console.warn(`Archivo rechazado - tipo incorrecto: ${file.fieldname}, ${file.mimetype}`);\n      return cb(new Error(`El archivo debe ser una imagen. Tipo recibido: ${file.mimetype}`));\n    }\n    \n    console.log(`Imagen aceptada: ${file.originalname}`);\n    return cb(null, true);\n  } \n  else if (isVideoField) {\n    if (!isVideo) {\n      console.warn(`Archivo rechazado - tipo incorrecto: ${file.fieldname}, ${file.mimetype}`);\n      return cb(new Error(`El archivo debe ser un video. Tipo recibido: ${file.mimetype}`));\n    }\n    \n    console.log(`Video aceptado: ${file.originalname}`);\n    return cb(null, true);\n  }\n  else if (isMainMediaField || isMediaManagerField) {\n    // Permitir tanto imágenes como videos para estos campos\n    if (!isImage && !isVideo) {\n      console.warn(`Archivo rechazado - tipo incorrecto: ${file.fieldname}, ${file.mimetype}`);\n      return cb(new Error(`El archivo multimedia debe ser una imagen o un video. Tipo recibido: ${file.mimetype}`));\n    }\n    \n    const fieldDescription = isMainMediaField ? 'principal' : 'MediaManager';\n    console.log(`Archivo ${fieldDescription} aceptado: ${file.originalname} (${isImage ? 'imagen' : 'video'})`);\n    return cb(null, true);\n  } \n  else {\n    // Por defecto, rechazar otros tipos de archivo desconocidos\n    console.warn(`Tipo de campo no reconocido: ${file.fieldname}, rechazado por seguridad`);\n    return cb(new Error(`Tipo de campo no soportado: ${file.fieldname}`));\n  }\n};\n\n// Constantes para los límites de tamaño\nconst MAX_PHOTO_SIZE = 5 * 1024 * 1024; // 5MB para fotos\nconst MAX_VIDEO_SIZE = 10 * 1024 * 1024; // 10MB para videos\n\n// Configurar manejo de errores para multer\nconst multerErrorHandler = (err: any, req: Request, res: Response, next: Function) => {\n  if (err instanceof multer.MulterError) {\n    console.error(\"Error de Multer:\", err.code, err.field);\n    \n    // Manejar errores específicos de multer con mensajes amigables\n    if (err.code === 'LIMIT_FILE_SIZE') {\n      return res.status(400).json({\n        success: false,\n        message: \"El archivo es demasiado grande. El tamaño máximo permitido es 10MB para videos y 5MB para imágenes.\",\n        error: 'FILE_TOO_LARGE',\n        field: err.field\n      });\n    }\n    \n    if (err.code === 'LIMIT_FILE_COUNT') {\n      return res.status(400).json({\n        success: false,\n        message: \"Se han enviado demasiados archivos. Máximo 10 archivos por solicitud.\",\n        error: 'TOO_MANY_FILES'\n      });\n    }\n    \n    // Otros errores de multer\n    return res.status(400).json({\n      success: false,\n      message: `Error al subir archivo: ${err.message}`,\n      error: err.code\n    });\n  }\n  \n  // Si no es un error de multer, pasar al siguiente middleware\n  if (err) {\n    return next(err);\n  }\n  \n  next();\n};\n\n// Configurar el middleware multer con mejores límites\nconst upload = multer({ \n  storage: storage_uploads,\n  fileFilter: fileFilter,\n  limits: {\n    fileSize: MAX_VIDEO_SIZE, // Usar el límite mayor (10MB) y validar específicamente en el código\n    files: 10, // Máximo 10 archivos por solicitud para evitar abusos\n  }\n});\n\nexport async function registerRoutes(app: Express): Promise<Server> {\n  // Serve static files from public directory\n  app.use(express.static('public'));\n\n  // Auth route middleware\n  const isAuthenticated = (req: Request, res: Response, next: Function) => {\n    if (!req.isAuthenticated()) {\n      console.log(`Petición no autenticada: ${req.method} ${req.path}`);\n      console.log(`Session ID presente: ${!!req.sessionID}`);\n      console.log(`Cookies: ${req.headers.cookie || 'No cookies'}`);\n      return res.status(401).json({ message: \"Not authenticated\" });\n    }\n    return next();\n  };\n\n  // Test auth route - force content type to be application/json\n  app.get(\"/api/auth/test\", (req, res) => {\n    console.log(\"Auth test route accessed\");\n    console.log(\"Session ID:\", req.sessionID);\n    console.log(\"Auth status:\", req.isAuthenticated());\n    console.log(\"User:\", req.user);\n    console.log(\"Session:\", req.session);\n    \n    // Force content type to application/json\n    res.setHeader('Content-Type', 'application/json');\n    \n    return res.send(JSON.stringify({\n      success: true,\n      message: \"Auth test route\",\n      authenticated: req.isAuthenticated(),\n      sessionId: req.sessionID,\n      user: req.user || null,\n      session: req.session ? {\n        id: req.session.id,\n        cookie: {\n          expires: req.session.cookie.expires,\n          maxAge: req.session.cookie.maxAge\n        }\n      } : null\n    }));\n  });\n  \n  // Auth routes\n  // Register a new user\n  app.post(\"/api/auth/register\", async (req, res) => {\n    try {\n      console.log(\"Registration attempt with data:\", { \n        email: req.body.email,\n        username: req.body.username,\n        name: req.body.name\n      });\n      \n      // Validate all input data\n      const validatedData = insertUserSchema.parse(req.body);\n      \n      // Check if email already exists\n      const existingEmail = await storage.getUserByEmail(validatedData.email);\n      if (existingEmail) {\n        console.log(`Registration rejected: Email ${validatedData.email} already exists`);\n        return res.status(400).json({ message: \"Email already in use\" });\n      }\n\n      // Check if username already exists\n      const existingUsername = await storage.getUserByUsername(validatedData.username);\n      if (existingUsername) {\n        console.log(`Registration rejected: Username ${validatedData.username} already exists`);\n        return res.status(400).json({ message: \"Username already taken\" });\n      }\n\n      // Hash password with bcrypt\n      const salt = await bcrypt.genSalt(10);\n      const hashedPassword = await bcrypt.hash(validatedData.password, salt);\n\n      // Create user with the hashed password\n      const user = await storage.insertUser({\n        ...validatedData,\n        password: hashedPassword,\n      });\n\n      console.log(`User registered successfully: ID=${user.id}, Username=${user.username}`);\n\n      // Remove password from the response data\n      const { password: _, ...userWithoutPassword } = user;\n\n      // Automatically log the user in after registration\n      req.login(userWithoutPassword, (err) => {\n        if (err) {\n          console.error(\"Error during auto-login after registration:\", err);\n          return res.status(500).json({ message: \"Registration successful, but automatic login failed\" });\n        }\n        \n        console.log(`User ${user.id} automatically logged in after registration`);\n        return res.status(201).json(userWithoutPassword);\n      });\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        console.log(\"Registration validation errors:\", error.errors);\n        return res.status(400).json({ \n          message: \"Validation error\",\n          errors: error.errors.map(e => ({\n            field: e.path.join('.'),\n            message: e.message\n          }))\n        });\n      }\n      console.error(\"Error registering user:\", error);\n      return res.status(500).json({ message: \"Internal server error during registration\" });\n    }\n  });\n\n  // User login\n  app.post(\"/api/auth/login\", (req, res, next) => {\n    try {\n      console.log(\"Login attempt for:\", req.body.email);\n      \n      // Log request details for debugging\n      console.log(\"Login headers:\", req.headers);\n      console.log(\"Login body:\", req.body);\n      \n      // Validate login data\n      loginUserSchema.parse(req.body);\n      \n      // Use passport for authentication\n      passport.authenticate(\"local\", (err: any, user: any, info: any) => {\n        if (err) {\n          console.error(\"Authentication error:\", err);\n          return next(err);\n        }\n        \n        // Authentication failed\n        if (!user) {\n          console.log(`Login failed for ${req.body.email}: ${info?.message || \"Unknown reason\"}`);\n          return res.status(401).json({ message: info?.message || \"Invalid email or password\" });\n        }\n        \n        // User authenticated, establish session\n        req.login(user, (err) => {\n          if (err) {\n            console.error(\"Session error during login:\", err);\n            return next(err);\n          }\n          \n          console.log(`User ${user.id} (${user.email}) authenticated, establishing session...`);\n          \n          // Force save the session immediately \n          req.session.save((err) => {\n            if (err) {\n              console.error(\"Error saving session:\", err);\n              return next(err);\n            }\n            \n            console.log(`User ${user.id} (${user.email}) logged in successfully`);\n            \n            // Debug session info\n            if (req.session) {\n              console.log(`Session created: id=${req.session.id}, expires=${req.session.cookie.expires}`);\n              console.log(\"Session cookie:\", req.session.cookie);\n              // Set a test value in the session\n              (req.session as any).loginTime = new Date().toISOString();\n              (req.session as any).userId = user.id;\n            }\n            \n            // Set the cookie manually to ensure persistence\n            res.cookie('pipol.sid', req.sessionID, {\n              maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days in milliseconds\n              httpOnly: true,\n              secure: false, // Change to true in production (HTTPS)\n              path: '/',\n              sameSite: 'none'\n            });\n            \n            // Log authentication status for debugging\n            console.log(\"Is authenticated after login:\", req.isAuthenticated());\n            \n            // Return user data without debug information for production use\n            return res.json(user);\n          });\n        });\n      })(req, res, next);\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        console.log(\"Login validation errors:\", error.errors);\n        return res.status(400).json({ \n          message: \"Invalid login data\", \n          errors: error.errors\n        });\n      }\n      console.error(\"Unexpected login error:\", error);\n      return res.status(500).json({ message: \"Internal server error during login\" });\n    }\n  });\n\n  // Test auth endpoint to verify authentication status\n  app.get(\"/api/auth/test\", (req, res) => {\n    try {\n      if (req.isAuthenticated()) {\n        console.log(`Auth test successful for user ${req.user.id}`);\n        return res.json({ \n          authenticated: true, \n          userId: req.user.id,\n          sessionId: req.sessionID\n        });\n      } else {\n        console.log(\"Auth test failed: Not authenticated\");\n        return res.status(401).json({ \n          authenticated: false,\n          sessionId: req.sessionID || null\n        });\n      }\n    } catch (error) {\n      console.error(\"Error in auth test:\", error);\n      return res.status(500).json({ message: \"Error checking authentication status\" });\n    }\n  });\n\n  // Get current user data\n  app.get(\"/api/auth/me\", (req, res) => {\n    try {\n      if (!req.isAuthenticated()) {\n        console.log(\"Auth check for GET /api/auth/me: Not authenticated\");\n        return res.status(401).json({ message: \"Not authenticated\" });\n      }\n      \n      if (!req.user) {\n        console.log(\"Auth check for GET /api/auth/me: User authenticated but no user data\");\n        return res.status(401).json({ message: \"User data not available\" });\n      }\n      \n      console.log(`User data requested for user ${req.user.id}`);\n      return res.json(req.user);\n    } catch (error) {\n      console.error(\"Error in /api/auth/me:\", error);\n      return res.status(500).json({ message: \"Internal server error\" });\n    }\n  });\n\n  // User logout\n  app.post(\"/api/auth/logout\", (req, res) => {\n    if (!req.isAuthenticated()) {\n      return res.status(200).json({ message: \"Already logged out\" });\n    }\n    \n    // Store user ID for logging\n    const userId = req.user.id;\n    console.log(`Logout requested for user ${userId}`);\n    \n    req.logout((err) => {\n      if (err) {\n        console.error(\"Error during logout:\", err);\n        return res.status(500).json({ message: \"Error during logout\" });\n      }\n      \n      // Destroy the session completely\n      req.session.destroy((err) => {\n        if (err) {\n          console.error(\"Error destroying session:\", err);\n        }\n        \n        console.log(`User ${userId} logged out successfully`);\n        res.clearCookie('connect.sid');\n        res.json({ message: \"Logged out successfully\" });\n      });\n    });\n  });\n  \n  // Proxy para solicitudes a la API de Google Places (para evitar problemas CORS)\n  app.get('/api/google-proxy/:service/:endpoint', async (req, res) => {\n    try {\n      const { service, endpoint } = req.params;\n      // Copiar los query params para no modificar el objeto original\n      const queryParams = { ...req.query };\n      \n      // Eliminar clave 'key' del query string\n      if (queryParams.key) {\n        delete queryParams.key;\n      }\n      \n      // Si es una solicitud de búsqueda, agregamos parámetros para mejorar los resultados\n      if (endpoint === 'textsearch' || endpoint === 'findplacefromtext') {\n        // Priorizar la región del usuario (Argentina) para mostrar resultados más relevantes\n        if (!queryParams.region && !queryParams.location) {\n          queryParams.region = 'ar'; // Argentina\n        }\n        \n        // Si la consulta es muy genérica (como 'parque'), agregar más contexto\n        if (queryParams.query && typeof queryParams.query === 'string' && queryParams.query.length < 10) {\n          // Agregar \"en Argentina\" o \"en Mexico\" según la región especificada\n          const region = queryParams.region || 'ar';\n          const countryName = region === 'ar' ? 'Argentina' : (region === 'mx' ? 'México' : '');\n          \n          if (countryName && !queryParams.query.includes(countryName)) {\n            queryParams.query = `${queryParams.query} en ${countryName}`;\n            console.log('Query modificada para mejorar resultados:', queryParams.query);\n          }\n        }\n        \n        // Parámetros para mejorar resultados\n        queryParams.language = 'es'; // Resultados en español\n        queryParams.inputtype = 'textquery';\n        \n        // Aumentar el número de resultados\n        if (!queryParams.maxResults) {\n          queryParams.maxResults = '10';\n        }\n      }\n      \n      // Usar la API key del servidor para mayor seguridad\n      const API_KEY = 'AIzaSyCy5iYWFh36MvrxPKr58A7TPd-f6YHtT1I';\n      \n      const urlParams = new URLSearchParams(queryParams as Record<string, string>).toString();\n      const url = `https://maps.googleapis.com/maps/api/${service}/${endpoint}?${urlParams}&key=${API_KEY}`;\n      console.log(`Proxying Google API request to: ${url}`);\n      \n      const response = await fetch(url);\n      \n      if (!response.ok) {\n        console.error('Error en respuesta HTTP de Google API:', response.status, response.statusText);\n        return res.status(response.status).json({ \n          status: 'ERROR',\n          error_message: `Error HTTP ${response.status}: ${response.statusText}` \n        });\n      }\n      \n      // Parsear la respuesta como texto primero para depurar cualquier problema\n      const responseText = await response.text();\n      \n      try {\n        // Intentar parsear JSON\n        const data = JSON.parse(responseText);\n        console.log('Google API response status:', data.status);\n        \n        if (data.status !== 'OK') {\n          console.log('Google API error details:', data.error_message || 'No error message provided');\n        } else {\n          console.log('Google API returned', data.results?.length || 0, 'results');\n        }\n        \n        return res.json(data);\n      } catch (jsonError) {\n        console.error('Error parsing Google API response as JSON:', jsonError);\n        console.error('Response text (first 200 chars):', responseText.substring(0, 200));\n        \n        return res.status(500).json({ \n          status: 'ERROR',\n          error_message: 'Error parsing Google API response',\n          response_preview: responseText.substring(0, 100) + '...' \n        });\n      }\n    } catch (error) {\n      console.error('Error proxy Google API:', error);\n      res.status(500).json({ \n        status: 'ERROR',\n        error_message: error instanceof Error ? error.message : 'Unknown error in Google API proxy'\n      });\n    }\n  });\n\n  // Event routes\n  // Ruta para obtener un evento específico por ID\n  app.get(\"/api/events/:id\", async (req, res) => {\n    try {\n      const eventId = parseInt(req.params.id);\n      const event = await storage.getEventById(eventId);\n      \n      if (!event) {\n        return res.status(404).json({ message: \"Evento no encontrado\" });\n      }\n      \n      // Incluir organizador\n      const organizer = await storage.getUserById(event.organizerId);\n      \n      // Obtener lista de asistentes\n      const attendees = await storage.getEventAttendees(eventId);\n      \n      // Formatear respuesta\n      const eventWithDetails = {\n        ...event,\n        organizer: organizer ? {\n          id: organizer.id,\n          name: organizer.name,\n          avatar: organizer.avatar\n        } : null,\n        attendees: attendees ? await Promise.all(attendees.map(async (attendee) => {\n          const user = await storage.getUserById(attendee.userId);\n          return {\n            id: attendee.id,\n            user: user ? {\n              id: user.id,\n              name: user.name,\n              avatar: user.avatar\n            } : null\n          };\n        })) : []\n      };\n      \n      res.json(eventWithDetails);\n    } catch (error) {\n      console.error(\"Error fetching event by ID:\", error);\n      res.status(500).json({ message: \"Error al obtener detalles del evento\" });\n    }\n  });\n  \n  // Obtener todos los eventos\n  app.get(\"/api/events\", async (req, res) => {\n    try {\n      const { lat, lng, radius, category, paymentType } = req.query;\n      \n      let events;\n      \n      // If lat and lng are provided, get nearby events\n      if (lat && lng) {\n        events = await storage.getNearbyEvents(\n          parseFloat(lat as string),\n          parseFloat(lng as string),\n          radius ? parseFloat(radius as string) : 10\n        );\n      } else {\n        // Otherwise get all events with filters\n        const filters: any = {};\n        \n        if (category) {\n          filters.category = Array.isArray(category) ? category : [category as string];\n        }\n        \n        if (paymentType) {\n          filters.paymentType = Array.isArray(paymentType) ? paymentType : [paymentType as string];\n        }\n        \n        events = await storage.getEvents(filters);\n      }\n      \n      res.json(events);\n    } catch (error) {\n      console.error(\"Error fetching events:\", error);\n      res.status(500).json({ message: \"Error fetching events\" });\n    }\n  });\n\n  app.get(\"/api/events/:id\", async (req, res) => {\n    try {\n      const eventId = parseInt(req.params.id);\n      const event = await storage.getEventById(eventId);\n      \n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      res.json(event);\n    } catch (error) {\n      console.error(\"Error fetching event:\", error);\n      res.status(500).json({ message: \"Error fetching event\" });\n    }\n  });\n\n  app.post(\"/api/events\", isAuthenticated, (req, res, next) => {\n    // Aplicar upload como middleware con manejo de errores integrado\n    // Usamos upload.any() para aceptar cualquier campo de archivo\n    // Esto evitará el error \"Unexpected field\"\n    const uploadMiddleware = upload.any();\n    \n    uploadMiddleware(req, res, (err) => {\n      if (err) {\n        return multerErrorHandler(err, req, res, next);\n      }\n      next();\n    });\n  }, async (req, res) => {\n    try {\n      console.log(\"Creando evento. Datos recibidos:\", JSON.stringify(req.body));\n      const userId = (req.user as any).id;\n      console.log(\"Usando organizerId:\", userId);\n      \n      // Definir interfaz para los elementos multimedia\n      interface MediaItem {\n        type: string;\n        url: string;\n        order: number;\n        isMain?: boolean;\n      }\n      \n      // CORRECCIÓN DEL BUG: El error \"undefined\" ocurre cuando hay problemas \n      // al procesar los archivos o el campo mediaItems durante la creación\n      \n      // Inicializamos variables con valores por defecto seguros\n      let photoUrl = '';\n      let videoUrl = '';\n      let mediaItems: MediaItem[] = [];\n      let mainMediaType = 'photo'; // Valor por defecto seguro\n      let mainMediaUrl = '';\n      const filesByField: {[key: string]: Express.Multer.File[]} = {};\n      \n      try {\n        // Procesamos archivos subidos si existen con validación robusta\n        const files = req.files as Express.Multer.File[] || [];\n        \n        // Loguear información útil para depuración\n        console.log(\"¿Hay archivos?\", Array.isArray(files) && files.length > 0);\n        \n        if (Array.isArray(files) && files.length > 0) {\n          console.log(\"Archivos recibidos:\", files.map(f => ({\n            fieldname: f.fieldname,\n            originalname: f.originalname,\n            mimetype: f.mimetype,\n            size: f.size\n          })));\n          \n          // Agrupar archivos por fieldname para facilitar procesamiento con validación\n          files.forEach(file => {\n            if (file && file.fieldname) {\n              if (!filesByField[file.fieldname]) {\n                filesByField[file.fieldname] = [];\n              }\n              filesByField[file.fieldname].push(file);\n            }\n          });\n        } else {\n          console.log(\"No se recibieron archivos adjuntos\");\n        }\n      } catch (err) {\n        console.error(\"Error al procesar archivos:\", err);\n        // No propagamos el error, continuamos con un estado limpio\n      }\n      \n      console.log(\"Campos de archivos encontrados:\", Object.keys(filesByField).length > 0 ? Object.keys(filesByField) : \"ninguno\");\n      \n      // Procesar archivo principal (retrocompatibilidad)\n      if (filesByField.eventPhoto) {\n        const photoFile = filesByField.eventPhoto[0];\n        const photoPath = photoFile.path.replace('public', '');\n        photoUrl = photoPath; // URL relativa para el navegador\n        console.log(`Procesando eventPhoto: ${photoFile.originalname} -> ${photoPath}`);\n        \n        // Si no hay un medio principal definido, usar esta foto como principal\n        if (!mainMediaUrl) {\n          mainMediaUrl = photoPath;\n          mainMediaType = 'photo';\n          console.log(`Estableciendo eventPhoto como medio principal: ${photoPath}`);\n        }\n        \n        // No añadimos a mediaItems aquí, lo haremos mediante MediaManager\n      }\n      \n      if (filesByField.eventVideo) {\n        const videoFile = filesByField.eventVideo[0];\n        const videoPath = videoFile.path.replace('public', '');\n        videoUrl = videoPath; // URL relativa para el navegador\n        console.log(`Procesando eventVideo: ${videoFile.originalname} -> ${videoPath}`);\n        \n        // No añadimos a mediaItems aquí, lo haremos mediante MediaManager\n      }\n      \n      // Procesar fotos adicionales (retrocompatibilidad)\n      if (filesByField.photos) {\n        const photoUrls = filesByField.photos.map(file => {\n          console.log(`Procesando foto adicional: ${file.originalname}`);\n          return file.path.replace('public', '');\n        });\n        \n        // Si no hay un medio principal definido y hay fotos, usar la primera foto como principal\n        if (!mainMediaUrl && photoUrls.length > 0) {\n          mainMediaUrl = photoUrls[0];\n          mainMediaType = 'photo';\n          console.log(`Estableciendo primera foto como medio principal: ${mainMediaUrl}`);\n        }\n        \n        // No añadimos a mediaItems aquí, lo haremos mediante MediaManager\n      }\n      \n      // Procesar videos adicionales (retrocompatibilidad)\n      if (filesByField.videos) {\n        filesByField.videos.forEach(file => {\n          console.log(`Procesando video adicional: ${file.originalname}`);\n          // No añadimos a mediaItems aquí, lo haremos mediante MediaManager\n        });\n      }\n      \n      // Procesar el archivo principal especificado\n      if (filesByField.mainMediaFile) {\n        const mainFile = filesByField.mainMediaFile[0];\n        const mediaPath = mainFile.path.replace('public', '');\n        // Determinar tipo según el mimetype\n        const isVideo = mainFile.mimetype.startsWith('video/');\n        mainMediaType = isVideo ? 'video' : 'photo';\n        mainMediaUrl = mediaPath;\n        \n        console.log(\"======= ESTABLECIENDO MEDIA PRINCIPAL EXPLÍCITO =======\");\n        console.log(`ARCHIVO: ${mainFile.originalname}`);\n        console.log(`TIPO: ${mainMediaType}`);\n        console.log(`URL: ${mainMediaUrl}`);\n        console.log(`TAMAÑO: ${(mainFile.size/1024).toFixed(1)}KB`);\n        console.log(\"=====================================================\");\n      }\n      \n      // Procesar archivos de MediaManager con robusto manejo de errores y validación\n      // para evitar el error \"undefined\" cuando faltan valores\n      // Primero verificar si existe la información de mediaItems como JSON\n      if (req.body && req.body.mediaItems) {\n        try {\n          console.log(\"MediaItems JSON recibido:\", req.body.mediaItems);\n          \n          // Parse de la información de mediaItems con validación para evitar undefined\n          let mediaItemsInfo = [];\n          try {\n            mediaItemsInfo = JSON.parse(req.body.mediaItems) || [];\n            // Asegurar que es un array\n            if (!Array.isArray(mediaItemsInfo)) {\n              console.warn(\"mediaItemsInfo no es un array, usando array vacío\");\n              mediaItemsInfo = [];\n            }\n          } catch (parseError) {\n            console.error(\"Error al parsear JSON de mediaItems:\", parseError);\n            console.warn(\"Usando array vacío como valor seguro para mediaItemsInfo\");\n            mediaItemsInfo = [];\n          }\n          \n          console.log(\"MediaItems parseado:\", mediaItemsInfo);\n          \n          // Buscar archivos subidos con patrón mediaFile_X con validación para objetos undefined\n          const mediaFileKeys = Object.keys(filesByField || {})\n            .filter(key => key && typeof key === 'string' && key.startsWith('mediaFile_'));\n            \n          console.log(\"Claves de archivos multimedia encontradas:\", mediaFileKeys);\n          console.log(\"Todos los archivos recibidos:\", Object.keys(filesByField || {}));\n          \n          // Variable para rastrear el elemento principal con inicialización segura\n          let mainItemFound = false;\n          \n          if (mediaFileKeys.length > 0) {\n            console.log(`Procesando ${mediaFileKeys.length} archivos de MediaManager`);\n            \n            // No vaciamos el array de mediaItems para mantener la compatibilidad\n            // mediaItems = [];\n            \n            // Crear nueva lista mediaItems basada en los archivos subidos y la metadata\n            const newMediaItems: MediaItem[] = [];\n            \n            // Contador para validar límites\n            let photoCount = 0;\n            let videoCount = 0;\n            const MAX_PHOTOS = 6;\n            const MAX_VIDEOS = 3;\n            const MAX_PHOTO_SIZE = 5 * 1024 * 1024; // 5MB\n            const MAX_VIDEO_SIZE = 10 * 1024 * 1024; // 10MB\n            \n            // Crear un array de promesas para procesar todos los archivos\n            for (const key of mediaFileKeys) {\n              try {\n                // Acceso seguro a los archivos utilizando filesByField\n                if (!filesByField[key] || !filesByField[key][0]) {\n                  console.warn(`No se encontró archivo para ${key}`);\n                  continue;\n                }\n                \n                const file = filesByField[key][0];\n                const mediaPath = file.path.replace('public', '');\n                \n                // Extraer índice del nombre de campo (mediaFile_X)\n                const indexMatch = key.match(/mediaFile_(\\d+)/);\n                if (!indexMatch) {\n                  console.warn(`No se pudo extraer índice de ${key}`);\n                  continue;\n                }\n                \n                const index = parseInt(indexMatch[1]);\n                \n                // Determinar el tipo de archivo\n                const isVideo = file.mimetype.startsWith('video/');\n                const fileType = isVideo ? 'video' : 'photo';\n                \n                // Validar tamaño del archivo\n                const isOversize = isVideo \n                  ? file.size > MAX_VIDEO_SIZE \n                  : file.size > MAX_PHOTO_SIZE;\n                \n                if (isOversize) {\n                  console.warn(`Archivo ${key} excede el tamaño máximo permitido: ${(file.size / (1024 * 1024)).toFixed(1)}MB`);\n                  \n                  // Eliminar el archivo que excede el tamaño\n                  try {\n                    fs.unlinkSync(file.path);\n                    console.log(`Archivo sobredimensionado eliminado: ${file.path}`);\n                  } catch (unlinkError) {\n                    console.error(`Error eliminando archivo sobredimensionado: ${file.path}`, unlinkError);\n                  }\n                  \n                  continue;\n                }\n                \n                // Verificar límites por tipo\n                if (isVideo && videoCount >= MAX_VIDEOS) {\n                  console.warn(`Se excedió el límite de videos (${MAX_VIDEOS}), omitiendo ${key}`);\n                  \n                  // Eliminar el archivo excedente\n                  try {\n                    fs.unlinkSync(file.path);\n                    console.log(`Archivo excedente eliminado: ${file.path}`);\n                  } catch (unlinkError) {\n                    console.error(`Error eliminando archivo excedente: ${file.path}`, unlinkError);\n                  }\n                  \n                  continue;\n                } else if (!isVideo && photoCount >= MAX_PHOTOS) {\n                  console.warn(`Se excedió el límite de fotos (${MAX_PHOTOS}), omitiendo ${key}`);\n                  \n                  // Eliminar el archivo excedente\n                  try {\n                    fs.unlinkSync(file.path);\n                    console.log(`Archivo excedente eliminado: ${file.path}`);\n                  } catch (unlinkError) {\n                    console.error(`Error eliminando archivo excedente: ${file.path}`, unlinkError);\n                  }\n                  \n                  continue;\n                }\n                \n                // Incrementar el contador correspondiente\n                if (isVideo) {\n                  videoCount++;\n                } else {\n                  photoCount++;\n                }\n                \n                // Buscar la metadata correspondiente con validación robusta\n                let matchedMetadata = null;\n                \n                // Buscar por ID en la metadata con múltiples capas de validación\n                if (Array.isArray(mediaItemsInfo) && mediaItemsInfo.length > 0) {\n                  for (const item of mediaItemsInfo) {\n                    // Verificar que el item es un objeto válido\n                    if (item && typeof item === 'object') {\n                      // Verificar si el índice del elemento coincide con el índice del archivo\n                      // o si la propiedad id contiene el índice\n                      const hasMatchingOrder = typeof item.order === 'number' && item.order === index;\n                      const hasMatchingId = item.id && typeof item.id === 'string' && item.id.includes(`_${index}`);\n                      \n                      if (hasMatchingOrder || hasMatchingId) {\n                        matchedMetadata = item;\n                        console.log(`Encontrada metadata para archivo ${key} por ID/orden:`, matchedMetadata);\n                        break;\n                      }\n                    }\n                  }\n                  \n                  // Si no encontramos por ID, intentamos por posición en la lista con validación\n                  if (!matchedMetadata && index < mediaItemsInfo.length) {\n                    const possibleMatch = mediaItemsInfo[index];\n                    // Verificar que el elemento encontrado es un objeto válido\n                    if (possibleMatch && typeof possibleMatch === 'object') {\n                      matchedMetadata = possibleMatch;\n                      console.log(`Encontrada metadata para archivo ${key} por posición en array:`, matchedMetadata);\n                    }\n                  }\n                }\n                \n                // Si aún no tenemos metadata, creamos un objeto seguro con valores por defecto\n                if (!matchedMetadata) {\n                  console.log(`No se encontró metadata para archivo ${key}, usando valores por defecto`);\n                  matchedMetadata = {\n                    type: fileType, // Usar el tipo detectado del mimetype\n                    order: index,\n                    isMain: false\n                  };\n                }\n                \n                // Log para depuración\n                console.log(`Procesando archivo ${key} con metadata final:`, matchedMetadata);\n                \n                // Crear el objeto MediaItem con valores por defecto seguros\n                // para evitar cualquier valor undefined o null\n                const mediaItem: MediaItem = {\n                  // Usar tipo de la metadata o determinarlo por el mimetype con valor seguro\n                  type: (matchedMetadata && matchedMetadata.type) ? matchedMetadata.type : fileType,\n                  url: mediaPath,\n                  // Usar orden de la metadata o usar el índice con valor seguro\n                  order: (matchedMetadata && typeof matchedMetadata.order === 'number') ? \n                         matchedMetadata.order : index,\n                  // Usar isMain de la metadata o false por defecto con verificación estricta\n                  isMain: !!(matchedMetadata && matchedMetadata.isMain === true)\n                };\n                \n                console.log(`Media item creado: ${mediaItem.type}, isMain: ${mediaItem.isMain}, URL: ${mediaItem.url}`);\n                \n                console.log(`Procesado archivo ${key}: ${mediaItem.type}, isMain: ${mediaItem.isMain}, tamaño: ${(file.size / 1024).toFixed(1)}KB`);\n                newMediaItems.push(mediaItem);\n                \n                // Si es el elemento principal, actualizar mainMediaType y mainMediaUrl\n                if (mediaItem.isMain) {\n                  mainMediaType = mediaItem.type;\n                  mainMediaUrl = mediaItem.url;\n                  console.log(`Archivo ${key} establecido como principal: ${mainMediaType} - ${mainMediaUrl}`);\n                }\n              } catch (error) {\n                console.error(`Error procesando archivo ${key}:`, error);\n              }\n            }\n            \n            // Reemplazar mediaItems con los nuevos\n            if (newMediaItems.length > 0) {\n              // Ordenar por la propiedad order para mantener el orden especificado\n              newMediaItems.sort((a, b) => (a.order || 0) - (b.order || 0));\n              \n              // Verificar si hay un elemento principal\n              const hasMainItem = newMediaItems.some(item => item.isMain === true);\n              \n              console.log(`¿Existe elemento principal explícito? ${hasMainItem}`);\n              \n              // Si no hay elemento principal, establecer el primero como principal\n              // priorizando fotos sobre videos\n              if (!hasMainItem && newMediaItems.length > 0) {\n                const firstPhoto = newMediaItems.find(item => item.type === 'photo');\n                const itemToSetMain = firstPhoto || newMediaItems[0];\n                \n                itemToSetMain.isMain = true;\n                mainMediaType = itemToSetMain.type;\n                mainMediaUrl = itemToSetMain.url;\n                \n                console.log(`Estableciendo elemento principal automáticamente: ${mainMediaType} - ${mainMediaUrl}`);\n              } else if (hasMainItem) {\n                // Obtener el elemento principal explícito\n                const mainItem = newMediaItems.find(item => item.isMain === true);\n                if (mainItem) {\n                  mainMediaType = mainItem.type;\n                  mainMediaUrl = mainItem.url;\n                  console.log(`Usando elemento principal explícito: ${mainMediaType} - ${mainMediaUrl}`);\n                }\n              }\n              \n              // Simplificamos el procesamiento de los archivos multimedia\n              \n              // Reemplazamos completamente los mediaItems con los nuevos elementos\n              // Esto evita la duplicación de archivos\n              mediaItems = newMediaItems;\n              console.log(\"Reemplazando mediaItems con los nuevos elementos procesados\");\n              \n              console.log(`Total de elementos multimedia: ${mediaItems.length} (incluyendo ${newMediaItems.length} nuevos)`);\n              console.log(`Composición: ${mediaItems.filter(i => i.type === 'photo').length} fotos, ${mediaItems.filter(i => i.type === 'video').length} videos`);\n            }\n          }\n        } catch (error) {\n          console.error(\"Error procesando mediaItems JSON:\", error);\n        }\n      }\n      \n      // Verificar si tenemos elementos multimedia antes de continuar\n      console.log(\"Estado final de los mediaItems antes de guardar:\", \n        mediaItems.map(item => ({\n          tipo: item.type,\n          url: item.url,\n          orden: item.order || 0,\n          principal: item.isMain || false\n        }))\n      );\n      \n      // Verificar estado de los medios principales\n      console.log(\"Media principal:\", {\n        mainMediaType,\n        mainMediaUrl\n      });\n      \n      // Convertir mediaItems a JSON string\n      const mediaItemsJson = JSON.stringify(mediaItems);\n      \n      try {\n        const validatedData = insertEventSchema.parse({\n          ...req.body,\n          organizerId: userId,\n          // Añadir URLs de los archivos (mantener por compatibilidad)\n          photoUrl: photoUrl || req.body.photoUrl || null,\n          videoUrl: videoUrl || req.body.videoUrl || null,\n          // Nuevos campos multimedia\n          mediaItems: mediaItemsJson,\n          mainMediaType: mainMediaType,\n          mainMediaUrl: mainMediaUrl\n        });\n        console.log(\"Datos validados:\", JSON.stringify(validatedData));\n        \n        const event = await storage.insertEvent(validatedData);\n        console.log(\"Evento creado con éxito:\", JSON.stringify(event));\n        res.status(201).json(event);\n      } catch (validationError) {\n        console.error(\"Error de validación:\", validationError);\n        // Si hay error, eliminar los archivos subidos\n        // Con upload.any() ya no tenemos acceso a los archivos así\n        // Eliminamos los archivos por el array filesByField\n        if (filesByField.eventPhoto && filesByField.eventPhoto.length > 0) {\n          try {\n            fs.unlinkSync(filesByField.eventPhoto[0].path);\n          } catch (err) {\n            console.error(\"Error al eliminar archivo:\", err);\n          }\n        }\n        if (filesByField.eventVideo && filesByField.eventVideo.length > 0) {\n          try {\n            fs.unlinkSync(filesByField.eventVideo[0].path);\n          } catch (err) {\n            console.error(\"Error al eliminar archivo:\", err);\n          }\n        }\n        \n        if (validationError instanceof z.ZodError) {\n          return res.status(400).json({ errors: validationError.errors });\n        }\n        throw validationError;\n      }\n    } catch (error) {\n      console.error(\"Error completo al crear evento:\", error);\n      \n      // Check if this is a foreign key constraint error\n      if (error instanceof Error && \n          error.toString().includes(\"violates foreign key constraint\") &&\n          error.toString().includes(\"events_organizer_id_users_id_fk\")) {\n        return res.status(401).json({ \n          message: \"You need to sign up and log in before creating an event\",\n          code: \"USER_NOT_FOUND\"\n        });\n      }\n      \n      res.status(500).json({ message: \"Error creating event\", error: String(error) });\n    }\n  });\n\n  // Ruta PUT para actualización básica sin archivos\n  app.put(\"/api/events/:id\", isAuthenticated, async (req, res) => {\n    try {\n      // Debug: Qué contiene la solicitud PUT\n      console.log(\"===== DATOS RECIBIDOS EN PUT =====\");\n      console.log(\"Content-Type:\", req.get('Content-Type'));\n      console.log(\"Headers:\", JSON.stringify(req.headers, null, 2));\n      console.log(\"Body keys:\", Object.keys(req.body));\n      \n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      // Check if event exists\n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      // Check if user is the organizer\n      if (event.organizerId !== user.id) {\n        return res.status(403).json({ message: \"Not authorized to update this event\" });\n      }\n      \n      // Create a copy of the request body for updating\n      const updateData = { ...req.body };\n      \n      // Procesar la fecha correctamente si existe\n      if (updateData.date) {\n        try {\n          // Convertir la fecha a un objeto Date apropiado\n          updateData.date = new Date(updateData.date);\n          console.log(\"Date converted to:\", updateData.date);\n        } catch (error) {\n          console.error(\"Error converting date:\", error);\n          return res.status(400).json({ message: \"Invalid date format\" });\n        }\n      }\n      \n      // Procesar mediaItems si existen para actualizar mainMediaType y mainMediaUrl\n      if (updateData.mediaItems) {\n        console.log(\"Actualizando evento en la base de datos. ID:\", eventId);\n        console.log(\"Datos de multimedia a guardar:\");\n        console.log(\"- mediaItems:\", updateData.mediaItems);\n        console.log(\"- mainMediaType:\", updateData.mainMediaType);\n        console.log(\"- mainMediaUrl:\", updateData.mainMediaUrl);\n        \n        try {\n          // Convertir mediaItems de string a objeto JSON si es necesario\n          let mediaItems = updateData.mediaItems;\n          if (typeof mediaItems === 'string') {\n            mediaItems = JSON.parse(mediaItems);\n          }\n          \n          // Buscar el elemento principal\n          const mainItem = Array.isArray(mediaItems) ? \n            mediaItems.find(item => item && item.isMain === true) : null;\n          \n          // Si hay un elemento principal, actualizar mainMediaType y mainMediaUrl\n          if (mainItem) {\n            updateData.mainMediaType = mainItem.type;\n            updateData.mainMediaUrl = mainItem.url;\n            console.log(\"Elemento principal encontrado y actualizado:\", {\n              type: mainItem.type,\n              url: mainItem.url\n            });\n          } else if (Array.isArray(mediaItems) && mediaItems.length > 0) {\n            // Si no hay elemento principal pero hay elementos, usar el primero\n            updateData.mainMediaType = mediaItems[0].type;\n            updateData.mainMediaUrl = mediaItems[0].url;\n            console.log(\"Usando primer elemento como principal por defecto:\", {\n              type: mediaItems[0].type,\n              url: mediaItems[0].url\n            });\n          }\n        } catch (error) {\n          console.error(\"Error procesando mediaItems:\", error);\n        }\n        \n        // Verificación después de actualizar\n        console.log(\"Verificación después de actualizar:\");\n        console.log(\"- mediaItems almacenados:\", updateData.mediaItems);\n        console.log(\"- mainMediaType almacenado:\", updateData.mainMediaType);\n        console.log(\"- mainMediaUrl almacenado:\", updateData.mainMediaUrl);\n      }\n      \n      // Obtener evento original para comparar medios\n      const originalEvent = await storage.getEventById(eventId);\n      \n      // Detectar si hay cambios en los medios\n      let mediaChanged = false;\n      \n      if (originalEvent) {\n        // Verificar cambios en URL de medio principal o tipo\n        if (originalEvent.mainMediaUrl !== updateData.mainMediaUrl || \n            originalEvent.mainMediaType !== updateData.mainMediaType) {\n          mediaChanged = true;\n          console.log(\"Cambio detectado en medio principal:\");\n          console.log(`- Original: ${originalEvent.mainMediaType} - ${originalEvent.mainMediaUrl}`);\n          console.log(`- Nuevo: ${updateData.mainMediaType} - ${updateData.mainMediaUrl}`);\n        }\n        \n        // Verificar cambios en la colección de medios\n        try {\n          const originalMediaItems = originalEvent.mediaItems ? JSON.parse(originalEvent.mediaItems) : [];\n          const newMediaItems = typeof updateData.mediaItems === 'string' \n            ? JSON.parse(updateData.mediaItems) \n            : updateData.mediaItems;\n            \n          if (JSON.stringify(originalMediaItems) !== JSON.stringify(newMediaItems)) {\n            mediaChanged = true;\n            console.log(\"Cambio detectado en colección de medios\");\n          }\n        } catch (error) {\n          console.error(\"Error comparando mediaItems:\", error);\n        }\n      }\n      \n      // Update event\n      const updatedEvent = await storage.updateEvent(eventId, updateData);\n      console.log(\"Evento actualizado correctamente.\");\n      console.log(`¿Hubo cambios en los medios? ${mediaChanged ? 'SÍ' : 'NO'}`);\n      \n      // Broadcast event update to all connected clients via WebSocket\n      broadcastMessage({\n        type: 'event_updated',\n        event: updatedEvent,\n        updatedBy: user.id  // Agregar el ID del usuario que realizó la actualización\n      });\n      \n      // Si se actualizó el medio principal, envía un mensaje específico para esto\n      if (mediaChanged) {\n        broadcastMessage({\n          type: 'event_media_updated',\n          eventId: updatedEvent.id,\n          updatedBy: user.id\n        });\n      }\n      \n      console.log(\"Notificación de actualización de evento enviada a todos los clientes WebSocket\");\n      \n      res.json(updatedEvent);\n    } catch (error) {\n      console.error(\"Error updating event:\", error);\n      res.status(500).json({ message: \"Error updating event\" });\n    }\n  });\n  \n  // Ruta PATCH para actualización con archivos\n  app.patch(\"/api/events/:id\", isAuthenticated, (req, res, next) => {\n    // Aplicar upload como middleware con manejo de errores integrado\n    const uploadMiddleware = upload.fields([\n      { name: 'eventPhoto', maxCount: 1 }, // Mantener para compatibilidad\n      { name: 'eventVideo', maxCount: 1 }, // Mantener para compatibilidad\n      { name: 'photos', maxCount: 6 },  // Permitir hasta 6 fotos en total\n      { name: 'videos', maxCount: 3 },  // Permitir hasta 3 videos en total\n      { name: 'mainMedia', maxCount: 1 }, // Archivo principal (puede ser foto o video)\n      { name: 'mainMediaFile', maxCount: 1 }, // Archivo principal (nuevo nombre usado en el frontend)\n      // Nuevos campos para MediaManager\n      { name: 'mediaFile_0', maxCount: 1 },\n      { name: 'mediaFile_1', maxCount: 1 },\n      { name: 'mediaFile_2', maxCount: 1 },\n      { name: 'mediaFile_3', maxCount: 1 },\n      { name: 'mediaFile_4', maxCount: 1 },\n      { name: 'mediaFile_5', maxCount: 1 },\n      { name: 'mediaFile_6', maxCount: 1 },\n      { name: 'mediaFile_7', maxCount: 1 },\n      { name: 'mediaFile_8', maxCount: 1 },\n      { name: 'mediaFile_9', maxCount: 1 }\n    ]);\n    \n    uploadMiddleware(req, res, (err) => {\n      if (err) {\n        return multerErrorHandler(err, req, res, next);\n      }\n      next();\n    });\n  }, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      // Check if event exists\n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      // Check if user is the organizer\n      if (event.organizerId !== user.id) {\n        return res.status(403).json({ message: \"Not authorized to update this event\" });\n      }\n      \n      // Procesar archivos subidos\n      const files = req.files as { [fieldname: string]: Express.Multer.File[] };\n      \n      // Datos para actualizar\n      const updateData: any = { ...req.body };\n      \n      // Procesar la fecha correctamente si existe\n      if (updateData.date) {\n        try {\n          // Convertir la fecha a un objeto Date apropiado\n          updateData.date = new Date(updateData.date);\n          console.log(\"Date converted to:\", updateData.date);\n        } catch (error) {\n          console.error(\"Error converting date:\", error);\n          return res.status(400).json({ message: \"Invalid date format\" });\n        }\n      }\n      \n      // Definir interfaz para los elementos multimedia\n      interface MediaItem {\n        type: string;\n        url: string;\n        order: number;\n        isMain?: boolean;\n      }\n      \n      // Definir interfaces para la información de medios\n      interface MediaItemInfo {\n        id?: string;\n        type: string;\n        url?: string;\n        isMain?: boolean;\n        isNew?: boolean;\n        fileIndex?: number;\n        order?: number;\n        deleted?: boolean;\n        toDelete?: boolean;\n      }\n      \n      // Definir array para almacenar los elementos multimedia\n      let mediaItems: MediaItem[] = [];\n      let mainMediaType = req.body.mainMediaType || 'photo';\n      let mainMediaUrl = req.body.mainMediaUrl || '';\n      \n      // Parsear información de elementos multimedia si existe\n      let mediaItemsInfo: MediaItemInfo[] = [];\n      if (req.body.mediaItemsInfo) {\n        try {\n          mediaItemsInfo = JSON.parse(req.body.mediaItemsInfo);\n          console.log(\"Información de elementos multimedia:\", mediaItemsInfo);\n        } catch (e) {\n          console.warn(\"Error al parsear mediaItemsInfo:\", e);\n          mediaItemsInfo = [];\n        }\n      }\n      \n      // Si ya hay elementos multimedia en la base de datos, cargarlos\n      if (event.mediaItems) {\n        try {\n          mediaItems = JSON.parse(event.mediaItems);\n        } catch (e) {\n          console.warn(\"No se pudo parsear mediaItems del evento:\", e);\n          // Inicializar como array vacío si hay error\n          mediaItems = [];\n        }\n      }\n      \n      // Verificar si el usuario quiere eliminar archivos existentes\n      if (req.body.resetMedia === 'true' || req.body.resetMedia === true) {\n        mediaItems = []; // Eliminar todos los archivos multimedia existentes\n        mainMediaUrl = ''; // Resetear el medio principal\n      }\n      \n      // Procesar elementos marcados para eliminar\n      const itemsToDelete = mediaItemsInfo.filter(info => info.url && (info.toDelete || info.deleted));\n      \n      if (itemsToDelete.length > 0) {\n        console.log(`Se encontraron ${itemsToDelete.length} elementos marcados para eliminar`);\n        \n        // Filtrar mediaItems para excluir los elementos marcados para eliminación\n        mediaItems = mediaItems.filter(item => {\n          // Verificar si este item coincide con alguno marcado para eliminar\n          const shouldDelete = itemsToDelete.some(\n            deleteItem => deleteItem.url === item.url && deleteItem.type === item.type\n          );\n          \n          // Si se va a eliminar el medio principal, resetear mainMediaUrl\n          if (shouldDelete && item.url === mainMediaUrl) {\n            console.log(`Eliminando el medio principal actual: ${item.url}`);\n            mainMediaUrl = '';\n            mainMediaType = 'photo'; // Default to photo to avoid enum error\n          }\n          \n          // Devolver true para mantener, false para eliminar\n          return !shouldDelete;\n        });\n        \n        console.log(`Quedan ${mediaItems.length} elementos multimedia después de eliminar los marcados`);\n      }\n      \n      // Si aún hay elementos multimedia después de las eliminaciones, \n      // asegurarse de que haya un elemento principal si el anterior fue eliminado\n      if (mediaItems.length > 0 && !mainMediaUrl) {\n        // Buscar algún elemento marcado como principal\n        const mainItem = mediaItems.find(item => item.isMain);\n        \n        if (mainItem) {\n          // Usar el elemento que ya está marcado como principal\n          mainMediaUrl = mainItem.url;\n          mainMediaType = mainItem.type;\n          console.log(`Usando elemento marcado como principal: ${mainItem.url}`);\n        } else {\n          // Si no hay ninguno, usar el primer elemento disponible\n          mainMediaUrl = mediaItems[0].url;\n          mainMediaType = mediaItems[0].type;\n          mediaItems[0].isMain = true; // Marcar como principal\n          console.log(`Estableciendo nuevo elemento principal por defecto: ${mainMediaUrl}`);\n        }\n      }\n      \n      // Procesar la foto principal (mantener por compatibilidad)\n      if (files.eventPhoto && files.eventPhoto.length > 0) {\n        const photoPath = files.eventPhoto[0].path.replace('public', '');\n        updateData.photo_url = photoPath;\n        \n        // Añadir a mediaItems si no existe ya\n        if (!mediaItems.some(item => item.url === photoPath)) {\n          mediaItems.push({ type: 'photo', url: photoPath, order: mediaItems.length });\n        }\n        \n        // Si no hay media principal o se solicitó resetear, usar esta foto\n        if (!mainMediaUrl || req.body.resetMedia) {\n          mainMediaUrl = photoPath;\n          mainMediaType = 'photo';\n        }\n      }\n      \n      // Procesar el video principal (mantener por compatibilidad)\n      if (files.eventVideo && files.eventVideo.length > 0) {\n        const videoPath = files.eventVideo[0].path.replace('public', '');\n        updateData.video_url = videoPath;\n        \n        // Añadir a mediaItems si no existe ya\n        if (!mediaItems.some(item => item.url === videoPath)) {\n          mediaItems.push({ type: 'video', url: videoPath, order: mediaItems.length });\n        }\n      }\n      \n      // Procesar fotos adicionales (hasta 6 en total)\n      if (files.photos && files.photos.length > 0) {\n        const photoUrls = files.photos.map(file => file.path.replace('public', ''));\n        console.log(`Procesando ${photoUrls.length} nuevas fotos subidas`);\n        \n        // Buscar elementos marcados como principales en la información\n        // Tanto archivos existentes como nuevos\n        const mainPhotoInfo = mediaItemsInfo.find(info => \n          info.isMain && info.isNew && info.type === 'photo'\n        );\n        \n        console.log(\"Info de fotos principales:\", mainPhotoInfo ? JSON.stringify(mainPhotoInfo) : \"ninguna\");\n          \n        // Añadir a la lista de medios\n        photoUrls.forEach((url, index) => {\n          if (!mediaItems.some(item => item.url === url)) {\n            // Verificar si este elemento debe ser el principal\n            // Si se ha marcado explícitamente este archivo nuevo como principal\n            // o si no hay un medio principal definido y este es el primer elemento\n            let isPhotoMain = false;\n            \n            // Revisar si este archivo está marcado como principal en la info\n            if (mainPhotoInfo) {\n              // Compara el índice del archivo con el que está en la información\n              isPhotoMain = mainPhotoInfo.fileIndex === index;\n              console.log(`Verificando si foto ${index} es principal según mainPhotoInfo: ${isPhotoMain}`);\n            } else if (!mainMediaUrl && mediaItems.length === 0) {\n              // Si no hay principal definido, usar el primer elemento\n              isPhotoMain = true;\n              console.log(`Estableciendo foto ${index} como principal por defecto (primera foto)`);\n            }\n            \n            // Añadir el elemento a la lista\n            mediaItems.push({ \n              type: 'photo', \n              url, \n              order: mediaItems.length, // Asignar orden secuencial\n              isMain: isPhotoMain\n            });\n            \n            // Si es principal, actualizar las variables de control\n            if (isPhotoMain) {\n              mainMediaUrl = url;\n              mainMediaType = 'photo';\n              console.log(`Estableciendo nueva foto subida como principal: ${url}`);\n              \n              // Asegurarse de que ningún otro elemento sea principal\n              mediaItems.forEach(item => {\n                if (item.url !== url) {\n                  item.isMain = false;\n                }\n              });\n            }\n          }\n        });\n        \n        // Si después de todo el proceso no hay un medio principal definido \n        // y hay fotos nuevas, usar la primera foto como principal\n        if (!mainMediaUrl && photoUrls.length > 0) {\n          mainMediaUrl = photoUrls[0];\n          mainMediaType = 'photo';\n          \n          // Actualizar el indicador isMain en el array de medios\n          const firstPhotoIndex = mediaItems.findIndex(item => \n            item.type === 'photo' && item.url === photoUrls[0]\n          );\n          \n          if (firstPhotoIndex >= 0) {\n            // Marcar el primer elemento como principal\n            mediaItems.forEach((item, idx) => {\n              item.isMain = idx === firstPhotoIndex;\n            });\n          }\n          \n          console.log(`Estableciendo nueva foto como principal (último recurso): ${mainMediaUrl}`);\n        }\n      }\n      \n      // Procesar videos adicionales (hasta 3 en total)\n      if (files.videos && files.videos.length > 0) {\n        const videoUrls = files.videos.map(file => file.path.replace('public', ''));\n        console.log(`Procesando ${videoUrls.length} nuevos videos subidos`);\n        \n        // Obtener información sobre cuál video debe ser el principal (si hay)\n        const mainVideoInfo = mediaItemsInfo.find(info => \n          info.isMain && info.isNew && info.type === 'video'\n        );\n        \n        console.log(\"Info de videos principales:\", mainVideoInfo ? JSON.stringify(mainVideoInfo) : \"ninguna\");\n        \n        // Añadir a la lista de medios\n        videoUrls.forEach((url, index) => {\n          if (!mediaItems.some(item => item.url === url)) {\n            // Verificar si este elemento debe ser el principal\n            let isVideoMain = false;\n            \n            // Revisar si este archivo está marcado como principal en la info\n            if (mainVideoInfo) {\n              // Compara el índice del archivo con el que está en la información\n              isVideoMain = mainVideoInfo.fileIndex === index;\n              console.log(`Verificando si video ${index} es principal según mainVideoInfo: ${isVideoMain}`);\n            } else if (!mainMediaUrl && mediaItems.length === 0) {\n              // Si no hay principal definido, usar el primer elemento\n              isVideoMain = true;\n              console.log(`Estableciendo video ${index} como principal por defecto (primer video)`);\n            }\n              \n            mediaItems.push({ \n              type: 'video', \n              url, \n              order: mediaItems.length, // Asignar orden secuencial\n              isMain: isVideoMain\n            });\n            \n            // Si es principal, actualizar las variables de control\n            if (isVideoMain) {\n              mainMediaUrl = url;\n              mainMediaType = 'video';\n              console.log(`Estableciendo nuevo video subido como principal: ${url}`);\n              \n              // Asegurarse de que ningún otro elemento sea principal\n              mediaItems.forEach(item => {\n                if (item.url !== url) {\n                  item.isMain = false;\n                }\n              });\n            }\n          }\n        });\n        \n        // Si después de todo el proceso no hay un medio principal definido \n        // y hay videos nuevos, usar el primer video como principal\n        if (!mainMediaUrl && videoUrls.length > 0) {\n          mainMediaUrl = videoUrls[0];\n          mainMediaType = 'video';\n          \n          // Actualizar el indicador isMain en el array de medios\n          const firstVideoIndex = mediaItems.findIndex(item => \n            item.type === 'video' && item.url === videoUrls[0]\n          );\n          \n          if (firstVideoIndex >= 0) {\n            // Marcar el primer elemento como principal\n            mediaItems.forEach((item, idx) => {\n              item.isMain = idx === firstVideoIndex;\n            });\n          }\n          \n          console.log(`Estableciendo nuevo video como principal (último recurso): ${mainMediaUrl}`);\n        }\n      }\n      \n      // Procesar mediaItems JSON enviado directamente desde el cliente\n      if (req.body.mediaItems) {\n        try {\n          console.log(\"=== PROCESANDO MEDIA ITEMS DEL CLIENTE ===\");\n          console.log(\"JSON recibido:\", req.body.mediaItems);\n          \n          // Parsear el JSON enviado por el cliente\n          let clientMediaItems = [];\n          try {\n            clientMediaItems = JSON.parse(req.body.mediaItems);\n            console.log(`Elementos multimedia recibidos: ${clientMediaItems.length}`);\n          } catch (parseError) {\n            console.error(\"Error al parsear mediaItems:\", parseError);\n            clientMediaItems = [];\n          }\n          \n          // DETECCIÓN DE PROBLEMA CRÍTICO: Verificar si hay medios existentes y el cliente envía array vacío\n          // Este es un patrón común cuando se edita el evento modificando sólo campos básicos\n          let preservingExistingMedia = false;\n          \n          if (mediaItems.length > 0 && \n              (clientMediaItems.length === 0 || \n               !clientMediaItems.some((item: any) => item && item.url))) {\n            \n            console.log(\"⚠️ CASO ESPECIAL DETECTADO: El cliente envió un array vacío o sin elementos válidos\");\n            console.log(`⚠️ El evento ya tiene ${mediaItems.length} elementos multimedia existentes`);\n            console.log(\"🔒 PRESERVANDO los elementos multimedia existentes:\");\n            console.log(JSON.stringify(mediaItems));\n            \n            // IMPORTANTE: Marcar que estamos preservando medios existentes\n            preservingExistingMedia = true;\n            \n            // Asegurar que haya un elemento principal\n            const currentMainItem = mediaItems.find(item => item.isMain);\n            if (!currentMainItem && mediaItems.length > 0) {\n              // Si no hay un elemento principal, establecer el primero como principal\n              mediaItems[0].isMain = true;\n              mainMediaUrl = mediaItems[0].url;\n              mainMediaType = mediaItems[0].type;\n              console.log(`✅ Estableciendo primer elemento como principal: ${mainMediaType} - ${mainMediaUrl}`);\n            } else if (currentMainItem) {\n              // Asegurar que las variables principales estén sincronizadas\n              mainMediaUrl = currentMainItem.url;\n              mainMediaType = currentMainItem.type;\n              console.log(`✅ Sincronizando con elemento principal existente: ${mainMediaType} - ${mainMediaUrl}`);\n            }\n          }\n          \n          // Solo procesar los mediaItems del cliente si no estamos preservando los existentes\n          if (!preservingExistingMedia && Array.isArray(clientMediaItems)) {\n            // MEJORA CRÍTICA: Verificar primero si hay un elemento explícitamente marcado como principal\n            const explicitMainItem = clientMediaItems.find((item: any) => \n              item && item.isMain === true && !item.toDelete && !item.deleted\n            );\n            \n            if (explicitMainItem) {\n              console.log(\"DETECTADO ELEMENTO EXPLÍCITAMENTE MARCADO COMO PRINCIPAL:\", {\n                tipo: explicitMainItem.type || \"desconocido\",\n                url: explicitMainItem.url || \"sin URL\"\n              });\n            } else {\n              console.log(\"No se encontró un elemento explícitamente marcado como principal\");\n            }\n            // PASO 1: Identificar elementos explícitamente marcados para eliminación\n            const itemsToDelete = clientMediaItems\n              .filter((item: any) => {\n                // Verificar cada item minuciosamente\n                if (!item || !item.url) return false;\n                \n                // Comprobar si está marcado explícitamente para eliminar\n                const markedForDeletion = item.toDelete === true || item.deleted === true;\n                \n                // Registrar cada elemento marcado para eliminar\n                if (markedForDeletion) {\n                  console.log(`Elemento marcado para eliminación: ${item.type} - ${item.url}`);\n                }\n                \n                return markedForDeletion;\n              });\n              \n              // Registrar cuántos elementos se marcarán para eliminación\n              if (itemsToDelete.length > 0) {\n                console.log(`Se han marcado ${itemsToDelete.length} elementos para eliminación`);\n              }\n              \n              // Lista de URLs a eliminar para filtrado más sencillo\n              const urlsToDelete = itemsToDelete.map((item: any) => item.url);\n              console.log(`URLs a eliminar: [${urlsToDelete.join(', ')}]`);\n              \n              // Guardar una copia de los mediaItems actuales antes de procesarlos\n              // Esto nos permitirá preservar los que son nuevos subidos en esta misma petición\n              const existingMediaItems = [...mediaItems];\n              \n              // Crear un nuevo array para almacenar los mediaItems actualizados\n              const updatedMediaItems: MediaItem[] = [];\n              \n              // Lista de URLs de elementos que vienen del cliente para evitar duplicados\n              const clientUrls = clientMediaItems\n                .filter((item: any) => item && item.url && !item.toDelete && !item.deleted)\n                .map((item: any) => item.url);\n              \n              // Primero, agregar los archivos recién subidos que no están en el mediaItems del cliente\n              // y que no están marcados para eliminación\n              const newlyUploadedItems = existingMediaItems.filter(item => \n                !clientUrls.includes(item.url) && !urlsToDelete.includes(item.url));\n              \n              if (newlyUploadedItems.length > 0) {\n                console.log(`Preservando ${newlyUploadedItems.length} elementos recién subidos que no están en mediaItems del cliente`);\n                updatedMediaItems.push(...newlyUploadedItems);\n              }\n              \n              // MEJORA: Verificar si algún elemento del cliente está marcado como principal\n              const hasClientMainItem = clientMediaItems.some((item: any) => \n                item && item.isMain === true && !item.toDelete && !item.deleted\n              );\n              \n              console.log(\"¿Hay un elemento principal explícito en mediaItems del cliente?\", hasClientMainItem);\n              \n              // Procesar los elementos enviados por el cliente\n              clientMediaItems.forEach((item: { \n                type: string; \n                url?: string; \n                isMain?: boolean;\n                order?: number; \n                toDelete?: boolean;\n                deleted?: boolean;\n              }, index: number) => {\n                // Verificar si el elemento está marcado para eliminación\n                const shouldRemove = item.toDelete === true || item.deleted === true;\n                \n                // Solo procesar elementos que no están marcados para eliminación y tienen URL\n                if (item.url && !shouldRemove) {\n                  // MEJORA: Mantener el flag isMain exactamente como viene del cliente\n                  // sin normalizar a booleano en este punto para preservar mejor la selección\n                  const mediaItem = {\n                    type: item.type || 'photo',\n                    url: item.url,\n                    order: item.order !== undefined ? item.order : index + newlyUploadedItems.length,\n                    isMain: item.isMain === true  // Preservar la selección explícita\n                  };\n                  \n                  // Agregar al array de mediaItems\n                  updatedMediaItems.push(mediaItem);\n                  \n                  // Si este ítem está marcado como principal, actualizar los valores principales\n                  if (item.isMain === true) {\n                    mainMediaUrl = item.url;\n                    mainMediaType = item.type || 'photo';\n                    console.log(`Estableciendo media principal desde cliente: ${mainMediaType} - ${mainMediaUrl}`);\n                  }\n                } else if (item.url && shouldRemove) {\n                  console.log(`ELIMINANDO elemento: ${item.type} - ${item.url}`);\n                  \n                  // Si el elemento eliminado era el principal, registrarlo\n                  if (item.isMain) {\n                    console.log(`¡ATENCIÓN! Se está eliminando el elemento principal: ${item.url}`);\n                  }\n                }\n              });\n              \n              // Actualizar mediaItems con los elementos que han sido procesados (excluyendo los eliminados)\n              mediaItems = updatedMediaItems;\n            }\n          }\n        } catch (error) {\n          console.error(\"Error al procesar mediaItems JSON:\", error);\n        }\n      }\n      \n      // Verificar si mainMediaUrl sigue siendo válido (podría haber sido eliminado)\n      if (mainMediaUrl) {\n        const mainMediaExists = mediaItems.some(item => item.url === mainMediaUrl);\n        if (!mainMediaExists) {\n          console.log(`El media principal ${mainMediaUrl} ya no existe, estableciendo uno nuevo`);\n          \n          // Intentar encontrar un nuevo elemento principal (preferiblemente foto)\n          const firstPhoto = mediaItems.find(item => item.type === 'photo');\n          if (firstPhoto) {\n            mainMediaUrl = firstPhoto.url;\n            mainMediaType = 'photo';\n            \n            // Actualizar la propiedad isMain en los elementos\n            mediaItems.forEach(item => {\n              item.isMain = item.url === mainMediaUrl;\n            });\n            \n            console.log(`Nuevo media principal establecido: ${mainMediaType} - ${mainMediaUrl}`);\n          } else if (mediaItems.length > 0) {\n            // Si no hay fotos, usar el primer elemento disponible\n            mainMediaUrl = mediaItems[0].url;\n            mainMediaType = mediaItems[0].type;\n            mediaItems[0].isMain = true;\n            \n            console.log(`Nuevo media principal (no foto) establecido: ${mainMediaType} - ${mainMediaUrl}`);\n          } else {\n            // No hay elementos multimedia\n            mainMediaUrl = '';\n            mainMediaType = 'photo'; // Default to photo to avoid enum error\n            console.log('No hay elementos multimedia disponibles para establecer como principal');\n          }\n        }\n      }\n      \n      console.log(`Procesados ${mediaItems.length} elementos multimedia en total (incluidos archivos nuevos)`);\n      \n      // Procesar el archivo principal especificado (subido como archivo)\n      if (files.mainMediaFile && files.mainMediaFile.length > 0) {\n        const mediaPath = files.mainMediaFile[0].path.replace('public', '');\n        // Determinar tipo según el mimetype\n        const isVideo = files.mainMediaFile[0].mimetype.startsWith('video/');\n        mainMediaType = isVideo ? 'video' : 'photo';\n        mainMediaUrl = mediaPath;\n        \n        console.log(`Archivo principal subido: ${mainMediaType} - ${mainMediaUrl}`);\n        \n        // Asegurarse de que está en mediaItems\n        if (!mediaItems.some(item => item.url === mediaPath)) {\n          // Crear un nuevo elemento multimedia para el archivo principal\n          const mainMediaItem = { \n            type: mainMediaType, \n            url: mediaPath, \n            order: mediaItems.length,\n            isMain: true\n          };\n          \n          // Agregarlo a mediaItems\n          mediaItems.push(mainMediaItem);\n          console.log(`Agregado nuevo archivo principal a mediaItems: ${mainMediaType} - ${mediaPath}`);\n        } else {\n          // Actualizar el elemento existente para marcarlo como principal\n          // Mantenemos todos los demás elementos, pero actualizamos el isMain\n          mediaItems = mediaItems.map(item => ({\n            ...item,\n            isMain: item.url === mediaPath,\n            // Asegurar que el tipo coincida si es el elemento principal\n            type: item.url === mediaPath ? mainMediaType : item.type\n          }));\n          console.log(`Actualizado elemento existente como principal: ${mainMediaType} - ${mediaPath}`);\n        }\n      } else if (req.body.mainMediaUrl) {\n        // Permitir establecer un medio existente como principal\n        mainMediaUrl = req.body.mainMediaUrl;\n        mainMediaType = req.body.mainMediaType || 'photo';\n        \n        console.log(`Estableciendo medio existente como principal: ${mainMediaType} - ${mainMediaUrl}`);\n        \n        // Actualizar mediaItems para reflejar el cambio de elemento principal\n        mediaItems = mediaItems.map(item => ({\n          ...item,\n          isMain: item.url === mainMediaUrl,\n          // Asegurar que el tipo coincida si es el elemento principal\n          type: item.url === mainMediaUrl ? mainMediaType : item.type\n        }));\n      }\n      \n      // Verificar coherencia: asegurar que si hay mainMediaUrl, también hay mainMediaType\n      if (mainMediaUrl && !mainMediaType) {\n        // Determinar el tipo basado en la extensión del archivo\n        const isVideoExt = /\\.(mp4|mov|avi|wmv|flv|webm)$/i.test(mainMediaUrl);\n        mainMediaType = isVideoExt ? 'video' : 'photo';\n        console.log(`Corrigiendo tipo de medio principal: ${mainMediaType} para ${mainMediaUrl}`);\n      }\n      \n      // Y viceversa: si no hay URL principal, no debería haber tipo\n      if (!mainMediaUrl && mainMediaType) {\n        console.log(`Corrigiendo inconsistencia: mainMediaType establecido (${mainMediaType}) pero no hay mainMediaUrl`);\n        \n        // Si hay al menos un elemento multimedia, usar el primero como principal\n        if (mediaItems.length > 0) {\n          // Buscar algún elemento que ya esté marcado como principal\n          const mainItem = mediaItems.find(item => item.isMain === true);\n          \n          if (mainItem) {\n            // Usar el elemento marcado como principal\n            mainMediaUrl = mainItem.url;\n            mainMediaType = mainItem.type;\n            console.log(`Usando elemento marcado como principal: ${mainMediaType} - ${mainMediaUrl}`);\n          } else {\n            // Si ninguno está marcado, usar el primero\n            mainMediaUrl = mediaItems[0].url;\n            mainMediaType = mediaItems[0].type;\n            console.log(`Usando primer elemento como principal: ${mainMediaType} - ${mainMediaUrl}`);\n            \n            // Actualizar el isMain en mediaItems\n            mediaItems = mediaItems.map((item, index) => ({\n              ...item,\n              isMain: index === 0\n            }));\n          }\n        } else {\n          // No hay elementos multimedia, usamos un tipo por defecto para evitar errores de enum\n          mainMediaType = 'photo'; // Default to photo to avoid enum error\n        }\n      }\n      \n      // Reorganizar elementos basados en el campo order\n      mediaItems.sort((a, b) => {\n        // Si el orden no está definido, considerar como último\n        const orderA = a.order !== undefined ? a.order : Number.MAX_SAFE_INTEGER;\n        const orderB = b.order !== undefined ? b.order : Number.MAX_SAFE_INTEGER;\n        return orderA - orderB;\n      });\n      \n      // Reasignar órdenes para asegurar consistencia\n      mediaItems = mediaItems.map((item, index) => ({\n        ...item,\n        order: index\n      }));\n      \n      // Asegurarse de que exactamente un elemento esté marcado como principal\n      const principalItems = mediaItems.filter(item => item.isMain === true);\n      \n      if (principalItems.length === 0 && mediaItems.length > 0) {\n        // Si ninguno está marcado como principal, intentar encontrar una foto primero\n        const firstPhoto = mediaItems.find(item => item.type === 'photo');\n        \n        if (firstPhoto) {\n          // Preferir una foto como elemento principal\n          firstPhoto.isMain = true;\n          mainMediaUrl = firstPhoto.url;\n          mainMediaType = 'photo';\n          console.log(`Estableciendo primera foto como principal por defecto: ${mainMediaUrl}`);\n        } else {\n          // Si no hay fotos, usar el primer elemento (probablemente un video)\n          mediaItems[0].isMain = true;\n          mainMediaUrl = mediaItems[0].url;\n          mainMediaType = mediaItems[0].type;\n          console.log(`Estableciendo el primer elemento como principal por defecto: ${mainMediaType} - ${mainMediaUrl}`);\n        }\n      } else if (principalItems.length > 1) {\n        // Si hay más de uno marcado como principal, dejar solo el primero\n        let foundMain = false;\n        mediaItems = mediaItems.map(item => {\n          if (item.isMain && !foundMain) {\n            foundMain = true;\n            // Asegurar que mainMediaUrl y mainMediaType están actualizados\n            mainMediaUrl = item.url;\n            mainMediaType = item.type;\n            return item;\n          }\n          return { ...item, isMain: false };\n        });\n        console.log(`Resolviendo múltiples principales: único elemento principal ahora es ${mainMediaType} - ${mainMediaUrl}`);\n      }\n      \n      // Limitar a máximo 6 fotos y 3 videos y preservar el elemento principal\n      const MAX_PHOTOS = 6;\n      const MAX_VIDEOS = 3;\n      \n      // Separar fotos y videos, y mantener referencia a cual es el elemento principal\n      const mainItem = mediaItems.find(item => item.isMain === true);\n      const photos = mediaItems.filter(item => item.type === 'photo');\n      const videos = mediaItems.filter(item => item.type === 'video');\n      \n      let photosToKeep = photos;\n      let videosToKeep = videos;\n      \n      // Limitar fotos si exceden el máximo\n      if (photos.length > MAX_PHOTOS) {\n        console.log(`Limitando cantidad de fotos: ${photos.length} → ${MAX_PHOTOS}`);\n        \n        // Si el elemento principal es una foto, asegurarse de que esté entre las que se mantienen\n        if (mainItem && mainItem.type === 'photo') {\n          // Quitar el elemento principal del array para no contarlo en el límite\n          const otherPhotos = photos.filter(item => item !== mainItem);\n          \n          // Mantener el elemento principal + hasta (MAX_PHOTOS-1) otras fotos\n          const remainingPhotos = otherPhotos.slice(0, MAX_PHOTOS - 1);\n          photosToKeep = [mainItem, ...remainingPhotos];\n        } else {\n          // Si no hay principal o no es una foto, simplemente mantener las primeras MAX_PHOTOS\n          photosToKeep = photos.slice(0, MAX_PHOTOS);\n        }\n      }\n      \n      // Limitar videos si exceden el máximo\n      if (videos.length > MAX_VIDEOS) {\n        console.log(`Limitando cantidad de videos: ${videos.length} → ${MAX_VIDEOS}`);\n        \n        // Si el elemento principal es un video, asegurarse de que esté entre los que se mantienen\n        if (mainItem && mainItem.type === 'video') {\n          // Quitar el elemento principal del array para no contarlo en el límite\n          const otherVideos = videos.filter(item => item !== mainItem);\n          \n          // Mantener el elemento principal + hasta (MAX_VIDEOS-1) otros videos\n          const remainingVideos = otherVideos.slice(0, MAX_VIDEOS - 1);\n          videosToKeep = [mainItem, ...remainingVideos];\n        } else {\n          // Si no hay principal o no es un video, simplemente mantener los primeros MAX_VIDEOS\n          videosToKeep = videos.slice(0, MAX_VIDEOS);\n        }\n      }\n      \n      // Asignar los elementos filtrados y reordenar\n      mediaItems = [...photosToKeep, ...videosToKeep];\n      \n      // Verificar si el elemento principal se conservó después de la filtración\n      if (mainItem && !mediaItems.includes(mainItem)) {\n        console.warn(\"El elemento principal se perdió durante la filtración. Asignando uno nuevo.\");\n        \n        // Si el elemento principal se perdió, asignar uno nuevo\n        if (mediaItems.length > 0) {\n          // Preferir fotos como elemento principal\n          const newMainItem = mediaItems.find(item => item.type === 'photo') || mediaItems[0];\n          \n          // Actualizar flags y variables\n          mediaItems = mediaItems.map(item => ({\n            ...item,\n            isMain: item === newMainItem\n          }));\n          \n          mainMediaUrl = newMainItem.url;\n          mainMediaType = newMainItem.type;\n          \n          console.log(`Nuevo elemento principal asignado: ${mainMediaType} - ${mainMediaUrl}`);\n        } else {\n          // No hay elementos multimedia después de la filtración\n          mainMediaUrl = '';\n          mainMediaType = 'photo'; // Default to photo to avoid enum error\n        }\n      }\n      \n      // Re-asignar órdenes para mantener consistencia después de filtrar\n      mediaItems = mediaItems.map((item, index) => ({\n        ...item,\n        order: index\n      }));\n      \n      // Actualizar los campos de multimedia\n      updateData.mediaItems = JSON.stringify(mediaItems);\n      \n      // Asegurar que mainMediaType sea siempre un string, no un array\n      if (Array.isArray(mainMediaType)) {\n        updateData.mainMediaType = mainMediaType[0] || 'photo';\n        console.log(`Corrigiendo mainMediaType de array a string: ${mainMediaType} → ${updateData.mainMediaType}`);\n      } else {\n        updateData.mainMediaType = mainMediaType || 'photo';\n      }\n      \n      updateData.mainMediaUrl = mainMediaUrl;\n      \n      // Si hay preguntas de postulación, incluirlas\n      if (req.body.applicationQuestions) {\n        updateData.applicationQuestions = req.body.applicationQuestions;\n      }\n      \n      // Update event\n      const updatedEvent = await storage.updateEvent(eventId, updateData);\n      \n      // Broadcast event update to all connected clients\n      broadcastMessage({\n        type: 'event_updated',\n        event: updatedEvent\n      });\n      console.log(\"Notificación de actualización de evento enviada a todos los clientes WebSocket\");\n      \n      res.json(updatedEvent);\n    } catch (error) {\n      console.error(\"Error updating event with files:\", error);\n      res.status(500).json({ message: \"Error updating event\", error: String(error) });\n    }\n  });\n\n  app.delete(\"/api/events/:id\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      // Check if event exists\n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      // Check if user is the organizer\n      if (event.organizerId !== user.id) {\n        return res.status(403).json({ message: \"Not authorized to delete this event\" });\n      }\n      \n      // Delete event\n      await storage.deleteEvent(eventId);\n      res.json({ message: \"Event deleted successfully\" });\n    } catch (error) {\n      console.error(\"Error deleting event:\", error);\n      res.status(500).json({ message: \"Error deleting event\" });\n    }\n  });\n\n  // Event attendance routes\n  app.post(\"/api/events/:id/join\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      // Check if event exists\n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      // Check if user is already attending\n      const existingAttendee = await storage.getEventAttendee(eventId, user.id);\n      if (existingAttendee) {\n        return res.status(400).json({ \n          message: \"Already joined this event\",\n          status: existingAttendee.status\n        });\n      }\n      \n      // Check if event is at capacity\n      if (event.maxCapacity) {\n        const attendees = await storage.getEventAttendees(eventId);\n        if (attendees.length >= event.maxCapacity) {\n          return res.status(400).json({ message: \"Event is at maximum capacity\" });\n        }\n      }\n      \n      // For private events, create a pending request\n      if (event.privacyType === 'private') {\n        const attendee = await storage.joinEvent({\n          eventId,\n          userId: user.id,\n          status: 'pending',\n          paymentStatus: event.paymentType === 'free' ? 'completed' : 'pending'\n        });\n        \n        return res.status(201).json({ \n          attendee, \n          requiresPayment: false,\n          isPendingApproval: true\n        });\n      }\n      \n      // For paid events, process through Stripe\n      if (event.paymentType === 'paid' && event.price) {\n        if (!stripe) {\n          return res.status(500).json({ message: \"Payment processing is not available\" });\n        }\n        \n        // Pagos desactivados, creamos un objeto simulado para mantener compatibilidad con el código\n        const paymentIntent = {\n          id: `free_event_${Date.now()}`,\n          client_secret: `free_event_no_payment_required_${Date.now()}`\n        };\n        \n        // Create attendance record with pending payment\n        const attendee = await storage.joinEvent({\n          eventId,\n          userId: user.id,\n          status: 'approved',\n          paymentStatus: 'pending',\n          paymentIntentId: paymentIntent.id\n        });\n        \n        return res.status(201).json({ \n          attendee,\n          clientSecret: paymentIntent.client_secret,\n          requiresPayment: true,\n          isPendingApproval: false\n        });\n      }\n      \n      // For free events, just add them\n      const attendee = await storage.joinEvent({\n        eventId,\n        userId: user.id,\n        status: 'approved',\n        paymentStatus: 'completed'\n      });\n      \n      res.status(201).json({ \n        attendee, \n        requiresPayment: false,\n        isPendingApproval: false\n      });\n    } catch (error) {\n      console.error(\"Error joining event:\", error);\n      res.status(500).json({ message: \"Error joining event\" });\n    }\n  });\n\n  app.delete(\"/api/events/:id/leave\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      // Check if user is attending\n      const attendee = await storage.getEventAttendee(eventId, user.id);\n      if (!attendee) {\n        return res.status(404).json({ message: \"Not attending this event\" });\n      }\n      \n      // Cannot leave a paid event if payment is completed\n      if (attendee.paymentStatus === 'completed' && attendee.paymentIntentId) {\n        return res.status(400).json({ message: \"Cannot leave a paid event after payment is completed\" });\n      }\n      \n      // Pagos desactivados, no necesitamos cancelar el payment intent\n      // Si hubiera pagos, aquí se cancelaría el payment intent\n      \n      // Remove attendee record\n      await storage.leaveEvent(eventId, user.id);\n      res.json({ message: \"Left event successfully\" });\n    } catch (error) {\n      console.error(\"Error leaving event:\", error);\n      res.status(500).json({ message: \"Error leaving event\" });\n    }\n  });\n  \n  // Approve/reject join requests for private events\n  app.post(\"/api/events/:id/requests/:attendeeId/approve\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      const attendeeId = parseInt(req.params.attendeeId);\n      \n      // Verify the event exists and user is the organizer\n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      if (event.organizerId !== user.id) {\n        return res.status(403).json({ message: \"Only the event organizer can approve requests\" });\n      }\n      \n      // Get the attendee record\n      const attendee = await storage.getEventAttendee(eventId, attendeeId);\n      if (!attendee) {\n        return res.status(404).json({ message: \"Join request not found\" });\n      }\n      \n      if (attendee.status !== 'pending') {\n        return res.status(400).json({ message: \"This request has already been processed\" });\n      }\n      \n      // Update attendee status\n      const updatedAttendee = await storage.updateEventAttendee(attendee.id, {\n        status: 'approved'\n      });\n      \n      res.json({ \n        attendee: updatedAttendee,\n        message: \"Join request approved\" \n      });\n    } catch (error) {\n      console.error(\"Error approving join request:\", error);\n      res.status(500).json({ message: \"Server error\" });\n    }\n  });\n  \n  app.post(\"/api/events/:id/requests/:attendeeId/reject\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      const attendeeId = parseInt(req.params.attendeeId);\n      \n      // Verify the event exists and user is the organizer\n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      if (event.organizerId !== user.id) {\n        return res.status(403).json({ message: \"Only the event organizer can reject requests\" });\n      }\n      \n      // Get the attendee record\n      const attendee = await storage.getEventAttendee(eventId, attendeeId);\n      if (!attendee) {\n        return res.status(404).json({ message: \"Join request not found\" });\n      }\n      \n      if (attendee.status !== 'pending') {\n        return res.status(400).json({ message: \"This request has already been processed\" });\n      }\n      \n      // Delete the attendee record\n      await storage.leaveEvent(eventId, attendeeId);\n      \n      res.json({ message: \"Join request rejected\" });\n    } catch (error) {\n      console.error(\"Error rejecting join request:\", error);\n      res.status(500).json({ message: \"Server error\" });\n    }\n  });\n  \n  // Get pending join requests for an event\n  app.get(\"/api/events/:id/requests\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      // Verify the event exists and user is the organizer\n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      if (event.organizerId !== user.id) {\n        return res.status(403).json({ message: \"Only the event organizer can view join requests\" });\n      }\n      \n      // Get all attendees for the event\n      const attendees = await storage.getEventAttendees(eventId);\n      \n      // Filter to only pending requests\n      const pendingRequests = attendees.filter(attendee => attendee.status === 'pending');\n      \n      res.json(pendingRequests);\n    } catch (error) {\n      console.error(\"Error fetching join requests:\", error);\n      res.status(500).json({ message: \"Server error\" });\n    }\n  });\n  \n  // Check user's status for an event (for pending requests)\n  app.get(\"/api/events/:id/status\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      // Get user's attendance record\n      const attendee = await storage.getEventAttendee(eventId, user.id);\n      if (!attendee) {\n        return res.status(404).json({ \n          message: \"No estás registrado en este evento\",\n          status: null\n        });\n      }\n      \n      // Return status\n      res.json({ \n        status: attendee.status,\n        paymentStatus: attendee.paymentStatus\n      });\n    } catch (error) {\n      console.error(\"Error checking event status:\", error);\n      res.status(500).json({ message: \"Error del servidor\" });\n    }\n  });\n\n  // Simplified payment routes - all events are free\n  app.post(\"/api/payment/confirm\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const { eventId } = req.body;\n      \n      // Check if the event exists\n      const event = await storage.getEventById(parseInt(eventId));\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      // Automatically join the event as free\n      try {\n        // Update the attendee record\n        const updatedAttendee = await storage.updatePaymentStatus(\n          parseInt(eventId),\n          user.id,\n          'free',\n          \"\"\n        );\n        \n        res.json(updatedAttendee);\n      } catch (error) {\n        console.error(\"Error updating event status:\", error);\n        res.status(500).json({ message: \"Error updating event attendance\" });\n      }\n    } catch (error) {\n      console.error(\"Error joining event:\", error);\n      res.status(500).json({ message: \"Error joining event\" });\n    }\n  });\n\n  // User events routes\n  app.get(\"/api/user/events/created\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const events = await storage.getUserCreatedEvents(user.id);\n      res.json(events);\n    } catch (error) {\n      console.error(\"Error fetching created events:\", error);\n      res.status(500).json({ message: \"Error fetching created events\" });\n    }\n  });\n\n  app.get(\"/api/user/events/attending\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const events = await storage.getUserAttendingEvents(user.id);\n      res.json(events);\n    } catch (error) {\n      console.error(\"Error fetching attending events:\", error);\n      res.status(500).json({ message: \"Error fetching attending events\" });\n    }\n  });\n\n  // Simplified payment intent route - all events are free\n  app.post(\"/api/create-payment-intent\", isAuthenticated, async (req, res) => {\n    try {      \n      const { eventId } = req.body;\n      const user = req.user as any;\n      \n      // Get the event details\n      const event = await storage.getEventById(parseInt(eventId));\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      // Automatically join the event as a free event\n      try {\n        await storage.joinEvent({\n          eventId: parseInt(eventId),\n          userId: user.id,\n          paymentStatus: \"free\",\n          paymentIntentId: \"\"\n        });\n        \n        // Return a fake client secret to keep the client logic working\n        res.json({ \n          clientSecret: \"free_event_no_payment_required\",\n          message: \"Joined event successfully\" \n        });\n      } catch (error) {\n        console.error(\"Error joining event:\", error);\n        res.status(500).json({ message: \"Error joining event\" });\n      }\n    } catch (error) {\n      console.error(\"Error handling free event join:\", error);\n      res.status(500).json({ message: \"Server error\" });\n    }\n  });\n\n  const httpServer = createServer(app);\n  \n  // Initialize WebSocket server on a different path to avoid conflict with Vite HMR\n  const wss = new WebSocketServer({ \n    server: httpServer, \n    path: '/ws' \n  });\n  \n  // Store active connections\n  const clients = new Map<string, { ws: WebSocket, userId: number, userName: string }>();\n  \n  // Función para enviar mensajes a todos los clientes\n  const broadcastMessage = (data: any) => {\n    const message = JSON.stringify(data);\n    clients.forEach(({ ws }) => {\n      if (ws.readyState === WebSocket.OPEN) {\n        ws.send(message);\n      }\n    });\n    console.log(`Broadcasted ${data.type} to ${clients.size} clients`);\n  };\n  \n  wss.on('connection', (ws, req) => {\n    console.log('WebSocket connection established');\n    \n    // Intentar extraer información de sesión si está disponible\n    const url = new URL(req.url || '', `http://${req.headers.host}`);\n    const sid = url.searchParams.get('sid');\n    if (sid) {\n      console.log(`WebSocket connection with session ID: ${sid.substring(0, 8)}...`);\n    }\n    \n    // Generate client ID\n    const clientId = Math.random().toString(36).substring(2, 15);\n    \n    // Handle messages\n    ws.on('message', async (message) => {\n      try {\n        const data = JSON.parse(message.toString());\n        \n        // Handle authentication\n        if (data.type === 'auth') {\n          const { userId, userName } = data;\n          clients.set(clientId, { ws, userId, userName });\n          console.log(`Client authenticated: ${userName} (${userId})`);\n          \n          // Send confirmation to the client\n          ws.send(JSON.stringify({\n            type: 'auth_success',\n            userId,\n            userName\n          }));\n          \n          return;\n        }\n        \n        // Handle chat messages - only logged in users\n        if (data.type === 'message' && clients.has(clientId)) {\n          const { eventId, content } = data;\n          const sender = clients.get(clientId)!;\n          \n          // Validate data\n          if (!eventId || !content || content.trim() === '') {\n            return;\n          }\n          \n          const messageData = {\n            type: 'message',\n            eventId,\n            userId: sender.userId,\n            userName: sender.userName,\n            content,\n            timestamp: new Date().toISOString()\n          };\n          \n          // Broadcast to all clients connected to the same event\n          clients.forEach((client) => {\n            if (client.ws.readyState === WebSocket.OPEN) {\n              client.ws.send(JSON.stringify(messageData));\n            }\n          });\n          \n          return;\n        }\n      } catch (error) {\n        console.error('Error processing WebSocket message:', error);\n      }\n    });\n    \n    // Handle disconnection\n    ws.on('close', () => {\n      clients.delete(clientId);\n      console.log('WebSocket connection closed');\n    });\n    \n    // Send initial message\n    ws.send(JSON.stringify({ \n      type: 'connection_established',\n      message: 'Successfully connected to Pipol chat server'\n    }));\n  });\n\n  return httpServer;\n}\n","size_bytes":101400},"routes-original.ts":{"content":"import express, { Express, Request, Response } from \"express\";\nimport { createServer, type Server } from \"http\";\nimport { storage } from \"./storage\";\nimport bcrypt from \"bcrypt\";\nimport passport from \"passport\";\nimport { loginUserSchema, insertUserSchema, insertEventSchema, insertEventAttendeeSchema } from \"@shared/schema\";\nimport { z } from \"zod\";\nimport Stripe from \"stripe\";\nimport { WebSocketServer } from 'ws';\nimport { WebSocket } from 'ws';\nimport multer from 'multer';\nimport path from 'path';\nimport fs from 'fs';\n\nif (!process.env.SESSION_SECRET) {\n  console.warn(\"No SESSION_SECRET provided, using default secret. This is insecure!\");\n}\n\n// Payment functionality is disabled for this app\nconsole.log(\"Payment functionality is disabled in this version of the app.\");\n\n// Set stripe to null - all events will be free\nconst stripe = null;\n\n// Configurar almacenamiento para multer\nconst storage_uploads = multer.diskStorage({\n  destination: function (req, file, cb) {\n    // Definir el directorio según el tipo de archivo\n    let uploadPath = 'public/uploads/events';\n    \n    // Asegurarse de que el directorio existe\n    if (!fs.existsSync(uploadPath)) {\n      fs.mkdirSync(uploadPath, { recursive: true });\n    }\n    \n    cb(null, uploadPath);\n  },\n  filename: function (req, file, cb) {\n    // Generar un nombre de archivo único\n    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\n    const extension = path.extname(file.originalname);\n    cb(null, 'event-' + uniqueSuffix + extension);\n  }\n});\n\n// Filtrar archivos por tipo y validar condiciones\nconst fileFilter = (req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {\n  console.log(`Procesando archivo: ${file.fieldname}, tipo: ${file.mimetype}`);\n  \n  // Categorizar el archivo según el campo\n  const isImageField = file.fieldname === 'eventPhoto' || file.fieldname === 'photos' || file.fieldname.startsWith('photos[');\n  const isVideoField = file.fieldname === 'eventVideo' || file.fieldname === 'videos' || file.fieldname.startsWith('videos[');\n  const isMainMediaField = file.fieldname === 'mainMediaFile' || file.fieldname === 'mainMedia';\n  const isMediaManagerField = file.fieldname.startsWith('mediaFile_');\n  \n  // Verificar tipo de contenido\n  const isImage = file.mimetype.startsWith('image/');\n  const isVideo = file.mimetype.startsWith('video/');\n  \n  // Validar según tipo de campo\n  if (isImageField) {\n    if (!isImage) {\n      console.warn(`Archivo rechazado - tipo incorrecto: ${file.fieldname}, ${file.mimetype}`);\n      return cb(new Error(`El archivo debe ser una imagen. Tipo recibido: ${file.mimetype}`));\n    }\n    \n    console.log(`Imagen aceptada: ${file.originalname}`);\n    return cb(null, true);\n  } \n  else if (isVideoField) {\n    if (!isVideo) {\n      console.warn(`Archivo rechazado - tipo incorrecto: ${file.fieldname}, ${file.mimetype}`);\n      return cb(new Error(`El archivo debe ser un video. Tipo recibido: ${file.mimetype}`));\n    }\n    \n    console.log(`Video aceptado: ${file.originalname}`);\n    return cb(null, true);\n  }\n  else if (isMainMediaField || isMediaManagerField) {\n    // Permitir tanto imágenes como videos para estos campos\n    if (!isImage && !isVideo) {\n      console.warn(`Archivo rechazado - tipo incorrecto: ${file.fieldname}, ${file.mimetype}`);\n      return cb(new Error(`El archivo multimedia debe ser una imagen o un video. Tipo recibido: ${file.mimetype}`));\n    }\n    \n    const fieldDescription = isMainMediaField ? 'principal' : 'MediaManager';\n    console.log(`Archivo ${fieldDescription} aceptado: ${file.originalname} (${isImage ? 'imagen' : 'video'})`);\n    return cb(null, true);\n  } \n  else {\n    // Por defecto, rechazar otros tipos de archivo desconocidos\n    console.warn(`Tipo de campo no reconocido: ${file.fieldname}, rechazado por seguridad`);\n    return cb(new Error(`Tipo de campo no soportado: ${file.fieldname}`));\n  }\n};\n\n// Constantes para los límites de tamaño\nconst MAX_PHOTO_SIZE = 5 * 1024 * 1024; // 5MB para fotos\nconst MAX_VIDEO_SIZE = 10 * 1024 * 1024; // 10MB para videos\n\n// Configurar manejo de errores para multer\nconst multerErrorHandler = (err: any, req: Request, res: Response, next: Function) => {\n  if (err instanceof multer.MulterError) {\n    console.error(\"Error de Multer:\", err.code, err.field);\n    \n    // Manejar errores específicos de multer con mensajes amigables\n    if (err.code === 'LIMIT_FILE_SIZE') {\n      return res.status(400).json({\n        success: false,\n        message: \"El archivo es demasiado grande. El tamaño máximo permitido es 10MB para videos y 5MB para imágenes.\",\n        error: 'FILE_TOO_LARGE',\n        field: err.field\n      });\n    }\n    \n    if (err.code === 'LIMIT_FILE_COUNT') {\n      return res.status(400).json({\n        success: false,\n        message: \"Se han enviado demasiados archivos. Máximo 10 archivos por solicitud.\",\n        error: 'TOO_MANY_FILES'\n      });\n    }\n    \n    // Otros errores de multer\n    return res.status(400).json({\n      success: false,\n      message: `Error al subir archivo: ${err.message}`,\n      error: err.code\n    });\n  }\n  \n  // Si no es un error de multer, pasar al siguiente middleware\n  if (err) {\n    return next(err);\n  }\n  \n  next();\n};\n\n// Configurar el middleware multer con mejores límites\nconst upload = multer({ \n  storage: storage_uploads,\n  fileFilter: fileFilter,\n  limits: {\n    fileSize: MAX_VIDEO_SIZE, // Usar el límite mayor (10MB) y validar específicamente en el código\n    files: 10, // Máximo 10 archivos por solicitud para evitar abusos\n  }\n});\n\nexport async function registerRoutes(app: Express): Promise<Server> {\n  // Serve static files from public directory\n  app.use(express.static('public'));\n\n  // Auth route middleware\n  const isAuthenticated = (req: Request, res: Response, next: Function) => {\n    if (!req.isAuthenticated()) {\n      console.log(`Petición no autenticada: ${req.method} ${req.path}`);\n      console.log(`Session ID presente: ${!!req.sessionID}`);\n      console.log(`Cookies: ${req.headers.cookie || 'No cookies'}`);\n      return res.status(401).json({ message: \"Not authenticated\" });\n    }\n    return next();\n  };\n\n  // Test auth route - force content type to be application/json\n  app.get(\"/api/auth/test\", (req, res) => {\n    console.log(\"Auth test route accessed\");\n    console.log(\"Session ID:\", req.sessionID);\n    console.log(\"Auth status:\", req.isAuthenticated());\n    console.log(\"User:\", req.user);\n    console.log(\"Session:\", req.session);\n    \n    // Force content type to application/json\n    res.setHeader('Content-Type', 'application/json');\n    \n    return res.send(JSON.stringify({\n      success: true,\n      message: \"Auth test route\",\n      authenticated: req.isAuthenticated(),\n      sessionId: req.sessionID,\n      user: req.user || null,\n      session: req.session ? {\n        id: req.session.id,\n        cookie: {\n          expires: req.session.cookie.expires,\n          maxAge: req.session.cookie.maxAge\n        }\n      } : null\n    }));\n  });\n  \n  // Auth routes\n  // Register a new user\n  app.post(\"/api/auth/register\", async (req, res) => {\n    try {\n      console.log(\"Registration attempt with data:\", { \n        email: req.body.email,\n        username: req.body.username,\n        name: req.body.name\n      });\n      \n      // Validate all input data\n      const validatedData = insertUserSchema.parse(req.body);\n      \n      // Check if email already exists\n      const existingEmail = await storage.getUserByEmail(validatedData.email);\n      if (existingEmail) {\n        console.log(`Registration rejected: Email ${validatedData.email} already exists`);\n        return res.status(400).json({ message: \"Email already in use\" });\n      }\n\n      // Check if username already exists\n      const existingUsername = await storage.getUserByUsername(validatedData.username);\n      if (existingUsername) {\n        console.log(`Registration rejected: Username ${validatedData.username} already exists`);\n        return res.status(400).json({ message: \"Username already taken\" });\n      }\n\n      // Hash password with bcrypt\n      const salt = await bcrypt.genSalt(10);\n      const hashedPassword = await bcrypt.hash(validatedData.password, salt);\n\n      // Create user with the hashed password\n      const user = await storage.insertUser({\n        ...validatedData,\n        password: hashedPassword,\n      });\n\n      console.log(`User registered successfully: ID=${user.id}, Username=${user.username}`);\n\n      // Remove password from the response data\n      const { password: _, ...userWithoutPassword } = user;\n\n      // Automatically log the user in after registration\n      req.login(userWithoutPassword, (err) => {\n        if (err) {\n          console.error(\"Error during auto-login after registration:\", err);\n          return res.status(500).json({ message: \"Registration successful, but automatic login failed\" });\n        }\n        \n        console.log(`User ${user.id} automatically logged in after registration`);\n        return res.status(201).json(userWithoutPassword);\n      });\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        console.log(\"Registration validation errors:\", error.errors);\n        return res.status(400).json({ \n          message: \"Validation error\",\n          errors: error.errors.map(e => ({\n            field: e.path.join('.'),\n            message: e.message\n          }))\n        });\n      }\n      console.error(\"Error registering user:\", error);\n      return res.status(500).json({ message: \"Internal server error during registration\" });\n    }\n  });\n\n  // User login\n  app.post(\"/api/auth/login\", (req, res, next) => {\n    try {\n      console.log(\"Login attempt for:\", req.body.email);\n      \n      // Log request details for debugging\n      console.log(\"Login headers:\", req.headers);\n      console.log(\"Login body:\", req.body);\n      \n      // Validate login data\n      loginUserSchema.parse(req.body);\n      \n      // Use passport for authentication\n      passport.authenticate(\"local\", (err: any, user: any, info: any) => {\n        if (err) {\n          console.error(\"Authentication error:\", err);\n          return next(err);\n        }\n        \n        // Authentication failed\n        if (!user) {\n          console.log(`Login failed for ${req.body.email}: ${info?.message || \"Unknown reason\"}`);\n          return res.status(401).json({ message: info?.message || \"Invalid email or password\" });\n        }\n        \n        // User authenticated, establish session\n        req.login(user, (err) => {\n          if (err) {\n            console.error(\"Session error during login:\", err);\n            return next(err);\n          }\n          \n          console.log(`User ${user.id} (${user.email}) authenticated, establishing session...`);\n          \n          // Force save the session immediately \n          req.session.save((err) => {\n            if (err) {\n              console.error(\"Error saving session:\", err);\n              return next(err);\n            }\n            \n            console.log(`User ${user.id} (${user.email}) logged in successfully`);\n            \n            // Debug session info\n            if (req.session) {\n              console.log(`Session created: id=${req.session.id}, expires=${req.session.cookie.expires}`);\n              console.log(\"Session cookie:\", req.session.cookie);\n              // Set a test value in the session\n              (req.session as any).loginTime = new Date().toISOString();\n              (req.session as any).userId = user.id;\n            }\n            \n            // Set the cookie manually to ensure persistence\n            res.cookie('pipol.sid', req.sessionID, {\n              maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days in milliseconds\n              httpOnly: true,\n              secure: false, // Change to true in production (HTTPS)\n              path: '/',\n              sameSite: 'none'\n            });\n            \n            // Log authentication status for debugging\n            console.log(\"Is authenticated after login:\", req.isAuthenticated());\n            \n            // Return user data without debug information for production use\n            return res.json(user);\n          });\n        });\n      })(req, res, next);\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        console.log(\"Login validation errors:\", error.errors);\n        return res.status(400).json({ \n          message: \"Invalid login data\", \n          errors: error.errors\n        });\n      }\n      console.error(\"Unexpected login error:\", error);\n      return res.status(500).json({ message: \"Internal server error during login\" });\n    }\n  });\n\n  // Test auth endpoint to verify authentication status\n  app.get(\"/api/auth/test\", (req, res) => {\n    try {\n      if (req.isAuthenticated()) {\n        console.log(`Auth test successful for user ${req.user.id}`);\n        return res.json({ \n          authenticated: true, \n          userId: req.user.id,\n          sessionId: req.sessionID\n        });\n      } else {\n        console.log(\"Auth test failed: Not authenticated\");\n        return res.status(401).json({ \n          authenticated: false,\n          sessionId: req.sessionID || null\n        });\n      }\n    } catch (error) {\n      console.error(\"Error in auth test:\", error);\n      return res.status(500).json({ message: \"Error checking authentication status\" });\n    }\n  });\n\n  // Get current user data\n  app.get(\"/api/auth/me\", (req, res) => {\n    try {\n      if (!req.isAuthenticated()) {\n        console.log(\"Auth check for GET /api/auth/me: Not authenticated\");\n        return res.status(401).json({ message: \"Not authenticated\" });\n      }\n      \n      if (!req.user) {\n        console.log(\"Auth check for GET /api/auth/me: User authenticated but no user data\");\n        return res.status(401).json({ message: \"User data not available\" });\n      }\n      \n      console.log(`User data requested for user ${req.user.id}`);\n      return res.json(req.user);\n    } catch (error) {\n      console.error(\"Error in /api/auth/me:\", error);\n      return res.status(500).json({ message: \"Internal server error\" });\n    }\n  });\n\n  // User logout\n  app.post(\"/api/auth/logout\", (req, res) => {\n    if (!req.isAuthenticated()) {\n      return res.status(200).json({ message: \"Already logged out\" });\n    }\n    \n    // Store user ID for logging\n    const userId = req.user.id;\n    console.log(`Logout requested for user ${userId}`);\n    \n    req.logout((err) => {\n      if (err) {\n        console.error(\"Error during logout:\", err);\n        return res.status(500).json({ message: \"Error during logout\" });\n      }\n      \n      // Destroy the session completely\n      req.session.destroy((err) => {\n        if (err) {\n          console.error(\"Error destroying session:\", err);\n        }\n        \n        console.log(`User ${userId} logged out successfully`);\n        res.clearCookie('connect.sid');\n        res.json({ message: \"Logged out successfully\" });\n      });\n    });\n  });\n  \n  // Proxy para solicitudes a la API de Google Places (para evitar problemas CORS)\n  app.get('/api/google-proxy/:service/:endpoint', async (req, res) => {\n    try {\n      const { service, endpoint } = req.params;\n      // Copiar los query params para no modificar el objeto original\n      const queryParams = { ...req.query };\n      \n      // Eliminar clave 'key' del query string\n      if (queryParams.key) {\n        delete queryParams.key;\n      }\n      \n      // Si es una solicitud de búsqueda, agregamos parámetros para mejorar los resultados\n      if (endpoint === 'textsearch' || endpoint === 'findplacefromtext') {\n        // Priorizar la región del usuario (Argentina) para mostrar resultados más relevantes\n        if (!queryParams.region && !queryParams.location) {\n          queryParams.region = 'ar'; // Argentina\n        }\n        \n        // Si la consulta es muy genérica (como 'parque'), agregar más contexto\n        if (queryParams.query && typeof queryParams.query === 'string' && queryParams.query.length < 10) {\n          // Agregar \"en Argentina\" o \"en Mexico\" según la región especificada\n          const region = queryParams.region || 'ar';\n          const countryName = region === 'ar' ? 'Argentina' : (region === 'mx' ? 'México' : '');\n          \n          if (countryName && !queryParams.query.includes(countryName)) {\n            queryParams.query = `${queryParams.query} en ${countryName}`;\n            console.log('Query modificada para mejorar resultados:', queryParams.query);\n          }\n        }\n        \n        // Parámetros para mejorar resultados\n        queryParams.language = 'es'; // Resultados en español\n        queryParams.inputtype = 'textquery';\n        \n        // Aumentar el número de resultados\n        if (!queryParams.maxResults) {\n          queryParams.maxResults = '10';\n        }\n      }\n      \n      // Usar la API key del servidor para mayor seguridad\n      const API_KEY = 'AIzaSyCy5iYWFh36MvrxPKr58A7TPd-f6YHtT1I';\n      \n      const urlParams = new URLSearchParams(queryParams as Record<string, string>).toString();\n      const url = `https://maps.googleapis.com/maps/api/${service}/${endpoint}?${urlParams}&key=${API_KEY}`;\n      console.log(`Proxying Google API request to: ${url}`);\n      \n      const response = await fetch(url);\n      \n      if (!response.ok) {\n        console.error('Error en respuesta HTTP de Google API:', response.status, response.statusText);\n        return res.status(response.status).json({ \n          status: 'ERROR',\n          error_message: `Error HTTP ${response.status}: ${response.statusText}` \n        });\n      }\n      \n      // Parsear la respuesta como texto primero para depurar cualquier problema\n      const responseText = await response.text();\n      \n      try {\n        // Intentar parsear JSON\n        const data = JSON.parse(responseText);\n        console.log('Google API response status:', data.status);\n        \n        if (data.status !== 'OK') {\n          console.log('Google API error details:', data.error_message || 'No error message provided');\n        } else {\n          console.log('Google API returned', data.results?.length || 0, 'results');\n        }\n        \n        return res.json(data);\n      } catch (jsonError) {\n        console.error('Error parsing Google API response as JSON:', jsonError);\n        console.error('Response text (first 200 chars):', responseText.substring(0, 200));\n        \n        return res.status(500).json({ \n          status: 'ERROR',\n          error_message: 'Error parsing Google API response',\n          response_preview: responseText.substring(0, 100) + '...' \n        });\n      }\n    } catch (error) {\n      console.error('Error proxy Google API:', error);\n      res.status(500).json({ \n        status: 'ERROR',\n        error_message: error instanceof Error ? error.message : 'Unknown error in Google API proxy'\n      });\n    }\n  });\n\n  // Event routes\n  // Ruta para obtener un evento específico por ID\n  app.get(\"/api/events/:id\", async (req, res) => {\n    try {\n      const eventId = parseInt(req.params.id);\n      const event = await storage.getEventById(eventId);\n      \n      if (!event) {\n        return res.status(404).json({ message: \"Evento no encontrado\" });\n      }\n      \n      // Incluir organizador\n      const organizer = await storage.getUserById(event.organizerId);\n      \n      // Obtener lista de asistentes\n      const attendees = await storage.getEventAttendees(eventId);\n      \n      // Formatear respuesta\n      const eventWithDetails = {\n        ...event,\n        organizer: organizer ? {\n          id: organizer.id,\n          name: organizer.name,\n          avatar: organizer.avatar\n        } : null,\n        attendees: attendees ? await Promise.all(attendees.map(async (attendee) => {\n          const user = await storage.getUserById(attendee.userId);\n          return {\n            id: attendee.id,\n            user: user ? {\n              id: user.id,\n              name: user.name,\n              avatar: user.avatar\n            } : null\n          };\n        })) : []\n      };\n      \n      res.json(eventWithDetails);\n    } catch (error) {\n      console.error(\"Error fetching event by ID:\", error);\n      res.status(500).json({ message: \"Error al obtener detalles del evento\" });\n    }\n  });\n  \n  // Obtener todos los eventos\n  app.get(\"/api/events\", async (req, res) => {\n    try {\n      const { lat, lng, radius, category, paymentType } = req.query;\n      \n      let events;\n      \n      // If lat and lng are provided, get nearby events\n      if (lat && lng) {\n        events = await storage.getNearbyEvents(\n          parseFloat(lat as string),\n          parseFloat(lng as string),\n          radius ? parseFloat(radius as string) : 10\n        );\n      } else {\n        // Otherwise get all events with filters\n        const filters: any = {};\n        \n        if (category) {\n          filters.category = Array.isArray(category) ? category : [category as string];\n        }\n        \n        if (paymentType) {\n          filters.paymentType = Array.isArray(paymentType) ? paymentType : [paymentType as string];\n        }\n        \n        events = await storage.getEvents(filters);\n      }\n      \n      res.json(events);\n    } catch (error) {\n      console.error(\"Error fetching events:\", error);\n      res.status(500).json({ message: \"Error fetching events\" });\n    }\n  });\n\n  app.get(\"/api/events/:id\", async (req, res) => {\n    try {\n      const eventId = parseInt(req.params.id);\n      const event = await storage.getEventById(eventId);\n      \n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      res.json(event);\n    } catch (error) {\n      console.error(\"Error fetching event:\", error);\n      res.status(500).json({ message: \"Error fetching event\" });\n    }\n  });\n\n  app.post(\"/api/events\", isAuthenticated, (req, res, next) => {\n    // Aplicar upload como middleware con manejo de errores integrado\n    // Usamos upload.any() para aceptar cualquier campo de archivo\n    // Esto evitará el error \"Unexpected field\"\n    const uploadMiddleware = upload.any();\n    \n    uploadMiddleware(req, res, (err) => {\n      if (err) {\n        return multerErrorHandler(err, req, res, next);\n      }\n      next();\n    });\n  }, async (req, res) => {\n    try {\n      console.log(\"Creando evento. Datos recibidos:\", JSON.stringify(req.body));\n      const userId = (req.user as any).id;\n      console.log(\"Usando organizerId:\", userId);\n      \n      // Definir interfaz para los elementos multimedia\n      interface MediaItem {\n        type: string;\n        url: string;\n        order: number;\n        isMain?: boolean;\n      }\n      \n      // CORRECCIÓN DEL BUG: El error \"undefined\" ocurre cuando hay problemas \n      // al procesar los archivos o el campo mediaItems durante la creación\n      \n      // Inicializamos variables con valores por defecto seguros\n      let photoUrl = '';\n      let videoUrl = '';\n      let mediaItems: MediaItem[] = [];\n      let mainMediaType = 'photo'; // Valor por defecto seguro\n      let mainMediaUrl = '';\n      const filesByField: {[key: string]: Express.Multer.File[]} = {};\n      \n      try {\n        // Procesamos archivos subidos si existen con validación robusta\n        const files = req.files as Express.Multer.File[] || [];\n        \n        // Loguear información útil para depuración\n        console.log(\"¿Hay archivos?\", Array.isArray(files) && files.length > 0);\n        \n        if (Array.isArray(files) && files.length > 0) {\n          console.log(\"Archivos recibidos:\", files.map(f => ({\n            fieldname: f.fieldname,\n            originalname: f.originalname,\n            mimetype: f.mimetype,\n            size: f.size\n          })));\n          \n          // Agrupar archivos por fieldname para facilitar procesamiento con validación\n          files.forEach(file => {\n            if (file && file.fieldname) {\n              if (!filesByField[file.fieldname]) {\n                filesByField[file.fieldname] = [];\n              }\n              filesByField[file.fieldname].push(file);\n            }\n          });\n        } else {\n          console.log(\"No se recibieron archivos adjuntos\");\n        }\n      } catch (err) {\n        console.error(\"Error al procesar archivos:\", err);\n        // No propagamos el error, continuamos con un estado limpio\n      }\n      \n      console.log(\"Campos de archivos encontrados:\", Object.keys(filesByField).length > 0 ? Object.keys(filesByField) : \"ninguno\");\n      \n      // Procesar archivo principal (retrocompatibilidad)\n      if (filesByField.eventPhoto) {\n        const photoFile = filesByField.eventPhoto[0];\n        const photoPath = photoFile.path.replace('public', '');\n        photoUrl = photoPath; // URL relativa para el navegador\n        console.log(`Procesando eventPhoto: ${photoFile.originalname} -> ${photoPath}`);\n        \n        // Si no hay un medio principal definido, usar esta foto como principal\n        if (!mainMediaUrl) {\n          mainMediaUrl = photoPath;\n          mainMediaType = 'photo';\n          console.log(`Estableciendo eventPhoto como medio principal: ${photoPath}`);\n        }\n        \n        // No añadimos a mediaItems aquí, lo haremos mediante MediaManager\n      }\n      \n      if (filesByField.eventVideo) {\n        const videoFile = filesByField.eventVideo[0];\n        const videoPath = videoFile.path.replace('public', '');\n        videoUrl = videoPath; // URL relativa para el navegador\n        console.log(`Procesando eventVideo: ${videoFile.originalname} -> ${videoPath}`);\n        \n        // No añadimos a mediaItems aquí, lo haremos mediante MediaManager\n      }\n      \n      // Procesar fotos adicionales (retrocompatibilidad)\n      if (filesByField.photos) {\n        const photoUrls = filesByField.photos.map(file => {\n          console.log(`Procesando foto adicional: ${file.originalname}`);\n          return file.path.replace('public', '');\n        });\n        \n        // Si no hay un medio principal definido y hay fotos, usar la primera foto como principal\n        if (!mainMediaUrl && photoUrls.length > 0) {\n          mainMediaUrl = photoUrls[0];\n          mainMediaType = 'photo';\n          console.log(`Estableciendo primera foto como medio principal: ${mainMediaUrl}`);\n        }\n        \n        // No añadimos a mediaItems aquí, lo haremos mediante MediaManager\n      }\n      \n      // Procesar videos adicionales (retrocompatibilidad)\n      if (filesByField.videos) {\n        filesByField.videos.forEach(file => {\n          console.log(`Procesando video adicional: ${file.originalname}`);\n          // No añadimos a mediaItems aquí, lo haremos mediante MediaManager\n        });\n      }\n      \n      // Procesar el archivo principal especificado\n      if (filesByField.mainMediaFile) {\n        const mainFile = filesByField.mainMediaFile[0];\n        const mediaPath = mainFile.path.replace('public', '');\n        // Determinar tipo según el mimetype\n        const isVideo = mainFile.mimetype.startsWith('video/');\n        mainMediaType = isVideo ? 'video' : 'photo';\n        mainMediaUrl = mediaPath;\n        \n        console.log(\"======= ESTABLECIENDO MEDIA PRINCIPAL EXPLÍCITO =======\");\n        console.log(`ARCHIVO: ${mainFile.originalname}`);\n        console.log(`TIPO: ${mainMediaType}`);\n        console.log(`URL: ${mainMediaUrl}`);\n        console.log(`TAMAÑO: ${(mainFile.size/1024).toFixed(1)}KB`);\n        console.log(\"=====================================================\");\n      }\n      \n      // Procesar archivos de MediaManager con robusto manejo de errores y validación\n      // para evitar el error \"undefined\" cuando faltan valores\n      // Primero verificar si existe la información de mediaItems como JSON\n      if (req.body && req.body.mediaItems) {\n        try {\n          console.log(\"MediaItems JSON recibido:\", req.body.mediaItems);\n          \n          // Parse de la información de mediaItems con validación para evitar undefined\n          let mediaItemsInfo = [];\n          try {\n            mediaItemsInfo = JSON.parse(req.body.mediaItems) || [];\n            // Asegurar que es un array\n            if (!Array.isArray(mediaItemsInfo)) {\n              console.warn(\"mediaItemsInfo no es un array, usando array vacío\");\n              mediaItemsInfo = [];\n            }\n          } catch (parseError) {\n            console.error(\"Error al parsear JSON de mediaItems:\", parseError);\n            console.warn(\"Usando array vacío como valor seguro para mediaItemsInfo\");\n            mediaItemsInfo = [];\n          }\n          \n          console.log(\"MediaItems parseado:\", mediaItemsInfo);\n          \n          // Buscar archivos subidos con patrón mediaFile_X con validación para objetos undefined\n          const mediaFileKeys = Object.keys(filesByField || {})\n            .filter(key => key && typeof key === 'string' && key.startsWith('mediaFile_'));\n            \n          console.log(\"Claves de archivos multimedia encontradas:\", mediaFileKeys);\n          console.log(\"Todos los archivos recibidos:\", Object.keys(filesByField || {}));\n          \n          // Variable para rastrear el elemento principal con inicialización segura\n          let mainItemFound = false;\n          \n          if (mediaFileKeys.length > 0) {\n            console.log(`Procesando ${mediaFileKeys.length} archivos de MediaManager`);\n            \n            // No vaciamos el array de mediaItems para mantener la compatibilidad\n            // mediaItems = [];\n            \n            // Crear nueva lista mediaItems basada en los archivos subidos y la metadata\n            const newMediaItems: MediaItem[] = [];\n            \n            // Contador para validar límites\n            let photoCount = 0;\n            let videoCount = 0;\n            const MAX_PHOTOS = 6;\n            const MAX_VIDEOS = 3;\n            const MAX_PHOTO_SIZE = 5 * 1024 * 1024; // 5MB\n            const MAX_VIDEO_SIZE = 10 * 1024 * 1024; // 10MB\n            \n            // Crear un array de promesas para procesar todos los archivos\n            for (const key of mediaFileKeys) {\n              try {\n                // Acceso seguro a los archivos utilizando filesByField\n                if (!filesByField[key] || !filesByField[key][0]) {\n                  console.warn(`No se encontró archivo para ${key}`);\n                  continue;\n                }\n                \n                const file = filesByField[key][0];\n                const mediaPath = file.path.replace('public', '');\n                \n                // Extraer índice del nombre de campo (mediaFile_X)\n                const indexMatch = key.match(/mediaFile_(\\d+)/);\n                if (!indexMatch) {\n                  console.warn(`No se pudo extraer índice de ${key}`);\n                  continue;\n                }\n                \n                const index = parseInt(indexMatch[1]);\n                \n                // Determinar el tipo de archivo\n                const isVideo = file.mimetype.startsWith('video/');\n                const fileType = isVideo ? 'video' : 'photo';\n                \n                // Validar tamaño del archivo\n                const isOversize = isVideo \n                  ? file.size > MAX_VIDEO_SIZE \n                  : file.size > MAX_PHOTO_SIZE;\n                \n                if (isOversize) {\n                  console.warn(`Archivo ${key} excede el tamaño máximo permitido: ${(file.size / (1024 * 1024)).toFixed(1)}MB`);\n                  \n                  // Eliminar el archivo que excede el tamaño\n                  try {\n                    fs.unlinkSync(file.path);\n                    console.log(`Archivo sobredimensionado eliminado: ${file.path}`);\n                  } catch (unlinkError) {\n                    console.error(`Error eliminando archivo sobredimensionado: ${file.path}`, unlinkError);\n                  }\n                  \n                  continue;\n                }\n                \n                // Verificar límites por tipo\n                if (isVideo && videoCount >= MAX_VIDEOS) {\n                  console.warn(`Se excedió el límite de videos (${MAX_VIDEOS}), omitiendo ${key}`);\n                  \n                  // Eliminar el archivo excedente\n                  try {\n                    fs.unlinkSync(file.path);\n                    console.log(`Archivo excedente eliminado: ${file.path}`);\n                  } catch (unlinkError) {\n                    console.error(`Error eliminando archivo excedente: ${file.path}`, unlinkError);\n                  }\n                  \n                  continue;\n                } else if (!isVideo && photoCount >= MAX_PHOTOS) {\n                  console.warn(`Se excedió el límite de fotos (${MAX_PHOTOS}), omitiendo ${key}`);\n                  \n                  // Eliminar el archivo excedente\n                  try {\n                    fs.unlinkSync(file.path);\n                    console.log(`Archivo excedente eliminado: ${file.path}`);\n                  } catch (unlinkError) {\n                    console.error(`Error eliminando archivo excedente: ${file.path}`, unlinkError);\n                  }\n                  \n                  continue;\n                }\n                \n                // Incrementar el contador correspondiente\n                if (isVideo) {\n                  videoCount++;\n                } else {\n                  photoCount++;\n                }\n                \n                // Buscar la metadata correspondiente con validación robusta\n                let matchedMetadata = null;\n                \n                // Buscar por ID en la metadata con múltiples capas de validación\n                if (Array.isArray(mediaItemsInfo) && mediaItemsInfo.length > 0) {\n                  for (const item of mediaItemsInfo) {\n                    // Verificar que el item es un objeto válido\n                    if (item && typeof item === 'object') {\n                      // Verificar si el índice del elemento coincide con el índice del archivo\n                      // o si la propiedad id contiene el índice\n                      const hasMatchingOrder = typeof item.order === 'number' && item.order === index;\n                      const hasMatchingId = item.id && typeof item.id === 'string' && item.id.includes(`_${index}`);\n                      \n                      if (hasMatchingOrder || hasMatchingId) {\n                        matchedMetadata = item;\n                        console.log(`Encontrada metadata para archivo ${key} por ID/orden:`, matchedMetadata);\n                        break;\n                      }\n                    }\n                  }\n                  \n                  // Si no encontramos por ID, intentamos por posición en la lista con validación\n                  if (!matchedMetadata && index < mediaItemsInfo.length) {\n                    const possibleMatch = mediaItemsInfo[index];\n                    // Verificar que el elemento encontrado es un objeto válido\n                    if (possibleMatch && typeof possibleMatch === 'object') {\n                      matchedMetadata = possibleMatch;\n                      console.log(`Encontrada metadata para archivo ${key} por posición en array:`, matchedMetadata);\n                    }\n                  }\n                }\n                \n                // Si aún no tenemos metadata, creamos un objeto seguro con valores por defecto\n                if (!matchedMetadata) {\n                  console.log(`No se encontró metadata para archivo ${key}, usando valores por defecto`);\n                  matchedMetadata = {\n                    type: fileType, // Usar el tipo detectado del mimetype\n                    order: index,\n                    isMain: false\n                  };\n                }\n                \n                // Log para depuración\n                console.log(`Procesando archivo ${key} con metadata final:`, matchedMetadata);\n                \n                // Crear el objeto MediaItem con valores por defecto seguros\n                // para evitar cualquier valor undefined o null\n                const mediaItem: MediaItem = {\n                  // Usar tipo de la metadata o determinarlo por el mimetype con valor seguro\n                  type: (matchedMetadata && matchedMetadata.type) ? matchedMetadata.type : fileType,\n                  url: mediaPath,\n                  // Usar orden de la metadata o usar el índice con valor seguro\n                  order: (matchedMetadata && typeof matchedMetadata.order === 'number') ? \n                         matchedMetadata.order : index,\n                  // Usar isMain de la metadata o false por defecto con verificación estricta\n                  isMain: !!(matchedMetadata && matchedMetadata.isMain === true)\n                };\n                \n                console.log(`Media item creado: ${mediaItem.type}, isMain: ${mediaItem.isMain}, URL: ${mediaItem.url}`);\n                \n                console.log(`Procesado archivo ${key}: ${mediaItem.type}, isMain: ${mediaItem.isMain}, tamaño: ${(file.size / 1024).toFixed(1)}KB`);\n                newMediaItems.push(mediaItem);\n                \n                // Si es el elemento principal, actualizar mainMediaType y mainMediaUrl\n                if (mediaItem.isMain) {\n                  mainMediaType = mediaItem.type;\n                  mainMediaUrl = mediaItem.url;\n                  console.log(`Archivo ${key} establecido como principal: ${mainMediaType} - ${mainMediaUrl}`);\n                }\n              } catch (error) {\n                console.error(`Error procesando archivo ${key}:`, error);\n              }\n            }\n            \n            // Reemplazar mediaItems con los nuevos\n            if (newMediaItems.length > 0) {\n              // Ordenar por la propiedad order para mantener el orden especificado\n              newMediaItems.sort((a, b) => (a.order || 0) - (b.order || 0));\n              \n              // Verificar si hay un elemento principal\n              const hasMainItem = newMediaItems.some(item => item.isMain === true);\n              \n              console.log(`¿Existe elemento principal explícito? ${hasMainItem}`);\n              \n              // Si no hay elemento principal, establecer el primero como principal\n              // priorizando fotos sobre videos\n              if (!hasMainItem && newMediaItems.length > 0) {\n                const firstPhoto = newMediaItems.find(item => item.type === 'photo');\n                const itemToSetMain = firstPhoto || newMediaItems[0];\n                \n                itemToSetMain.isMain = true;\n                mainMediaType = itemToSetMain.type;\n                mainMediaUrl = itemToSetMain.url;\n                \n                console.log(`Estableciendo elemento principal automáticamente: ${mainMediaType} - ${mainMediaUrl}`);\n              } else if (hasMainItem) {\n                // Obtener el elemento principal explícito\n                const mainItem = newMediaItems.find(item => item.isMain === true);\n                if (mainItem) {\n                  mainMediaType = mainItem.type;\n                  mainMediaUrl = mainItem.url;\n                  console.log(`Usando elemento principal explícito: ${mainMediaType} - ${mainMediaUrl}`);\n                }\n              }\n              \n              // Simplificamos el procesamiento de los archivos multimedia\n              \n              // Reemplazamos completamente los mediaItems con los nuevos elementos\n              // Esto evita la duplicación de archivos\n              mediaItems = newMediaItems;\n              console.log(\"Reemplazando mediaItems con los nuevos elementos procesados\");\n              \n              console.log(`Total de elementos multimedia: ${mediaItems.length} (incluyendo ${newMediaItems.length} nuevos)`);\n              console.log(`Composición: ${mediaItems.filter(i => i.type === 'photo').length} fotos, ${mediaItems.filter(i => i.type === 'video').length} videos`);\n            }\n          }\n        } catch (error) {\n          console.error(\"Error procesando mediaItems JSON:\", error);\n        }\n      }\n      \n      // Verificar si tenemos elementos multimedia antes de continuar\n      console.log(\"Estado final de los mediaItems antes de guardar:\", \n        mediaItems.map(item => ({\n          tipo: item.type,\n          url: item.url,\n          orden: item.order || 0,\n          principal: item.isMain || false\n        }))\n      );\n      \n      // Verificar estado de los medios principales\n      console.log(\"Media principal:\", {\n        mainMediaType,\n        mainMediaUrl\n      });\n      \n      // Convertir mediaItems a JSON string\n      const mediaItemsJson = JSON.stringify(mediaItems);\n      \n      try {\n        const validatedData = insertEventSchema.parse({\n          ...req.body,\n          organizerId: userId,\n          // Añadir URLs de los archivos (mantener por compatibilidad)\n          photoUrl: photoUrl || req.body.photoUrl || null,\n          videoUrl: videoUrl || req.body.videoUrl || null,\n          // Nuevos campos multimedia\n          mediaItems: mediaItemsJson,\n          mainMediaType: mainMediaType,\n          mainMediaUrl: mainMediaUrl\n        });\n        console.log(\"Datos validados:\", JSON.stringify(validatedData));\n        \n        const event = await storage.insertEvent(validatedData);\n        console.log(\"Evento creado con éxito:\", JSON.stringify(event));\n        res.status(201).json(event);\n      } catch (validationError) {\n        console.error(\"Error de validación:\", validationError);\n        // Si hay error, eliminar los archivos subidos\n        // Con upload.any() ya no tenemos acceso a los archivos así\n        // Eliminamos los archivos por el array filesByField\n        if (filesByField.eventPhoto && filesByField.eventPhoto.length > 0) {\n          try {\n            fs.unlinkSync(filesByField.eventPhoto[0].path);\n          } catch (err) {\n            console.error(\"Error al eliminar archivo:\", err);\n          }\n        }\n        if (filesByField.eventVideo && filesByField.eventVideo.length > 0) {\n          try {\n            fs.unlinkSync(filesByField.eventVideo[0].path);\n          } catch (err) {\n            console.error(\"Error al eliminar archivo:\", err);\n          }\n        }\n        \n        if (validationError instanceof z.ZodError) {\n          return res.status(400).json({ errors: validationError.errors });\n        }\n        throw validationError;\n      }\n    } catch (error) {\n      console.error(\"Error completo al crear evento:\", error);\n      \n      // Check if this is a foreign key constraint error\n      if (error instanceof Error && \n          error.toString().includes(\"violates foreign key constraint\") &&\n          error.toString().includes(\"events_organizer_id_users_id_fk\")) {\n        return res.status(401).json({ \n          message: \"You need to sign up and log in before creating an event\",\n          code: \"USER_NOT_FOUND\"\n        });\n      }\n      \n      res.status(500).json({ message: \"Error creating event\", error: String(error) });\n    }\n  });\n\n  // Ruta PUT para actualización básica sin archivos\n  app.put(\"/api/events/:id\", isAuthenticated, async (req, res) => {\n    try {\n      // Debug: Qué contiene la solicitud PUT\n      console.log(\"===== DATOS RECIBIDOS EN PUT =====\");\n      console.log(\"Content-Type:\", req.get('Content-Type'));\n      console.log(\"Headers:\", JSON.stringify(req.headers, null, 2));\n      console.log(\"Body keys:\", Object.keys(req.body));\n      \n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      // Check if event exists\n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      // Check if user is the organizer\n      if (event.organizerId !== user.id) {\n        return res.status(403).json({ message: \"Not authorized to update this event\" });\n      }\n      \n      // Create a copy of the request body for updating\n      const updateData = { ...req.body };\n      \n      // Procesar la fecha correctamente si existe\n      if (updateData.date) {\n        try {\n          // Convertir la fecha a un objeto Date apropiado\n          updateData.date = new Date(updateData.date);\n          console.log(\"Date converted to:\", updateData.date);\n        } catch (error) {\n          console.error(\"Error converting date:\", error);\n          return res.status(400).json({ message: \"Invalid date format\" });\n        }\n      }\n      \n      // Procesar mediaItems si existen para actualizar mainMediaType y mainMediaUrl\n      if (updateData.mediaItems) {\n        console.log(\"Actualizando evento en la base de datos. ID:\", eventId);\n        console.log(\"Datos de multimedia a guardar:\");\n        console.log(\"- mediaItems:\", updateData.mediaItems);\n        console.log(\"- mainMediaType:\", updateData.mainMediaType);\n        console.log(\"- mainMediaUrl:\", updateData.mainMediaUrl);\n        \n        try {\n          // Convertir mediaItems de string a objeto JSON si es necesario\n          let mediaItems = updateData.mediaItems;\n          if (typeof mediaItems === 'string') {\n            mediaItems = JSON.parse(mediaItems);\n          }\n          \n          // Buscar el elemento principal\n          const mainItem = Array.isArray(mediaItems) ? \n            mediaItems.find(item => item && item.isMain === true) : null;\n          \n          // Si hay un elemento principal, actualizar mainMediaType y mainMediaUrl\n          if (mainItem) {\n            updateData.mainMediaType = mainItem.type;\n            updateData.mainMediaUrl = mainItem.url;\n            console.log(\"Elemento principal encontrado y actualizado:\", {\n              type: mainItem.type,\n              url: mainItem.url\n            });\n          } else if (Array.isArray(mediaItems) && mediaItems.length > 0) {\n            // Si no hay elemento principal pero hay elementos, usar el primero\n            updateData.mainMediaType = mediaItems[0].type;\n            updateData.mainMediaUrl = mediaItems[0].url;\n            console.log(\"Usando primer elemento como principal por defecto:\", {\n              type: mediaItems[0].type,\n              url: mediaItems[0].url\n            });\n          }\n        } catch (error) {\n          console.error(\"Error procesando mediaItems:\", error);\n        }\n        \n        // Verificación después de actualizar\n        console.log(\"Verificación después de actualizar:\");\n        console.log(\"- mediaItems almacenados:\", updateData.mediaItems);\n        console.log(\"- mainMediaType almacenado:\", updateData.mainMediaType);\n        console.log(\"- mainMediaUrl almacenado:\", updateData.mainMediaUrl);\n      }\n      \n      // Obtener evento original para comparar medios\n      const originalEvent = await storage.getEventById(eventId);\n      \n      // Detectar si hay cambios en los medios\n      let mediaChanged = false;\n      \n      if (originalEvent) {\n        // Verificar cambios en URL de medio principal o tipo\n        if (originalEvent.mainMediaUrl !== updateData.mainMediaUrl || \n            originalEvent.mainMediaType !== updateData.mainMediaType) {\n          mediaChanged = true;\n          console.log(\"Cambio detectado en medio principal:\");\n          console.log(`- Original: ${originalEvent.mainMediaType} - ${originalEvent.mainMediaUrl}`);\n          console.log(`- Nuevo: ${updateData.mainMediaType} - ${updateData.mainMediaUrl}`);\n        }\n        \n        // Verificar cambios en la colección de medios\n        try {\n          const originalMediaItems = originalEvent.mediaItems ? JSON.parse(originalEvent.mediaItems) : [];\n          const newMediaItems = typeof updateData.mediaItems === 'string' \n            ? JSON.parse(updateData.mediaItems) \n            : updateData.mediaItems;\n            \n          if (JSON.stringify(originalMediaItems) !== JSON.stringify(newMediaItems)) {\n            mediaChanged = true;\n            console.log(\"Cambio detectado en colección de medios\");\n          }\n        } catch (error) {\n          console.error(\"Error comparando mediaItems:\", error);\n        }\n      }\n      \n      // Update event\n      const updatedEvent = await storage.updateEvent(eventId, updateData);\n      console.log(\"Evento actualizado correctamente.\");\n      console.log(`¿Hubo cambios en los medios? ${mediaChanged ? 'SÍ' : 'NO'}`);\n      \n      // Broadcast event update to all connected clients via WebSocket\n      broadcastMessage({\n        type: 'event_updated',\n        event: updatedEvent,\n        updatedBy: user.id  // Agregar el ID del usuario que realizó la actualización\n      });\n      \n      // Si se actualizó el medio principal, envía un mensaje específico para esto\n      if (mediaChanged) {\n        broadcastMessage({\n          type: 'event_media_updated',\n          eventId: updatedEvent.id,\n          updatedBy: user.id\n        });\n      }\n      \n      console.log(\"Notificación de actualización de evento enviada a todos los clientes WebSocket\");\n      \n      res.json(updatedEvent);\n    } catch (error) {\n      console.error(\"Error updating event:\", error);\n      res.status(500).json({ message: \"Error updating event\" });\n    }\n  });\n  \n  // Ruta PATCH para actualización con archivos\n  app.patch(\"/api/events/:id\", isAuthenticated, (req, res, next) => {\n    // Aplicar upload como middleware con manejo de errores integrado\n    const uploadMiddleware = upload.fields([\n      { name: 'eventPhoto', maxCount: 1 }, // Mantener para compatibilidad\n      { name: 'eventVideo', maxCount: 1 }, // Mantener para compatibilidad\n      { name: 'photos', maxCount: 6 },  // Permitir hasta 6 fotos en total\n      { name: 'videos', maxCount: 3 },  // Permitir hasta 3 videos en total\n      { name: 'mainMedia', maxCount: 1 }, // Archivo principal (puede ser foto o video)\n      { name: 'mainMediaFile', maxCount: 1 }, // Archivo principal (nuevo nombre usado en el frontend)\n      // Nuevos campos para MediaManager\n      { name: 'mediaFile_0', maxCount: 1 },\n      { name: 'mediaFile_1', maxCount: 1 },\n      { name: 'mediaFile_2', maxCount: 1 },\n      { name: 'mediaFile_3', maxCount: 1 },\n      { name: 'mediaFile_4', maxCount: 1 },\n      { name: 'mediaFile_5', maxCount: 1 },\n      { name: 'mediaFile_6', maxCount: 1 },\n      { name: 'mediaFile_7', maxCount: 1 },\n      { name: 'mediaFile_8', maxCount: 1 },\n      { name: 'mediaFile_9', maxCount: 1 }\n    ]);\n    \n    uploadMiddleware(req, res, (err) => {\n      if (err) {\n        return multerErrorHandler(err, req, res, next);\n      }\n      next();\n    });\n  }, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      // Check if event exists\n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      // Check if user is the organizer\n      if (event.organizerId !== user.id) {\n        return res.status(403).json({ message: \"Not authorized to update this event\" });\n      }\n      \n      // Procesar archivos subidos\n      const files = req.files as { [fieldname: string]: Express.Multer.File[] };\n      \n      // Datos para actualizar\n      const updateData: any = { ...req.body };\n      \n      // Procesar la fecha correctamente si existe\n      if (updateData.date) {\n        try {\n          // Convertir la fecha a un objeto Date apropiado\n          updateData.date = new Date(updateData.date);\n          console.log(\"Date converted to:\", updateData.date);\n        } catch (error) {\n          console.error(\"Error converting date:\", error);\n          return res.status(400).json({ message: \"Invalid date format\" });\n        }\n      }\n      \n      // Definir interfaz para los elementos multimedia\n      interface MediaItem {\n        type: string;\n        url: string;\n        order: number;\n        isMain?: boolean;\n      }\n      \n      // Definir interfaces para la información de medios\n      interface MediaItemInfo {\n        id?: string;\n        type: string;\n        url?: string;\n        isMain?: boolean;\n        isNew?: boolean;\n        fileIndex?: number;\n        order?: number;\n        deleted?: boolean;\n        toDelete?: boolean;\n      }\n      \n      // Definir array para almacenar los elementos multimedia\n      let mediaItems: MediaItem[] = [];\n      let mainMediaType = req.body.mainMediaType || 'photo';\n      let mainMediaUrl = req.body.mainMediaUrl || '';\n      \n      // Parsear información de elementos multimedia si existe\n      let mediaItemsInfo: MediaItemInfo[] = [];\n      if (req.body.mediaItemsInfo) {\n        try {\n          mediaItemsInfo = JSON.parse(req.body.mediaItemsInfo);\n          console.log(\"Información de elementos multimedia:\", mediaItemsInfo);\n        } catch (e) {\n          console.warn(\"Error al parsear mediaItemsInfo:\", e);\n          mediaItemsInfo = [];\n        }\n      }\n      \n      // Si ya hay elementos multimedia en la base de datos, cargarlos\n      if (event.mediaItems) {\n        try {\n          mediaItems = JSON.parse(event.mediaItems);\n        } catch (e) {\n          console.warn(\"No se pudo parsear mediaItems del evento:\", e);\n          // Inicializar como array vacío si hay error\n          mediaItems = [];\n        }\n      }\n      \n      // Verificar si el usuario quiere eliminar archivos existentes\n      if (req.body.resetMedia === 'true' || req.body.resetMedia === true) {\n        mediaItems = []; // Eliminar todos los archivos multimedia existentes\n        mainMediaUrl = ''; // Resetear el medio principal\n      }\n      \n      // Procesar elementos marcados para eliminar\n      const itemsToDelete = mediaItemsInfo.filter(info => info.url && (info.toDelete || info.deleted));\n      \n      if (itemsToDelete.length > 0) {\n        console.log(`Se encontraron ${itemsToDelete.length} elementos marcados para eliminar`);\n        \n        // Filtrar mediaItems para excluir los elementos marcados para eliminación\n        mediaItems = mediaItems.filter(item => {\n          // Verificar si este item coincide con alguno marcado para eliminar\n          const shouldDelete = itemsToDelete.some(\n            deleteItem => deleteItem.url === item.url && deleteItem.type === item.type\n          );\n          \n          // Si se va a eliminar el medio principal, resetear mainMediaUrl\n          if (shouldDelete && item.url === mainMediaUrl) {\n            console.log(`Eliminando el medio principal actual: ${item.url}`);\n            mainMediaUrl = '';\n            mainMediaType = 'photo'; // Default to photo to avoid enum error\n          }\n          \n          // Devolver true para mantener, false para eliminar\n          return !shouldDelete;\n        });\n        \n        console.log(`Quedan ${mediaItems.length} elementos multimedia después de eliminar los marcados`);\n      }\n      \n      // Si aún hay elementos multimedia después de las eliminaciones, \n      // asegurarse de que haya un elemento principal si el anterior fue eliminado\n      if (mediaItems.length > 0 && !mainMediaUrl) {\n        // Buscar algún elemento marcado como principal\n        const mainItem = mediaItems.find(item => item.isMain);\n        \n        if (mainItem) {\n          // Usar el elemento que ya está marcado como principal\n          mainMediaUrl = mainItem.url;\n          mainMediaType = mainItem.type;\n          console.log(`Usando elemento marcado como principal: ${mainItem.url}`);\n        } else {\n          // Si no hay ninguno, usar el primer elemento disponible\n          mainMediaUrl = mediaItems[0].url;\n          mainMediaType = mediaItems[0].type;\n          mediaItems[0].isMain = true; // Marcar como principal\n          console.log(`Estableciendo nuevo elemento principal por defecto: ${mainMediaUrl}`);\n        }\n      }\n      \n      // Procesar la foto principal (mantener por compatibilidad)\n      if (files.eventPhoto && files.eventPhoto.length > 0) {\n        const photoPath = files.eventPhoto[0].path.replace('public', '');\n        updateData.photo_url = photoPath;\n        \n        // Añadir a mediaItems si no existe ya\n        if (!mediaItems.some(item => item.url === photoPath)) {\n          mediaItems.push({ type: 'photo', url: photoPath, order: mediaItems.length });\n        }\n        \n        // Si no hay media principal o se solicitó resetear, usar esta foto\n        if (!mainMediaUrl || req.body.resetMedia) {\n          mainMediaUrl = photoPath;\n          mainMediaType = 'photo';\n        }\n      }\n      \n      // Procesar el video principal (mantener por compatibilidad)\n      if (files.eventVideo && files.eventVideo.length > 0) {\n        const videoPath = files.eventVideo[0].path.replace('public', '');\n        updateData.video_url = videoPath;\n        \n        // Añadir a mediaItems si no existe ya\n        if (!mediaItems.some(item => item.url === videoPath)) {\n          mediaItems.push({ type: 'video', url: videoPath, order: mediaItems.length });\n        }\n      }\n      \n      // Procesar fotos adicionales (hasta 6 en total)\n      if (files.photos && files.photos.length > 0) {\n        const photoUrls = files.photos.map(file => file.path.replace('public', ''));\n        console.log(`Procesando ${photoUrls.length} nuevas fotos subidas`);\n        \n        // Buscar elementos marcados como principales en la información\n        // Tanto archivos existentes como nuevos\n        const mainPhotoInfo = mediaItemsInfo.find(info => \n          info.isMain && info.isNew && info.type === 'photo'\n        );\n        \n        console.log(\"Info de fotos principales:\", mainPhotoInfo ? JSON.stringify(mainPhotoInfo) : \"ninguna\");\n          \n        // Añadir a la lista de medios\n        photoUrls.forEach((url, index) => {\n          if (!mediaItems.some(item => item.url === url)) {\n            // Verificar si este elemento debe ser el principal\n            // Si se ha marcado explícitamente este archivo nuevo como principal\n            // o si no hay un medio principal definido y este es el primer elemento\n            let isPhotoMain = false;\n            \n            // Revisar si este archivo está marcado como principal en la info\n            if (mainPhotoInfo) {\n              // Compara el índice del archivo con el que está en la información\n              isPhotoMain = mainPhotoInfo.fileIndex === index;\n              console.log(`Verificando si foto ${index} es principal según mainPhotoInfo: ${isPhotoMain}`);\n            } else if (!mainMediaUrl && mediaItems.length === 0) {\n              // Si no hay principal definido, usar el primer elemento\n              isPhotoMain = true;\n              console.log(`Estableciendo foto ${index} como principal por defecto (primera foto)`);\n            }\n            \n            // Añadir el elemento a la lista\n            mediaItems.push({ \n              type: 'photo', \n              url, \n              order: mediaItems.length, // Asignar orden secuencial\n              isMain: isPhotoMain\n            });\n            \n            // Si es principal, actualizar las variables de control\n            if (isPhotoMain) {\n              mainMediaUrl = url;\n              mainMediaType = 'photo';\n              console.log(`Estableciendo nueva foto subida como principal: ${url}`);\n              \n              // Asegurarse de que ningún otro elemento sea principal\n              mediaItems.forEach(item => {\n                if (item.url !== url) {\n                  item.isMain = false;\n                }\n              });\n            }\n          }\n        });\n        \n        // Si después de todo el proceso no hay un medio principal definido \n        // y hay fotos nuevas, usar la primera foto como principal\n        if (!mainMediaUrl && photoUrls.length > 0) {\n          mainMediaUrl = photoUrls[0];\n          mainMediaType = 'photo';\n          \n          // Actualizar el indicador isMain en el array de medios\n          const firstPhotoIndex = mediaItems.findIndex(item => \n            item.type === 'photo' && item.url === photoUrls[0]\n          );\n          \n          if (firstPhotoIndex >= 0) {\n            // Marcar el primer elemento como principal\n            mediaItems.forEach((item, idx) => {\n              item.isMain = idx === firstPhotoIndex;\n            });\n          }\n          \n          console.log(`Estableciendo nueva foto como principal (último recurso): ${mainMediaUrl}`);\n        }\n      }\n      \n      // Procesar videos adicionales (hasta 3 en total)\n      if (files.videos && files.videos.length > 0) {\n        const videoUrls = files.videos.map(file => file.path.replace('public', ''));\n        console.log(`Procesando ${videoUrls.length} nuevos videos subidos`);\n        \n        // Obtener información sobre cuál video debe ser el principal (si hay)\n        const mainVideoInfo = mediaItemsInfo.find(info => \n          info.isMain && info.isNew && info.type === 'video'\n        );\n        \n        console.log(\"Info de videos principales:\", mainVideoInfo ? JSON.stringify(mainVideoInfo) : \"ninguna\");\n        \n        // Añadir a la lista de medios\n        videoUrls.forEach((url, index) => {\n          if (!mediaItems.some(item => item.url === url)) {\n            // Verificar si este elemento debe ser el principal\n            let isVideoMain = false;\n            \n            // Revisar si este archivo está marcado como principal en la info\n            if (mainVideoInfo) {\n              // Compara el índice del archivo con el que está en la información\n              isVideoMain = mainVideoInfo.fileIndex === index;\n              console.log(`Verificando si video ${index} es principal según mainVideoInfo: ${isVideoMain}`);\n            } else if (!mainMediaUrl && mediaItems.length === 0) {\n              // Si no hay principal definido, usar el primer elemento\n              isVideoMain = true;\n              console.log(`Estableciendo video ${index} como principal por defecto (primer video)`);\n            }\n              \n            mediaItems.push({ \n              type: 'video', \n              url, \n              order: mediaItems.length, // Asignar orden secuencial\n              isMain: isVideoMain\n            });\n            \n            // Si es principal, actualizar las variables de control\n            if (isVideoMain) {\n              mainMediaUrl = url;\n              mainMediaType = 'video';\n              console.log(`Estableciendo nuevo video subido como principal: ${url}`);\n              \n              // Asegurarse de que ningún otro elemento sea principal\n              mediaItems.forEach(item => {\n                if (item.url !== url) {\n                  item.isMain = false;\n                }\n              });\n            }\n          }\n        });\n        \n        // Si después de todo el proceso no hay un medio principal definido \n        // y hay videos nuevos, usar el primer video como principal\n        if (!mainMediaUrl && videoUrls.length > 0) {\n          mainMediaUrl = videoUrls[0];\n          mainMediaType = 'video';\n          \n          // Actualizar el indicador isMain en el array de medios\n          const firstVideoIndex = mediaItems.findIndex(item => \n            item.type === 'video' && item.url === videoUrls[0]\n          );\n          \n          if (firstVideoIndex >= 0) {\n            // Marcar el primer elemento como principal\n            mediaItems.forEach((item, idx) => {\n              item.isMain = idx === firstVideoIndex;\n            });\n          }\n          \n          console.log(`Estableciendo nuevo video como principal (último recurso): ${mainMediaUrl}`);\n        }\n      }\n      \n      // Procesar mediaItems JSON enviado directamente desde el cliente\n      if (req.body.mediaItems) {\n        try {\n          console.log(\"=== PROCESANDO MEDIA ITEMS DEL CLIENTE ===\");\n          console.log(\"JSON recibido:\", req.body.mediaItems);\n          \n          // Parsear el JSON enviado por el cliente\n          let clientMediaItems = [];\n          try {\n            clientMediaItems = JSON.parse(req.body.mediaItems);\n            console.log(`Elementos multimedia recibidos: ${clientMediaItems.length}`);\n          } catch (parseError) {\n            console.error(\"Error al parsear mediaItems:\", parseError);\n            clientMediaItems = [];\n          }\n          \n          // DETECCIÓN DE PROBLEMA CRÍTICO: Verificar si hay medios existentes y el cliente envía array vacío\n          // Este es un patrón común cuando se edita el evento modificando sólo campos básicos\n          let preservingExistingMedia = false;\n          \n          if (mediaItems.length > 0 && \n              (clientMediaItems.length === 0 || \n               !clientMediaItems.some((item: any) => item && item.url))) {\n            \n            console.log(\"⚠️ CASO ESPECIAL DETECTADO: El cliente envió un array vacío o sin elementos válidos\");\n            console.log(`⚠️ El evento ya tiene ${mediaItems.length} elementos multimedia existentes`);\n            console.log(\"🔒 PRESERVANDO los elementos multimedia existentes:\");\n            console.log(JSON.stringify(mediaItems));\n            \n            // IMPORTANTE: Marcar que estamos preservando medios existentes\n            preservingExistingMedia = true;\n            \n            // Asegurar que haya un elemento principal\n            const currentMainItem = mediaItems.find(item => item.isMain);\n            if (!currentMainItem && mediaItems.length > 0) {\n              // Si no hay un elemento principal, establecer el primero como principal\n              mediaItems[0].isMain = true;\n              mainMediaUrl = mediaItems[0].url;\n              mainMediaType = mediaItems[0].type;\n              console.log(`✅ Estableciendo primer elemento como principal: ${mainMediaType} - ${mainMediaUrl}`);\n            } else if (currentMainItem) {\n              // Asegurar que las variables principales estén sincronizadas\n              mainMediaUrl = currentMainItem.url;\n              mainMediaType = currentMainItem.type;\n              console.log(`✅ Sincronizando con elemento principal existente: ${mainMediaType} - ${mainMediaUrl}`);\n            }\n          }\n          \n          // Solo procesar los mediaItems del cliente si no estamos preservando los existentes\n          if (!preservingExistingMedia && Array.isArray(clientMediaItems)) {\n            // MEJORA CRÍTICA: Verificar primero si hay un elemento explícitamente marcado como principal\n            const explicitMainItem = clientMediaItems.find((item: any) => \n              item && item.isMain === true && !item.toDelete && !item.deleted\n            );\n            \n            if (explicitMainItem) {\n              console.log(\"DETECTADO ELEMENTO EXPLÍCITAMENTE MARCADO COMO PRINCIPAL:\", {\n                tipo: explicitMainItem.type || \"desconocido\",\n                url: explicitMainItem.url || \"sin URL\"\n              });\n            } else {\n              console.log(\"No se encontró un elemento explícitamente marcado como principal\");\n            }\n            // PASO 1: Identificar elementos explícitamente marcados para eliminación\n            const itemsToDelete = clientMediaItems\n              .filter((item: any) => {\n                // Verificar cada item minuciosamente\n                if (!item || !item.url) return false;\n                \n                // Comprobar si está marcado explícitamente para eliminar\n                const markedForDeletion = item.toDelete === true || item.deleted === true;\n                \n                // Registrar cada elemento marcado para eliminar\n                if (markedForDeletion) {\n                  console.log(`Elemento marcado para eliminación: ${item.type} - ${item.url}`);\n                }\n                \n                return markedForDeletion;\n              });\n              \n              // Registrar cuántos elementos se marcarán para eliminación\n              if (itemsToDelete.length > 0) {\n                console.log(`Se han marcado ${itemsToDelete.length} elementos para eliminación`);\n              }\n              \n              // Lista de URLs a eliminar para filtrado más sencillo\n              const urlsToDelete = itemsToDelete.map((item: any) => item.url);\n              console.log(`URLs a eliminar: [${urlsToDelete.join(', ')}]`);\n              \n              // Guardar una copia de los mediaItems actuales antes de procesarlos\n              // Esto nos permitirá preservar los que son nuevos subidos en esta misma petición\n              const existingMediaItems = [...mediaItems];\n              \n              // Crear un nuevo array para almacenar los mediaItems actualizados\n              const updatedMediaItems: MediaItem[] = [];\n              \n              // Lista de URLs de elementos que vienen del cliente para evitar duplicados\n              const clientUrls = clientMediaItems\n                .filter((item: any) => item && item.url && !item.toDelete && !item.deleted)\n                .map((item: any) => item.url);\n              \n              // Primero, agregar los archivos recién subidos que no están en el mediaItems del cliente\n              // y que no están marcados para eliminación\n              const newlyUploadedItems = existingMediaItems.filter(item => \n                !clientUrls.includes(item.url) && !urlsToDelete.includes(item.url));\n              \n              if (newlyUploadedItems.length > 0) {\n                console.log(`Preservando ${newlyUploadedItems.length} elementos recién subidos que no están en mediaItems del cliente`);\n                updatedMediaItems.push(...newlyUploadedItems);\n              }\n              \n              // MEJORA: Verificar si algún elemento del cliente está marcado como principal\n              const hasClientMainItem = clientMediaItems.some((item: any) => \n                item && item.isMain === true && !item.toDelete && !item.deleted\n              );\n              \n              console.log(\"¿Hay un elemento principal explícito en mediaItems del cliente?\", hasClientMainItem);\n              \n              // Procesar los elementos enviados por el cliente\n              clientMediaItems.forEach((item: { \n                type: string; \n                url?: string; \n                isMain?: boolean;\n                order?: number; \n                toDelete?: boolean;\n                deleted?: boolean;\n              }, index: number) => {\n                // Verificar si el elemento está marcado para eliminación\n                const shouldRemove = item.toDelete === true || item.deleted === true;\n                \n                // Solo procesar elementos que no están marcados para eliminación y tienen URL\n                if (item.url && !shouldRemove) {\n                  // MEJORA: Mantener el flag isMain exactamente como viene del cliente\n                  // sin normalizar a booleano en este punto para preservar mejor la selección\n                  const mediaItem = {\n                    type: item.type || 'photo',\n                    url: item.url,\n                    order: item.order !== undefined ? item.order : index + newlyUploadedItems.length,\n                    isMain: item.isMain === true  // Preservar la selección explícita\n                  };\n                  \n                  // Agregar al array de mediaItems\n                  updatedMediaItems.push(mediaItem);\n                  \n                  // Si este ítem está marcado como principal, actualizar los valores principales\n                  if (item.isMain === true) {\n                    mainMediaUrl = item.url;\n                    mainMediaType = item.type || 'photo';\n                    console.log(`Estableciendo media principal desde cliente: ${mainMediaType} - ${mainMediaUrl}`);\n                  }\n                } else if (item.url && shouldRemove) {\n                  console.log(`ELIMINANDO elemento: ${item.type} - ${item.url}`);\n                  \n                  // Si el elemento eliminado era el principal, registrarlo\n                  if (item.isMain) {\n                    console.log(`¡ATENCIÓN! Se está eliminando el elemento principal: ${item.url}`);\n                  }\n                }\n              });\n              \n              // Actualizar mediaItems con los elementos que han sido procesados (excluyendo los eliminados)\n              mediaItems = updatedMediaItems;\n            }\n          }\n        } catch (error) {\n          console.error(\"Error al procesar mediaItems JSON:\", error);\n        }\n      }\n      \n      // Verificar si mainMediaUrl sigue siendo válido (podría haber sido eliminado)\n      if (mainMediaUrl) {\n        const mainMediaExists = mediaItems.some(item => item.url === mainMediaUrl);\n        if (!mainMediaExists) {\n          console.log(`El media principal ${mainMediaUrl} ya no existe, estableciendo uno nuevo`);\n          \n          // Intentar encontrar un nuevo elemento principal (preferiblemente foto)\n          const firstPhoto = mediaItems.find(item => item.type === 'photo');\n          if (firstPhoto) {\n            mainMediaUrl = firstPhoto.url;\n            mainMediaType = 'photo';\n            \n            // Actualizar la propiedad isMain en los elementos\n            mediaItems.forEach(item => {\n              item.isMain = item.url === mainMediaUrl;\n            });\n            \n            console.log(`Nuevo media principal establecido: ${mainMediaType} - ${mainMediaUrl}`);\n          } else if (mediaItems.length > 0) {\n            // Si no hay fotos, usar el primer elemento disponible\n            mainMediaUrl = mediaItems[0].url;\n            mainMediaType = mediaItems[0].type;\n            mediaItems[0].isMain = true;\n            \n            console.log(`Nuevo media principal (no foto) establecido: ${mainMediaType} - ${mainMediaUrl}`);\n          } else {\n            // No hay elementos multimedia\n            mainMediaUrl = '';\n            mainMediaType = 'photo'; // Default to photo to avoid enum error\n            console.log('No hay elementos multimedia disponibles para establecer como principal');\n          }\n        }\n      }\n      \n      console.log(`Procesados ${mediaItems.length} elementos multimedia en total (incluidos archivos nuevos)`);\n      \n      // Procesar el archivo principal especificado (subido como archivo)\n      if (files.mainMediaFile && files.mainMediaFile.length > 0) {\n        const mediaPath = files.mainMediaFile[0].path.replace('public', '');\n        // Determinar tipo según el mimetype\n        const isVideo = files.mainMediaFile[0].mimetype.startsWith('video/');\n        mainMediaType = isVideo ? 'video' : 'photo';\n        mainMediaUrl = mediaPath;\n        \n        console.log(`Archivo principal subido: ${mainMediaType} - ${mainMediaUrl}`);\n        \n        // Asegurarse de que está en mediaItems\n        if (!mediaItems.some(item => item.url === mediaPath)) {\n          // Crear un nuevo elemento multimedia para el archivo principal\n          const mainMediaItem = { \n            type: mainMediaType, \n            url: mediaPath, \n            order: mediaItems.length,\n            isMain: true\n          };\n          \n          // Agregarlo a mediaItems\n          mediaItems.push(mainMediaItem);\n          console.log(`Agregado nuevo archivo principal a mediaItems: ${mainMediaType} - ${mediaPath}`);\n        } else {\n          // Actualizar el elemento existente para marcarlo como principal\n          // Mantenemos todos los demás elementos, pero actualizamos el isMain\n          mediaItems = mediaItems.map(item => ({\n            ...item,\n            isMain: item.url === mediaPath,\n            // Asegurar que el tipo coincida si es el elemento principal\n            type: item.url === mediaPath ? mainMediaType : item.type\n          }));\n          console.log(`Actualizado elemento existente como principal: ${mainMediaType} - ${mediaPath}`);\n        }\n      } else if (req.body.mainMediaUrl) {\n        // Permitir establecer un medio existente como principal\n        mainMediaUrl = req.body.mainMediaUrl;\n        mainMediaType = req.body.mainMediaType || 'photo';\n        \n        console.log(`Estableciendo medio existente como principal: ${mainMediaType} - ${mainMediaUrl}`);\n        \n        // Actualizar mediaItems para reflejar el cambio de elemento principal\n        mediaItems = mediaItems.map(item => ({\n          ...item,\n          isMain: item.url === mainMediaUrl,\n          // Asegurar que el tipo coincida si es el elemento principal\n          type: item.url === mainMediaUrl ? mainMediaType : item.type\n        }));\n      }\n      \n      // Verificar coherencia: asegurar que si hay mainMediaUrl, también hay mainMediaType\n      if (mainMediaUrl && !mainMediaType) {\n        // Determinar el tipo basado en la extensión del archivo\n        const isVideoExt = /\\.(mp4|mov|avi|wmv|flv|webm)$/i.test(mainMediaUrl);\n        mainMediaType = isVideoExt ? 'video' : 'photo';\n        console.log(`Corrigiendo tipo de medio principal: ${mainMediaType} para ${mainMediaUrl}`);\n      }\n      \n      // Y viceversa: si no hay URL principal, no debería haber tipo\n      if (!mainMediaUrl && mainMediaType) {\n        console.log(`Corrigiendo inconsistencia: mainMediaType establecido (${mainMediaType}) pero no hay mainMediaUrl`);\n        \n        // Si hay al menos un elemento multimedia, usar el primero como principal\n        if (mediaItems.length > 0) {\n          // Buscar algún elemento que ya esté marcado como principal\n          const mainItem = mediaItems.find(item => item.isMain === true);\n          \n          if (mainItem) {\n            // Usar el elemento marcado como principal\n            mainMediaUrl = mainItem.url;\n            mainMediaType = mainItem.type;\n            console.log(`Usando elemento marcado como principal: ${mainMediaType} - ${mainMediaUrl}`);\n          } else {\n            // Si ninguno está marcado, usar el primero\n            mainMediaUrl = mediaItems[0].url;\n            mainMediaType = mediaItems[0].type;\n            console.log(`Usando primer elemento como principal: ${mainMediaType} - ${mainMediaUrl}`);\n            \n            // Actualizar el isMain en mediaItems\n            mediaItems = mediaItems.map((item, index) => ({\n              ...item,\n              isMain: index === 0\n            }));\n          }\n        } else {\n          // No hay elementos multimedia, usamos un tipo por defecto para evitar errores de enum\n          mainMediaType = 'photo'; // Default to photo to avoid enum error\n        }\n      }\n      \n      // Reorganizar elementos basados en el campo order\n      mediaItems.sort((a, b) => {\n        // Si el orden no está definido, considerar como último\n        const orderA = a.order !== undefined ? a.order : Number.MAX_SAFE_INTEGER;\n        const orderB = b.order !== undefined ? b.order : Number.MAX_SAFE_INTEGER;\n        return orderA - orderB;\n      });\n      \n      // Reasignar órdenes para asegurar consistencia\n      mediaItems = mediaItems.map((item, index) => ({\n        ...item,\n        order: index\n      }));\n      \n      // Asegurarse de que exactamente un elemento esté marcado como principal\n      const principalItems = mediaItems.filter(item => item.isMain === true);\n      \n      if (principalItems.length === 0 && mediaItems.length > 0) {\n        // Si ninguno está marcado como principal, intentar encontrar una foto primero\n        const firstPhoto = mediaItems.find(item => item.type === 'photo');\n        \n        if (firstPhoto) {\n          // Preferir una foto como elemento principal\n          firstPhoto.isMain = true;\n          mainMediaUrl = firstPhoto.url;\n          mainMediaType = 'photo';\n          console.log(`Estableciendo primera foto como principal por defecto: ${mainMediaUrl}`);\n        } else {\n          // Si no hay fotos, usar el primer elemento (probablemente un video)\n          mediaItems[0].isMain = true;\n          mainMediaUrl = mediaItems[0].url;\n          mainMediaType = mediaItems[0].type;\n          console.log(`Estableciendo el primer elemento como principal por defecto: ${mainMediaType} - ${mainMediaUrl}`);\n        }\n      } else if (principalItems.length > 1) {\n        // Si hay más de uno marcado como principal, dejar solo el primero\n        let foundMain = false;\n        mediaItems = mediaItems.map(item => {\n          if (item.isMain && !foundMain) {\n            foundMain = true;\n            // Asegurar que mainMediaUrl y mainMediaType están actualizados\n            mainMediaUrl = item.url;\n            mainMediaType = item.type;\n            return item;\n          }\n          return { ...item, isMain: false };\n        });\n        console.log(`Resolviendo múltiples principales: único elemento principal ahora es ${mainMediaType} - ${mainMediaUrl}`);\n      }\n      \n      // Limitar a máximo 6 fotos y 3 videos y preservar el elemento principal\n      const MAX_PHOTOS = 6;\n      const MAX_VIDEOS = 3;\n      \n      // Separar fotos y videos, y mantener referencia a cual es el elemento principal\n      const mainItem = mediaItems.find(item => item.isMain === true);\n      const photos = mediaItems.filter(item => item.type === 'photo');\n      const videos = mediaItems.filter(item => item.type === 'video');\n      \n      let photosToKeep = photos;\n      let videosToKeep = videos;\n      \n      // Limitar fotos si exceden el máximo\n      if (photos.length > MAX_PHOTOS) {\n        console.log(`Limitando cantidad de fotos: ${photos.length} → ${MAX_PHOTOS}`);\n        \n        // Si el elemento principal es una foto, asegurarse de que esté entre las que se mantienen\n        if (mainItem && mainItem.type === 'photo') {\n          // Quitar el elemento principal del array para no contarlo en el límite\n          const otherPhotos = photos.filter(item => item !== mainItem);\n          \n          // Mantener el elemento principal + hasta (MAX_PHOTOS-1) otras fotos\n          const remainingPhotos = otherPhotos.slice(0, MAX_PHOTOS - 1);\n          photosToKeep = [mainItem, ...remainingPhotos];\n        } else {\n          // Si no hay principal o no es una foto, simplemente mantener las primeras MAX_PHOTOS\n          photosToKeep = photos.slice(0, MAX_PHOTOS);\n        }\n      }\n      \n      // Limitar videos si exceden el máximo\n      if (videos.length > MAX_VIDEOS) {\n        console.log(`Limitando cantidad de videos: ${videos.length} → ${MAX_VIDEOS}`);\n        \n        // Si el elemento principal es un video, asegurarse de que esté entre los que se mantienen\n        if (mainItem && mainItem.type === 'video') {\n          // Quitar el elemento principal del array para no contarlo en el límite\n          const otherVideos = videos.filter(item => item !== mainItem);\n          \n          // Mantener el elemento principal + hasta (MAX_VIDEOS-1) otros videos\n          const remainingVideos = otherVideos.slice(0, MAX_VIDEOS - 1);\n          videosToKeep = [mainItem, ...remainingVideos];\n        } else {\n          // Si no hay principal o no es un video, simplemente mantener los primeros MAX_VIDEOS\n          videosToKeep = videos.slice(0, MAX_VIDEOS);\n        }\n      }\n      \n      // Asignar los elementos filtrados y reordenar\n      mediaItems = [...photosToKeep, ...videosToKeep];\n      \n      // Verificar si el elemento principal se conservó después de la filtración\n      if (mainItem && !mediaItems.includes(mainItem)) {\n        console.warn(\"El elemento principal se perdió durante la filtración. Asignando uno nuevo.\");\n        \n        // Si el elemento principal se perdió, asignar uno nuevo\n        if (mediaItems.length > 0) {\n          // Preferir fotos como elemento principal\n          const newMainItem = mediaItems.find(item => item.type === 'photo') || mediaItems[0];\n          \n          // Actualizar flags y variables\n          mediaItems = mediaItems.map(item => ({\n            ...item,\n            isMain: item === newMainItem\n          }));\n          \n          mainMediaUrl = newMainItem.url;\n          mainMediaType = newMainItem.type;\n          \n          console.log(`Nuevo elemento principal asignado: ${mainMediaType} - ${mainMediaUrl}`);\n        } else {\n          // No hay elementos multimedia después de la filtración\n          mainMediaUrl = '';\n          mainMediaType = 'photo'; // Default to photo to avoid enum error\n        }\n      }\n      \n      // Re-asignar órdenes para mantener consistencia después de filtrar\n      mediaItems = mediaItems.map((item, index) => ({\n        ...item,\n        order: index\n      }));\n      \n      // Actualizar los campos de multimedia\n      updateData.mediaItems = JSON.stringify(mediaItems);\n      \n      // Asegurar que mainMediaType sea siempre un string, no un array\n      if (Array.isArray(mainMediaType)) {\n        updateData.mainMediaType = mainMediaType[0] || 'photo';\n        console.log(`Corrigiendo mainMediaType de array a string: ${mainMediaType} → ${updateData.mainMediaType}`);\n      } else {\n        updateData.mainMediaType = mainMediaType || 'photo';\n      }\n      \n      updateData.mainMediaUrl = mainMediaUrl;\n      \n      // Si hay preguntas de postulación, incluirlas\n      if (req.body.applicationQuestions) {\n        updateData.applicationQuestions = req.body.applicationQuestions;\n      }\n      \n      // Update event\n      const updatedEvent = await storage.updateEvent(eventId, updateData);\n      \n      // Broadcast event update to all connected clients\n      broadcastMessage({\n        type: 'event_updated',\n        event: updatedEvent\n      });\n      console.log(\"Notificación de actualización de evento enviada a todos los clientes WebSocket\");\n      \n      res.json(updatedEvent);\n    } catch (error) {\n      console.error(\"Error updating event with files:\", error);\n      res.status(500).json({ message: \"Error updating event\", error: String(error) });\n    }\n  });\n\n  app.delete(\"/api/events/:id\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      // Check if event exists\n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      // Check if user is the organizer\n      if (event.organizerId !== user.id) {\n        return res.status(403).json({ message: \"Not authorized to delete this event\" });\n      }\n      \n      // Delete event\n      await storage.deleteEvent(eventId);\n      res.json({ message: \"Event deleted successfully\" });\n    } catch (error) {\n      console.error(\"Error deleting event:\", error);\n      res.status(500).json({ message: \"Error deleting event\" });\n    }\n  });\n\n  // Event attendance routes\n  app.post(\"/api/events/:id/join\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      // Check if event exists\n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      // Check if user is already attending\n      const existingAttendee = await storage.getEventAttendee(eventId, user.id);\n      if (existingAttendee) {\n        return res.status(400).json({ \n          message: \"Already joined this event\",\n          status: existingAttendee.status\n        });\n      }\n      \n      // Check if event is at capacity\n      if (event.maxCapacity) {\n        const attendees = await storage.getEventAttendees(eventId);\n        if (attendees.length >= event.maxCapacity) {\n          return res.status(400).json({ message: \"Event is at maximum capacity\" });\n        }\n      }\n      \n      // For private events, create a pending request\n      if (event.privacyType === 'private') {\n        const attendee = await storage.joinEvent({\n          eventId,\n          userId: user.id,\n          status: 'pending',\n          paymentStatus: event.paymentType === 'free' ? 'completed' : 'pending'\n        });\n        \n        return res.status(201).json({ \n          attendee, \n          requiresPayment: false,\n          isPendingApproval: true\n        });\n      }\n      \n      // For paid events, process through Stripe\n      if (event.paymentType === 'paid' && event.price) {\n        if (!stripe) {\n          return res.status(500).json({ message: \"Payment processing is not available\" });\n        }\n        \n        // Pagos desactivados, creamos un objeto simulado para mantener compatibilidad con el código\n        const paymentIntent = {\n          id: `free_event_${Date.now()}`,\n          client_secret: `free_event_no_payment_required_${Date.now()}`\n        };\n        \n        // Create attendance record with pending payment\n        const attendee = await storage.joinEvent({\n          eventId,\n          userId: user.id,\n          status: 'approved',\n          paymentStatus: 'pending',\n          paymentIntentId: paymentIntent.id\n        });\n        \n        return res.status(201).json({ \n          attendee,\n          clientSecret: paymentIntent.client_secret,\n          requiresPayment: true,\n          isPendingApproval: false\n        });\n      }\n      \n      // For free events, just add them\n      const attendee = await storage.joinEvent({\n        eventId,\n        userId: user.id,\n        status: 'approved',\n        paymentStatus: 'completed'\n      });\n      \n      res.status(201).json({ \n        attendee, \n        requiresPayment: false,\n        isPendingApproval: false\n      });\n    } catch (error) {\n      console.error(\"Error joining event:\", error);\n      res.status(500).json({ message: \"Error joining event\" });\n    }\n  });\n\n  app.delete(\"/api/events/:id/leave\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      // Check if user is attending\n      const attendee = await storage.getEventAttendee(eventId, user.id);\n      if (!attendee) {\n        return res.status(404).json({ message: \"Not attending this event\" });\n      }\n      \n      // Cannot leave a paid event if payment is completed\n      if (attendee.paymentStatus === 'completed' && attendee.paymentIntentId) {\n        return res.status(400).json({ message: \"Cannot leave a paid event after payment is completed\" });\n      }\n      \n      // Pagos desactivados, no necesitamos cancelar el payment intent\n      // Si hubiera pagos, aquí se cancelaría el payment intent\n      \n      // Remove attendee record\n      await storage.leaveEvent(eventId, user.id);\n      res.json({ message: \"Left event successfully\" });\n    } catch (error) {\n      console.error(\"Error leaving event:\", error);\n      res.status(500).json({ message: \"Error leaving event\" });\n    }\n  });\n  \n  // Approve/reject join requests for private events\n  app.post(\"/api/events/:id/requests/:attendeeId/approve\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      const attendeeId = parseInt(req.params.attendeeId);\n      \n      // Verify the event exists and user is the organizer\n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      if (event.organizerId !== user.id) {\n        return res.status(403).json({ message: \"Only the event organizer can approve requests\" });\n      }\n      \n      // Get the attendee record\n      const attendee = await storage.getEventAttendee(eventId, attendeeId);\n      if (!attendee) {\n        return res.status(404).json({ message: \"Join request not found\" });\n      }\n      \n      if (attendee.status !== 'pending') {\n        return res.status(400).json({ message: \"This request has already been processed\" });\n      }\n      \n      // Update attendee status\n      const updatedAttendee = await storage.updateEventAttendee(attendee.id, {\n        status: 'approved'\n      });\n      \n      res.json({ \n        attendee: updatedAttendee,\n        message: \"Join request approved\" \n      });\n    } catch (error) {\n      console.error(\"Error approving join request:\", error);\n      res.status(500).json({ message: \"Server error\" });\n    }\n  });\n  \n  app.post(\"/api/events/:id/requests/:attendeeId/reject\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      const attendeeId = parseInt(req.params.attendeeId);\n      \n      // Verify the event exists and user is the organizer\n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      if (event.organizerId !== user.id) {\n        return res.status(403).json({ message: \"Only the event organizer can reject requests\" });\n      }\n      \n      // Get the attendee record\n      const attendee = await storage.getEventAttendee(eventId, attendeeId);\n      if (!attendee) {\n        return res.status(404).json({ message: \"Join request not found\" });\n      }\n      \n      if (attendee.status !== 'pending') {\n        return res.status(400).json({ message: \"This request has already been processed\" });\n      }\n      \n      // Delete the attendee record\n      await storage.leaveEvent(eventId, attendeeId);\n      \n      res.json({ message: \"Join request rejected\" });\n    } catch (error) {\n      console.error(\"Error rejecting join request:\", error);\n      res.status(500).json({ message: \"Server error\" });\n    }\n  });\n  \n  // Get pending join requests for an event\n  app.get(\"/api/events/:id/requests\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      // Verify the event exists and user is the organizer\n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      if (event.organizerId !== user.id) {\n        return res.status(403).json({ message: \"Only the event organizer can view join requests\" });\n      }\n      \n      // Get all attendees for the event\n      const attendees = await storage.getEventAttendees(eventId);\n      \n      // Filter to only pending requests\n      const pendingRequests = attendees.filter(attendee => attendee.status === 'pending');\n      \n      res.json(pendingRequests);\n    } catch (error) {\n      console.error(\"Error fetching join requests:\", error);\n      res.status(500).json({ message: \"Server error\" });\n    }\n  });\n  \n  // Check user's status for an event (for pending requests)\n  app.get(\"/api/events/:id/status\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      // Get user's attendance record\n      const attendee = await storage.getEventAttendee(eventId, user.id);\n      if (!attendee) {\n        return res.status(404).json({ \n          message: \"No estás registrado en este evento\",\n          status: null\n        });\n      }\n      \n      // Return status\n      res.json({ \n        status: attendee.status,\n        paymentStatus: attendee.paymentStatus\n      });\n    } catch (error) {\n      console.error(\"Error checking event status:\", error);\n      res.status(500).json({ message: \"Error del servidor\" });\n    }\n  });\n\n  // Simplified payment routes - all events are free\n  app.post(\"/api/payment/confirm\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const { eventId } = req.body;\n      \n      // Check if the event exists\n      const event = await storage.getEventById(parseInt(eventId));\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      // Automatically join the event as free\n      try {\n        // Update the attendee record\n        const updatedAttendee = await storage.updatePaymentStatus(\n          parseInt(eventId),\n          user.id,\n          'free',\n          \"\"\n        );\n        \n        res.json(updatedAttendee);\n      } catch (error) {\n        console.error(\"Error updating event status:\", error);\n        res.status(500).json({ message: \"Error updating event attendance\" });\n      }\n    } catch (error) {\n      console.error(\"Error joining event:\", error);\n      res.status(500).json({ message: \"Error joining event\" });\n    }\n  });\n\n  // User events routes\n  app.get(\"/api/user/events/created\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const events = await storage.getUserCreatedEvents(user.id);\n      res.json(events);\n    } catch (error) {\n      console.error(\"Error fetching created events:\", error);\n      res.status(500).json({ message: \"Error fetching created events\" });\n    }\n  });\n\n  app.get(\"/api/user/events/attending\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const events = await storage.getUserAttendingEvents(user.id);\n      res.json(events);\n    } catch (error) {\n      console.error(\"Error fetching attending events:\", error);\n      res.status(500).json({ message: \"Error fetching attending events\" });\n    }\n  });\n\n  // Simplified payment intent route - all events are free\n  app.post(\"/api/create-payment-intent\", isAuthenticated, async (req, res) => {\n    try {      \n      const { eventId } = req.body;\n      const user = req.user as any;\n      \n      // Get the event details\n      const event = await storage.getEventById(parseInt(eventId));\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      // Automatically join the event as a free event\n      try {\n        await storage.joinEvent({\n          eventId: parseInt(eventId),\n          userId: user.id,\n          paymentStatus: \"free\",\n          paymentIntentId: \"\"\n        });\n        \n        // Return a fake client secret to keep the client logic working\n        res.json({ \n          clientSecret: \"free_event_no_payment_required\",\n          message: \"Joined event successfully\" \n        });\n      } catch (error) {\n        console.error(\"Error joining event:\", error);\n        res.status(500).json({ message: \"Error joining event\" });\n      }\n    } catch (error) {\n      console.error(\"Error handling free event join:\", error);\n      res.status(500).json({ message: \"Server error\" });\n    }\n  });\n\n  const httpServer = createServer(app);\n  \n  // Initialize WebSocket server on a different path to avoid conflict with Vite HMR\n  const wss = new WebSocketServer({ \n    server: httpServer, \n    path: '/ws' \n  });\n  \n  // Store active connections\n  const clients = new Map<string, { ws: WebSocket, userId: number, userName: string }>();\n  \n  // Función para enviar mensajes a todos los clientes\n  const broadcastMessage = (data: any) => {\n    const message = JSON.stringify(data);\n    clients.forEach(({ ws }) => {\n      if (ws.readyState === WebSocket.OPEN) {\n        ws.send(message);\n      }\n    });\n    console.log(`Broadcasted ${data.type} to ${clients.size} clients`);\n  };\n  \n  wss.on('connection', (ws, req) => {\n    console.log('WebSocket connection established');\n    \n    // Intentar extraer información de sesión si está disponible\n    const url = new URL(req.url || '', `http://${req.headers.host}`);\n    const sid = url.searchParams.get('sid');\n    if (sid) {\n      console.log(`WebSocket connection with session ID: ${sid.substring(0, 8)}...`);\n    }\n    \n    // Generate client ID\n    const clientId = Math.random().toString(36).substring(2, 15);\n    \n    // Handle messages\n    ws.on('message', async (message) => {\n      try {\n        const data = JSON.parse(message.toString());\n        \n        // Handle authentication\n        if (data.type === 'auth') {\n          const { userId, userName } = data;\n          clients.set(clientId, { ws, userId, userName });\n          console.log(`Client authenticated: ${userName} (${userId})`);\n          \n          // Send confirmation to the client\n          ws.send(JSON.stringify({\n            type: 'auth_success',\n            userId,\n            userName\n          }));\n          \n          return;\n        }\n        \n        // Handle chat messages - only logged in users\n        if (data.type === 'message' && clients.has(clientId)) {\n          const { eventId, content } = data;\n          const sender = clients.get(clientId)!;\n          \n          // Validate data\n          if (!eventId || !content || content.trim() === '') {\n            return;\n          }\n          \n          const messageData = {\n            type: 'message',\n            eventId,\n            userId: sender.userId,\n            userName: sender.userName,\n            content,\n            timestamp: new Date().toISOString()\n          };\n          \n          // Broadcast to all clients connected to the same event\n          clients.forEach((client) => {\n            if (client.ws.readyState === WebSocket.OPEN) {\n              client.ws.send(JSON.stringify(messageData));\n            }\n          });\n          \n          return;\n        }\n      } catch (error) {\n        console.error('Error processing WebSocket message:', error);\n      }\n    });\n    \n    // Handle disconnection\n    ws.on('close', () => {\n      clients.delete(clientId);\n      console.log('WebSocket connection closed');\n    });\n    \n    // Send initial message\n    ws.send(JSON.stringify({ \n      type: 'connection_established',\n      message: 'Successfully connected to Pipol chat server'\n    }));\n  });\n\n  return httpServer;\n}\n","size_bytes":101400},"setup-database.js":{"content":"import { createClient } from '@supabase/supabase-js';\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nconst supabase = createClient(\n  process.env.SUPABASE_URL,\n  process.env.SUPABASE_ANON_KEY\n);\n\nconst createTables = async () => {\n  console.log('Creating database tables...');\n\n  const sql = `\n    -- Create enums first\n    DO $$ BEGIN\n        CREATE TYPE event_category AS ENUM ('social', 'music', 'spiritual', 'education', 'sports', 'food', 'art', 'technology', 'games', 'outdoor', 'networking', 'workshop', 'conference', 'party', 'fair', 'exhibition');\n    EXCEPTION\n        WHEN duplicate_object THEN null;\n    END $$;\n\n    DO $$ BEGIN\n        CREATE TYPE privacy_type AS ENUM ('public', 'private');\n    EXCEPTION\n        WHEN duplicate_object THEN null;\n    END $$;\n\n    DO $$ BEGIN\n        CREATE TYPE private_access_type AS ENUM ('solicitud', 'postulacion', 'paga');\n    EXCEPTION\n        WHEN duplicate_object THEN null;\n    END $$;\n\n    DO $$ BEGIN\n        CREATE TYPE payment_type AS ENUM ('free', 'paid');\n    EXCEPTION\n        WHEN duplicate_object THEN null;\n    END $$;\n\n    DO $$ BEGIN\n        CREATE TYPE multimedia_type AS ENUM ('photo', 'video');\n    EXCEPTION\n        WHEN duplicate_object THEN null;\n    END $$;\n\n    DO $$ BEGIN\n        CREATE TYPE attendee_status AS ENUM ('pending', 'approved', 'rejected');\n    EXCEPTION\n        WHEN duplicate_object THEN null;\n    END $$;\n\n    -- Users table\n    CREATE TABLE IF NOT EXISTS users (\n      id SERIAL PRIMARY KEY,\n      username TEXT NOT NULL UNIQUE,\n      email TEXT NOT NULL UNIQUE,\n      password TEXT,\n      name TEXT NOT NULL,\n      bio TEXT,\n      avatar TEXT,\n      supabase_id TEXT UNIQUE,\n      stripe_customer_id TEXT,\n      stripe_subscription_id TEXT,\n      created_at TIMESTAMP DEFAULT NOW() NOT NULL,\n      updated_at TIMESTAMP DEFAULT NOW() NOT NULL\n    );\n\n    -- Events table\n    CREATE TABLE IF NOT EXISTS events (\n      id SERIAL PRIMARY KEY,\n      title TEXT NOT NULL,\n      description TEXT NOT NULL,\n      category event_category NOT NULL,\n      date TIMESTAMP NOT NULL,\n      latitude DECIMAL(10, 6) NOT NULL,\n      longitude DECIMAL(10, 6) NOT NULL,\n      location_name TEXT NOT NULL,\n      location_address TEXT NOT NULL,\n      payment_type payment_type NOT NULL DEFAULT 'free',\n      price DECIMAL(10, 2),\n      max_capacity INTEGER,\n      privacy_type privacy_type NOT NULL DEFAULT 'public',\n      private_access_type private_access_type,\n      application_questions TEXT,\n      photo_url TEXT,\n      photo_urls TEXT,\n      video_url TEXT,\n      video_urls TEXT,\n      media_items TEXT,\n      main_media_type multimedia_type DEFAULT 'photo',\n      main_media_url TEXT,\n      organizer_id INTEGER REFERENCES users(id) NOT NULL,\n      created_at TIMESTAMP DEFAULT NOW() NOT NULL,\n      updated_at TIMESTAMP DEFAULT NOW() NOT NULL\n    );\n\n    -- Event attendees table\n    CREATE TABLE IF NOT EXISTS event_attendees (\n      id SERIAL PRIMARY KEY,\n      event_id INTEGER REFERENCES events(id) NOT NULL,\n      user_id INTEGER REFERENCES users(id) NOT NULL,\n      status attendee_status DEFAULT 'approved' NOT NULL,\n      payment_status TEXT DEFAULT 'pending',\n      payment_intent_id TEXT,\n      created_at TIMESTAMP DEFAULT NOW() NOT NULL\n    );\n\n    -- User interests table\n    CREATE TABLE IF NOT EXISTS user_interests (\n      id SERIAL PRIMARY KEY,\n      user_id INTEGER REFERENCES users(id) NOT NULL,\n      category event_category NOT NULL,\n      created_at TIMESTAMP DEFAULT NOW() NOT NULL\n    );\n\n    -- Create indexes for performance (only if they don't exist)\n    CREATE INDEX IF NOT EXISTS idx_events_category ON events(category);\n    CREATE INDEX IF NOT EXISTS idx_events_date ON events(date);\n    CREATE INDEX IF NOT EXISTS idx_events_organizer ON events(organizer_id);\n    CREATE INDEX IF NOT EXISTS idx_event_attendees_event ON event_attendees(event_id);\n    CREATE INDEX IF NOT EXISTS idx_event_attendees_user ON event_attendees(user_id);\n    CREATE INDEX IF NOT EXISTS idx_users_supabase_id ON users(supabase_id);\n  `;\n\n  try {\n    const { data, error } = await supabase.rpc('exec_sql', { sql });\n    \n    if (error) {\n      console.error('Error creating tables:', error);\n      return false;\n    }\n    \n    console.log('Database tables created successfully!');\n    return true;\n  } catch (error) {\n    console.error('Error executing SQL:', error);\n    return false;\n  }\n};\n\n// Run the setup\ncreateTables().then(success => {\n  if (success) {\n    console.log('Database setup completed successfully!');\n  } else {\n    console.log('Database setup failed.');\n  }\n  process.exit(success ? 0 : 1);\n});","size_bytes":4604},"setup-db.js":{"content":"// Script to setup database tables in Supabase\nimport { createClient } from '@supabase/supabase-js';\nimport dotenv from 'dotenv';\nimport fs from 'fs';\n\n// Load environment variables\ndotenv.config();\n\n// Validate Supabase credentials\nconst supabaseUrl = process.env.SUPABASE_URL;\nconst supabaseKey = process.env.SUPABASE_ANON_KEY;\n\nif (!supabaseUrl || !supabaseKey) {\n  console.error('Missing Supabase credentials');\n  process.exit(1);\n}\n\n// Create Supabase client\nconst supabase = createClient(supabaseUrl, supabaseKey);\n\n// Read SQL file\nconst sql = fs.readFileSync('./supabase-setup.sql', 'utf8');\n\n// Extract CREATE TABLE statements from SQL\nconst tableStatements = sql.match(/CREATE TABLE\\s+\\w+\\s*\\([^;]+\\);/g) || [];\n\nasync function setupDatabase() {\n  console.log('Setting up database tables...');\n\n  // Check if users table exists\n  const { data: userData, error: userError } = await supabase\n    .from('users')\n    .select('id')\n    .limit(1);\n\n  if (userError && userError.code === '42P01') {\n    console.log('Users table does not exist, creating tables...');\n    \n    try {\n      // Execute SQL in Supabase SQL Editor\n      console.log('Please execute the SQL statements in supabase-setup.sql manually in the Supabase SQL Editor.');\n      console.log('The application will continue to run, but data operations may fail until tables are created.');\n      \n      // Create a simple users table for testing\n      const { error } = await supabase.rpc('exec_sql', {\n        query: `\n          CREATE TABLE IF NOT EXISTS users (\n            id SERIAL PRIMARY KEY,\n            username TEXT UNIQUE,\n            email TEXT UNIQUE,\n            password TEXT,\n            name TEXT,\n            bio TEXT,\n            avatar TEXT,\n            supabase_id TEXT UNIQUE,\n            stripe_customer_id TEXT,\n            stripe_subscription_id TEXT,\n            created_at TIMESTAMP DEFAULT NOW(),\n            updated_at TIMESTAMP DEFAULT NOW()\n          );\n        `\n      });\n      \n      if (error) {\n        console.error('Error creating users table:', error.message);\n        // If the exec_sql function doesn't exist or fails, we'll proceed anyway\n        console.log('Could not create users table via RPC, application may have limited functionality');\n      } else {\n        console.log('Created users table successfully');\n      }\n    } catch (error) {\n      console.error('Error setting up database:', error);\n    }\n  } else {\n    console.log('Users table already exists, skipping table creation');\n  }\n\n  console.log('Database setup complete');\n}\n\nsetupDatabase().catch(err => {\n  console.error('Failed to setup database:', err);\n});","size_bytes":2638},"setup-notifications-table.js":{"content":"import { createClient } from '@supabase/supabase-js';\nimport 'dotenv/config';\n\nconst supabase = createClient(\n  process.env.SUPABASE_URL,\n  process.env.SUPABASE_ANON_KEY\n);\n\nasync function setupNotificationsTable() {\n  console.log('🔧 Setting up notifications table...');\n  \n  try {\n    // Create notification_type enum if it doesn't exist\n    const enumResult = await supabase\n      .rpc('exec_sql', { \n        sql: \"CREATE TYPE notification_type AS ENUM ('request_approved', 'request_rejected', 'new_request')\"\n      });\n    \n    console.log('✅ Notification type enum created (or already exists)');\n  } catch (error) {\n    // Enum might already exist, that's ok\n    console.log('⚠️ Notification type enum might already exist');\n  }\n\n  try {\n    // Create notifications table\n    const tableResult = await supabase\n      .rpc('exec_sql', { \n        sql: `\n          CREATE TABLE notifications (\n            id SERIAL PRIMARY KEY,\n            user_id INTEGER NOT NULL REFERENCES users(id),\n            type notification_type NOT NULL,\n            title TEXT NOT NULL,\n            message TEXT NOT NULL,\n            event_id INTEGER REFERENCES events(id),\n            request_id INTEGER REFERENCES event_attendees(id),\n            is_read BOOLEAN DEFAULT FALSE NOT NULL,\n            created_at TIMESTAMP DEFAULT NOW() NOT NULL\n          )\n        `\n      });\n      \n    console.log('✅ Notifications table created successfully');\n    \n    // Test the table by checking if it exists\n    const testResult = await supabase\n      .from('notifications')\n      .select('*')\n      .limit(1);\n      \n    if (testResult.error && testResult.error.code === '42P01') {\n      console.log('❌ Table creation failed');\n      console.error(testResult.error);\n    } else {\n      console.log('✅ Notifications table is accessible');\n    }\n    \n  } catch (error) {\n    console.error('❌ Error creating notifications table:', error);\n  }\n}\n\nsetupNotificationsTable();","size_bytes":1958},"setup-supabase-db.js":{"content":"// This script runs the SQL from supabase-setup.sql to set up the database\nimport { createClient } from '@supabase/supabase-js';\nimport fs from 'fs';\nimport dotenv from 'dotenv';\n\n// Load environment variables\ndotenv.config();\n\n// Validate Supabase credentials\nconst supabaseUrl = process.env.SUPABASE_URL;\nconst supabaseAnonKey = process.env.SUPABASE_ANON_KEY;\n\nif (!supabaseUrl || !supabaseAnonKey) {\n  console.error('Missing Supabase credentials');\n  console.error('Make sure SUPABASE_URL and SUPABASE_ANON_KEY are defined in environment variables');\n  process.exit(1);\n}\n\n// Create Supabase client\nconst supabase = createClient(supabaseUrl, supabaseAnonKey);\n\n// Read the SQL file\nconst sqlContent = fs.readFileSync('./supabase-setup.sql', 'utf8');\n\n// Split the SQL into individual statements (split by semicolons)\nconst statements = sqlContent\n  .split(';')\n  .map(statement => statement.trim())\n  .filter(statement => statement.length > 0);\n\n// Execute each statement\nasync function executeStatements() {\n  console.log(`Found ${statements.length} SQL statements to execute`);\n  \n  for (let i = 0; i < statements.length; i++) {\n    const statement = statements[i];\n    try {\n      // Log the first 50 characters of the statement for debugging\n      console.log(`Executing statement ${i + 1}/${statements.length}: ${statement.substring(0, 50)}...`);\n      \n      // Execute the SQL statement\n      const { error } = await supabase.rpc('exec_sql', { query: statement + ';' });\n      \n      if (error) {\n        console.error(`Error executing statement ${i + 1}:`, error.message);\n        // Continue with the next statement even if there's an error\n      } else {\n        console.log(`Successfully executed statement ${i + 1}`);\n      }\n    } catch (err) {\n      console.error(`Exception executing statement ${i + 1}:`, err);\n    }\n  }\n  \n  console.log('Database setup completed');\n}\n\n// Run the setup\nexecuteStatements().catch(err => {\n  console.error('Failed to set up database:', err);\n  process.exit(1);\n});","size_bytes":2015},"setup-supabase-tables.js":{"content":"// This script uses the Supabase REST API to create tables\nimport { createClient } from '@supabase/supabase-js';\nimport dotenv from 'dotenv';\nimport fs from 'fs';\n\n// Load environment variables\ndotenv.config();\n\n// Validate Supabase credentials\nconst supabaseUrl = process.env.SUPABASE_URL;\nconst supabaseAnonKey = process.env.SUPABASE_ANON_KEY;\n\nif (!supabaseUrl || !supabaseAnonKey) {\n  console.error('Missing Supabase credentials');\n  console.error('Make sure SUPABASE_URL and SUPABASE_ANON_KEY are defined in environment variables');\n  process.exit(1);\n}\n\n// Create Supabase client\nconst supabase = createClient(supabaseUrl, supabaseAnonKey);\n\n// Function to read and execute SQL file\nasync function createTables() {\n  try {\n    console.log('Setting up database tables...');\n\n    // Create enum types first\n    console.log('Creating enum types...');\n    \n    // Creating event_category enum\n    await supabase.rpc('create_enum_type', { \n      type_name: 'event_category',\n      enum_values: ['social', 'music', 'spiritual', 'education', 'sports', 'food', 'art', 'technology', \n                   'games', 'outdoor', 'networking', 'workshop', 'conference', 'party', 'fair', 'exhibition']\n    });\n    \n    // Creating privacy_type enum\n    await supabase.rpc('create_enum_type', { \n      type_name: 'privacy_type',\n      enum_values: ['public', 'private']\n    });\n    \n    // Creating private_access_type enum\n    await supabase.rpc('create_enum_type', { \n      type_name: 'private_access_type',\n      enum_values: ['solicitud', 'postulacion', 'paga']\n    });\n    \n    // Creating payment_type enum\n    await supabase.rpc('create_enum_type', { \n      type_name: 'payment_type',\n      enum_values: ['free', 'paid']\n    });\n    \n    // Creating multimedia_type enum\n    await supabase.rpc('create_enum_type', { \n      type_name: 'multimedia_type',\n      enum_values: ['photo', 'video']\n    });\n    \n    // Creating attendee_status enum\n    await supabase.rpc('create_enum_type', { \n      type_name: 'attendee_status',\n      enum_values: ['pending', 'approved', 'rejected']\n    });\n\n    console.log('Creating users table...');\n    // Create users table\n    const { error: usersError } = await supabase\n      .from('users')\n      .insert({ id: 1, username: 'temp_user', email: 'temp@example.com', name: 'Temporary User', password: 'temp' })\n      .select();\n    \n    if (usersError && !usersError.message.includes('duplicate')) {\n      console.error('Error creating users table:', usersError);\n    } else {\n      console.log('Users table created or already exists');\n    }\n\n    console.log('Database setup complete');\n    return true;\n  } catch (error) {\n    console.error('Error setting up database:', error);\n    return false;\n  }\n}\n\n// Run the setup\ncreateTables().then(success => {\n  console.log('Setup completed with result:', success ? 'SUCCESS' : 'FAILED');\n});","size_bytes":2866},"setup-tables-simple.js":{"content":"import { supabase } from './server/supabase-client.js';\n\nconst setupTables = async () => {\n  console.log('Setting up database tables...');\n\n  // Create the users table first\n  const { error: usersError } = await supabase.rpc('exec_sql', {\n    sql: `\n      CREATE TABLE IF NOT EXISTS users (\n        id SERIAL PRIMARY KEY,\n        username TEXT NOT NULL UNIQUE,\n        email TEXT NOT NULL UNIQUE,\n        password TEXT,\n        name TEXT NOT NULL,\n        bio TEXT,\n        avatar TEXT,\n        supabase_id TEXT UNIQUE,\n        stripe_customer_id TEXT,\n        stripe_subscription_id TEXT,\n        created_at TIMESTAMP DEFAULT NOW() NOT NULL,\n        updated_at TIMESTAMP DEFAULT NOW() NOT NULL\n      );\n    `\n  });\n\n  if (usersError) {\n    console.error('Error creating users table:', usersError);\n    return false;\n  }\n\n  console.log('Users table created successfully');\n  return true;\n};\n\nsetupTables().then(success => {\n  console.log(success ? 'Database setup complete' : 'Database setup failed');\n  process.exit(success ? 0 : 1);\n});","size_bytes":1038},"setup-tables.js":{"content":"// Script to set up database tables in Supabase\nimport { createClient } from '@supabase/supabase-js';\nimport fs from 'fs';\nimport dotenv from 'dotenv';\n\n// Load environment variables\ndotenv.config();\n\n// Validate Supabase credentials\nconst supabaseUrl = process.env.SUPABASE_URL;\nconst supabaseAnonKey = process.env.SUPABASE_ANON_KEY;\n\nif (!supabaseUrl || !supabaseAnonKey) {\n  console.error('Missing Supabase credentials');\n  process.exit(1);\n}\n\n// Create Supabase client\nconst supabase = createClient(supabaseUrl, supabaseAnonKey);\n\nasync function createTables() {\n  try {\n    console.log('Setting up database tables in Supabase...');\n    \n    // Check if users table exists by trying to query it\n    const { data: userData, error: userError } = await supabase\n      .from('users')\n      .select('id')\n      .limit(1);\n    \n    if (userError && userError.code === '42P01') {\n      console.log('Users table does not exist, creating it...');\n      \n      // Create users table\n      const createUsersResult = await supabase.rpc('create_users_table');\n      console.log('Create users table result:', createUsersResult);\n      \n      console.log('To complete database setup, please execute the SQL in supabase-setup.sql');\n      console.log('in the Supabase SQL Editor. This will create all necessary tables and indexes.');\n    } else {\n      console.log('Users table exists, no need to create it');\n    }\n    \n    // Create a test user for login testing\n    console.log('Creating a test user via Supabase Auth...');\n    const { data: authUserData, error: authUserError } = await supabase.auth.signUp({\n      email: 'test@example.com',\n      password: 'testpassword123',\n    });\n    \n    if (authUserError) {\n      console.error('Error creating test user:', authUserError);\n    } else {\n      console.log('Test user created or already exists:', authUserData);\n      \n      // Add user to our database table\n      if (authUserData.user) {\n        const { data: dbUserData, error: dbUserError } = await supabase\n          .from('users')\n          .upsert(\n            {\n              email: 'test@example.com',\n              username: 'testuser',\n              name: 'Test User',\n              supabase_id: authUserData.user.id,\n            },\n            { onConflict: 'email' }\n          );\n        \n        if (dbUserError) {\n          console.error('Error adding user to database:', dbUserError);\n        } else {\n          console.log('User added to database');\n        }\n      }\n    }\n    \n    console.log('Database setup process complete');\n    \n  } catch (error) {\n    console.error('Error in createTables:', error);\n  }\n}\n\ncreateTables();","size_bytes":2643},"setup-via-supabase.js":{"content":"import { createClient } from '@supabase/supabase-js';\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nconst supabaseUrl = process.env.SUPABASE_URL;\nconst supabaseKey = process.env.SUPABASE_ANON_KEY;\n\nconst supabase = createClient(supabaseUrl, supabaseKey);\n\nconst createUserTable = async () => {\n  console.log('Creating users table via Supabase...');\n  \n  // First, let's try to create a simple users table using Supabase's REST API\n  const createTableSQL = `\n    CREATE TABLE IF NOT EXISTS users (\n      id SERIAL PRIMARY KEY,\n      username TEXT NOT NULL UNIQUE,\n      email TEXT NOT NULL UNIQUE,\n      password TEXT,\n      name TEXT NOT NULL,\n      bio TEXT,\n      avatar TEXT,\n      supabase_id TEXT UNIQUE,\n      stripe_customer_id TEXT,\n      stripe_subscription_id TEXT,\n      created_at TIMESTAMP DEFAULT NOW() NOT NULL,\n      updated_at TIMESTAMP DEFAULT NOW() NOT NULL\n    );\n    \n    CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);\n    CREATE INDEX IF NOT EXISTS idx_users_username ON users(username);\n    CREATE INDEX IF NOT EXISTS idx_users_supabase_id ON users(supabase_id);\n  `;\n\n  try {\n    // Try using Supabase's SQL runner function if available\n    const { data, error } = await supabase.rpc('exec_sql', { \n      sql: createTableSQL \n    });\n    \n    if (error) {\n      console.log('RPC method failed, trying direct table creation...');\n      \n      // Try to insert a test row to see if table exists\n      const { error: testError } = await supabase\n        .from('users')\n        .select('id')\n        .limit(1);\n        \n      if (testError && testError.code === 'PGRST116') {\n        console.log('Table does not exist. Please create it manually in Supabase dashboard.');\n        return false;\n      } else {\n        console.log('Users table already exists or was created successfully');\n        return true;\n      }\n    } else {\n      console.log('Users table created successfully via RPC');\n      return true;\n    }\n  } catch (error) {\n    console.error('Error creating table:', error);\n    return false;\n  }\n};\n\ncreateUserTable().then(success => {\n  console.log(success ? 'Setup complete' : 'Manual setup required');\n  process.exit(0);\n});","size_bytes":2176},"simple-carousel.tsx":{"content":"import React, { useState } from \"react\";\nimport { ChevronLeft, ChevronRight } from \"lucide-react\";\n\ntype MediaItem = {\n  type: 'photo' | 'video';\n  url: string;\n  isMain?: boolean;\n  order?: number;\n};\n\ntype SimpleCarouselProps = {\n  items: MediaItem[];\n  eventTitle: string;\n};\n\nconst SimpleMediaCarousel = ({ items, eventTitle }: SimpleCarouselProps) => {\n  const [currentIndex, setCurrentIndex] = useState(0);\n\n  if (!items || items.length === 0) return null;\n\n  const nextSlide = () => {\n    setCurrentIndex((prev) => (prev + 1) % items.length);\n  };\n\n  const prevSlide = () => {\n    setCurrentIndex((prev) => (prev - 1 + items.length) % items.length);\n  };\n\n  const currentItem = items[currentIndex];\n\n  return (\n    <div className=\"mb-5\">\n      <h3 className=\"font-semibold mb-3\">Contenido multimedia</h3>\n      <div className=\"relative aspect-[4/5] rounded-xl overflow-hidden bg-black\">\n        {/* Current media item */}\n        {currentItem.type === 'video' ? (\n          <video\n            key={currentIndex}\n            src={currentItem.url}\n            className=\"w-full h-full object-contain\"\n            preload=\"metadata\"\n            controls\n          />\n        ) : (\n          <img\n            src={currentItem.url}\n            alt={`${eventTitle} - imagen ${currentIndex + 1}`}\n            className=\"w-full h-full object-contain\"\n          />\n        )}\n\n        {/* Navigation arrows */}\n        {items.length > 1 && (\n          <>\n            <button\n              onClick={prevSlide}\n              className=\"absolute left-2 top-1/2 transform -translate-y-1/2 bg-white/80 text-gray-800 rounded-full p-2 hover:bg-white transition-colors shadow-md\"\n            >\n              <ChevronLeft size={20} />\n            </button>\n            <button\n              onClick={nextSlide}\n              className=\"absolute right-2 top-1/2 transform -translate-y-1/2 bg-white/80 text-gray-800 rounded-full p-2 hover:bg-white transition-colors shadow-md\"\n            >\n              <ChevronRight size={20} />\n            </button>\n          </>\n        )}\n\n        {/* Pagination indicator */}\n        {items.length > 1 && (\n          <div className=\"absolute top-2 right-2 bg-black/70 text-white text-sm px-2 py-1 rounded\">\n            {currentIndex + 1} / {items.length}\n          </div>\n        )}\n\n        {/* Main indicator badge */}\n        {currentItem.isMain && (\n          <div className=\"absolute top-2 left-2 bg-yellow-500 text-white text-xs px-2 py-1 rounded\">\n            Principal\n          </div>\n        )}\n      </div>\n\n      {/* Dot navigation */}\n      {items.length > 1 && (\n        <div className=\"flex gap-1 mt-3 justify-center\">\n          {items.map((_, index) => (\n            <button\n              key={index}\n              onClick={() => setCurrentIndex(index)}\n              className={`w-2 h-2 rounded-full transition-colors ${\n                index === currentIndex ? 'bg-blue-500' : 'bg-gray-300'\n              }`}\n            />\n          ))}\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default SimpleMediaCarousel;","size_bytes":3063},"tailwind.config.ts":{"content":"import type { Config } from \"tailwindcss\";\n\nexport default {\n  darkMode: [\"class\"],\n  content: [\"./client/index.html\", \"./client/src/**/*.{js,jsx,ts,tsx}\"],\n  theme: {\n    extend: {\n      borderRadius: {\n        lg: \"var(--radius)\",\n        md: \"calc(var(--radius) - 2px)\",\n        sm: \"calc(var(--radius) - 4px)\",\n      },\n      colors: {\n        background: \"hsl(var(--background))\",\n        foreground: \"hsl(var(--foreground))\",\n        card: {\n          DEFAULT: \"hsl(var(--card))\",\n          foreground: \"hsl(var(--card-foreground))\",\n        },\n        popover: {\n          DEFAULT: \"hsl(var(--popover))\",\n          foreground: \"hsl(var(--popover-foreground))\",\n        },\n        primary: {\n          DEFAULT: \"hsl(var(--primary))\",\n          foreground: \"hsl(var(--primary-foreground))\",\n        },\n        secondary: {\n          DEFAULT: \"hsl(var(--secondary))\",\n          foreground: \"hsl(var(--secondary-foreground))\",\n        },\n        muted: {\n          DEFAULT: \"hsl(var(--muted))\",\n          foreground: \"hsl(var(--muted-foreground))\",\n        },\n        accent: {\n          DEFAULT: \"hsl(var(--accent))\",\n          foreground: \"hsl(var(--accent-foreground))\",\n        },\n        destructive: {\n          DEFAULT: \"hsl(var(--destructive))\",\n          foreground: \"hsl(var(--destructive-foreground))\",\n        },\n        border: \"hsl(var(--border))\",\n        input: \"hsl(var(--input))\",\n        ring: \"hsl(var(--ring))\",\n        chart: {\n          \"1\": \"hsl(var(--chart-1))\",\n          \"2\": \"hsl(var(--chart-2))\",\n          \"3\": \"hsl(var(--chart-3))\",\n          \"4\": \"hsl(var(--chart-4))\",\n          \"5\": \"hsl(var(--chart-5))\",\n        },\n        sidebar: {\n          DEFAULT: \"hsl(var(--sidebar-background))\",\n          foreground: \"hsl(var(--sidebar-foreground))\",\n          primary: \"hsl(var(--sidebar-primary))\",\n          \"primary-foreground\": \"hsl(var(--sidebar-primary-foreground))\",\n          accent: \"hsl(var(--sidebar-accent))\",\n          \"accent-foreground\": \"hsl(var(--sidebar-accent-foreground))\",\n          border: \"hsl(var(--sidebar-border))\",\n          ring: \"hsl(var(--sidebar-ring))\",\n        },\n      },\n      keyframes: {\n        \"accordion-down\": {\n          from: {\n            height: \"0\",\n          },\n          to: {\n            height: \"var(--radix-accordion-content-height)\",\n          },\n        },\n        \"accordion-up\": {\n          from: {\n            height: \"var(--radix-accordion-content-height)\",\n          },\n          to: {\n            height: \"0\",\n          },\n        },\n      },\n      animation: {\n        \"accordion-down\": \"accordion-down 0.2s ease-out\",\n        \"accordion-up\": \"accordion-up 0.2s ease-out\",\n      },\n    },\n  },\n  plugins: [require(\"tailwindcss-animate\"), require(\"@tailwindcss/typography\")],\n} satisfies Config;\n","size_bytes":2787},"test-organizer-fix.js":{"content":"// Test script to verify organizer recognition is working\nimport fetch from 'node-fetch';\n\nasync function testOrganizerRecognition() {\n  try {\n    // Test the status endpoint with a sample event\n    const response = await fetch('http://localhost:5000/api/events/2/status', {\n      method: 'GET',\n      headers: {\n        'Cookie': 'connect.sid=s%3A_example_session_id'  // This won't work but will show auth flow\n      }\n    });\n    \n    console.log('Status response:', response.status);\n    const data = await response.text();\n    console.log('Response data:', data);\n    \n  } catch (error) {\n    console.error('Test error:', error);\n  }\n}\n\ntestOrganizerRecognition();","size_bytes":669},"test-supabase-connection.js":{"content":"// Simple script to test Supabase connection\nimport { createClient } from '@supabase/supabase-js';\nimport dotenv from 'dotenv';\n\n// Load environment variables\ndotenv.config();\n\n// Get Supabase credentials\nconst supabaseUrl = process.env.SUPABASE_URL;\nconst supabaseKey = process.env.SUPABASE_ANON_KEY;\n\nconsole.log('Testing Supabase connection with:');\nconsole.log('URL:', supabaseUrl ? 'Available (not shown for security)' : 'Missing');\nconsole.log('Key:', supabaseKey ? 'Available (not shown for security)' : 'Missing');\n\n// Create Supabase client\nconst supabase = createClient(supabaseUrl, supabaseKey);\n\nasync function testConnection() {\n  try {\n    // Test a simple query - should return { count: 0 } if table doesn't exist\n    // or actual count if table exists\n    console.log('Attempting to connect to Supabase...');\n    const { data, error } = await supabase.from('_test_connection').select('*').limit(1);\n    \n    if (error && error.code !== 'PGRST116') {\n      // PGRST116 means relation doesn't exist, which is expected\n      console.error('Supabase connection error:', error);\n      return false;\n    }\n    \n    console.log('Supabase connection successful!');\n    return true;\n  } catch (error) {\n    console.error('Exception during Supabase connection test:', error);\n    return false;\n  }\n}\n\ntestConnection().then(success => {\n  console.log('Connection test result:', success ? 'SUCCESS' : 'FAILED');\n  \n  if (!success) {\n    console.log('\\nTroubleshooting tips:');\n    console.log('1. Verify the SUPABASE_URL is correct (should start with https://)');\n    console.log('2. Check if the SUPABASE_ANON_KEY is correct');\n    console.log('3. Ensure your Supabase project is active');\n  }\n});","size_bytes":1702},"vite.config.ts":{"content":"import { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\nimport path from \"path\";\nimport { fileURLToPath } from \"url\";\nimport runtimeErrorOverlay from \"@replit/vite-plugin-runtime-error-modal\";\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\n\nexport default defineConfig({\n  plugins: [\n    react(),\n    runtimeErrorOverlay(),\n    ...(process.env.NODE_ENV !== \"production\" &&\n    process.env.REPL_ID !== undefined\n      ? [\n          await import(\"@replit/vite-plugin-cartographer\").then((m) =>\n            m.cartographer(),\n          ),\n        ]\n      : []),\n  ],\n  resolve: {\n    alias: {\n      \"@db\": path.resolve(__dirname, \"db\"),\n      \"@\": path.resolve(__dirname, \"client\", \"src\"),\n      \"@shared\": path.resolve(__dirname, \"shared\"),\n      \"@assets\": path.resolve(__dirname, \"attached_assets\"),\n    },\n  },\n  root: path.resolve(__dirname, \"client\"),\n  build: {\n    outDir: path.resolve(__dirname, \"dist/public\"),\n    emptyOutDir: true,\n  },\n  server: {\n    host: \"0.0.0.0\",\n    port: 5173,\n    hmr: {\n      clientPort: 443,\n    },\n  },\n  define: {\n    // Expose Supabase environment variables to the client\n    'import.meta.env.VITE_SUPABASE_URL': JSON.stringify(process.env.SUPABASE_URL),\n    'import.meta.env.VITE_SUPABASE_ANON_KEY': JSON.stringify(process.env.SUPABASE_ANON_KEY),\n  },\n});\n","size_bytes":1337},"backups/routes-original.ts":{"content":"import express, { Express, Request, Response } from \"express\";\nimport { createServer, type Server } from \"http\";\nimport { storage } from \"./storage\";\nimport bcrypt from \"bcrypt\";\nimport passport from \"passport\";\nimport { loginUserSchema, insertUserSchema, insertEventSchema, insertEventAttendeeSchema } from \"@shared/schema\";\nimport { z } from \"zod\";\nimport Stripe from \"stripe\";\nimport { WebSocketServer } from 'ws';\nimport { WebSocket } from 'ws';\nimport multer from 'multer';\nimport path from 'path';\nimport fs from 'fs';\n\nif (!process.env.SESSION_SECRET) {\n  console.warn(\"No SESSION_SECRET provided, using default secret. This is insecure!\");\n}\n\n// Payment functionality is disabled for this app\nconsole.log(\"Payment functionality is disabled in this version of the app.\");\n\n// Set stripe to null - all events will be free\nconst stripe = null;\n\n// Configurar almacenamiento para multer\nconst storage_uploads = multer.diskStorage({\n  destination: function (req, file, cb) {\n    // Definir el directorio según el tipo de archivo\n    let uploadPath = 'public/uploads/events';\n    \n    // Asegurarse de que el directorio existe\n    if (!fs.existsSync(uploadPath)) {\n      fs.mkdirSync(uploadPath, { recursive: true });\n    }\n    \n    cb(null, uploadPath);\n  },\n  filename: function (req, file, cb) {\n    // Generar un nombre de archivo único\n    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\n    const extension = path.extname(file.originalname);\n    cb(null, 'event-' + uniqueSuffix + extension);\n  }\n});\n\n// Filtrar archivos por tipo y validar condiciones\nconst fileFilter = (req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {\n  console.log(`Procesando archivo: ${file.fieldname}, tipo: ${file.mimetype}`);\n  \n  // Categorizar el archivo según el campo\n  const isImageField = file.fieldname === 'eventPhoto' || file.fieldname === 'photos' || file.fieldname.startsWith('photos[');\n  const isVideoField = file.fieldname === 'eventVideo' || file.fieldname === 'videos' || file.fieldname.startsWith('videos[');\n  const isMainMediaField = file.fieldname === 'mainMediaFile' || file.fieldname === 'mainMedia';\n  const isMediaManagerField = file.fieldname.startsWith('mediaFile_');\n  \n  // Verificar tipo de contenido\n  const isImage = file.mimetype.startsWith('image/');\n  const isVideo = file.mimetype.startsWith('video/');\n  \n  // Validar según tipo de campo\n  if (isImageField) {\n    if (!isImage) {\n      console.warn(`Archivo rechazado - tipo incorrecto: ${file.fieldname}, ${file.mimetype}`);\n      return cb(new Error(`El archivo debe ser una imagen. Tipo recibido: ${file.mimetype}`));\n    }\n    \n    console.log(`Imagen aceptada: ${file.originalname}`);\n    return cb(null, true);\n  } \n  else if (isVideoField) {\n    if (!isVideo) {\n      console.warn(`Archivo rechazado - tipo incorrecto: ${file.fieldname}, ${file.mimetype}`);\n      return cb(new Error(`El archivo debe ser un video. Tipo recibido: ${file.mimetype}`));\n    }\n    \n    console.log(`Video aceptado: ${file.originalname}`);\n    return cb(null, true);\n  }\n  else if (isMainMediaField || isMediaManagerField) {\n    // Permitir tanto imágenes como videos para estos campos\n    if (!isImage && !isVideo) {\n      console.warn(`Archivo rechazado - tipo incorrecto: ${file.fieldname}, ${file.mimetype}`);\n      return cb(new Error(`El archivo multimedia debe ser una imagen o un video. Tipo recibido: ${file.mimetype}`));\n    }\n    \n    const fieldDescription = isMainMediaField ? 'principal' : 'MediaManager';\n    console.log(`Archivo ${fieldDescription} aceptado: ${file.originalname} (${isImage ? 'imagen' : 'video'})`);\n    return cb(null, true);\n  } \n  else {\n    // Por defecto, rechazar otros tipos de archivo desconocidos\n    console.warn(`Tipo de campo no reconocido: ${file.fieldname}, rechazado por seguridad`);\n    return cb(new Error(`Tipo de campo no soportado: ${file.fieldname}`));\n  }\n};\n\n// Constantes para los límites de tamaño\nconst MAX_PHOTO_SIZE = 5 * 1024 * 1024; // 5MB para fotos\nconst MAX_VIDEO_SIZE = 10 * 1024 * 1024; // 10MB para videos\n\n// Configurar manejo de errores para multer\nconst multerErrorHandler = (err: any, req: Request, res: Response, next: Function) => {\n  if (err instanceof multer.MulterError) {\n    console.error(\"Error de Multer:\", err.code, err.field);\n    \n    // Manejar errores específicos de multer con mensajes amigables\n    if (err.code === 'LIMIT_FILE_SIZE') {\n      return res.status(400).json({\n        success: false,\n        message: \"El archivo es demasiado grande. El tamaño máximo permitido es 10MB para videos y 5MB para imágenes.\",\n        error: 'FILE_TOO_LARGE',\n        field: err.field\n      });\n    }\n    \n    if (err.code === 'LIMIT_FILE_COUNT') {\n      return res.status(400).json({\n        success: false,\n        message: \"Se han enviado demasiados archivos. Máximo 10 archivos por solicitud.\",\n        error: 'TOO_MANY_FILES'\n      });\n    }\n    \n    // Otros errores de multer\n    return res.status(400).json({\n      success: false,\n      message: `Error al subir archivo: ${err.message}`,\n      error: err.code\n    });\n  }\n  \n  // Si no es un error de multer, pasar al siguiente middleware\n  if (err) {\n    return next(err);\n  }\n  \n  next();\n};\n\n// Configurar el middleware multer con mejores límites\nconst upload = multer({ \n  storage: storage_uploads,\n  fileFilter: fileFilter,\n  limits: {\n    fileSize: MAX_VIDEO_SIZE, // Usar el límite mayor (10MB) y validar específicamente en el código\n    files: 10, // Máximo 10 archivos por solicitud para evitar abusos\n  }\n});\n\nexport async function registerRoutes(app: Express): Promise<Server> {\n  // Serve static files from public directory\n  app.use(express.static('public'));\n\n  // Auth route middleware\n  const isAuthenticated = (req: Request, res: Response, next: Function) => {\n    if (!req.isAuthenticated()) {\n      console.log(`Petición no autenticada: ${req.method} ${req.path}`);\n      console.log(`Session ID presente: ${!!req.sessionID}`);\n      console.log(`Cookies: ${req.headers.cookie || 'No cookies'}`);\n      return res.status(401).json({ message: \"Not authenticated\" });\n    }\n    return next();\n  };\n\n  // Test auth route - force content type to be application/json\n  app.get(\"/api/auth/test\", (req, res) => {\n    console.log(\"Auth test route accessed\");\n    console.log(\"Session ID:\", req.sessionID);\n    console.log(\"Auth status:\", req.isAuthenticated());\n    console.log(\"User:\", req.user);\n    console.log(\"Session:\", req.session);\n    \n    // Force content type to application/json\n    res.setHeader('Content-Type', 'application/json');\n    \n    return res.send(JSON.stringify({\n      success: true,\n      message: \"Auth test route\",\n      authenticated: req.isAuthenticated(),\n      sessionId: req.sessionID,\n      user: req.user || null,\n      session: req.session ? {\n        id: req.session.id,\n        cookie: {\n          expires: req.session.cookie.expires,\n          maxAge: req.session.cookie.maxAge\n        }\n      } : null\n    }));\n  });\n  \n  // Auth routes\n  // Register a new user\n  app.post(\"/api/auth/register\", async (req, res) => {\n    try {\n      console.log(\"Registration attempt with data:\", { \n        email: req.body.email,\n        username: req.body.username,\n        name: req.body.name\n      });\n      \n      // Validate all input data\n      const validatedData = insertUserSchema.parse(req.body);\n      \n      // Check if email already exists\n      const existingEmail = await storage.getUserByEmail(validatedData.email);\n      if (existingEmail) {\n        console.log(`Registration rejected: Email ${validatedData.email} already exists`);\n        return res.status(400).json({ message: \"Email already in use\" });\n      }\n\n      // Check if username already exists\n      const existingUsername = await storage.getUserByUsername(validatedData.username);\n      if (existingUsername) {\n        console.log(`Registration rejected: Username ${validatedData.username} already exists`);\n        return res.status(400).json({ message: \"Username already taken\" });\n      }\n\n      // Hash password with bcrypt\n      const salt = await bcrypt.genSalt(10);\n      const hashedPassword = await bcrypt.hash(validatedData.password, salt);\n\n      // Create user with the hashed password\n      const user = await storage.insertUser({\n        ...validatedData,\n        password: hashedPassword,\n      });\n\n      console.log(`User registered successfully: ID=${user.id}, Username=${user.username}`);\n\n      // Remove password from the response data\n      const { password: _, ...userWithoutPassword } = user;\n\n      // Automatically log the user in after registration\n      req.login(userWithoutPassword, (err) => {\n        if (err) {\n          console.error(\"Error during auto-login after registration:\", err);\n          return res.status(500).json({ message: \"Registration successful, but automatic login failed\" });\n        }\n        \n        console.log(`User ${user.id} automatically logged in after registration`);\n        return res.status(201).json(userWithoutPassword);\n      });\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        console.log(\"Registration validation errors:\", error.errors);\n        return res.status(400).json({ \n          message: \"Validation error\",\n          errors: error.errors.map(e => ({\n            field: e.path.join('.'),\n            message: e.message\n          }))\n        });\n      }\n      console.error(\"Error registering user:\", error);\n      return res.status(500).json({ message: \"Internal server error during registration\" });\n    }\n  });\n\n  // User login\n  app.post(\"/api/auth/login\", (req, res, next) => {\n    try {\n      console.log(\"Login attempt for:\", req.body.email);\n      \n      // Log request details for debugging\n      console.log(\"Login headers:\", req.headers);\n      console.log(\"Login body:\", req.body);\n      \n      // Validate login data\n      loginUserSchema.parse(req.body);\n      \n      // Use passport for authentication\n      passport.authenticate(\"local\", (err: any, user: any, info: any) => {\n        if (err) {\n          console.error(\"Authentication error:\", err);\n          return next(err);\n        }\n        \n        // Authentication failed\n        if (!user) {\n          console.log(`Login failed for ${req.body.email}: ${info?.message || \"Unknown reason\"}`);\n          return res.status(401).json({ message: info?.message || \"Invalid email or password\" });\n        }\n        \n        // User authenticated, establish session\n        req.login(user, (err) => {\n          if (err) {\n            console.error(\"Session error during login:\", err);\n            return next(err);\n          }\n          \n          console.log(`User ${user.id} (${user.email}) authenticated, establishing session...`);\n          \n          // Force save the session immediately \n          req.session.save((err) => {\n            if (err) {\n              console.error(\"Error saving session:\", err);\n              return next(err);\n            }\n            \n            console.log(`User ${user.id} (${user.email}) logged in successfully`);\n            \n            // Debug session info\n            if (req.session) {\n              console.log(`Session created: id=${req.session.id}, expires=${req.session.cookie.expires}`);\n              console.log(\"Session cookie:\", req.session.cookie);\n              // Set a test value in the session\n              (req.session as any).loginTime = new Date().toISOString();\n              (req.session as any).userId = user.id;\n            }\n            \n            // Set the cookie manually to ensure persistence\n            res.cookie('pipol.sid', req.sessionID, {\n              maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days in milliseconds\n              httpOnly: true,\n              secure: false, // Change to true in production (HTTPS)\n              path: '/',\n              sameSite: 'none'\n            });\n            \n            // Log authentication status for debugging\n            console.log(\"Is authenticated after login:\", req.isAuthenticated());\n            \n            // Return user data without debug information for production use\n            return res.json(user);\n          });\n        });\n      })(req, res, next);\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        console.log(\"Login validation errors:\", error.errors);\n        return res.status(400).json({ \n          message: \"Invalid login data\", \n          errors: error.errors\n        });\n      }\n      console.error(\"Unexpected login error:\", error);\n      return res.status(500).json({ message: \"Internal server error during login\" });\n    }\n  });\n\n  // Test auth endpoint to verify authentication status\n  app.get(\"/api/auth/test\", (req, res) => {\n    try {\n      if (req.isAuthenticated()) {\n        console.log(`Auth test successful for user ${req.user.id}`);\n        return res.json({ \n          authenticated: true, \n          userId: req.user.id,\n          sessionId: req.sessionID\n        });\n      } else {\n        console.log(\"Auth test failed: Not authenticated\");\n        return res.status(401).json({ \n          authenticated: false,\n          sessionId: req.sessionID || null\n        });\n      }\n    } catch (error) {\n      console.error(\"Error in auth test:\", error);\n      return res.status(500).json({ message: \"Error checking authentication status\" });\n    }\n  });\n\n  // Get current user data\n  app.get(\"/api/auth/me\", (req, res) => {\n    try {\n      if (!req.isAuthenticated()) {\n        console.log(\"Auth check for GET /api/auth/me: Not authenticated\");\n        return res.status(401).json({ message: \"Not authenticated\" });\n      }\n      \n      if (!req.user) {\n        console.log(\"Auth check for GET /api/auth/me: User authenticated but no user data\");\n        return res.status(401).json({ message: \"User data not available\" });\n      }\n      \n      console.log(`User data requested for user ${req.user.id}`);\n      return res.json(req.user);\n    } catch (error) {\n      console.error(\"Error in /api/auth/me:\", error);\n      return res.status(500).json({ message: \"Internal server error\" });\n    }\n  });\n\n  // User logout\n  app.post(\"/api/auth/logout\", (req, res) => {\n    if (!req.isAuthenticated()) {\n      return res.status(200).json({ message: \"Already logged out\" });\n    }\n    \n    // Store user ID for logging\n    const userId = req.user.id;\n    console.log(`Logout requested for user ${userId}`);\n    \n    req.logout((err) => {\n      if (err) {\n        console.error(\"Error during logout:\", err);\n        return res.status(500).json({ message: \"Error during logout\" });\n      }\n      \n      // Destroy the session completely\n      req.session.destroy((err) => {\n        if (err) {\n          console.error(\"Error destroying session:\", err);\n        }\n        \n        console.log(`User ${userId} logged out successfully`);\n        res.clearCookie('connect.sid');\n        res.json({ message: \"Logged out successfully\" });\n      });\n    });\n  });\n  \n  // Proxy para solicitudes a la API de Google Places (para evitar problemas CORS)\n  app.get('/api/google-proxy/:service/:endpoint', async (req, res) => {\n    try {\n      const { service, endpoint } = req.params;\n      // Copiar los query params para no modificar el objeto original\n      const queryParams = { ...req.query };\n      \n      // Eliminar clave 'key' del query string\n      if (queryParams.key) {\n        delete queryParams.key;\n      }\n      \n      // Si es una solicitud de búsqueda, agregamos parámetros para mejorar los resultados\n      if (endpoint === 'textsearch' || endpoint === 'findplacefromtext') {\n        // Priorizar la región del usuario (Argentina) para mostrar resultados más relevantes\n        if (!queryParams.region && !queryParams.location) {\n          queryParams.region = 'ar'; // Argentina\n        }\n        \n        // Si la consulta es muy genérica (como 'parque'), agregar más contexto\n        if (queryParams.query && typeof queryParams.query === 'string' && queryParams.query.length < 10) {\n          // Agregar \"en Argentina\" o \"en Mexico\" según la región especificada\n          const region = queryParams.region || 'ar';\n          const countryName = region === 'ar' ? 'Argentina' : (region === 'mx' ? 'México' : '');\n          \n          if (countryName && !queryParams.query.includes(countryName)) {\n            queryParams.query = `${queryParams.query} en ${countryName}`;\n            console.log('Query modificada para mejorar resultados:', queryParams.query);\n          }\n        }\n        \n        // Parámetros para mejorar resultados\n        queryParams.language = 'es'; // Resultados en español\n        queryParams.inputtype = 'textquery';\n        \n        // Aumentar el número de resultados\n        if (!queryParams.maxResults) {\n          queryParams.maxResults = '10';\n        }\n      }\n      \n      // Usar la API key del servidor para mayor seguridad\n      const API_KEY = 'AIzaSyCy5iYWFh36MvrxPKr58A7TPd-f6YHtT1I';\n      \n      const urlParams = new URLSearchParams(queryParams as Record<string, string>).toString();\n      const url = `https://maps.googleapis.com/maps/api/${service}/${endpoint}?${urlParams}&key=${API_KEY}`;\n      console.log(`Proxying Google API request to: ${url}`);\n      \n      const response = await fetch(url);\n      \n      if (!response.ok) {\n        console.error('Error en respuesta HTTP de Google API:', response.status, response.statusText);\n        return res.status(response.status).json({ \n          status: 'ERROR',\n          error_message: `Error HTTP ${response.status}: ${response.statusText}` \n        });\n      }\n      \n      // Parsear la respuesta como texto primero para depurar cualquier problema\n      const responseText = await response.text();\n      \n      try {\n        // Intentar parsear JSON\n        const data = JSON.parse(responseText);\n        console.log('Google API response status:', data.status);\n        \n        if (data.status !== 'OK') {\n          console.log('Google API error details:', data.error_message || 'No error message provided');\n        } else {\n          console.log('Google API returned', data.results?.length || 0, 'results');\n        }\n        \n        return res.json(data);\n      } catch (jsonError) {\n        console.error('Error parsing Google API response as JSON:', jsonError);\n        console.error('Response text (first 200 chars):', responseText.substring(0, 200));\n        \n        return res.status(500).json({ \n          status: 'ERROR',\n          error_message: 'Error parsing Google API response',\n          response_preview: responseText.substring(0, 100) + '...' \n        });\n      }\n    } catch (error) {\n      console.error('Error proxy Google API:', error);\n      res.status(500).json({ \n        status: 'ERROR',\n        error_message: error instanceof Error ? error.message : 'Unknown error in Google API proxy'\n      });\n    }\n  });\n\n  // Event routes\n  // Ruta para obtener un evento específico por ID\n  app.get(\"/api/events/:id\", async (req, res) => {\n    try {\n      const eventId = parseInt(req.params.id);\n      const event = await storage.getEventById(eventId);\n      \n      if (!event) {\n        return res.status(404).json({ message: \"Evento no encontrado\" });\n      }\n      \n      // Incluir organizador\n      const organizer = await storage.getUserById(event.organizerId);\n      \n      // Obtener lista de asistentes\n      const attendees = await storage.getEventAttendees(eventId);\n      \n      // Formatear respuesta\n      const eventWithDetails = {\n        ...event,\n        organizer: organizer ? {\n          id: organizer.id,\n          name: organizer.name,\n          avatar: organizer.avatar\n        } : null,\n        attendees: attendees ? await Promise.all(attendees.map(async (attendee) => {\n          const user = await storage.getUserById(attendee.userId);\n          return {\n            id: attendee.id,\n            user: user ? {\n              id: user.id,\n              name: user.name,\n              avatar: user.avatar\n            } : null\n          };\n        })) : []\n      };\n      \n      res.json(eventWithDetails);\n    } catch (error) {\n      console.error(\"Error fetching event by ID:\", error);\n      res.status(500).json({ message: \"Error al obtener detalles del evento\" });\n    }\n  });\n  \n  // Obtener todos los eventos\n  app.get(\"/api/events\", async (req, res) => {\n    try {\n      const { lat, lng, radius, category, paymentType } = req.query;\n      \n      let events;\n      \n      // If lat and lng are provided, get nearby events\n      if (lat && lng) {\n        events = await storage.getNearbyEvents(\n          parseFloat(lat as string),\n          parseFloat(lng as string),\n          radius ? parseFloat(radius as string) : 10\n        );\n      } else {\n        // Otherwise get all events with filters\n        const filters: any = {};\n        \n        if (category) {\n          filters.category = Array.isArray(category) ? category : [category as string];\n        }\n        \n        if (paymentType) {\n          filters.paymentType = Array.isArray(paymentType) ? paymentType : [paymentType as string];\n        }\n        \n        events = await storage.getEvents(filters);\n      }\n      \n      res.json(events);\n    } catch (error) {\n      console.error(\"Error fetching events:\", error);\n      res.status(500).json({ message: \"Error fetching events\" });\n    }\n  });\n\n  app.get(\"/api/events/:id\", async (req, res) => {\n    try {\n      const eventId = parseInt(req.params.id);\n      const event = await storage.getEventById(eventId);\n      \n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      res.json(event);\n    } catch (error) {\n      console.error(\"Error fetching event:\", error);\n      res.status(500).json({ message: \"Error fetching event\" });\n    }\n  });\n\n  app.post(\"/api/events\", isAuthenticated, (req, res, next) => {\n    // Aplicar upload como middleware con manejo de errores integrado\n    // Usamos upload.any() para aceptar cualquier campo de archivo\n    // Esto evitará el error \"Unexpected field\"\n    const uploadMiddleware = upload.any();\n    \n    uploadMiddleware(req, res, (err) => {\n      if (err) {\n        return multerErrorHandler(err, req, res, next);\n      }\n      next();\n    });\n  }, async (req, res) => {\n    try {\n      console.log(\"Creando evento. Datos recibidos:\", JSON.stringify(req.body));\n      const userId = (req.user as any).id;\n      console.log(\"Usando organizerId:\", userId);\n      \n      // Definir interfaz para los elementos multimedia\n      interface MediaItem {\n        type: string;\n        url: string;\n        order: number;\n        isMain?: boolean;\n      }\n      \n      // CORRECCIÓN DEL BUG: El error \"undefined\" ocurre cuando hay problemas \n      // al procesar los archivos o el campo mediaItems durante la creación\n      \n      // Inicializamos variables con valores por defecto seguros\n      let photoUrl = '';\n      let videoUrl = '';\n      let mediaItems: MediaItem[] = [];\n      let mainMediaType = 'photo'; // Valor por defecto seguro\n      let mainMediaUrl = '';\n      const filesByField: {[key: string]: Express.Multer.File[]} = {};\n      \n      try {\n        // Procesamos archivos subidos si existen con validación robusta\n        const files = req.files as Express.Multer.File[] || [];\n        \n        // Loguear información útil para depuración\n        console.log(\"¿Hay archivos?\", Array.isArray(files) && files.length > 0);\n        \n        if (Array.isArray(files) && files.length > 0) {\n          console.log(\"Archivos recibidos:\", files.map(f => ({\n            fieldname: f.fieldname,\n            originalname: f.originalname,\n            mimetype: f.mimetype,\n            size: f.size\n          })));\n          \n          // Agrupar archivos por fieldname para facilitar procesamiento con validación\n          files.forEach(file => {\n            if (file && file.fieldname) {\n              if (!filesByField[file.fieldname]) {\n                filesByField[file.fieldname] = [];\n              }\n              filesByField[file.fieldname].push(file);\n            }\n          });\n        } else {\n          console.log(\"No se recibieron archivos adjuntos\");\n        }\n      } catch (err) {\n        console.error(\"Error al procesar archivos:\", err);\n        // No propagamos el error, continuamos con un estado limpio\n      }\n      \n      console.log(\"Campos de archivos encontrados:\", Object.keys(filesByField).length > 0 ? Object.keys(filesByField) : \"ninguno\");\n      \n      // Procesar archivo principal (retrocompatibilidad)\n      if (filesByField.eventPhoto) {\n        const photoFile = filesByField.eventPhoto[0];\n        const photoPath = photoFile.path.replace('public', '');\n        photoUrl = photoPath; // URL relativa para el navegador\n        console.log(`Procesando eventPhoto: ${photoFile.originalname} -> ${photoPath}`);\n        \n        // Si no hay un medio principal definido, usar esta foto como principal\n        if (!mainMediaUrl) {\n          mainMediaUrl = photoPath;\n          mainMediaType = 'photo';\n          console.log(`Estableciendo eventPhoto como medio principal: ${photoPath}`);\n        }\n        \n        // No añadimos a mediaItems aquí, lo haremos mediante MediaManager\n      }\n      \n      if (filesByField.eventVideo) {\n        const videoFile = filesByField.eventVideo[0];\n        const videoPath = videoFile.path.replace('public', '');\n        videoUrl = videoPath; // URL relativa para el navegador\n        console.log(`Procesando eventVideo: ${videoFile.originalname} -> ${videoPath}`);\n        \n        // No añadimos a mediaItems aquí, lo haremos mediante MediaManager\n      }\n      \n      // Procesar fotos adicionales (retrocompatibilidad)\n      if (filesByField.photos) {\n        const photoUrls = filesByField.photos.map(file => {\n          console.log(`Procesando foto adicional: ${file.originalname}`);\n          return file.path.replace('public', '');\n        });\n        \n        // Si no hay un medio principal definido y hay fotos, usar la primera foto como principal\n        if (!mainMediaUrl && photoUrls.length > 0) {\n          mainMediaUrl = photoUrls[0];\n          mainMediaType = 'photo';\n          console.log(`Estableciendo primera foto como medio principal: ${mainMediaUrl}`);\n        }\n        \n        // No añadimos a mediaItems aquí, lo haremos mediante MediaManager\n      }\n      \n      // Procesar videos adicionales (retrocompatibilidad)\n      if (filesByField.videos) {\n        filesByField.videos.forEach(file => {\n          console.log(`Procesando video adicional: ${file.originalname}`);\n          // No añadimos a mediaItems aquí, lo haremos mediante MediaManager\n        });\n      }\n      \n      // Procesar el archivo principal especificado\n      if (filesByField.mainMediaFile) {\n        const mainFile = filesByField.mainMediaFile[0];\n        const mediaPath = mainFile.path.replace('public', '');\n        // Determinar tipo según el mimetype\n        const isVideo = mainFile.mimetype.startsWith('video/');\n        mainMediaType = isVideo ? 'video' : 'photo';\n        mainMediaUrl = mediaPath;\n        \n        console.log(\"======= ESTABLECIENDO MEDIA PRINCIPAL EXPLÍCITO =======\");\n        console.log(`ARCHIVO: ${mainFile.originalname}`);\n        console.log(`TIPO: ${mainMediaType}`);\n        console.log(`URL: ${mainMediaUrl}`);\n        console.log(`TAMAÑO: ${(mainFile.size/1024).toFixed(1)}KB`);\n        console.log(\"=====================================================\");\n      }\n      \n      // Procesar archivos de MediaManager con robusto manejo de errores y validación\n      // para evitar el error \"undefined\" cuando faltan valores\n      // Primero verificar si existe la información de mediaItems como JSON\n      if (req.body && req.body.mediaItems) {\n        try {\n          console.log(\"MediaItems JSON recibido:\", req.body.mediaItems);\n          \n          // Parse de la información de mediaItems con validación para evitar undefined\n          let mediaItemsInfo = [];\n          try {\n            mediaItemsInfo = JSON.parse(req.body.mediaItems) || [];\n            // Asegurar que es un array\n            if (!Array.isArray(mediaItemsInfo)) {\n              console.warn(\"mediaItemsInfo no es un array, usando array vacío\");\n              mediaItemsInfo = [];\n            }\n          } catch (parseError) {\n            console.error(\"Error al parsear JSON de mediaItems:\", parseError);\n            console.warn(\"Usando array vacío como valor seguro para mediaItemsInfo\");\n            mediaItemsInfo = [];\n          }\n          \n          console.log(\"MediaItems parseado:\", mediaItemsInfo);\n          \n          // Buscar archivos subidos con patrón mediaFile_X con validación para objetos undefined\n          const mediaFileKeys = Object.keys(filesByField || {})\n            .filter(key => key && typeof key === 'string' && key.startsWith('mediaFile_'));\n            \n          console.log(\"Claves de archivos multimedia encontradas:\", mediaFileKeys);\n          console.log(\"Todos los archivos recibidos:\", Object.keys(filesByField || {}));\n          \n          // Variable para rastrear el elemento principal con inicialización segura\n          let mainItemFound = false;\n          \n          if (mediaFileKeys.length > 0) {\n            console.log(`Procesando ${mediaFileKeys.length} archivos de MediaManager`);\n            \n            // No vaciamos el array de mediaItems para mantener la compatibilidad\n            // mediaItems = [];\n            \n            // Crear nueva lista mediaItems basada en los archivos subidos y la metadata\n            const newMediaItems: MediaItem[] = [];\n            \n            // Contador para validar límites\n            let photoCount = 0;\n            let videoCount = 0;\n            const MAX_PHOTOS = 6;\n            const MAX_VIDEOS = 3;\n            const MAX_PHOTO_SIZE = 5 * 1024 * 1024; // 5MB\n            const MAX_VIDEO_SIZE = 10 * 1024 * 1024; // 10MB\n            \n            // Crear un array de promesas para procesar todos los archivos\n            for (const key of mediaFileKeys) {\n              try {\n                // Acceso seguro a los archivos utilizando filesByField\n                if (!filesByField[key] || !filesByField[key][0]) {\n                  console.warn(`No se encontró archivo para ${key}`);\n                  continue;\n                }\n                \n                const file = filesByField[key][0];\n                const mediaPath = file.path.replace('public', '');\n                \n                // Extraer índice del nombre de campo (mediaFile_X)\n                const indexMatch = key.match(/mediaFile_(\\d+)/);\n                if (!indexMatch) {\n                  console.warn(`No se pudo extraer índice de ${key}`);\n                  continue;\n                }\n                \n                const index = parseInt(indexMatch[1]);\n                \n                // Determinar el tipo de archivo\n                const isVideo = file.mimetype.startsWith('video/');\n                const fileType = isVideo ? 'video' : 'photo';\n                \n                // Validar tamaño del archivo\n                const isOversize = isVideo \n                  ? file.size > MAX_VIDEO_SIZE \n                  : file.size > MAX_PHOTO_SIZE;\n                \n                if (isOversize) {\n                  console.warn(`Archivo ${key} excede el tamaño máximo permitido: ${(file.size / (1024 * 1024)).toFixed(1)}MB`);\n                  \n                  // Eliminar el archivo que excede el tamaño\n                  try {\n                    fs.unlinkSync(file.path);\n                    console.log(`Archivo sobredimensionado eliminado: ${file.path}`);\n                  } catch (unlinkError) {\n                    console.error(`Error eliminando archivo sobredimensionado: ${file.path}`, unlinkError);\n                  }\n                  \n                  continue;\n                }\n                \n                // Verificar límites por tipo\n                if (isVideo && videoCount >= MAX_VIDEOS) {\n                  console.warn(`Se excedió el límite de videos (${MAX_VIDEOS}), omitiendo ${key}`);\n                  \n                  // Eliminar el archivo excedente\n                  try {\n                    fs.unlinkSync(file.path);\n                    console.log(`Archivo excedente eliminado: ${file.path}`);\n                  } catch (unlinkError) {\n                    console.error(`Error eliminando archivo excedente: ${file.path}`, unlinkError);\n                  }\n                  \n                  continue;\n                } else if (!isVideo && photoCount >= MAX_PHOTOS) {\n                  console.warn(`Se excedió el límite de fotos (${MAX_PHOTOS}), omitiendo ${key}`);\n                  \n                  // Eliminar el archivo excedente\n                  try {\n                    fs.unlinkSync(file.path);\n                    console.log(`Archivo excedente eliminado: ${file.path}`);\n                  } catch (unlinkError) {\n                    console.error(`Error eliminando archivo excedente: ${file.path}`, unlinkError);\n                  }\n                  \n                  continue;\n                }\n                \n                // Incrementar el contador correspondiente\n                if (isVideo) {\n                  videoCount++;\n                } else {\n                  photoCount++;\n                }\n                \n                // Buscar la metadata correspondiente con validación robusta\n                let matchedMetadata = null;\n                \n                // Buscar por ID en la metadata con múltiples capas de validación\n                if (Array.isArray(mediaItemsInfo) && mediaItemsInfo.length > 0) {\n                  for (const item of mediaItemsInfo) {\n                    // Verificar que el item es un objeto válido\n                    if (item && typeof item === 'object') {\n                      // Verificar si el índice del elemento coincide con el índice del archivo\n                      // o si la propiedad id contiene el índice\n                      const hasMatchingOrder = typeof item.order === 'number' && item.order === index;\n                      const hasMatchingId = item.id && typeof item.id === 'string' && item.id.includes(`_${index}`);\n                      \n                      if (hasMatchingOrder || hasMatchingId) {\n                        matchedMetadata = item;\n                        console.log(`Encontrada metadata para archivo ${key} por ID/orden:`, matchedMetadata);\n                        break;\n                      }\n                    }\n                  }\n                  \n                  // Si no encontramos por ID, intentamos por posición en la lista con validación\n                  if (!matchedMetadata && index < mediaItemsInfo.length) {\n                    const possibleMatch = mediaItemsInfo[index];\n                    // Verificar que el elemento encontrado es un objeto válido\n                    if (possibleMatch && typeof possibleMatch === 'object') {\n                      matchedMetadata = possibleMatch;\n                      console.log(`Encontrada metadata para archivo ${key} por posición en array:`, matchedMetadata);\n                    }\n                  }\n                }\n                \n                // Si aún no tenemos metadata, creamos un objeto seguro con valores por defecto\n                if (!matchedMetadata) {\n                  console.log(`No se encontró metadata para archivo ${key}, usando valores por defecto`);\n                  matchedMetadata = {\n                    type: fileType, // Usar el tipo detectado del mimetype\n                    order: index,\n                    isMain: false\n                  };\n                }\n                \n                // Log para depuración\n                console.log(`Procesando archivo ${key} con metadata final:`, matchedMetadata);\n                \n                // Crear el objeto MediaItem con valores por defecto seguros\n                // para evitar cualquier valor undefined o null\n                const mediaItem: MediaItem = {\n                  // Usar tipo de la metadata o determinarlo por el mimetype con valor seguro\n                  type: (matchedMetadata && matchedMetadata.type) ? matchedMetadata.type : fileType,\n                  url: mediaPath,\n                  // Usar orden de la metadata o usar el índice con valor seguro\n                  order: (matchedMetadata && typeof matchedMetadata.order === 'number') ? \n                         matchedMetadata.order : index,\n                  // Usar isMain de la metadata o false por defecto con verificación estricta\n                  isMain: !!(matchedMetadata && matchedMetadata.isMain === true)\n                };\n                \n                console.log(`Media item creado: ${mediaItem.type}, isMain: ${mediaItem.isMain}, URL: ${mediaItem.url}`);\n                \n                console.log(`Procesado archivo ${key}: ${mediaItem.type}, isMain: ${mediaItem.isMain}, tamaño: ${(file.size / 1024).toFixed(1)}KB`);\n                newMediaItems.push(mediaItem);\n                \n                // Si es el elemento principal, actualizar mainMediaType y mainMediaUrl\n                if (mediaItem.isMain) {\n                  mainMediaType = mediaItem.type;\n                  mainMediaUrl = mediaItem.url;\n                  console.log(`Archivo ${key} establecido como principal: ${mainMediaType} - ${mainMediaUrl}`);\n                }\n              } catch (error) {\n                console.error(`Error procesando archivo ${key}:`, error);\n              }\n            }\n            \n            // Reemplazar mediaItems con los nuevos\n            if (newMediaItems.length > 0) {\n              // Ordenar por la propiedad order para mantener el orden especificado\n              newMediaItems.sort((a, b) => (a.order || 0) - (b.order || 0));\n              \n              // Verificar si hay un elemento principal\n              const hasMainItem = newMediaItems.some(item => item.isMain === true);\n              \n              console.log(`¿Existe elemento principal explícito? ${hasMainItem}`);\n              \n              // Si no hay elemento principal, establecer el primero como principal\n              // priorizando fotos sobre videos\n              if (!hasMainItem && newMediaItems.length > 0) {\n                const firstPhoto = newMediaItems.find(item => item.type === 'photo');\n                const itemToSetMain = firstPhoto || newMediaItems[0];\n                \n                itemToSetMain.isMain = true;\n                mainMediaType = itemToSetMain.type;\n                mainMediaUrl = itemToSetMain.url;\n                \n                console.log(`Estableciendo elemento principal automáticamente: ${mainMediaType} - ${mainMediaUrl}`);\n              } else if (hasMainItem) {\n                // Obtener el elemento principal explícito\n                const mainItem = newMediaItems.find(item => item.isMain === true);\n                if (mainItem) {\n                  mainMediaType = mainItem.type;\n                  mainMediaUrl = mainItem.url;\n                  console.log(`Usando elemento principal explícito: ${mainMediaType} - ${mainMediaUrl}`);\n                }\n              }\n              \n              // Simplificamos el procesamiento de los archivos multimedia\n              \n              // Reemplazamos completamente los mediaItems con los nuevos elementos\n              // Esto evita la duplicación de archivos\n              mediaItems = newMediaItems;\n              console.log(\"Reemplazando mediaItems con los nuevos elementos procesados\");\n              \n              console.log(`Total de elementos multimedia: ${mediaItems.length} (incluyendo ${newMediaItems.length} nuevos)`);\n              console.log(`Composición: ${mediaItems.filter(i => i.type === 'photo').length} fotos, ${mediaItems.filter(i => i.type === 'video').length} videos`);\n            }\n          }\n        } catch (error) {\n          console.error(\"Error procesando mediaItems JSON:\", error);\n        }\n      }\n      \n      // Verificar si tenemos elementos multimedia antes de continuar\n      console.log(\"Estado final de los mediaItems antes de guardar:\", \n        mediaItems.map(item => ({\n          tipo: item.type,\n          url: item.url,\n          orden: item.order || 0,\n          principal: item.isMain || false\n        }))\n      );\n      \n      // Verificar estado de los medios principales\n      console.log(\"Media principal:\", {\n        mainMediaType,\n        mainMediaUrl\n      });\n      \n      // Convertir mediaItems a JSON string\n      const mediaItemsJson = JSON.stringify(mediaItems);\n      \n      try {\n        const validatedData = insertEventSchema.parse({\n          ...req.body,\n          organizerId: userId,\n          // Añadir URLs de los archivos (mantener por compatibilidad)\n          photoUrl: photoUrl || req.body.photoUrl || null,\n          videoUrl: videoUrl || req.body.videoUrl || null,\n          // Nuevos campos multimedia\n          mediaItems: mediaItemsJson,\n          mainMediaType: mainMediaType,\n          mainMediaUrl: mainMediaUrl\n        });\n        console.log(\"Datos validados:\", JSON.stringify(validatedData));\n        \n        const event = await storage.insertEvent(validatedData);\n        console.log(\"Evento creado con éxito:\", JSON.stringify(event));\n        res.status(201).json(event);\n      } catch (validationError) {\n        console.error(\"Error de validación:\", validationError);\n        // Si hay error, eliminar los archivos subidos\n        // Con upload.any() ya no tenemos acceso a los archivos así\n        // Eliminamos los archivos por el array filesByField\n        if (filesByField.eventPhoto && filesByField.eventPhoto.length > 0) {\n          try {\n            fs.unlinkSync(filesByField.eventPhoto[0].path);\n          } catch (err) {\n            console.error(\"Error al eliminar archivo:\", err);\n          }\n        }\n        if (filesByField.eventVideo && filesByField.eventVideo.length > 0) {\n          try {\n            fs.unlinkSync(filesByField.eventVideo[0].path);\n          } catch (err) {\n            console.error(\"Error al eliminar archivo:\", err);\n          }\n        }\n        \n        if (validationError instanceof z.ZodError) {\n          return res.status(400).json({ errors: validationError.errors });\n        }\n        throw validationError;\n      }\n    } catch (error) {\n      console.error(\"Error completo al crear evento:\", error);\n      \n      // Check if this is a foreign key constraint error\n      if (error instanceof Error && \n          error.toString().includes(\"violates foreign key constraint\") &&\n          error.toString().includes(\"events_organizer_id_users_id_fk\")) {\n        return res.status(401).json({ \n          message: \"You need to sign up and log in before creating an event\",\n          code: \"USER_NOT_FOUND\"\n        });\n      }\n      \n      res.status(500).json({ message: \"Error creating event\", error: String(error) });\n    }\n  });\n\n  // Ruta PUT para actualización básica sin archivos\n  app.put(\"/api/events/:id\", isAuthenticated, async (req, res) => {\n    try {\n      // Debug: Qué contiene la solicitud PUT\n      console.log(\"===== DATOS RECIBIDOS EN PUT =====\");\n      console.log(\"Content-Type:\", req.get('Content-Type'));\n      console.log(\"Headers:\", JSON.stringify(req.headers, null, 2));\n      console.log(\"Body keys:\", Object.keys(req.body));\n      \n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      // Check if event exists\n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      // Check if user is the organizer\n      if (event.organizerId !== user.id) {\n        return res.status(403).json({ message: \"Not authorized to update this event\" });\n      }\n      \n      // Create a copy of the request body for updating\n      const updateData = { ...req.body };\n      \n      // Procesar la fecha correctamente si existe\n      if (updateData.date) {\n        try {\n          // Convertir la fecha a un objeto Date apropiado\n          updateData.date = new Date(updateData.date);\n          console.log(\"Date converted to:\", updateData.date);\n        } catch (error) {\n          console.error(\"Error converting date:\", error);\n          return res.status(400).json({ message: \"Invalid date format\" });\n        }\n      }\n      \n      // Procesar mediaItems si existen para actualizar mainMediaType y mainMediaUrl\n      if (updateData.mediaItems) {\n        console.log(\"Actualizando evento en la base de datos. ID:\", eventId);\n        console.log(\"Datos de multimedia a guardar:\");\n        console.log(\"- mediaItems:\", updateData.mediaItems);\n        console.log(\"- mainMediaType:\", updateData.mainMediaType);\n        console.log(\"- mainMediaUrl:\", updateData.mainMediaUrl);\n        \n        try {\n          // Convertir mediaItems de string a objeto JSON si es necesario\n          let mediaItems = updateData.mediaItems;\n          if (typeof mediaItems === 'string') {\n            mediaItems = JSON.parse(mediaItems);\n          }\n          \n          // Buscar el elemento principal\n          const mainItem = Array.isArray(mediaItems) ? \n            mediaItems.find(item => item && item.isMain === true) : null;\n          \n          // Si hay un elemento principal, actualizar mainMediaType y mainMediaUrl\n          if (mainItem) {\n            updateData.mainMediaType = mainItem.type;\n            updateData.mainMediaUrl = mainItem.url;\n            console.log(\"Elemento principal encontrado y actualizado:\", {\n              type: mainItem.type,\n              url: mainItem.url\n            });\n          } else if (Array.isArray(mediaItems) && mediaItems.length > 0) {\n            // Si no hay elemento principal pero hay elementos, usar el primero\n            updateData.mainMediaType = mediaItems[0].type;\n            updateData.mainMediaUrl = mediaItems[0].url;\n            console.log(\"Usando primer elemento como principal por defecto:\", {\n              type: mediaItems[0].type,\n              url: mediaItems[0].url\n            });\n          }\n        } catch (error) {\n          console.error(\"Error procesando mediaItems:\", error);\n        }\n        \n        // Verificación después de actualizar\n        console.log(\"Verificación después de actualizar:\");\n        console.log(\"- mediaItems almacenados:\", updateData.mediaItems);\n        console.log(\"- mainMediaType almacenado:\", updateData.mainMediaType);\n        console.log(\"- mainMediaUrl almacenado:\", updateData.mainMediaUrl);\n      }\n      \n      // Obtener evento original para comparar medios\n      const originalEvent = await storage.getEventById(eventId);\n      \n      // Detectar si hay cambios en los medios\n      let mediaChanged = false;\n      \n      if (originalEvent) {\n        // Verificar cambios en URL de medio principal o tipo\n        if (originalEvent.mainMediaUrl !== updateData.mainMediaUrl || \n            originalEvent.mainMediaType !== updateData.mainMediaType) {\n          mediaChanged = true;\n          console.log(\"Cambio detectado en medio principal:\");\n          console.log(`- Original: ${originalEvent.mainMediaType} - ${originalEvent.mainMediaUrl}`);\n          console.log(`- Nuevo: ${updateData.mainMediaType} - ${updateData.mainMediaUrl}`);\n        }\n        \n        // Verificar cambios en la colección de medios\n        try {\n          const originalMediaItems = originalEvent.mediaItems ? JSON.parse(originalEvent.mediaItems) : [];\n          const newMediaItems = typeof updateData.mediaItems === 'string' \n            ? JSON.parse(updateData.mediaItems) \n            : updateData.mediaItems;\n            \n          if (JSON.stringify(originalMediaItems) !== JSON.stringify(newMediaItems)) {\n            mediaChanged = true;\n            console.log(\"Cambio detectado en colección de medios\");\n          }\n        } catch (error) {\n          console.error(\"Error comparando mediaItems:\", error);\n        }\n      }\n      \n      // Update event\n      const updatedEvent = await storage.updateEvent(eventId, updateData);\n      console.log(\"Evento actualizado correctamente.\");\n      console.log(`¿Hubo cambios en los medios? ${mediaChanged ? 'SÍ' : 'NO'}`);\n      \n      // Broadcast event update to all connected clients via WebSocket\n      broadcastMessage({\n        type: 'event_updated',\n        event: updatedEvent,\n        updatedBy: user.id  // Agregar el ID del usuario que realizó la actualización\n      });\n      \n      // Si se actualizó el medio principal, envía un mensaje específico para esto\n      if (mediaChanged) {\n        broadcastMessage({\n          type: 'event_media_updated',\n          eventId: updatedEvent.id,\n          updatedBy: user.id\n        });\n      }\n      \n      console.log(\"Notificación de actualización de evento enviada a todos los clientes WebSocket\");\n      \n      res.json(updatedEvent);\n    } catch (error) {\n      console.error(\"Error updating event:\", error);\n      res.status(500).json({ message: \"Error updating event\" });\n    }\n  });\n  \n  // Ruta PATCH para actualización con archivos\n  app.patch(\"/api/events/:id\", isAuthenticated, (req, res, next) => {\n    // Aplicar upload como middleware con manejo de errores integrado\n    const uploadMiddleware = upload.fields([\n      { name: 'eventPhoto', maxCount: 1 }, // Mantener para compatibilidad\n      { name: 'eventVideo', maxCount: 1 }, // Mantener para compatibilidad\n      { name: 'photos', maxCount: 6 },  // Permitir hasta 6 fotos en total\n      { name: 'videos', maxCount: 3 },  // Permitir hasta 3 videos en total\n      { name: 'mainMedia', maxCount: 1 }, // Archivo principal (puede ser foto o video)\n      { name: 'mainMediaFile', maxCount: 1 }, // Archivo principal (nuevo nombre usado en el frontend)\n      // Nuevos campos para MediaManager\n      { name: 'mediaFile_0', maxCount: 1 },\n      { name: 'mediaFile_1', maxCount: 1 },\n      { name: 'mediaFile_2', maxCount: 1 },\n      { name: 'mediaFile_3', maxCount: 1 },\n      { name: 'mediaFile_4', maxCount: 1 },\n      { name: 'mediaFile_5', maxCount: 1 },\n      { name: 'mediaFile_6', maxCount: 1 },\n      { name: 'mediaFile_7', maxCount: 1 },\n      { name: 'mediaFile_8', maxCount: 1 },\n      { name: 'mediaFile_9', maxCount: 1 }\n    ]);\n    \n    uploadMiddleware(req, res, (err) => {\n      if (err) {\n        return multerErrorHandler(err, req, res, next);\n      }\n      next();\n    });\n  }, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      // Check if event exists\n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      // Check if user is the organizer\n      if (event.organizerId !== user.id) {\n        return res.status(403).json({ message: \"Not authorized to update this event\" });\n      }\n      \n      // Procesar archivos subidos\n      const files = req.files as { [fieldname: string]: Express.Multer.File[] };\n      \n      // Datos para actualizar\n      const updateData: any = { ...req.body };\n      \n      // Procesar la fecha correctamente si existe\n      if (updateData.date) {\n        try {\n          // Convertir la fecha a un objeto Date apropiado\n          updateData.date = new Date(updateData.date);\n          console.log(\"Date converted to:\", updateData.date);\n        } catch (error) {\n          console.error(\"Error converting date:\", error);\n          return res.status(400).json({ message: \"Invalid date format\" });\n        }\n      }\n      \n      // Definir interfaz para los elementos multimedia\n      interface MediaItem {\n        type: string;\n        url: string;\n        order: number;\n        isMain?: boolean;\n      }\n      \n      // Definir interfaces para la información de medios\n      interface MediaItemInfo {\n        id?: string;\n        type: string;\n        url?: string;\n        isMain?: boolean;\n        isNew?: boolean;\n        fileIndex?: number;\n        order?: number;\n        deleted?: boolean;\n        toDelete?: boolean;\n      }\n      \n      // Definir array para almacenar los elementos multimedia\n      let mediaItems: MediaItem[] = [];\n      let mainMediaType = req.body.mainMediaType || 'photo';\n      let mainMediaUrl = req.body.mainMediaUrl || '';\n      \n      // Parsear información de elementos multimedia si existe\n      let mediaItemsInfo: MediaItemInfo[] = [];\n      if (req.body.mediaItemsInfo) {\n        try {\n          mediaItemsInfo = JSON.parse(req.body.mediaItemsInfo);\n          console.log(\"Información de elementos multimedia:\", mediaItemsInfo);\n        } catch (e) {\n          console.warn(\"Error al parsear mediaItemsInfo:\", e);\n          mediaItemsInfo = [];\n        }\n      }\n      \n      // Si ya hay elementos multimedia en la base de datos, cargarlos\n      if (event.mediaItems) {\n        try {\n          mediaItems = JSON.parse(event.mediaItems);\n        } catch (e) {\n          console.warn(\"No se pudo parsear mediaItems del evento:\", e);\n          // Inicializar como array vacío si hay error\n          mediaItems = [];\n        }\n      }\n      \n      // Verificar si el usuario quiere eliminar archivos existentes\n      if (req.body.resetMedia === 'true' || req.body.resetMedia === true) {\n        mediaItems = []; // Eliminar todos los archivos multimedia existentes\n        mainMediaUrl = ''; // Resetear el medio principal\n      }\n      \n      // Procesar elementos marcados para eliminar\n      const itemsToDelete = mediaItemsInfo.filter(info => info.url && (info.toDelete || info.deleted));\n      \n      if (itemsToDelete.length > 0) {\n        console.log(`Se encontraron ${itemsToDelete.length} elementos marcados para eliminar`);\n        \n        // Filtrar mediaItems para excluir los elementos marcados para eliminación\n        mediaItems = mediaItems.filter(item => {\n          // Verificar si este item coincide con alguno marcado para eliminar\n          const shouldDelete = itemsToDelete.some(\n            deleteItem => deleteItem.url === item.url && deleteItem.type === item.type\n          );\n          \n          // Si se va a eliminar el medio principal, resetear mainMediaUrl\n          if (shouldDelete && item.url === mainMediaUrl) {\n            console.log(`Eliminando el medio principal actual: ${item.url}`);\n            mainMediaUrl = '';\n            mainMediaType = 'photo'; // Default to photo to avoid enum error\n          }\n          \n          // Devolver true para mantener, false para eliminar\n          return !shouldDelete;\n        });\n        \n        console.log(`Quedan ${mediaItems.length} elementos multimedia después de eliminar los marcados`);\n      }\n      \n      // Si aún hay elementos multimedia después de las eliminaciones, \n      // asegurarse de que haya un elemento principal si el anterior fue eliminado\n      if (mediaItems.length > 0 && !mainMediaUrl) {\n        // Buscar algún elemento marcado como principal\n        const mainItem = mediaItems.find(item => item.isMain);\n        \n        if (mainItem) {\n          // Usar el elemento que ya está marcado como principal\n          mainMediaUrl = mainItem.url;\n          mainMediaType = mainItem.type;\n          console.log(`Usando elemento marcado como principal: ${mainItem.url}`);\n        } else {\n          // Si no hay ninguno, usar el primer elemento disponible\n          mainMediaUrl = mediaItems[0].url;\n          mainMediaType = mediaItems[0].type;\n          mediaItems[0].isMain = true; // Marcar como principal\n          console.log(`Estableciendo nuevo elemento principal por defecto: ${mainMediaUrl}`);\n        }\n      }\n      \n      // Procesar la foto principal (mantener por compatibilidad)\n      if (files.eventPhoto && files.eventPhoto.length > 0) {\n        const photoPath = files.eventPhoto[0].path.replace('public', '');\n        updateData.photo_url = photoPath;\n        \n        // Añadir a mediaItems si no existe ya\n        if (!mediaItems.some(item => item.url === photoPath)) {\n          mediaItems.push({ type: 'photo', url: photoPath, order: mediaItems.length });\n        }\n        \n        // Si no hay media principal o se solicitó resetear, usar esta foto\n        if (!mainMediaUrl || req.body.resetMedia) {\n          mainMediaUrl = photoPath;\n          mainMediaType = 'photo';\n        }\n      }\n      \n      // Procesar el video principal (mantener por compatibilidad)\n      if (files.eventVideo && files.eventVideo.length > 0) {\n        const videoPath = files.eventVideo[0].path.replace('public', '');\n        updateData.video_url = videoPath;\n        \n        // Añadir a mediaItems si no existe ya\n        if (!mediaItems.some(item => item.url === videoPath)) {\n          mediaItems.push({ type: 'video', url: videoPath, order: mediaItems.length });\n        }\n      }\n      \n      // Procesar fotos adicionales (hasta 6 en total)\n      if (files.photos && files.photos.length > 0) {\n        const photoUrls = files.photos.map(file => file.path.replace('public', ''));\n        console.log(`Procesando ${photoUrls.length} nuevas fotos subidas`);\n        \n        // Buscar elementos marcados como principales en la información\n        // Tanto archivos existentes como nuevos\n        const mainPhotoInfo = mediaItemsInfo.find(info => \n          info.isMain && info.isNew && info.type === 'photo'\n        );\n        \n        console.log(\"Info de fotos principales:\", mainPhotoInfo ? JSON.stringify(mainPhotoInfo) : \"ninguna\");\n          \n        // Añadir a la lista de medios\n        photoUrls.forEach((url, index) => {\n          if (!mediaItems.some(item => item.url === url)) {\n            // Verificar si este elemento debe ser el principal\n            // Si se ha marcado explícitamente este archivo nuevo como principal\n            // o si no hay un medio principal definido y este es el primer elemento\n            let isPhotoMain = false;\n            \n            // Revisar si este archivo está marcado como principal en la info\n            if (mainPhotoInfo) {\n              // Compara el índice del archivo con el que está en la información\n              isPhotoMain = mainPhotoInfo.fileIndex === index;\n              console.log(`Verificando si foto ${index} es principal según mainPhotoInfo: ${isPhotoMain}`);\n            } else if (!mainMediaUrl && mediaItems.length === 0) {\n              // Si no hay principal definido, usar el primer elemento\n              isPhotoMain = true;\n              console.log(`Estableciendo foto ${index} como principal por defecto (primera foto)`);\n            }\n            \n            // Añadir el elemento a la lista\n            mediaItems.push({ \n              type: 'photo', \n              url, \n              order: mediaItems.length, // Asignar orden secuencial\n              isMain: isPhotoMain\n            });\n            \n            // Si es principal, actualizar las variables de control\n            if (isPhotoMain) {\n              mainMediaUrl = url;\n              mainMediaType = 'photo';\n              console.log(`Estableciendo nueva foto subida como principal: ${url}`);\n              \n              // Asegurarse de que ningún otro elemento sea principal\n              mediaItems.forEach(item => {\n                if (item.url !== url) {\n                  item.isMain = false;\n                }\n              });\n            }\n          }\n        });\n        \n        // Si después de todo el proceso no hay un medio principal definido \n        // y hay fotos nuevas, usar la primera foto como principal\n        if (!mainMediaUrl && photoUrls.length > 0) {\n          mainMediaUrl = photoUrls[0];\n          mainMediaType = 'photo';\n          \n          // Actualizar el indicador isMain en el array de medios\n          const firstPhotoIndex = mediaItems.findIndex(item => \n            item.type === 'photo' && item.url === photoUrls[0]\n          );\n          \n          if (firstPhotoIndex >= 0) {\n            // Marcar el primer elemento como principal\n            mediaItems.forEach((item, idx) => {\n              item.isMain = idx === firstPhotoIndex;\n            });\n          }\n          \n          console.log(`Estableciendo nueva foto como principal (último recurso): ${mainMediaUrl}`);\n        }\n      }\n      \n      // Procesar videos adicionales (hasta 3 en total)\n      if (files.videos && files.videos.length > 0) {\n        const videoUrls = files.videos.map(file => file.path.replace('public', ''));\n        console.log(`Procesando ${videoUrls.length} nuevos videos subidos`);\n        \n        // Obtener información sobre cuál video debe ser el principal (si hay)\n        const mainVideoInfo = mediaItemsInfo.find(info => \n          info.isMain && info.isNew && info.type === 'video'\n        );\n        \n        console.log(\"Info de videos principales:\", mainVideoInfo ? JSON.stringify(mainVideoInfo) : \"ninguna\");\n        \n        // Añadir a la lista de medios\n        videoUrls.forEach((url, index) => {\n          if (!mediaItems.some(item => item.url === url)) {\n            // Verificar si este elemento debe ser el principal\n            let isVideoMain = false;\n            \n            // Revisar si este archivo está marcado como principal en la info\n            if (mainVideoInfo) {\n              // Compara el índice del archivo con el que está en la información\n              isVideoMain = mainVideoInfo.fileIndex === index;\n              console.log(`Verificando si video ${index} es principal según mainVideoInfo: ${isVideoMain}`);\n            } else if (!mainMediaUrl && mediaItems.length === 0) {\n              // Si no hay principal definido, usar el primer elemento\n              isVideoMain = true;\n              console.log(`Estableciendo video ${index} como principal por defecto (primer video)`);\n            }\n              \n            mediaItems.push({ \n              type: 'video', \n              url, \n              order: mediaItems.length, // Asignar orden secuencial\n              isMain: isVideoMain\n            });\n            \n            // Si es principal, actualizar las variables de control\n            if (isVideoMain) {\n              mainMediaUrl = url;\n              mainMediaType = 'video';\n              console.log(`Estableciendo nuevo video subido como principal: ${url}`);\n              \n              // Asegurarse de que ningún otro elemento sea principal\n              mediaItems.forEach(item => {\n                if (item.url !== url) {\n                  item.isMain = false;\n                }\n              });\n            }\n          }\n        });\n        \n        // Si después de todo el proceso no hay un medio principal definido \n        // y hay videos nuevos, usar el primer video como principal\n        if (!mainMediaUrl && videoUrls.length > 0) {\n          mainMediaUrl = videoUrls[0];\n          mainMediaType = 'video';\n          \n          // Actualizar el indicador isMain en el array de medios\n          const firstVideoIndex = mediaItems.findIndex(item => \n            item.type === 'video' && item.url === videoUrls[0]\n          );\n          \n          if (firstVideoIndex >= 0) {\n            // Marcar el primer elemento como principal\n            mediaItems.forEach((item, idx) => {\n              item.isMain = idx === firstVideoIndex;\n            });\n          }\n          \n          console.log(`Estableciendo nuevo video como principal (último recurso): ${mainMediaUrl}`);\n        }\n      }\n      \n      // Procesar mediaItems JSON enviado directamente desde el cliente\n      if (req.body.mediaItems) {\n        try {\n          console.log(\"=== PROCESANDO MEDIA ITEMS DEL CLIENTE ===\");\n          console.log(\"JSON recibido:\", req.body.mediaItems);\n          \n          // Parsear el JSON enviado por el cliente\n          let clientMediaItems = [];\n          try {\n            clientMediaItems = JSON.parse(req.body.mediaItems);\n            console.log(`Elementos multimedia recibidos: ${clientMediaItems.length}`);\n          } catch (parseError) {\n            console.error(\"Error al parsear mediaItems:\", parseError);\n            clientMediaItems = [];\n          }\n          \n          // DETECCIÓN DE PROBLEMA CRÍTICO: Verificar si hay medios existentes y el cliente envía array vacío\n          // Este es un patrón común cuando se edita el evento modificando sólo campos básicos\n          let preservingExistingMedia = false;\n          \n          if (mediaItems.length > 0 && \n              (clientMediaItems.length === 0 || \n               !clientMediaItems.some((item: any) => item && item.url))) {\n            \n            console.log(\"⚠️ CASO ESPECIAL DETECTADO: El cliente envió un array vacío o sin elementos válidos\");\n            console.log(`⚠️ El evento ya tiene ${mediaItems.length} elementos multimedia existentes`);\n            console.log(\"🔒 PRESERVANDO los elementos multimedia existentes:\");\n            console.log(JSON.stringify(mediaItems));\n            \n            // IMPORTANTE: Marcar que estamos preservando medios existentes\n            preservingExistingMedia = true;\n            \n            // Asegurar que haya un elemento principal\n            const currentMainItem = mediaItems.find(item => item.isMain);\n            if (!currentMainItem && mediaItems.length > 0) {\n              // Si no hay un elemento principal, establecer el primero como principal\n              mediaItems[0].isMain = true;\n              mainMediaUrl = mediaItems[0].url;\n              mainMediaType = mediaItems[0].type;\n              console.log(`✅ Estableciendo primer elemento como principal: ${mainMediaType} - ${mainMediaUrl}`);\n            } else if (currentMainItem) {\n              // Asegurar que las variables principales estén sincronizadas\n              mainMediaUrl = currentMainItem.url;\n              mainMediaType = currentMainItem.type;\n              console.log(`✅ Sincronizando con elemento principal existente: ${mainMediaType} - ${mainMediaUrl}`);\n            }\n          }\n          \n          // Solo procesar los mediaItems del cliente si no estamos preservando los existentes\n          if (!preservingExistingMedia && Array.isArray(clientMediaItems)) {\n            // MEJORA CRÍTICA: Verificar primero si hay un elemento explícitamente marcado como principal\n            const explicitMainItem = clientMediaItems.find((item: any) => \n              item && item.isMain === true && !item.toDelete && !item.deleted\n            );\n            \n            if (explicitMainItem) {\n              console.log(\"DETECTADO ELEMENTO EXPLÍCITAMENTE MARCADO COMO PRINCIPAL:\", {\n                tipo: explicitMainItem.type || \"desconocido\",\n                url: explicitMainItem.url || \"sin URL\"\n              });\n            } else {\n              console.log(\"No se encontró un elemento explícitamente marcado como principal\");\n            }\n            // PASO 1: Identificar elementos explícitamente marcados para eliminación\n            const itemsToDelete = clientMediaItems\n              .filter((item: any) => {\n                // Verificar cada item minuciosamente\n                if (!item || !item.url) return false;\n                \n                // Comprobar si está marcado explícitamente para eliminar\n                const markedForDeletion = item.toDelete === true || item.deleted === true;\n                \n                // Registrar cada elemento marcado para eliminar\n                if (markedForDeletion) {\n                  console.log(`Elemento marcado para eliminación: ${item.type} - ${item.url}`);\n                }\n                \n                return markedForDeletion;\n              });\n              \n              // Registrar cuántos elementos se marcarán para eliminación\n              if (itemsToDelete.length > 0) {\n                console.log(`Se han marcado ${itemsToDelete.length} elementos para eliminación`);\n              }\n              \n              // Lista de URLs a eliminar para filtrado más sencillo\n              const urlsToDelete = itemsToDelete.map((item: any) => item.url);\n              console.log(`URLs a eliminar: [${urlsToDelete.join(', ')}]`);\n              \n              // Guardar una copia de los mediaItems actuales antes de procesarlos\n              // Esto nos permitirá preservar los que son nuevos subidos en esta misma petición\n              const existingMediaItems = [...mediaItems];\n              \n              // Crear un nuevo array para almacenar los mediaItems actualizados\n              const updatedMediaItems: MediaItem[] = [];\n              \n              // Lista de URLs de elementos que vienen del cliente para evitar duplicados\n              const clientUrls = clientMediaItems\n                .filter((item: any) => item && item.url && !item.toDelete && !item.deleted)\n                .map((item: any) => item.url);\n              \n              // Primero, agregar los archivos recién subidos que no están en el mediaItems del cliente\n              // y que no están marcados para eliminación\n              const newlyUploadedItems = existingMediaItems.filter(item => \n                !clientUrls.includes(item.url) && !urlsToDelete.includes(item.url));\n              \n              if (newlyUploadedItems.length > 0) {\n                console.log(`Preservando ${newlyUploadedItems.length} elementos recién subidos que no están en mediaItems del cliente`);\n                updatedMediaItems.push(...newlyUploadedItems);\n              }\n              \n              // MEJORA: Verificar si algún elemento del cliente está marcado como principal\n              const hasClientMainItem = clientMediaItems.some((item: any) => \n                item && item.isMain === true && !item.toDelete && !item.deleted\n              );\n              \n              console.log(\"¿Hay un elemento principal explícito en mediaItems del cliente?\", hasClientMainItem);\n              \n              // Procesar los elementos enviados por el cliente\n              clientMediaItems.forEach((item: { \n                type: string; \n                url?: string; \n                isMain?: boolean;\n                order?: number; \n                toDelete?: boolean;\n                deleted?: boolean;\n              }, index: number) => {\n                // Verificar si el elemento está marcado para eliminación\n                const shouldRemove = item.toDelete === true || item.deleted === true;\n                \n                // Solo procesar elementos que no están marcados para eliminación y tienen URL\n                if (item.url && !shouldRemove) {\n                  // MEJORA: Mantener el flag isMain exactamente como viene del cliente\n                  // sin normalizar a booleano en este punto para preservar mejor la selección\n                  const mediaItem = {\n                    type: item.type || 'photo',\n                    url: item.url,\n                    order: item.order !== undefined ? item.order : index + newlyUploadedItems.length,\n                    isMain: item.isMain === true  // Preservar la selección explícita\n                  };\n                  \n                  // Agregar al array de mediaItems\n                  updatedMediaItems.push(mediaItem);\n                  \n                  // Si este ítem está marcado como principal, actualizar los valores principales\n                  if (item.isMain === true) {\n                    mainMediaUrl = item.url;\n                    mainMediaType = item.type || 'photo';\n                    console.log(`Estableciendo media principal desde cliente: ${mainMediaType} - ${mainMediaUrl}`);\n                  }\n                } else if (item.url && shouldRemove) {\n                  console.log(`ELIMINANDO elemento: ${item.type} - ${item.url}`);\n                  \n                  // Si el elemento eliminado era el principal, registrarlo\n                  if (item.isMain) {\n                    console.log(`¡ATENCIÓN! Se está eliminando el elemento principal: ${item.url}`);\n                  }\n                }\n              });\n              \n              // Actualizar mediaItems con los elementos que han sido procesados (excluyendo los eliminados)\n              mediaItems = updatedMediaItems;\n            }\n          }\n        } catch (error) {\n          console.error(\"Error al procesar mediaItems JSON:\", error);\n        }\n      }\n      \n      // Verificar si mainMediaUrl sigue siendo válido (podría haber sido eliminado)\n      if (mainMediaUrl) {\n        const mainMediaExists = mediaItems.some(item => item.url === mainMediaUrl);\n        if (!mainMediaExists) {\n          console.log(`El media principal ${mainMediaUrl} ya no existe, estableciendo uno nuevo`);\n          \n          // Intentar encontrar un nuevo elemento principal (preferiblemente foto)\n          const firstPhoto = mediaItems.find(item => item.type === 'photo');\n          if (firstPhoto) {\n            mainMediaUrl = firstPhoto.url;\n            mainMediaType = 'photo';\n            \n            // Actualizar la propiedad isMain en los elementos\n            mediaItems.forEach(item => {\n              item.isMain = item.url === mainMediaUrl;\n            });\n            \n            console.log(`Nuevo media principal establecido: ${mainMediaType} - ${mainMediaUrl}`);\n          } else if (mediaItems.length > 0) {\n            // Si no hay fotos, usar el primer elemento disponible\n            mainMediaUrl = mediaItems[0].url;\n            mainMediaType = mediaItems[0].type;\n            mediaItems[0].isMain = true;\n            \n            console.log(`Nuevo media principal (no foto) establecido: ${mainMediaType} - ${mainMediaUrl}`);\n          } else {\n            // No hay elementos multimedia\n            mainMediaUrl = '';\n            mainMediaType = 'photo'; // Default to photo to avoid enum error\n            console.log('No hay elementos multimedia disponibles para establecer como principal');\n          }\n        }\n      }\n      \n      console.log(`Procesados ${mediaItems.length} elementos multimedia en total (incluidos archivos nuevos)`);\n      \n      // Procesar el archivo principal especificado (subido como archivo)\n      if (files.mainMediaFile && files.mainMediaFile.length > 0) {\n        const mediaPath = files.mainMediaFile[0].path.replace('public', '');\n        // Determinar tipo según el mimetype\n        const isVideo = files.mainMediaFile[0].mimetype.startsWith('video/');\n        mainMediaType = isVideo ? 'video' : 'photo';\n        mainMediaUrl = mediaPath;\n        \n        console.log(`Archivo principal subido: ${mainMediaType} - ${mainMediaUrl}`);\n        \n        // Asegurarse de que está en mediaItems\n        if (!mediaItems.some(item => item.url === mediaPath)) {\n          // Crear un nuevo elemento multimedia para el archivo principal\n          const mainMediaItem = { \n            type: mainMediaType, \n            url: mediaPath, \n            order: mediaItems.length,\n            isMain: true\n          };\n          \n          // Agregarlo a mediaItems\n          mediaItems.push(mainMediaItem);\n          console.log(`Agregado nuevo archivo principal a mediaItems: ${mainMediaType} - ${mediaPath}`);\n        } else {\n          // Actualizar el elemento existente para marcarlo como principal\n          // Mantenemos todos los demás elementos, pero actualizamos el isMain\n          mediaItems = mediaItems.map(item => ({\n            ...item,\n            isMain: item.url === mediaPath,\n            // Asegurar que el tipo coincida si es el elemento principal\n            type: item.url === mediaPath ? mainMediaType : item.type\n          }));\n          console.log(`Actualizado elemento existente como principal: ${mainMediaType} - ${mediaPath}`);\n        }\n      } else if (req.body.mainMediaUrl) {\n        // Permitir establecer un medio existente como principal\n        mainMediaUrl = req.body.mainMediaUrl;\n        mainMediaType = req.body.mainMediaType || 'photo';\n        \n        console.log(`Estableciendo medio existente como principal: ${mainMediaType} - ${mainMediaUrl}`);\n        \n        // Actualizar mediaItems para reflejar el cambio de elemento principal\n        mediaItems = mediaItems.map(item => ({\n          ...item,\n          isMain: item.url === mainMediaUrl,\n          // Asegurar que el tipo coincida si es el elemento principal\n          type: item.url === mainMediaUrl ? mainMediaType : item.type\n        }));\n      }\n      \n      // Verificar coherencia: asegurar que si hay mainMediaUrl, también hay mainMediaType\n      if (mainMediaUrl && !mainMediaType) {\n        // Determinar el tipo basado en la extensión del archivo\n        const isVideoExt = /\\.(mp4|mov|avi|wmv|flv|webm)$/i.test(mainMediaUrl);\n        mainMediaType = isVideoExt ? 'video' : 'photo';\n        console.log(`Corrigiendo tipo de medio principal: ${mainMediaType} para ${mainMediaUrl}`);\n      }\n      \n      // Y viceversa: si no hay URL principal, no debería haber tipo\n      if (!mainMediaUrl && mainMediaType) {\n        console.log(`Corrigiendo inconsistencia: mainMediaType establecido (${mainMediaType}) pero no hay mainMediaUrl`);\n        \n        // Si hay al menos un elemento multimedia, usar el primero como principal\n        if (mediaItems.length > 0) {\n          // Buscar algún elemento que ya esté marcado como principal\n          const mainItem = mediaItems.find(item => item.isMain === true);\n          \n          if (mainItem) {\n            // Usar el elemento marcado como principal\n            mainMediaUrl = mainItem.url;\n            mainMediaType = mainItem.type;\n            console.log(`Usando elemento marcado como principal: ${mainMediaType} - ${mainMediaUrl}`);\n          } else {\n            // Si ninguno está marcado, usar el primero\n            mainMediaUrl = mediaItems[0].url;\n            mainMediaType = mediaItems[0].type;\n            console.log(`Usando primer elemento como principal: ${mainMediaType} - ${mainMediaUrl}`);\n            \n            // Actualizar el isMain en mediaItems\n            mediaItems = mediaItems.map((item, index) => ({\n              ...item,\n              isMain: index === 0\n            }));\n          }\n        } else {\n          // No hay elementos multimedia, usamos un tipo por defecto para evitar errores de enum\n          mainMediaType = 'photo'; // Default to photo to avoid enum error\n        }\n      }\n      \n      // Reorganizar elementos basados en el campo order\n      mediaItems.sort((a, b) => {\n        // Si el orden no está definido, considerar como último\n        const orderA = a.order !== undefined ? a.order : Number.MAX_SAFE_INTEGER;\n        const orderB = b.order !== undefined ? b.order : Number.MAX_SAFE_INTEGER;\n        return orderA - orderB;\n      });\n      \n      // Reasignar órdenes para asegurar consistencia\n      mediaItems = mediaItems.map((item, index) => ({\n        ...item,\n        order: index\n      }));\n      \n      // Asegurarse de que exactamente un elemento esté marcado como principal\n      const principalItems = mediaItems.filter(item => item.isMain === true);\n      \n      if (principalItems.length === 0 && mediaItems.length > 0) {\n        // Si ninguno está marcado como principal, intentar encontrar una foto primero\n        const firstPhoto = mediaItems.find(item => item.type === 'photo');\n        \n        if (firstPhoto) {\n          // Preferir una foto como elemento principal\n          firstPhoto.isMain = true;\n          mainMediaUrl = firstPhoto.url;\n          mainMediaType = 'photo';\n          console.log(`Estableciendo primera foto como principal por defecto: ${mainMediaUrl}`);\n        } else {\n          // Si no hay fotos, usar el primer elemento (probablemente un video)\n          mediaItems[0].isMain = true;\n          mainMediaUrl = mediaItems[0].url;\n          mainMediaType = mediaItems[0].type;\n          console.log(`Estableciendo el primer elemento como principal por defecto: ${mainMediaType} - ${mainMediaUrl}`);\n        }\n      } else if (principalItems.length > 1) {\n        // Si hay más de uno marcado como principal, dejar solo el primero\n        let foundMain = false;\n        mediaItems = mediaItems.map(item => {\n          if (item.isMain && !foundMain) {\n            foundMain = true;\n            // Asegurar que mainMediaUrl y mainMediaType están actualizados\n            mainMediaUrl = item.url;\n            mainMediaType = item.type;\n            return item;\n          }\n          return { ...item, isMain: false };\n        });\n        console.log(`Resolviendo múltiples principales: único elemento principal ahora es ${mainMediaType} - ${mainMediaUrl}`);\n      }\n      \n      // Limitar a máximo 6 fotos y 3 videos y preservar el elemento principal\n      const MAX_PHOTOS = 6;\n      const MAX_VIDEOS = 3;\n      \n      // Separar fotos y videos, y mantener referencia a cual es el elemento principal\n      const mainItem = mediaItems.find(item => item.isMain === true);\n      const photos = mediaItems.filter(item => item.type === 'photo');\n      const videos = mediaItems.filter(item => item.type === 'video');\n      \n      let photosToKeep = photos;\n      let videosToKeep = videos;\n      \n      // Limitar fotos si exceden el máximo\n      if (photos.length > MAX_PHOTOS) {\n        console.log(`Limitando cantidad de fotos: ${photos.length} → ${MAX_PHOTOS}`);\n        \n        // Si el elemento principal es una foto, asegurarse de que esté entre las que se mantienen\n        if (mainItem && mainItem.type === 'photo') {\n          // Quitar el elemento principal del array para no contarlo en el límite\n          const otherPhotos = photos.filter(item => item !== mainItem);\n          \n          // Mantener el elemento principal + hasta (MAX_PHOTOS-1) otras fotos\n          const remainingPhotos = otherPhotos.slice(0, MAX_PHOTOS - 1);\n          photosToKeep = [mainItem, ...remainingPhotos];\n        } else {\n          // Si no hay principal o no es una foto, simplemente mantener las primeras MAX_PHOTOS\n          photosToKeep = photos.slice(0, MAX_PHOTOS);\n        }\n      }\n      \n      // Limitar videos si exceden el máximo\n      if (videos.length > MAX_VIDEOS) {\n        console.log(`Limitando cantidad de videos: ${videos.length} → ${MAX_VIDEOS}`);\n        \n        // Si el elemento principal es un video, asegurarse de que esté entre los que se mantienen\n        if (mainItem && mainItem.type === 'video') {\n          // Quitar el elemento principal del array para no contarlo en el límite\n          const otherVideos = videos.filter(item => item !== mainItem);\n          \n          // Mantener el elemento principal + hasta (MAX_VIDEOS-1) otros videos\n          const remainingVideos = otherVideos.slice(0, MAX_VIDEOS - 1);\n          videosToKeep = [mainItem, ...remainingVideos];\n        } else {\n          // Si no hay principal o no es un video, simplemente mantener los primeros MAX_VIDEOS\n          videosToKeep = videos.slice(0, MAX_VIDEOS);\n        }\n      }\n      \n      // Asignar los elementos filtrados y reordenar\n      mediaItems = [...photosToKeep, ...videosToKeep];\n      \n      // Verificar si el elemento principal se conservó después de la filtración\n      if (mainItem && !mediaItems.includes(mainItem)) {\n        console.warn(\"El elemento principal se perdió durante la filtración. Asignando uno nuevo.\");\n        \n        // Si el elemento principal se perdió, asignar uno nuevo\n        if (mediaItems.length > 0) {\n          // Preferir fotos como elemento principal\n          const newMainItem = mediaItems.find(item => item.type === 'photo') || mediaItems[0];\n          \n          // Actualizar flags y variables\n          mediaItems = mediaItems.map(item => ({\n            ...item,\n            isMain: item === newMainItem\n          }));\n          \n          mainMediaUrl = newMainItem.url;\n          mainMediaType = newMainItem.type;\n          \n          console.log(`Nuevo elemento principal asignado: ${mainMediaType} - ${mainMediaUrl}`);\n        } else {\n          // No hay elementos multimedia después de la filtración\n          mainMediaUrl = '';\n          mainMediaType = 'photo'; // Default to photo to avoid enum error\n        }\n      }\n      \n      // Re-asignar órdenes para mantener consistencia después de filtrar\n      mediaItems = mediaItems.map((item, index) => ({\n        ...item,\n        order: index\n      }));\n      \n      // Actualizar los campos de multimedia\n      updateData.mediaItems = JSON.stringify(mediaItems);\n      \n      // Asegurar que mainMediaType sea siempre un string, no un array\n      if (Array.isArray(mainMediaType)) {\n        updateData.mainMediaType = mainMediaType[0] || 'photo';\n        console.log(`Corrigiendo mainMediaType de array a string: ${mainMediaType} → ${updateData.mainMediaType}`);\n      } else {\n        updateData.mainMediaType = mainMediaType || 'photo';\n      }\n      \n      updateData.mainMediaUrl = mainMediaUrl;\n      \n      // Si hay preguntas de postulación, incluirlas\n      if (req.body.applicationQuestions) {\n        updateData.applicationQuestions = req.body.applicationQuestions;\n      }\n      \n      // Update event\n      const updatedEvent = await storage.updateEvent(eventId, updateData);\n      \n      // Broadcast event update to all connected clients\n      broadcastMessage({\n        type: 'event_updated',\n        event: updatedEvent\n      });\n      console.log(\"Notificación de actualización de evento enviada a todos los clientes WebSocket\");\n      \n      res.json(updatedEvent);\n    } catch (error) {\n      console.error(\"Error updating event with files:\", error);\n      res.status(500).json({ message: \"Error updating event\", error: String(error) });\n    }\n  });\n\n  app.delete(\"/api/events/:id\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      // Check if event exists\n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      // Check if user is the organizer\n      if (event.organizerId !== user.id) {\n        return res.status(403).json({ message: \"Not authorized to delete this event\" });\n      }\n      \n      // Delete event\n      await storage.deleteEvent(eventId);\n      res.json({ message: \"Event deleted successfully\" });\n    } catch (error) {\n      console.error(\"Error deleting event:\", error);\n      res.status(500).json({ message: \"Error deleting event\" });\n    }\n  });\n\n  // Event attendance routes\n  app.post(\"/api/events/:id/join\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      // Check if event exists\n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      // Check if user is already attending\n      const existingAttendee = await storage.getEventAttendee(eventId, user.id);\n      if (existingAttendee) {\n        return res.status(400).json({ \n          message: \"Already joined this event\",\n          status: existingAttendee.status\n        });\n      }\n      \n      // Check if event is at capacity\n      if (event.maxCapacity) {\n        const attendees = await storage.getEventAttendees(eventId);\n        if (attendees.length >= event.maxCapacity) {\n          return res.status(400).json({ message: \"Event is at maximum capacity\" });\n        }\n      }\n      \n      // For private events, create a pending request\n      if (event.privacyType === 'private') {\n        const attendee = await storage.joinEvent({\n          eventId,\n          userId: user.id,\n          status: 'pending',\n          paymentStatus: event.paymentType === 'free' ? 'completed' : 'pending'\n        });\n        \n        return res.status(201).json({ \n          attendee, \n          requiresPayment: false,\n          isPendingApproval: true\n        });\n      }\n      \n      // For paid events, process through Stripe\n      if (event.paymentType === 'paid' && event.price) {\n        if (!stripe) {\n          return res.status(500).json({ message: \"Payment processing is not available\" });\n        }\n        \n        // Pagos desactivados, creamos un objeto simulado para mantener compatibilidad con el código\n        const paymentIntent = {\n          id: `free_event_${Date.now()}`,\n          client_secret: `free_event_no_payment_required_${Date.now()}`\n        };\n        \n        // Create attendance record with pending payment\n        const attendee = await storage.joinEvent({\n          eventId,\n          userId: user.id,\n          status: 'approved',\n          paymentStatus: 'pending',\n          paymentIntentId: paymentIntent.id\n        });\n        \n        return res.status(201).json({ \n          attendee,\n          clientSecret: paymentIntent.client_secret,\n          requiresPayment: true,\n          isPendingApproval: false\n        });\n      }\n      \n      // For free events, just add them\n      const attendee = await storage.joinEvent({\n        eventId,\n        userId: user.id,\n        status: 'approved',\n        paymentStatus: 'completed'\n      });\n      \n      res.status(201).json({ \n        attendee, \n        requiresPayment: false,\n        isPendingApproval: false\n      });\n    } catch (error) {\n      console.error(\"Error joining event:\", error);\n      res.status(500).json({ message: \"Error joining event\" });\n    }\n  });\n\n  app.delete(\"/api/events/:id/leave\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      // Check if user is attending\n      const attendee = await storage.getEventAttendee(eventId, user.id);\n      if (!attendee) {\n        return res.status(404).json({ message: \"Not attending this event\" });\n      }\n      \n      // Cannot leave a paid event if payment is completed\n      if (attendee.paymentStatus === 'completed' && attendee.paymentIntentId) {\n        return res.status(400).json({ message: \"Cannot leave a paid event after payment is completed\" });\n      }\n      \n      // Pagos desactivados, no necesitamos cancelar el payment intent\n      // Si hubiera pagos, aquí se cancelaría el payment intent\n      \n      // Remove attendee record\n      await storage.leaveEvent(eventId, user.id);\n      res.json({ message: \"Left event successfully\" });\n    } catch (error) {\n      console.error(\"Error leaving event:\", error);\n      res.status(500).json({ message: \"Error leaving event\" });\n    }\n  });\n  \n  // Approve/reject join requests for private events\n  app.post(\"/api/events/:id/requests/:attendeeId/approve\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      const attendeeId = parseInt(req.params.attendeeId);\n      \n      // Verify the event exists and user is the organizer\n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      if (event.organizerId !== user.id) {\n        return res.status(403).json({ message: \"Only the event organizer can approve requests\" });\n      }\n      \n      // Get the attendee record\n      const attendee = await storage.getEventAttendee(eventId, attendeeId);\n      if (!attendee) {\n        return res.status(404).json({ message: \"Join request not found\" });\n      }\n      \n      if (attendee.status !== 'pending') {\n        return res.status(400).json({ message: \"This request has already been processed\" });\n      }\n      \n      // Update attendee status\n      const updatedAttendee = await storage.updateEventAttendee(attendee.id, {\n        status: 'approved'\n      });\n      \n      res.json({ \n        attendee: updatedAttendee,\n        message: \"Join request approved\" \n      });\n    } catch (error) {\n      console.error(\"Error approving join request:\", error);\n      res.status(500).json({ message: \"Server error\" });\n    }\n  });\n  \n  app.post(\"/api/events/:id/requests/:attendeeId/reject\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      const attendeeId = parseInt(req.params.attendeeId);\n      \n      // Verify the event exists and user is the organizer\n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      if (event.organizerId !== user.id) {\n        return res.status(403).json({ message: \"Only the event organizer can reject requests\" });\n      }\n      \n      // Get the attendee record\n      const attendee = await storage.getEventAttendee(eventId, attendeeId);\n      if (!attendee) {\n        return res.status(404).json({ message: \"Join request not found\" });\n      }\n      \n      if (attendee.status !== 'pending') {\n        return res.status(400).json({ message: \"This request has already been processed\" });\n      }\n      \n      // Delete the attendee record\n      await storage.leaveEvent(eventId, attendeeId);\n      \n      res.json({ message: \"Join request rejected\" });\n    } catch (error) {\n      console.error(\"Error rejecting join request:\", error);\n      res.status(500).json({ message: \"Server error\" });\n    }\n  });\n  \n  // Get pending join requests for an event\n  app.get(\"/api/events/:id/requests\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      // Verify the event exists and user is the organizer\n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      if (event.organizerId !== user.id) {\n        return res.status(403).json({ message: \"Only the event organizer can view join requests\" });\n      }\n      \n      // Get all attendees for the event\n      const attendees = await storage.getEventAttendees(eventId);\n      \n      // Filter to only pending requests\n      const pendingRequests = attendees.filter(attendee => attendee.status === 'pending');\n      \n      res.json(pendingRequests);\n    } catch (error) {\n      console.error(\"Error fetching join requests:\", error);\n      res.status(500).json({ message: \"Server error\" });\n    }\n  });\n  \n  // Check user's status for an event (for pending requests)\n  app.get(\"/api/events/:id/status\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      // Get user's attendance record\n      const attendee = await storage.getEventAttendee(eventId, user.id);\n      if (!attendee) {\n        return res.status(404).json({ \n          message: \"No estás registrado en este evento\",\n          status: null\n        });\n      }\n      \n      // Return status\n      res.json({ \n        status: attendee.status,\n        paymentStatus: attendee.paymentStatus\n      });\n    } catch (error) {\n      console.error(\"Error checking event status:\", error);\n      res.status(500).json({ message: \"Error del servidor\" });\n    }\n  });\n\n  // Simplified payment routes - all events are free\n  app.post(\"/api/payment/confirm\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const { eventId } = req.body;\n      \n      // Check if the event exists\n      const event = await storage.getEventById(parseInt(eventId));\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      // Automatically join the event as free\n      try {\n        // Update the attendee record\n        const updatedAttendee = await storage.updatePaymentStatus(\n          parseInt(eventId),\n          user.id,\n          'free',\n          \"\"\n        );\n        \n        res.json(updatedAttendee);\n      } catch (error) {\n        console.error(\"Error updating event status:\", error);\n        res.status(500).json({ message: \"Error updating event attendance\" });\n      }\n    } catch (error) {\n      console.error(\"Error joining event:\", error);\n      res.status(500).json({ message: \"Error joining event\" });\n    }\n  });\n\n  // User events routes\n  app.get(\"/api/user/events/created\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const events = await storage.getUserCreatedEvents(user.id);\n      res.json(events);\n    } catch (error) {\n      console.error(\"Error fetching created events:\", error);\n      res.status(500).json({ message: \"Error fetching created events\" });\n    }\n  });\n\n  app.get(\"/api/user/events/attending\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const events = await storage.getUserAttendingEvents(user.id);\n      res.json(events);\n    } catch (error) {\n      console.error(\"Error fetching attending events:\", error);\n      res.status(500).json({ message: \"Error fetching attending events\" });\n    }\n  });\n\n  // Simplified payment intent route - all events are free\n  app.post(\"/api/create-payment-intent\", isAuthenticated, async (req, res) => {\n    try {      \n      const { eventId } = req.body;\n      const user = req.user as any;\n      \n      // Get the event details\n      const event = await storage.getEventById(parseInt(eventId));\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      // Automatically join the event as a free event\n      try {\n        await storage.joinEvent({\n          eventId: parseInt(eventId),\n          userId: user.id,\n          paymentStatus: \"free\",\n          paymentIntentId: \"\"\n        });\n        \n        // Return a fake client secret to keep the client logic working\n        res.json({ \n          clientSecret: \"free_event_no_payment_required\",\n          message: \"Joined event successfully\" \n        });\n      } catch (error) {\n        console.error(\"Error joining event:\", error);\n        res.status(500).json({ message: \"Error joining event\" });\n      }\n    } catch (error) {\n      console.error(\"Error handling free event join:\", error);\n      res.status(500).json({ message: \"Server error\" });\n    }\n  });\n\n  const httpServer = createServer(app);\n  \n  // Initialize WebSocket server on a different path to avoid conflict with Vite HMR\n  const wss = new WebSocketServer({ \n    server: httpServer, \n    path: '/ws' \n  });\n  \n  // Store active connections\n  const clients = new Map<string, { ws: WebSocket, userId: number, userName: string }>();\n  \n  // Función para enviar mensajes a todos los clientes\n  const broadcastMessage = (data: any) => {\n    const message = JSON.stringify(data);\n    clients.forEach(({ ws }) => {\n      if (ws.readyState === WebSocket.OPEN) {\n        ws.send(message);\n      }\n    });\n    console.log(`Broadcasted ${data.type} to ${clients.size} clients`);\n  };\n  \n  wss.on('connection', (ws, req) => {\n    console.log('WebSocket connection established');\n    \n    // Intentar extraer información de sesión si está disponible\n    const url = new URL(req.url || '', `http://${req.headers.host}`);\n    const sid = url.searchParams.get('sid');\n    if (sid) {\n      console.log(`WebSocket connection with session ID: ${sid.substring(0, 8)}...`);\n    }\n    \n    // Generate client ID\n    const clientId = Math.random().toString(36).substring(2, 15);\n    \n    // Handle messages\n    ws.on('message', async (message) => {\n      try {\n        const data = JSON.parse(message.toString());\n        \n        // Handle authentication\n        if (data.type === 'auth') {\n          const { userId, userName } = data;\n          clients.set(clientId, { ws, userId, userName });\n          console.log(`Client authenticated: ${userName} (${userId})`);\n          \n          // Send confirmation to the client\n          ws.send(JSON.stringify({\n            type: 'auth_success',\n            userId,\n            userName\n          }));\n          \n          return;\n        }\n        \n        // Handle chat messages - only logged in users\n        if (data.type === 'message' && clients.has(clientId)) {\n          const { eventId, content } = data;\n          const sender = clients.get(clientId)!;\n          \n          // Validate data\n          if (!eventId || !content || content.trim() === '') {\n            return;\n          }\n          \n          const messageData = {\n            type: 'message',\n            eventId,\n            userId: sender.userId,\n            userName: sender.userName,\n            content,\n            timestamp: new Date().toISOString()\n          };\n          \n          // Broadcast to all clients connected to the same event\n          clients.forEach((client) => {\n            if (client.ws.readyState === WebSocket.OPEN) {\n              client.ws.send(JSON.stringify(messageData));\n            }\n          });\n          \n          return;\n        }\n      } catch (error) {\n        console.error('Error processing WebSocket message:', error);\n      }\n    });\n    \n    // Handle disconnection\n    ws.on('close', () => {\n      clients.delete(clientId);\n      console.log('WebSocket connection closed');\n    });\n    \n    // Send initial message\n    ws.send(JSON.stringify({ \n      type: 'connection_established',\n      message: 'Successfully connected to Pipol chat server'\n    }));\n  });\n\n  return httpServer;\n}\n","size_bytes":101400},"db/index.ts":{"content":"// Re-export from server/db.ts for better organization\nexport * from '../server/db';","size_bytes":84},"db/init-schema.ts":{"content":"import { sql } from 'drizzle-orm';\nimport { db } from '@db';\nimport * as schema from '@shared/schema';\n\nasync function initSchema() {\n  console.log('Initializing database schema...');\n  \n  try {\n    // Create enums first\n    await db.execute(sql`\n      DO $$ BEGIN\n        CREATE TYPE event_category AS ENUM (\n          'social', 'music', 'spiritual', 'education', \n          'sports', 'food', 'art', 'technology',\n          'games', 'outdoor', 'networking', 'workshop',\n          'conference', 'party', 'fair', 'exhibition'\n        );\n      EXCEPTION\n        WHEN duplicate_object THEN NULL;\n      END $$;\n\n      DO $$ BEGIN\n        CREATE TYPE privacy_type AS ENUM ('public', 'private');\n      EXCEPTION\n        WHEN duplicate_object THEN NULL;\n      END $$;\n\n      DO $$ BEGIN\n        CREATE TYPE private_access_type AS ENUM ('solicitud', 'postulacion', 'paga');\n      EXCEPTION\n        WHEN duplicate_object THEN NULL;\n      END $$;\n\n      DO $$ BEGIN\n        CREATE TYPE payment_type AS ENUM ('free', 'paid');\n      EXCEPTION\n        WHEN duplicate_object THEN NULL;\n      END $$;\n\n      DO $$ BEGIN\n        CREATE TYPE multimedia_type AS ENUM ('photo', 'video');\n      EXCEPTION\n        WHEN duplicate_object THEN NULL;\n      END $$;\n\n      DO $$ BEGIN\n        CREATE TYPE attendee_status AS ENUM ('pending', 'approved', 'rejected');\n      EXCEPTION\n        WHEN duplicate_object THEN NULL;\n      END $$;\n    `);\n    \n    console.log('Created enum types');\n    \n    // Create tables one by one\n    // Users table\n    await db.execute(sql`\n      CREATE TABLE IF NOT EXISTS users (\n        id SERIAL PRIMARY KEY,\n        username TEXT NOT NULL UNIQUE,\n        email TEXT NOT NULL UNIQUE,\n        password TEXT NOT NULL,\n        name TEXT NOT NULL,\n        bio TEXT,\n        avatar TEXT,\n        stripe_customer_id TEXT,\n        stripe_subscription_id TEXT,\n        created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n        updated_at TIMESTAMP NOT NULL DEFAULT NOW()\n      );\n    `);\n    \n    console.log('Created users table');\n    \n    // Events table\n    await db.execute(sql`\n      CREATE TABLE IF NOT EXISTS events (\n        id SERIAL PRIMARY KEY,\n        title TEXT NOT NULL,\n        description TEXT NOT NULL,\n        category event_category NOT NULL,\n        date TIMESTAMP NOT NULL,\n        latitude DECIMAL(10, 6) NOT NULL,\n        longitude DECIMAL(10, 6) NOT NULL,\n        location_name TEXT NOT NULL,\n        location_address TEXT NOT NULL,\n        payment_type payment_type NOT NULL DEFAULT 'free',\n        price DECIMAL(10, 2),\n        max_capacity INTEGER,\n        privacy_type privacy_type NOT NULL DEFAULT 'public',\n        private_access_type private_access_type,\n        application_questions TEXT,\n        photo_url TEXT,\n        photo_urls TEXT,\n        video_url TEXT,\n        video_urls TEXT,\n        media_items TEXT,\n        main_media_type multimedia_type DEFAULT 'photo',\n        main_media_url TEXT,\n        organizer_id INTEGER NOT NULL REFERENCES users(id),\n        created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n        updated_at TIMESTAMP NOT NULL DEFAULT NOW()\n      );\n    `);\n    \n    console.log('Created events table');\n    \n    // Event Attendees table\n    await db.execute(sql`\n      CREATE TABLE IF NOT EXISTS event_attendees (\n        id SERIAL PRIMARY KEY,\n        event_id INTEGER NOT NULL REFERENCES events(id),\n        user_id INTEGER NOT NULL REFERENCES users(id),\n        status attendee_status NOT NULL DEFAULT 'approved',\n        payment_status TEXT DEFAULT 'pending',\n        payment_intent_id TEXT,\n        created_at TIMESTAMP NOT NULL DEFAULT NOW()\n      );\n    `);\n    \n    console.log('Created event_attendees table');\n    \n    // User Interests table\n    await db.execute(sql`\n      CREATE TABLE IF NOT EXISTS user_interests (\n        id SERIAL PRIMARY KEY,\n        user_id INTEGER NOT NULL REFERENCES users(id),\n        category event_category NOT NULL,\n        created_at TIMESTAMP NOT NULL DEFAULT NOW()\n      );\n    `);\n    \n    console.log('Created user_interests table');\n    \n    console.log('Database schema initialization completed successfully');\n  } catch (error) {\n    console.error('Error initializing database schema:', error);\n    throw error;\n  }\n}\n\ninitSchema()\n  .then(() => {\n    console.log('Schema initialization completed');\n    process.exit(0);\n  })\n  .catch((error) => {\n    console.error('Schema initialization failed:', error);\n    process.exit(1);\n  });","size_bytes":4435},"db/seed.ts":{"content":"import { db } from \"./index\";\nimport * as schema from \"@shared/schema\";\nimport bcrypt from \"bcryptjs\";\n\nasync function seed() {\n  try {\n    console.log(\"Starting database seed...\");\n\n    // Create initial users\n    const hashedPassword = await bcrypt.hash(\"password123\", 10);\n\n    // Check if users already exist to avoid duplicates\n    let users = await db.query.users.findMany();\n    if (users.length === 0) {\n      console.log(\"Creating sample users...\");\n      \n      users = await db.insert(schema.users).values([\n        {\n          username: \"sarah_johnson\",\n          email: \"sarah@example.com\",\n          password: hashedPassword,\n          name: \"Sarah Johnson\",\n          bio: \"Event organizer and community builder. I love connecting people!\",\n          avatar: \"https://images.unsplash.com/photo-1494790108377-be9c29b29330?ixlib=rb-1.2.1&auto=format&fit=crop&w=200&q=80\",\n        },\n        {\n          username: \"michael_smith\",\n          email: \"michael@example.com\",\n          password: hashedPassword,\n          name: \"Michael Smith\",\n          bio: \"Music enthusiast and concert promoter.\",\n          avatar: \"https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?ixlib=rb-1.2.1&auto=format&fit=crop&w=200&q=80\",\n        },\n        {\n          username: \"emma_wilson\",\n          email: \"emma@example.com\",\n          password: hashedPassword,\n          name: \"Emma Wilson\",\n          bio: \"Foodie and culinary workshop host.\",\n          avatar: \"https://images.unsplash.com/photo-1438761681033-6461ffad8d80?ixlib=rb-1.2.1&auto=format&fit=crop&w=200&q=80\",\n        }\n      ]).returning();\n      \n      console.log(`Created ${users.length} users`);\n    } else {\n      console.log(`Using ${users.length} existing users`);\n    }\n      \n    // Check if events already exist\n    const existingEvents = await db.query.events.findMany();\n    if (existingEvents.length === 0) {\n      // Create sample events\n      console.log(\"Creating sample events...\");\n      \n      const events = await db.insert(schema.events).values([\n        {\n          title: \"Community Networking Mixer\",\n          description: \"Join us for a relaxed networking event where entrepreneurs, creatives, and professionals can connect, share ideas, and build meaningful relationships. Light refreshments will be served.\",\n          category: \"social\",\n          date: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days from now\n          latitude: \"37.7749\",\n          longitude: \"-122.4194\",\n          locationName: \"Downtown Coworking Space\",\n          locationAddress: \"123 Main Street, Downtown\",\n          paymentType: \"paid\",\n          price: \"15.00\",\n          maxCapacity: 50,\n          privacyType: \"public\",\n          organizerId: users[0].id,\n        },\n        {\n          title: \"Live Jazz Night\",\n          description: \"Experience an unforgettable evening of live jazz music with talented local musicians. Food and drinks available for purchase.\",\n          category: \"music\",\n          date: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000), // 3 days from now\n          latitude: \"37.7833\",\n          longitude: \"-122.4167\",\n          locationName: \"Blue Note Jazz Club\",\n          locationAddress: \"456 Market St, Downtown\",\n          paymentType: \"paid\",\n          price: \"25.00\",\n          maxCapacity: 100,\n          privacyType: \"public\",\n          organizerId: users[0].id,\n        },\n        {\n          title: \"Farm-to-Table Dinner\",\n          description: \"Join us for a unique dining experience featuring seasonal ingredients sourced directly from local farms. Meet the farmers and learn about sustainable agriculture while enjoying a delicious meal.\",\n          category: \"food\",\n          date: new Date(Date.now() + 10 * 24 * 60 * 60 * 1000), // 10 days from now\n          latitude: \"37.7694\",\n          longitude: \"-122.4862\",\n          locationName: \"Urban Farm Collective\",\n          locationAddress: \"789 Green St, Sunset District\",\n          paymentType: \"paid\",\n          price: \"45.00\",\n          maxCapacity: 30,\n          privacyType: \"public\",\n          organizerId: users[0].id,\n        },\n        {\n          title: \"Morning Meditation in the Park\",\n          description: \"Start your day with a peaceful guided meditation session in the park. All experience levels welcome. Bring your own mat or blanket.\",\n          category: \"spiritual\",\n          date: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000), // 2 days from now\n          latitude: \"37.7695\",\n          longitude: \"-122.4830\",\n          locationName: \"Golden Gate Park\",\n          locationAddress: \"Golden Gate Park, Conservatory of Flowers\",\n          paymentType: \"free\",\n          privacyType: \"public\",\n          organizerId: users[0].id,\n        },\n        {\n          title: \"Tech Startup Pitch Night\",\n          description: \"Watch emerging startups pitch their innovative ideas to a panel of investors and industry experts. Networking opportunity after the presentations.\",\n          category: \"technology\",\n          date: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000), // 5 days from now\n          latitude: \"37.7790\",\n          longitude: \"-122.4190\",\n          locationName: \"Innovation Hub\",\n          locationAddress: \"555 Howard St, SOMA\",\n          paymentType: \"free\",\n          maxCapacity: 75,\n          privacyType: \"public\",\n          organizerId: users[0].id,\n        }\n      ]).returning();\n      \n      console.log(`Created ${events.length} events`);\n      \n      // Add user interests\n      console.log(\"Creating sample user interests...\");\n      \n      const interests = await db.insert(schema.userInterests).values([\n        {\n          userId: users[0].id,\n          category: \"social\",\n        },\n        {\n          userId: users[0].id,\n          category: \"spiritual\",\n        },\n        {\n          userId: users[0].id,\n          category: \"music\",\n        },\n        {\n          userId: users[0].id,\n          category: \"technology\",\n        },\n        {\n          userId: users[0].id,\n          category: \"food\",\n        }\n      ]).returning();\n      \n      console.log(`Created ${interests.length} user interests`);\n    } else {\n      console.log(\"Events already exist. Skipping event creation.\");\n    }\n      \n    console.log(\"Database seed completed successfully!\");\n  } catch (error) {\n    console.error(\"Error seeding database:\", error);\n  }\n}\n\nseed();\n","size_bytes":6388},"replit_agent/architecture.md":{"content":"# Architecture Overview\n\n## Overview\n\nPipol is a full-stack web application for event discovery and coordination. The application allows users to create, find, and attend events based on location and interests. It features user authentication, interactive maps, and potentially payment processing capabilities.\n\n## System Architecture\n\nThe application follows a client-server architecture with a clear separation between:\n\n- **Frontend**: React-based single-page application (SPA)\n- **Backend**: Express.js API server\n- **Database**: PostgreSQL with Drizzle ORM\n- **Services**: Map integration, authentication, and payment processing\n\n### High-level Architecture Diagram\n\n```\n┌─────────────┐      ┌─────────────┐      ┌─────────────┐\n│             │      │             │      │             │\n│   Client    │<─────│   Server    │<─────│  Database   │\n│   (React)   │      │  (Express)  │      │ (PostgreSQL)│\n│             │─────>│             │─────>│             │\n└─────────────┘      └─────────────┘      └─────────────┘\n       │                    │                    │\n       │                    │                    │\n       ▼                    ▼                    │\n┌─────────────┐      ┌─────────────┐             │\n│  Map APIs   │      │   Stripe    │             │\n│ (Mapbox/    │      │  Payment    │             │\n│  Google)    │      │  Gateway    │             │\n└─────────────┘      └─────────────┘             │\n                                                 │\n                                                 ▼\n                                          ┌─────────────┐\n                                          │ Neon.tech   │\n                                          │ Serverless  │\n                                          │ PostgreSQL  │\n                                          └─────────────┘\n```\n\n## Key Components\n\n### Frontend Architecture\n\nThe frontend is a React single-page application with the following features:\n\n1. **Component Structure**:\n   - Uses a UI component library based on Radix UI primitives with Tailwind CSS\n   - Implements shadcn/ui components for consistent design\n   - Organized with a feature-based structure (pages, components, hooks, lib)\n\n2. **State Management**:\n   - Utilizes React Query for server state management\n   - Uses React Context for global state (auth, theming)\n   - Local component state with React hooks\n\n3. **Routing**:\n   - Uses Wouter for lightweight client-side routing\n   - Implements protected routes for authenticated sections\n\n4. **Form Handling**:\n   - Uses React Hook Form with Zod validation\n   - Custom form components with error handling\n\n5. **Map Integration**:\n   - Mapbox for map rendering and geocoding\n   - Alternative Google Maps integration available\n\n### Backend Architecture\n\nThe backend is built on Express.js with:\n\n1. **API Structure**:\n   - RESTful API endpoints\n   - Server-side rendering fallback for client routes\n   - WebSocket support for real-time features\n\n2. **Authentication System**:\n   - Session-based authentication with Passport.js\n   - Password hashing with bcryptjs\n   - PostgreSQL session store\n\n3. **Database Access Layer**:\n   - Drizzle ORM for type-safe database operations\n   - Centralized storage layer with reusable database functions\n   - Data validation with Zod schemas\n\n4. **External Integrations**:\n   - Stripe payment processing\n   - Mapbox/Google Maps APIs\n\n### Database Schema\n\nThe database uses PostgreSQL with the following core entities:\n\n1. **Users**:\n   - Authentication credentials\n   - Profile information\n   - Stripe customer data\n\n2. **Events**:\n   - Event details (title, description, date, etc.)\n   - Geolocation data\n   - Categories and privacy settings\n   - Payment information\n\n3. **Event Attendees**:\n   - User-to-event relationship\n   - Attendance status\n\n4. **User Interests**:\n   - User preferences for event categories\n\nRelations are managed through Drizzle ORM with appropriate foreign key constraints.\n\n## Data Flow\n\n### Authentication Flow\n\n1. User submits credentials via login/register form\n2. Server validates credentials and creates session\n3. Client receives session cookie for subsequent authenticated requests\n4. Protected routes check session validity before rendering\n\n### Event Creation Flow\n\n1. User submits event details through create-event form\n2. Map component provides location data\n3. Server validates and stores event data\n4. Event becomes available for discovery by other users\n\n### Event Discovery Flow\n\n1. Map-based UI displays events in geographical area\n2. Filters apply based on user preferences\n3. User can view event details and opt to attend\n4. For paid events, payment flow is initiated\n\n### Payment Flow (if implemented)\n\n1. User selects paid event to attend\n2. Stripe integration handles secure payment processing\n3. On successful payment, user is added to event attendees\n4. Confirmation is sent to user\n\n## External Dependencies\n\n### Frontend Dependencies\n\n- **React**: Core UI library\n- **Tailwind CSS**: Utility-first CSS framework\n- **shadcn/ui**: Component library based on Radix UI\n- **TanStack Query**: Data fetching and cache management\n- **Wouter**: Lightweight routing\n- **React Hook Form**: Form state management \n- **Zod**: Schema validation\n- **Mapbox GL**: Map visualization\n- **Stripe.js**: Payment processing\n\n### Backend Dependencies\n\n- **Express**: Web server framework\n- **Passport.js**: Authentication middleware\n- **Bcrypt.js**: Password hashing\n- **Drizzle ORM**: Database ORM\n- **PostgreSQL**: Database\n- **Neon Serverless**: PostgreSQL provider\n- **connect-pg-simple**: Session store\n- **ws**: WebSocket implementation\n\n## Deployment Strategy\n\nThe application is configured for deployment on Replit with:\n\n1. **Build Process**:\n   - Vite for frontend build\n   - esbuild for server bundling\n\n2. **Environment Configuration**:\n   - Environment variables for API keys and connections\n   - Development vs production settings\n\n3. **Database Strategy**:\n   - Uses Neon.tech serverless PostgreSQL\n   - Database migrations with Drizzle Kit\n\n4. **Scaling Considerations**:\n   - Autoscaling configuration in Replit\n   - Serverless database for elastic scaling\n\n5. **Performance Optimization**:\n   - Static asset serving\n   - Client-side caching strategies\n   - Optimized build output\n\nThe deployment is configured to work seamlessly with Replit's ecosystem, leveraging its CI/CD capabilities and scaling features.","size_bytes":6927},"replit_agent/user_preferences.md":{"content":"# User Preferences\nThis file contains preferences for how the agent will work with the user. It can be updated by both the user and the agent.\n\nPreferred communication style: Simple, everyday language.","size_bytes":201},"scripts/fix-media-logic.js":{"content":"// Script de diagnóstico y solución para problemas de medios\nimport { storage } from '../server/storage.js';\nimport fs from 'fs';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nasync function analizeMediaItems() {\n  try {\n    console.log(\"=== COMENZANDO ANÁLISIS DE PROBLEMA DE MEDIOS ===\");\n    console.log(\"1. Verificando estructura de directorios de medios...\");\n    \n    const uploadsDir = path.join(process.cwd(), 'public/uploads/events');\n    if (!fs.existsSync(uploadsDir)) {\n      console.error(`ERROR: El directorio ${uploadsDir} no existe!`);\n      fs.mkdirSync(uploadsDir, { recursive: true });\n      console.log(`✓ Directorio ${uploadsDir} creado.`);\n    } else {\n      console.log(`✓ Directorio ${uploadsDir} existe.`);\n      const files = fs.readdirSync(uploadsDir);\n      console.log(`  - Contiene ${files.length} archivos.`);\n    }\n    \n    console.log(\"\\n2. Analizando medios del evento #6...\");\n    const event = await storage.getEventById(6);\n    \n    if (!event) {\n      console.error(\"ERROR: No se encontró el evento con ID 6\");\n      return;\n    }\n    \n    console.log(`✓ Evento encontrado: \"${event.title}\"`);\n    console.log(`  - Tipo de medio principal: ${event.mainMediaType || 'ninguno'}`);\n    console.log(`  - URL de medio principal: ${event.mainMediaUrl || 'ninguna'}`);\n    \n    // Analizar mediaItems\n    let mediaItems = [];\n    try {\n      if (event.mediaItems) {\n        mediaItems = JSON.parse(event.mediaItems);\n        console.log(`✓ Media items parseados: ${mediaItems.length} elementos`);\n        mediaItems.forEach((item, index) => {\n          console.log(`    [${index}] ${item.type}: ${item.url} (Principal: ${item.isMain ? 'Sí' : 'No'})`);\n        });\n      } else {\n        console.log(\"❌ El evento no tiene mediaItems definidos\");\n      }\n    } catch (error) {\n      console.error(\"❌ Error al parsear mediaItems:\", error);\n    }\n    \n    // Verificar si los archivos existen físicamente\n    console.log(\"\\n3. Verificando existencia física de archivos...\");\n    for (const item of mediaItems) {\n      if (item.url) {\n        const filePath = path.join(process.cwd(), 'public', item.url);\n        if (fs.existsSync(filePath)) {\n          console.log(`✓ Archivo ${item.url} existe físicamente`);\n        } else {\n          console.log(`❌ Archivo ${item.url} NO existe físicamente`);\n        }\n      }\n    }\n    \n    // Configurar evento con el video si está bien\n    console.log(\"\\n4. Verificando reparación anterior...\");\n    const videoFileName = 'event-1747358019955-759994718.mp4';\n    const videoPath = path.join(uploadsDir, videoFileName);\n    \n    if (fs.existsSync(videoPath)) {\n      console.log(`✓ El archivo de video principal existe: ${videoFileName}`);\n      \n      // Verificar si ya está configurado correctamente\n      const videoUrl = `/uploads/events/${videoFileName}`;\n      if (event.mainMediaUrl === videoUrl && event.mainMediaType === 'video') {\n        console.log(\"✓ El evento ya tiene el video configurado correctamente como medio principal\");\n        \n        // Verificar que esté en mediaItems\n        const hasVideoInMediaItems = mediaItems.some(item => \n          item.url === videoUrl && item.type === 'video');\n        \n        if (hasVideoInMediaItems) {\n          console.log(\"✓ El video también está incluido en el array mediaItems\");\n        } else {\n          console.log(\"❌ El video NO está incluido en el array mediaItems\");\n          console.log(\"   Agregando video a mediaItems...\");\n          \n          // Crear nuevo array con el video\n          const updatedMediaItems = [\n            { type: 'video', url: videoUrl, order: 0, isMain: true }\n          ];\n          \n          // Actualizar el evento\n          await storage.updateEvent(6, {\n            mediaItems: JSON.stringify(updatedMediaItems)\n          });\n          \n          console.log(\"✓ Video agregado a mediaItems\");\n        }\n      } else {\n        console.log(\"❌ El evento no tiene el video configurado correctamente\");\n        console.log(\"   Configurando video como medio principal...\");\n        \n        // Configurar video como medio principal\n        await storage.updateEvent(6, {\n          mainMediaType: 'video',\n          mainMediaUrl: videoUrl,\n          mediaItems: JSON.stringify([\n            { type: 'video', url: videoUrl, order: 0, isMain: true }\n          ])\n        });\n        \n        console.log(\"✓ Video configurado como medio principal\");\n      }\n    } else {\n      console.log(`❌ El archivo de video principal NO existe: ${videoFileName}`);\n    }\n    \n    // Verificar estado final\n    console.log(\"\\n5. Verificando estado final del evento...\");\n    const updatedEvent = await storage.getEventById(6);\n    console.log(`- Tipo de medio principal: ${updatedEvent.mainMediaType || 'ninguno'}`);\n    console.log(`- URL de medio principal: ${updatedEvent.mainMediaUrl || 'ninguna'}`);\n    \n    let updatedMediaItems = [];\n    try {\n      if (updatedEvent.mediaItems) {\n        updatedMediaItems = JSON.parse(updatedEvent.mediaItems);\n        console.log(`- Media items: ${updatedMediaItems.length} elementos`);\n        updatedMediaItems.forEach((item, index) => {\n          console.log(`    [${index}] ${item.type}: ${item.url} (Principal: ${item.isMain ? 'Sí' : 'No'})`);\n        });\n      } else {\n        console.log(\"- El evento no tiene mediaItems definidos\");\n      }\n    } catch (error) {\n      console.error(\"- Error al parsear mediaItems:\", error);\n    }\n    \n    console.log(\"\\n=== ANÁLISIS COMPLETADO ===\");\n    \n  } catch (error) {\n    console.error(\"Error en el análisis:\", error);\n  }\n}\n\n// Ejecutar la función principal\nanalizeMediaItems().then(() => {\n  console.log(\"\\nDiagnóstico finalizado\");\n  process.exit(0);\n}).catch(error => {\n  console.error(\"Error en script:\", error);\n  process.exit(1);\n});","size_bytes":5953},"scripts/fix-media.js":{"content":"// Script para reparar los medios perdidos en el evento con ID 6\nimport { storage } from '../server/storage.js';\nimport { db } from '../server/db.js';\nimport fs from 'fs';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nasync function fixEventMedia() {\n  try {\n    console.log(\"Iniciando reparación de medios para el evento #6...\");\n    \n    // Obtener el evento actual\n    const event = await storage.getEventById(6);\n    if (!event) {\n      console.error(\"No se encontró el evento con ID 6\");\n      return;\n    }\n    \n    console.log(\"Estado actual del evento:\", {\n      id: event.id,\n      title: event.title,\n      mediaItems: event.mediaItems,\n      mainMediaUrl: event.mainMediaUrl,\n      mainMediaType: event.mainMediaType\n    });\n    \n    // Obtener la lista de archivos de medios existentes para este evento\n    const uploadDir = path.join(process.cwd(), 'public/uploads/events');\n    const files = fs.readdirSync(uploadDir);\n    \n    // Buscar archivos de video relacionados (sabemos que había un video específico)\n    const eventMediaFiles = files.filter(file => \n      file.includes('event-1747358019955-759994718.mp4')\n    );\n    \n    if (eventMediaFiles.length === 0) {\n      console.log(\"No se encontraron archivos de medios para este evento\");\n      return;\n    }\n    \n    console.log(\"Archivos de medios encontrados:\", eventMediaFiles);\n    \n    // Construir los objetos mediaItems\n    const mediaItems = eventMediaFiles.map((file, index) => {\n      const fileType = file.endsWith('.mp4') ? 'video' : 'photo';\n      const url = `/uploads/events/${file}`;\n      return {\n        type: fileType,\n        url: url,\n        order: index,\n        isMain: index === 0 // El primer elemento será el principal\n      };\n    });\n    \n    // Preparar datos de actualización\n    const mainMedia = mediaItems.find(item => item.isMain);\n    const updateData = {\n      mediaItems: JSON.stringify(mediaItems),\n      mainMediaUrl: mainMedia ? mainMedia.url : '',\n      mainMediaType: mainMedia ? mainMedia.type : 'photo'\n    };\n    \n    console.log(\"Datos de actualización preparados:\", updateData);\n    \n    // Actualizar el evento en la base de datos\n    await storage.updateEvent(6, updateData);\n    \n    // Verificar actualización\n    const updatedEvent = await storage.getEventById(6);\n    console.log(\"Estado actualizado del evento:\", {\n      id: updatedEvent.id,\n      title: updatedEvent.title,\n      mediaItems: updatedEvent.mediaItems,\n      mainMediaUrl: updatedEvent.mainMediaUrl,\n      mainMediaType: updatedEvent.mainMediaType\n    });\n    \n    console.log(\"¡Reparación completada exitosamente!\");\n  } catch (error) {\n    console.error(\"Error al reparar medios:\", error);\n  }\n}\n\n// Ejecutar la función principal\nfixEventMedia().then(() => {\n  console.log(\"Script finalizado\");\n  process.exit(0);\n}).catch(error => {\n  console.error(\"Error en script:\", error);\n  process.exit(1);\n});","size_bytes":3017},"server/auth-routes.ts":{"content":"import express, { Request, Response } from 'express';\nimport { loginUserSchema, insertUserSchema } from '@shared/schema';\n// import { registerUser, loginUser, logoutUser, getCurrentUser, isAuthenticatedMiddleware } from './supabase-auth';\n\n// Temporary auth functions for local development\nconst registerUser = async () => ({ success: false, message: \"Auth disabled for local dev\" });\nconst loginUser = async () => ({ success: false, message: \"Auth disabled for local dev\" });\nconst logoutUser = async () => ({ success: true });\nconst getCurrentUser = async () => null;\nconst isAuthenticatedMiddleware = (req: any, res: any, next: any) => { next(); };\n\nconst router = express.Router();\n\n/**\n * Register a new user\n */\nrouter.post('/register', async (req: Request, res: Response) => {\n  try {\n    console.log(\"Registration attempt with data:\", { \n      email: req.body.email,\n      username: req.body.username,\n      name: req.body.name\n    });\n    \n    // Validate all input data\n    const validationResult = insertUserSchema.safeParse(req.body);\n    if (!validationResult.success) {\n      const errorMessage = validationResult.error.errors\n        .map(err => `${err.path.join('.')}: ${err.message}`)\n        .join(', ');\n      \n      return res.status(400).json({ \n        message: `Invalid input data: ${errorMessage}` \n      });\n    }\n\n    const { email, password, username, name } = validationResult.data;\n    \n    // Register user with Supabase\n    const newUser = await registerUser(email, password, username, name);\n    \n    // Return success with user data and token\n    return res.status(201).json({\n      message: \"Registration successful\",\n      user: {\n        id: newUser.id,\n        email: newUser.email,\n        username: newUser.username,\n        name: newUser.name\n      }\n    });\n  } catch (error: any) {\n    console.error(\"Error during registration:\", error);\n    \n    // Handle specific Supabase errors\n    if (error.message.includes('email already exists')) {\n      return res.status(400).json({ message: \"Email already in use\" });\n    }\n    \n    return res.status(500).json({ message: \"Internal server error\" });\n  }\n});\n\n/**\n * Login user\n */\nrouter.post('/login', async (req: Request, res: Response) => {\n  try {\n    console.log(\"Login attempt with email:\", req.body.email);\n    \n    // Validate login data\n    const validationResult = loginUserSchema.safeParse(req.body);\n    if (!validationResult.success) {\n      return res.status(400).json({ \n        message: \"Invalid login data\" \n      });\n    }\n    \n    const { email, password } = validationResult.data;\n    \n    // Login with Supabase\n    const { user, session } = await loginUser(email, password);\n    \n    // Store user in session for session-based authentication\n    if (req.session) {\n      (req.session as any).userId = user.id.toString();\n      (req.session as any).userEmail = user.email;\n      (req.session as any).authenticated = true;\n      (req.session as any).supabaseUserId = session.user?.id;\n      console.log(`Session stored for user ${user.id} (${user.email})`);\n    }\n    \n    // Return success with user data and token\n    return res.status(200).json({\n      message: \"Login successful\",\n      user: {\n        id: user.id,\n        email: user.email,\n        username: user.username,\n        name: user.name\n      },\n      token: session.access_token,\n      refresh_token: session.refresh_token\n    });\n  } catch (error: any) {\n    console.error(\"Error during login:\", error);\n    \n    // Handle specific Supabase errors\n    if (error.message.includes('Invalid login credentials')) {\n      return res.status(401).json({ message: \"Invalid credentials\" });\n    }\n    \n    return res.status(500).json({ message: \"Internal server error\" });\n  }\n});\n\n/**\n * Logout user\n */\nrouter.post('/logout', async (req: Request, res: Response) => {\n  try {\n    // Get token from authorization header\n    const authHeader = req.headers.authorization;\n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      return res.status(200).json({ message: \"Logout successful\" });\n    }\n    \n    const token = authHeader.split(' ')[1];\n    \n    // Logout from Supabase\n    await logoutUser(token || '');\n    \n    // Return success\n    return res.status(200).json({ message: \"Logout successful\" });\n  } catch (error) {\n    console.error(\"Error during logout:\", error);\n    return res.status(500).json({ message: \"Internal server error\" });\n  }\n});\n\n/**\n * Get current user\n */\nrouter.get('/me', isAuthenticatedMiddleware, (req: Request, res: Response) => {\n  // User will be set by the middleware\n  return res.status(200).json({\n    user: req.user\n  });\n});\n\n/**\n * Refresh authentication token\n */\nrouter.post('/refresh', async (req: Request, res: Response) => {\n  try {\n    // For now, return a simple response indicating refresh is not needed\n    // as we're handling session persistence differently\n    return res.status(200).json({\n      message: \"Session management handled client-side\"\n    });\n  } catch (error) {\n    console.error(\"Error in refresh endpoint:\", error);\n    return res.status(401).json({ message: \"Token refresh failed\" });\n  }\n});\n\n/**\n * Check auth status\n */\nrouter.get('/session', async (req: Request, res: Response) => {\n  try {\n    // Get token from authorization header\n    const authHeader = req.headers.authorization;\n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      return res.status(200).json({ \n        authenticated: false \n      });\n    }\n    \n    const token = authHeader.split(' ')[1];\n    \n    // Get current user\n    const user = await getCurrentUser(token || '');\n    \n    return res.status(200).json({\n      authenticated: !!user,\n      user: user || null\n    });\n  } catch (error) {\n    console.error(\"Error checking session:\", error);\n    return res.status(200).json({ authenticated: false });\n  }\n});\n\nexport { router as authRoutes };","size_bytes":5880},"server/auth.ts":{"content":"import { Express, Request, Response, NextFunction } from \"express\";\nimport { z } from \"zod\";\nimport { supabase } from \"./supabase-client\";\nimport { storage } from \"./storage\";\nimport { type User as SchemaUser } from \"@shared/schema\";\n\n// Declare types for Express\ndeclare global {\n  namespace Express {\n    interface User extends Omit<SchemaUser, 'password'> {}\n    \n    // Add user property to Request\n    interface Request {\n      user?: User;\n    }\n  }\n}\n\n// Middleware to check if the user is authenticated using either Supabase JWT or session\nasync function authMiddleware(req: Request, res: Response, next: NextFunction) {\n  try {\n    // First, check if there's already a user in the session (legacy auth)\n    if ((req as any).user && typeof (req as any).user === 'object') {\n      req.user = (req as any).user;\n      return next();\n    }\n    \n    // Check for session-based auth first (passport/express-session)\n    if ((req as any).session && (req as any).session.passport && (req as any).session.passport.user) {\n      try {\n        const userId = (req as any).session.passport.user;\n        const dbUser = await storage.getUserById(userId);\n        if (dbUser) {\n          req.user = dbUser;\n          return next();\n        }\n      } catch (sessionError) {\n        console.log('Session auth failed:', sessionError);\n      }\n    }\n    \n    // Fall back to JWT token verification\n    const authHeader = req.headers.authorization;\n    const token = authHeader?.split('Bearer ')[1];\n    \n    if (!token) {\n      // No token present, user is not authenticated\n      req.user = undefined;\n      return next();\n    }\n    \n    // Debug token verification\n    console.log(`Verifying token for ${req.method} ${req.path}: ${token.substring(0, 20)}...`);\n    \n    // Verify the token with Supabase\n    const { data: { user }, error } = await supabase.auth.getUser(token);\n    \n    if (error || !user) {\n      console.log('Token verification failed:', error?.message || 'User not found');\n      \n      // Try to refresh the session if the token is expired\n      try {\n        const { data: { session }, error: refreshError } = await supabase.auth.refreshSession();\n        if (session?.user && !refreshError) {\n          console.log('Session refreshed successfully');\n          // Get the user data from our database using the refreshed Supabase ID\n          const dbUser = await storage.getUserBySupabaseId(session.user.id);\n          if (dbUser) {\n            req.user = dbUser;\n            return next();\n          }\n        }\n      } catch (refreshError) {\n        console.log('Session refresh failed:', refreshError);\n      }\n      \n      req.user = undefined;\n      return next();\n    }\n    \n    // Get the user data from our database using the Supabase ID\n    const dbUser = await storage.getUserBySupabaseId(user.id);\n    \n    if (dbUser) {\n      console.log(`Authentication successful for user: ${dbUser.email}`);\n      req.user = dbUser;\n    } else {\n      console.log('User not found in database for Supabase ID:', user.id);\n    }\n    \n    next();\n  } catch (error) {\n    console.error('Authentication error:', error);\n    next(error);\n  }\n}\n\n// Check if user is authenticated\nexport function isAuthenticated(req: Request, res: Response, next: NextFunction) {\n  // Log authentication status for debugging\n  if (req.path.startsWith('/api/')) {\n    console.log(`Auth check for ${req.method} ${req.path}: ${req.user ? 'Authenticated' : 'Not authenticated'}`);\n  }\n  \n  if (!req.user) {\n    return res.status(401).json({ message: 'Not authenticated' });\n  }\n  \n  next();\n}\n\nexport function setupAuth(app: Express) {\n  console.log(\"Setting up authentication...\");\n\n  // Trust first proxy - needed for secure cookies behind a proxy/load balancer\n  app.set(\"trust proxy\", 1);\n  \n  // Add the authentication middleware to every request\n  app.use(authMiddleware);\n  \n  // Middleware to check if a user is authenticated (for logging purposes)\n  app.use((req: Request, res: Response, next: NextFunction) => {\n    // Log authentication status for debugging\n    if (req.path.startsWith('/api/')) {\n      console.log(`Auth check for ${req.method} ${req.path}: ${req.user ? 'Authenticated' : 'Not authenticated'}`);\n    }\n    next();\n  });\n  \n  console.log(\"Authentication setup complete\");\n}","size_bytes":4286},"server/conflict-detection.ts":{"content":"import { supabase } from './supabase-client';\n\nexport interface ConflictCheckParams {\n  userId: number;\n  startTime: Date;\n  endTime: Date;\n  paymentType: 'free' | 'paid';\n  excludeEventId?: number; // For editing events\n}\n\nexport interface ConflictResult {\n  hasConflict: boolean;\n  conflictingEvents: Array<{\n    id: number;\n    title: string;\n    startTime: Date;\n    endTime: Date;\n    paymentType: string;\n    role: 'creator' | 'attendee';\n  }>;\n  message?: string;\n}\n\n/**\n * Check for scheduling conflicts for a user\n * Rules:\n * 1. Users cannot create or attend events that overlap in time\n * 2. Paid event creators cannot create overlapping events  \n * 3. Free event creators cannot create overlapping events\n */\nexport async function checkEventConflicts(params: ConflictCheckParams): Promise<ConflictResult> {\n  const { userId, startTime, endTime, paymentType, excludeEventId } = params;\n\n  try {\n    console.log(`🕐 Checking conflicts for user ${userId} from ${startTime.toISOString()} to ${endTime.toISOString()}`);\n\n    // Get events the user created\n    let createdEventsQuery = supabase\n      .from('events')\n      .select('id, title, date, end_time, payment_type')\n      .eq('organizer_id', userId);\n\n    if (excludeEventId) {\n      createdEventsQuery = createdEventsQuery.neq('id', excludeEventId);\n    }\n\n    const { data: createdEvents, error: createdError } = await createdEventsQuery;\n\n    if (createdError) {\n      console.error('Error fetching created events:', createdError);\n      throw createdError;\n    }\n\n    // Get events the user is attending\n    let attendingEventsQuery = supabase\n      .from('event_attendees')\n      .select(`\n        events!inner(id, title, date, end_time, payment_type)\n      `)\n      .eq('user_id', userId)\n      .eq('status', 'approved');\n\n    const { data: attendingEvents, error: attendingError } = await attendingEventsQuery;\n\n    if (attendingError) {\n      console.error('Error fetching attending events:', attendingError);\n      throw attendingError;\n    }\n\n    const conflictingEvents: ConflictResult['conflictingEvents'] = [];\n\n    // Check conflicts with created events\n    if (createdEvents) {\n      for (const event of createdEvents) {\n        if (!event.end_time) continue; // Skip events without end time\n        \n        const eventStart = new Date(event.date);\n        const eventEnd = new Date(event.end_time);\n\n        // Check for overlap: events conflict if they overlap in any way\n        const hasOverlap = (\n          (startTime >= eventStart && startTime < eventEnd) ||\n          (endTime > eventStart && endTime <= eventEnd) ||\n          (startTime <= eventStart && endTime >= eventEnd)\n        );\n\n        if (hasOverlap) {\n          conflictingEvents.push({\n            id: event.id,\n            title: event.title,\n            startTime: eventStart,\n            endTime: eventEnd,\n            paymentType: event.payment_type,\n            role: 'creator'\n          });\n        }\n      }\n    }\n\n    // Check conflicts with attending events\n    if (attendingEvents) {\n      for (const attendeeRecord of attendingEvents) {\n        const event = attendeeRecord.events;\n        if (!event || !event.end_time) continue;\n\n        const eventStart = new Date(event.date);\n        const eventEnd = new Date(event.end_time);\n\n        const hasOverlap = (\n          (startTime >= eventStart && startTime < eventEnd) ||\n          (endTime > eventStart && endTime <= eventEnd) ||\n          (startTime <= eventStart && endTime >= eventEnd)\n        );\n\n        if (hasOverlap) {\n          conflictingEvents.push({\n            id: event.id,\n            title: event.title,\n            startTime: eventStart,\n            endTime: eventEnd,\n            paymentType: event.payment_type,\n            role: 'attendee'\n          });\n        }\n      }\n    }\n\n    const hasConflict = conflictingEvents.length > 0;\n    let message = '';\n\n    if (hasConflict) {\n      const creatorConflicts = conflictingEvents.filter(e => e.role === 'creator');\n      const attendeeConflicts = conflictingEvents.filter(e => e.role === 'attendee');\n\n      if (creatorConflicts.length > 0) {\n        message += `Tienes conflictos con eventos que has creado: ${creatorConflicts.map(e => e.title).join(', ')}. `;\n      }\n      \n      if (attendeeConflicts.length > 0) {\n        message += `Tienes conflictos con eventos a los que asistes: ${attendeeConflicts.map(e => e.title).join(', ')}.`;\n      }\n    }\n\n    console.log(`🕐 Conflict check result: ${hasConflict ? 'CONFLICTS FOUND' : 'NO CONFLICTS'}`);\n    \n    return {\n      hasConflict,\n      conflictingEvents,\n      message: message.trim()\n    };\n\n  } catch (error) {\n    console.error('Error in conflict detection:', error);\n    return {\n      hasConflict: false,\n      conflictingEvents: [],\n      message: 'Error checking conflicts'\n    };\n  }\n}\n\n/**\n * Check if a user can attend an event (no scheduling conflicts)\n */\nexport async function canUserAttendEvent(userId: number, eventId: number): Promise<ConflictResult> {\n  try {\n    // Get the event details\n    const { data: event, error } = await supabase\n      .from('events')\n      .select('date, end_time, payment_type')\n      .eq('id', eventId)\n      .single();\n\n    if (error || !event) {\n      return {\n        hasConflict: true,\n        conflictingEvents: [],\n        message: 'Event not found'\n      };\n    }\n\n    if (!event.end_time) {\n      return {\n        hasConflict: true,\n        conflictingEvents: [],\n        message: 'Event does not have end time set'\n      };\n    }\n\n    const startTime = new Date(event.date);\n    const endTime = new Date(event.end_time);\n\n    return await checkEventConflicts({\n      userId,\n      startTime,\n      endTime,\n      paymentType: event.payment_type as 'free' | 'paid'\n    });\n\n  } catch (error) {\n    console.error('Error checking if user can attend event:', error);\n    return {\n      hasConflict: true,\n      conflictingEvents: [],\n      message: 'Error checking attendance eligibility'\n    };\n  }\n}\n\n/**\n * Remove finished events from the map based on end time\n */\nexport async function removeFinishedEvents(): Promise<void> {\n  try {\n    const now = new Date();\n    \n    console.log(`🕐 Removing events that ended before ${now.toISOString()}`);\n\n    // For now, we'll mark events as \"ended\" instead of deleting them\n    // This can be used by the frontend to filter out ended events\n    const { error } = await supabase\n      .from('events')\n      .update({ \n        // We could add an \"ended\" status field, but for now just log\n      })\n      .lt('end_time', now.toISOString());\n\n    if (error) {\n      console.error('Error removing finished events:', error);\n    } else {\n      console.log('🕐 Finished events processing completed');\n    }\n\n  } catch (error) {\n    console.error('Error in removeFinishedEvents:', error);\n  }\n}","size_bytes":6836},"server/conflict-routes.ts":{"content":"import express from 'express';\nimport { checkEventConflicts, canUserAttendEvent } from './conflict-detection';\n\nconst router = express.Router();\n\n// Check for conflicts when creating/editing events\nrouter.post('/check-conflicts', async (req, res) => {\n  try {\n    const { startTime, endTime, paymentType, excludeEventId } = req.body;\n    \n    if (!req.user) {\n      return res.status(401).json({ message: 'Authentication required' });\n    }\n\n    if (!startTime || !endTime) {\n      return res.status(400).json({ message: 'Start time and end time are required' });\n    }\n\n    const result = await checkEventConflicts({\n      userId: req.user.id,\n      startTime: new Date(startTime),\n      endTime: new Date(endTime),\n      paymentType: paymentType || 'free',\n      excludeEventId\n    });\n\n    res.json(result);\n  } catch (error) {\n    console.error('Error checking event conflicts:', error);\n    res.status(500).json({ \n      hasConflict: false, \n      conflictingEvents: [],\n      message: 'Error checking conflicts' \n    });\n  }\n});\n\n// Check if user can attend a specific event\nrouter.post('/can-attend/:eventId', async (req, res) => {\n  try {\n    const { eventId } = req.params;\n    \n    if (!req.user) {\n      return res.status(401).json({ message: 'Authentication required' });\n    }\n\n    const result = await canUserAttendEvent(req.user.id, parseInt(eventId));\n    \n    res.json(result);\n  } catch (error) {\n    console.error('Error checking if user can attend event:', error);\n    res.status(500).json({ \n      hasConflict: true, \n      conflictingEvents: [],\n      message: 'Error checking attendance eligibility' \n    });\n  }\n});\n\nexport default router;","size_bytes":1663},"server/db.ts":{"content":"import dotenv from 'dotenv';\nimport { supabaseService } from './supabase-client';\n\n// Load environment variables\ndotenv.config();\n\nconsole.log(\"Database configured for Supabase operations...\");\n\n// CRITICAL FIX: Use service client for all database operations\n// This provides actual database access instead of fake operations\nexport const db = {\n  // For compatibility with existing code, we'll use Supabase client methods\n  query: {\n    events: {\n      findMany: async (options: any) => {\n        const { data, error } = await supabaseService\n          .from('events')\n          .select('*, attendees:event_attendees(*)')\n          .order('date', { ascending: false });\n        \n        if (error) throw error;\n        return data || [];\n      },\n      findFirst: async (options: any) => {\n        const { data, error } = await supabaseService\n          .from('events')\n          .select('*, attendees:event_attendees(*)')\n          .limit(1)\n          .single();\n        \n        if (error && error.code !== 'PGRST116') throw error;\n        return data;\n      }\n    },\n    eventAttendees: {\n      findMany: async (options: any) => {\n        const { data, error } = await supabaseService\n          .from('event_attendees')\n          .select('*, event:events(*, organizer:users(*))');\n        \n        if (error) throw error;\n        return data || [];\n      },\n      findFirst: async (options: any) => {\n        const { data, error } = await supabaseService\n          .from('event_attendees')\n          .select('*, user:users(*), event:events(*)')\n          .limit(1)\n          .single();\n        \n        if (error && error.code !== 'PGRST116') throw error;\n        return data;\n      }\n    },\n    userInterests: {\n      findMany: async (options: any) => {\n        const { data, error } = await supabaseService\n          .from('user_interests')\n          .select('*')\n          .order('created_at', { ascending: false });\n        \n        if (error) throw error;\n        return data || [];\n      }\n    },\n    userRatings: {\n      findMany: async (options: any) => {\n        const { data, error } = await supabaseService\n          .from('user_ratings')\n          .select('*')\n          .order('created_at', { ascending: false });\n        \n        if (error) throw error;\n        return data || [];\n      }\n    },\n    users: {\n      findMany: async (options: any) => {\n        let query = supabaseService.from('users').select('*');\n        \n        if (options?.where) {\n          // Apply where conditions properly\n          Object.entries(options.where).forEach(([key, value]) => {\n            query = query.eq(key, value);\n          });\n        }\n        \n        if (options?.limit) {\n          query = query.limit(options.limit);\n        }\n        \n        const { data, error } = await query;\n        if (error) throw error;\n        return data || [];\n      }\n    }\n  },\n  insert: (table: any) => ({\n    values: (values: any) => ({\n      returning: async () => {\n        // Debug table object structure\n        console.log(\"Table object structure:\", {\n          tableKeys: Object.keys(table || {}),\n          hasUnderscore: !!table._,\n          underscoreKeys: table._ ? Object.keys(table._) : null,\n          name: table?.name,\n          _name: table?._?.name,\n          toString: table.toString ? table.toString() : 'no toString'\n        });\n        \n        // Get table name - handle different possible structures\n        let tableName = 'events'; // default\n        \n        // Check if this is the userInterests table based on column presence\n        if (values.userId !== undefined && values.category !== undefined && values.eventId === undefined) {\n          tableName = 'user_interests';\n          // Map camelCase fields to snake_case for Supabase\n          values = {\n            ...values,\n            user_id: values.userId,\n            created_at: values.createdAt || new Date().toISOString()\n          };\n          // Remove camelCase fields\n          delete values.userId;\n          delete values.createdAt;\n        }\n        // Check if this is the eventAttendees table based on column presence\n        else if (values.eventId !== undefined && values.userId !== undefined) {\n          tableName = 'event_attendees';\n          // Map camelCase fields to snake_case for Supabase\n          values = {\n            ...values,\n            event_id: values.eventId,\n            user_id: values.userId,\n            payment_status: values.paymentStatus,\n            payment_intent_id: values.paymentIntentId,\n            created_at: values.createdAt\n          };\n          // Remove camelCase fields\n          delete values.eventId;\n          delete values.userId;\n          delete values.paymentStatus;\n          delete values.paymentIntentId;\n          delete values.createdAt;\n        } else if (table?._?.name) {\n          tableName = table._.name;\n        } else if (table?.name) {\n          tableName = table.name;\n        } else if (table?.table) {\n          tableName = table.table;\n        }\n        \n        console.log(\"Insert operation - table name:\", tableName, \"values:\", Object.keys(values));\n        \n        const { data, error } = await supabaseService\n          .from(tableName)\n          .insert(values)\n          .select();\n        \n        if (error) {\n          console.error(\"Database insert error:\", error);\n          throw error;\n        }\n        return data || [];\n      }\n    })\n  }),\n  update: (table: any) => ({\n    set: (values: any) => ({\n      where: (condition: any) => {\n        return {\n          returning: async () => {\n            // Get table name - handle different possible structures\n            const tableName = table?._?.name || table?.name || table?.table || 'events';\n            console.log(\"Update operation - table name:\", tableName, \"values:\", Object.keys(values));\n            \n            // CRITICAL FIX: Apply where conditions properly\n            let query = supabaseService.from(tableName).update(values);\n            \n            // Apply where conditions\n            if (condition && typeof condition === 'object') {\n              Object.entries(condition).forEach(([key, value]) => {\n                query = query.eq(key, value);\n              });\n            }\n            \n            const { data, error } = await query.select();\n            \n            if (error) {\n              console.error(\"Database update error:\", error);\n              throw error;\n            }\n            return data || [];\n          }\n        };\n      }\n    })\n  }),\n  delete: (table: any) => ({\n    where: async (condition: any) => {\n      const tableName = table?._?.name || table?.name || 'unknown';\n      \n      // CRITICAL FIX: Apply where conditions properly\n      let query = supabaseService.from(tableName).delete();\n      \n      // Apply where conditions\n      if (condition && typeof condition === 'object') {\n        Object.entries(condition).forEach(([key, value]) => {\n          query = query.eq(key, value);\n        });\n      }\n      \n      const { data, error } = await query;\n      \n      if (error) throw error;\n      return data || [];\n    }\n  }),\n  execute: async (query: any) => {\n    // CRITICAL FIX: Actually execute SQL using Supabase service client\n    console.log(\"Executing SQL:\", typeof query === 'string' ? query.substring(0, 100) + '...' : query.toString());\n    \n    if (typeof query === 'object' && query.sql) {\n      // Handle Drizzle-style query objects\n      const { data, error } = await supabaseService.rpc('exec_sql', { \n        sql_query: query.sql \n      });\n      \n      if (error) {\n        console.error(\"SQL execution error:\", error);\n        throw error;\n      }\n      \n      return { rows: data || [] };\n    } else if (typeof query === 'string') {\n      // Handle raw SQL strings\n      try {\n        const { data, error } = await supabaseService.rpc('exec_sql', { \n          sql_query: query \n        });\n        \n        if (error) {\n          console.error(\"SQL execution error:\", error);\n          throw error;\n        }\n        \n        return { rows: data || [] };\n      } catch (error) {\n        console.error(\"Failed to execute SQL:\", error);\n        // Fallback for DDL operations - log and continue\n        console.log(\"SQL execution completed (DDL operations may not return data)\");\n        return { rows: [] };\n      }\n    }\n    \n    console.log(\"Unsupported query type, skipping execution\");\n    return { rows: [] };\n  }\n};\n\nconsole.log(\"✅ Database configured with Supabase service client integration\");\n","size_bytes":8521},"server/fix-media-storage.js":{"content":"/**\n * PARCHE: CORRECCIÓN DEL PROBLEMA DE PÉRDIDA DE ARCHIVOS MULTIMEDIA EN EDICIÓN DE EVENTOS\n * \n * Este parche debe aplicarse después de la línea 1991:\n * \n *   // Actualizar los campos de multimedia\n *   updateData.mediaItems = JSON.stringify(mediaItems);\n * \n * Inmediatamente después agregar:\n */\n\n// VERIFICAR PÉRDIDA DE DATOS: Si mediaItems está vacío pero el evento tenía mediaItems antes\nif (mediaItems.length === 0 && event.mediaItems && event.mediaItems !== \"[]\") {\n  try {\n    // Intenta recuperar los mediaItems originales\n    const originalMediaItems = JSON.parse(event.mediaItems);\n    if (Array.isArray(originalMediaItems) && originalMediaItems.length > 0) {\n      console.log(\"🔒 PRESERVANDO MEDIOS ORIGINALES: Detectada posible pérdida de datos multimedia\");\n      console.log(`Evento tenía ${originalMediaItems.length} elementos multimedia antes de la actualización`);\n      console.log(\"Conservando los elementos multimedia originales\");\n      \n      // Restaurar los mediaItems originales\n      mediaItems = originalMediaItems;\n      \n      // Restaurar también el elemento principal\n      const mainItem = originalMediaItems.find(item => item.isMain);\n      if (mainItem) {\n        mainMediaUrl = mainItem.url;\n        mainMediaType = mainItem.type;\n        console.log(`Restaurando elemento principal: ${mainMediaType} - ${mainMediaUrl}`);\n      } else if (originalMediaItems.length > 0) {\n        // Si no hay un elemento principal marcado, usar el primero\n        mainMediaUrl = originalMediaItems[0].url;\n        mainMediaType = originalMediaItems[0].type;\n        originalMediaItems[0].isMain = true;\n        console.log(`Estableciendo primer elemento como principal: ${mainMediaType} - ${mainMediaUrl}`);\n      }\n      \n      // Actualizar también el updateData con estos valores\n      updateData.mediaItems = JSON.stringify(mediaItems);\n      updateData.mainMediaUrl = mainMediaUrl;\n      updateData.mainMediaType = mainMediaType;\n      \n      console.log(\"Datos de multimedia ACTUALIZADOS para guardar:\");\n      console.log(\"- mediaItems:\", mediaItems.length);\n      console.log(\"- mainMediaType:\", mainMediaType);\n      console.log(\"- mainMediaUrl:\", mainMediaUrl);\n    }\n  } catch (e) {\n    console.error(\"Error al intentar recuperar mediaItems originales:\", e);\n  }\n}","size_bytes":2318},"server/index.ts":{"content":"import express, { type Request, Response, NextFunction } from \"express\";\nimport session from \"express-session\";\nimport cookieParser from \"cookie-parser\";\nimport { registerRoutes } from \"./routes\";\nimport { setupVite, serveStatic, log } from \"./vite\";\nimport { mediaRouter } from \"./media-routes\";\n// Supabase integration enabled\nimport { supabase, supabaseService, testSupabaseConnection } from \"./supabase-client\";\nimport { isAuthenticatedMiddleware } from './supabase-auth';\nimport { supabaseRoutes } from \"./supabase-routes\";\nimport conflictRoutes from \"./conflict-routes\";\nimport { db } from \"./db\";\nimport { sql } from \"drizzle-orm\";\nimport passport from \"passport\";\nimport { Strategy as LocalStrategy } from \"passport-local\";\nimport bcrypt from \"bcrypt\";\nimport { storage } from \"./storage\";\n\nconst app = express();\n\n// Configure cookie parsing\napp.use(cookieParser());\n\n// Configure session management for persistent authentication\napp.use(session({\n  secret: process.env.SESSION_SECRET || 'pipol-session-secret-key-2025',\n  resave: false,\n  saveUninitialized: false,\n  name: 'pipol_session',\n  cookie: {\n    secure: false, // Set to true in production with HTTPS\n    httpOnly: true,\n    maxAge: 24 * 60 * 60 * 1000, // 24 hours\n    sameSite: 'lax'\n  },\n  rolling: true, // Extend session on activity\n  store: undefined // Use memory store for development\n}));\n\n// Configure passport for session management\napp.use(passport.initialize());\napp.use(passport.session());\n\n// Passport serialization for session persistence\npassport.serializeUser((user: any, done) => {\n  done(null, user.id);\n});\n\npassport.deserializeUser(async (id: any, done) => {\n  try {\n    console.log(\"Deserializing user with ID:\", id);\n    const userId = parseInt(id);\n    if (isNaN(userId)) {\n      console.log(\"Invalid user ID during deserialization:\", id);\n      return done(null, false);\n    }\n    \n    // Query Supabase directly to check if user exists using service client\n    console.log(\"Querying Supabase for user ID:\", userId);\n    const { data: users, error, count } = await supabaseService\n      .from('users')\n      .select('*', { count: 'exact' })\n      .eq('id', userId);\n    \n    console.log(\"Supabase query result:\", { \n      error: error?.message || null, \n      userCount: count, \n      hasUsers: users && users.length > 0,\n      firstUser: users && users.length > 0 ? { id: users[0].id, name: users[0].name, email: users[0].email } : null\n    });\n    \n    if (error) {\n      console.error(\"Supabase query error:\", error.message);\n      return done(null, false);\n    }\n    \n    if (users && users.length > 0) {\n      const user = users[0]; // Take first user if multiple exist\n      console.log(\"User deserialized successfully:\", user.id, user.name);\n      done(null, user);\n    } else {\n      console.log(\"User not found during deserialization for ID:\", userId);\n      \n      // Debug: Check if any users exist in the table\n      const { data: allUsers, error: allError } = await supabaseService\n        .from('users')\n        .select('id, name, email')\n        .limit(5);\n      \n      console.log(\"Debug: Sample users in database:\", { \n        error: allError?.message || null,\n        sampleUsers: allUsers || []\n      });\n      \n      done(null, false);\n    }\n  } catch (error) {\n    console.error(\"Error deserializing user:\", error);\n    done(null, false);\n  }\n});\n\n// Configure Passport Local Strategy for authentication\npassport.use(new LocalStrategy({\n  usernameField: 'email', // Use email as username field\n  passwordField: 'password'\n}, async (email, password, done) => {\n  try {\n    console.log(\"Local strategy: Authenticating user with email:\", email);\n    \n    // Find user by email\n    const user = await storage.getUserByEmail(email);\n    if (!user) {\n      console.log(\"Local strategy: User not found for email:\", email);\n      return done(null, false, { message: 'Invalid email or password' });\n    }\n    \n    // Check if user has a password (some users might be OAuth only)\n    if (!user.password) {\n      console.log(\"Local strategy: User has no password set:\", email);\n      return done(null, false, { message: 'Please use social login or reset your password' });\n    }\n    \n    // Verify password\n    const isValidPassword = await bcrypt.compare(password, user.password);\n    if (!isValidPassword) {\n      console.log(\"Local strategy: Invalid password for user:\", email);\n      return done(null, false, { message: 'Invalid email or password' });\n    }\n    \n    console.log(\"Local strategy: Authentication successful for user:\", email);\n    return done(null, user);\n  } catch (error) {\n    console.error(\"Local strategy: Authentication error:\", error);\n    return done(error);\n  }\n}));\n\n// Aumentar el límite de tamaño para solicitudes JSON\napp.use(express.json({ limit: '10mb' }));\napp.use(express.urlencoded({ extended: true, limit: '10mb' }));\n\n// Emergency route removed - issue was fixed in storage.ts by using Supabase client instead of mock db\n\n// Add CORS headers for development with proper credentials handling\napp.use((req, res, next) => {\n  const origin = req.headers.origin;\n  // For local development, allow localhost and 127.0.0.1\n  if (origin && (origin.includes('localhost') || origin.includes('127.0.0.1') || origin.includes('replit.dev'))) {\n    res.header('Access-Control-Allow-Origin', origin);\n  } else if (!origin) {\n    // Same-origin requests (no origin header)\n    res.header('Access-Control-Allow-Origin', 'http://localhost:5000');\n  }\n  \n  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');\n  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization, Cookie');\n  res.header('Access-Control-Allow-Credentials', 'true');\n  \n  // Set content headers for API routes to ensure correct handling\n  if (req.path.startsWith('/api/')) {\n    if (req.method !== 'OPTIONS') {\n      res.header('Content-Type', 'application/json');\n    }\n  }\n  \n  if (req.method === 'OPTIONS') {\n    return res.sendStatus(200);\n  }\n  next();\n});\n\napp.use((req, res, next) => {\n  const start = Date.now();\n  const path = req.path;\n  let capturedJsonResponse: Record<string, any> | undefined = undefined;\n\n  const originalResJson = res.json;\n  res.json = function (bodyJson, ...args) {\n    capturedJsonResponse = bodyJson;\n    return originalResJson.apply(res, [bodyJson, ...args]);\n  };\n\n  res.on(\"finish\", () => {\n    const duration = Date.now() - start;\n    if (path.startsWith(\"/api\")) {\n      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;\n      if (capturedJsonResponse) {\n        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;\n      }\n\n      if (logLine.length > 80) {\n        logLine = logLine.slice(0, 79) + \"…\";\n      }\n\n      log(logLine);\n    }\n  });\n\n  next();\n});\n\n(async () => {\n  // Test database connection\n  try {\n    await db.execute('SELECT 1');\n    console.log('Database connection successful');\n  } catch (error) {\n    console.error('Database connection failed:', error);\n  }\n  \n  // Create user_interests table if it doesn't exist\n  try {\n    console.log('Creating user_interests table if needed...');\n    await db.execute(`\n      CREATE TABLE IF NOT EXISTS user_interests (\n        id SERIAL PRIMARY KEY,\n        user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n        category TEXT NOT NULL,\n        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n        UNIQUE(user_id, category)\n      );\n    `);\n    console.log('user_interests table is ready');\n  } catch (error: any) {\n    console.log('user_interests table creation skipped (may already exist):', error.message);\n  }\n\n  // Create chat_messages table if it doesn't exist\n  try {\n    console.log('Creating chat_messages table if needed...');\n    await db.execute(`\n      CREATE TABLE IF NOT EXISTS chat_messages (\n        id SERIAL PRIMARY KEY,\n        event_id INTEGER NOT NULL REFERENCES events(id) ON DELETE CASCADE,\n        sender_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n        content TEXT NOT NULL,\n        message_type TEXT DEFAULT 'text' NOT NULL,\n        reply_to_id INTEGER REFERENCES chat_messages(id),\n        edited BOOLEAN DEFAULT false NOT NULL,\n        edited_at TIMESTAMP WITH TIME ZONE,\n        deleted_at TIMESTAMP WITH TIME ZONE,\n        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,\n        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL\n      );\n    `);\n    console.log('chat_messages table is ready');\n  } catch (error: any) {\n    console.log('chat_messages table creation skipped (may already exist):', error.message);\n  }\n\n  // Create notification type enum if it doesn't exist\n  try {\n    console.log('Creating notification_type enum if needed...');\n    await db.execute(`\n      DO $$ BEGIN\n        CREATE TYPE notification_type AS ENUM ('request_approved', 'request_rejected', 'new_request');\n      EXCEPTION\n        WHEN duplicate_object THEN NULL;\n      END $$;\n    `);\n    console.log('notification_type enum is ready');\n  } catch (error: any) {\n    console.log('notification_type enum creation skipped (may already exist):', error.message);\n  }\n\n  // Create notifications table if it doesn't exist\n  try {\n    console.log('Creating notifications table if needed...');\n    await db.execute(`\n      CREATE TABLE IF NOT EXISTS notifications (\n        id SERIAL PRIMARY KEY,\n        user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n        type notification_type NOT NULL,\n        title TEXT NOT NULL,\n        message TEXT NOT NULL,\n        event_id INTEGER REFERENCES events(id) ON DELETE CASCADE,\n        request_id INTEGER REFERENCES event_attendees(id) ON DELETE CASCADE,\n        is_read BOOLEAN DEFAULT FALSE NOT NULL,\n        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL\n      );\n    `);\n    console.log('notifications table is ready');\n  } catch (error: any) {\n    console.log('notifications table creation skipped (may already exist):', error.message);\n  }\n\n  // Add end_time column to events table if it doesn't exist\n  try {\n    console.log('Adding end_time column to events table if needed...');\n    await db.execute(`\n      ALTER TABLE events ADD COLUMN IF NOT EXISTS end_time TIMESTAMP WITH TIME ZONE;\n    `);\n    console.log('end_time column is ready');\n    \n    // Update existing events with default end time (2 hours after start)\n    await db.execute(`\n      UPDATE events \n      SET end_time = date + INTERVAL '2 hours' \n      WHERE end_time IS NULL;\n    `);\n    console.log('Existing events updated with default end times');\n  } catch (error: any) {\n    console.log('end_time column setup completed or skipped:', error.message);\n  }\n\n  // Add gender enums and columns\n  try {\n    console.log('Creating gender enums if needed...');\n    \n    // Create gender enum\n    await db.execute(`\n      DO $$ BEGIN\n        CREATE TYPE gender AS ENUM ('masculino', 'femenino', 'otro', 'no_especificar');\n      EXCEPTION\n        WHEN duplicate_object THEN NULL;\n      END $$;\n    `);\n    \n    // Create gender preference enum (recreate if needed to ensure correct values)\n    await db.execute(`\n      DO $$ BEGIN\n        DROP TYPE IF EXISTS gender_preference CASCADE;\n        CREATE TYPE gender_preference AS ENUM ('all_people', 'men', 'women');\n      EXCEPTION\n        WHEN others THEN \n          -- If there's an error, try to create the type anyway\n          BEGIN\n            CREATE TYPE gender_preference AS ENUM ('all_people', 'men', 'women');\n          EXCEPTION\n            WHEN duplicate_object THEN NULL;\n          END;\n      END $$;\n    `);\n    \n    console.log('Gender enums created successfully');\n  } catch (error: any) {\n    console.log('Gender enums creation completed or skipped:', error.message);\n  }\n  \n  // Add gender column to users table\n  try {\n    console.log('Adding gender column to users table if needed...');\n    await db.execute(`\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS gender gender;\n    `);\n    console.log('Gender column added to users table');\n  } catch (error: any) {\n    console.log('Gender column setup completed or skipped:', error.message);\n  }\n  \n  // Add gender_preference column to events table\n  try {\n    console.log('Adding gender_preference column to events table if needed...');\n    await db.execute(`\n      ALTER TABLE events ADD COLUMN IF NOT EXISTS gender_preference gender_preference DEFAULT 'all_people';\n    `);\n    \n    // Update existing events with default gender preference and convert 'mixto' to 'all_people'\n    await db.execute(`\n      UPDATE events \n      SET gender_preference = 'all_people' \n      WHERE gender_preference IS NULL OR gender_preference::text = 'mixto';\n    `);\n    \n    console.log('Gender preference column added to events table');\n  } catch (error: any) {\n    console.log('Gender preference column setup completed or skipped:', error.message);\n  }\n\n  // Create user_ratings table for aura system\n  try {\n    console.log('Creating user_ratings table if needed...');\n    \n    // Check if table exists by testing a simple query\n    const { error: checkError } = await supabase\n      .from('user_ratings')\n      .select('id')\n      .limit(1);\n    \n    if (checkError && checkError.message.includes('relation \"public.user_ratings\" does not exist')) {\n      console.log('Creating user_ratings table with fallback method...');\n      // Create table using Supabase-compatible approach\n      const createTableSQL = `\n        CREATE TABLE IF NOT EXISTS user_ratings (\n          id SERIAL PRIMARY KEY,\n          rated_user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n          rater_user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n          rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 10),\n          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,\n          updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,\n          UNIQUE(rated_user_id, rater_user_id)\n        );\n      `;\n      \n      // Create using supabase SQL execution - simplified approach\n      try {\n        // Try alternative approach - create an insert operation that will fail but reveal if table exists\n        await supabase.from('user_ratings').insert([]);\n      } catch (insertError: any) {\n        console.log('Table creation approach - ready to create via SQL editor');\n        console.log('Please execute this SQL in Supabase SQL editor:');\n        console.log(createTableSQL);\n      }\n    }\n    \n    console.log('user_ratings table is ready');\n  } catch (error: any) {\n    console.log('user_ratings table creation completed or skipped:', error.message);\n  }\n  \n  // Initialize local storage for media files\n  console.log('Setting up local file storage...');\n  try {\n    const fs = await import('fs');\n    const path = await import('path');\n    const uploadsDir = path.join(process.cwd(), 'public', 'uploads');\n    const attachedDir = path.join(process.cwd(), 'attached_assets');\n    \n    if (!fs.existsSync(uploadsDir)) {\n      fs.mkdirSync(uploadsDir, { recursive: true });\n    }\n    if (!fs.existsSync(attachedDir)) {\n      fs.mkdirSync(attachedDir, { recursive: true });\n    }\n    console.log('Local storage directories ready');\n  } catch (error) {\n    console.error('Error setting up local storage:', error);\n  }\n  \n  // Create a simple auth logger middleware\n  const logAuthStatus = (req: Request, res: Response, next: NextFunction) => {\n    if (req.path.startsWith('/api/auth/')) {\n      console.log(`Auth check for ${req.method} ${req.path}: ${req.user ? 'Authenticated' : 'Not authenticated'}`);\n    }\n    next();\n  };\n  \n  // Temporarily disable auth logger to fix middleware loop\n  // app.use(logAuthStatus);\n  \n  // Test Supabase connection\n  console.log('Testing Supabase connection...');\n  await testSupabaseConnection();\n  \n// Priority route removed - issue was fixed in storage.ts by using Supabase client instead of mock db\n  \n  // Serve static files from public directory (for multimedia files)\n  app.use(express.static('public'));\n  \n  // Add media router for file handling\n  app.use(mediaRouter);\n  \n  // Register Supabase auth routes\n  app.use('/api/auth', supabaseRoutes);\n  \n  // Register conflict detection routes with specific paths that need auth\n  app.use('/api/events/conflict-check', isAuthenticatedMiddleware, conflictRoutes);\n  \n  // Register API routes (excluding auth routes - handled by Supabase)\n  const server = await registerRoutes(app, { excludeAuth: true });\n\n  // Set up WebSocket server for chat\n  const { ChatWebSocketServer } = await import('./websocket-server');\n  new ChatWebSocketServer(server);\n\n  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {\n    const status = err.status || err.statusCode || 500;\n    const message = err.message || \"Internal Server Error\";\n\n    console.error(\"Express error handler:\", err);\n    res.status(status).json({ message });\n  });\n\n\n\n  // Add a special middleware to ensure API routes don't get handled by Vite\n  app.use((req, res, next) => {\n    // If this is an API request and has already been handled, don't pass it to Vite\n    if (req.path.startsWith('/api/') && res.headersSent) {\n      return;\n    }\n    next();\n  });\n  \n  // importantly only setup vite in development and after\n  // setting up all the other routes so the catch-all route\n  // doesn't interfere with the other routes\n  if (app.get(\"env\") === \"development\") {\n    await setupVite(app, server);\n  } else {\n    serveStatic(app);\n  }\n\n  // Use port 5000 for Replit compatibility, fallback to available port\n  const PORT = process.env.PORT || 5000;\n  log(`Attempting to start server on port ${PORT}...`);\n  \n  server.listen({\n    port: PORT,\n    host: \"0.0.0.0\",\n  }, () => {\n    log(`🚀 Server started successfully on port ${PORT}`);\n    \n    // Print additional information to make it clear for users\n    log(`-------------------------------------------------------`);\n    log(`Pipol Application is now running!`);\n    log(`Access the app in your browser at: http://localhost:${PORT}`);\n    log(`-------------------------------------------------------`);\n  }).on('error', (err: any) => {\n    const errorMessage = err instanceof Error ? err.message : String(err);\n    log(`Failed to start server: ${errorMessage}`);\n    process.exit(1);\n  });\n})();\n","size_bytes":18337},"server/media-helper.js":{"content":"/**\n * Media helper functions for processing uploaded files in events\n */\n\n/**\n * Processes newly uploaded media files and assigns them to the correct media items\n * @param {Object} files - The files object from multer\n * @param {Array} mediaItems - The array of existing media items\n * @param {Array} newMediaItems - Array of newly added media items from client\n * @returns {Object} Updated media information\n */\nfunction processUploadedMedia(files, mediaItems = [], newMediaItems = []) {\n  if (!files || Object.keys(files).length === 0) {\n    console.log(\"No files uploaded\");\n    return { mediaItems, mainMediaUrl: null, mainMediaType: null };\n  }\n\n  console.log(\"Processing uploaded files:\", Object.keys(files));\n  let mainMediaUrl = null;\n  let mainMediaType = null;\n  \n  // Go through all uploaded files\n  for (const fieldName in files) {\n    if (files[fieldName] && files[fieldName].length > 0) {\n      const file = files[fieldName][0];\n      if (!file) continue;\n      \n      const filePath = file.path.replace('public', '');\n      const fileType = file.mimetype.startsWith('video/') ? 'video' : 'photo';\n      \n      console.log(`Found file ${fieldName}: ${filePath} (${fileType})`);\n      \n      // Find if there's a corresponding new media item\n      let matchingItem = newMediaItems.find(item => \n        item.id && item.id.startsWith('new-') && \n        // Either this is a mainMediaFile or the item has a fileIndex matching the field name suffix\n        (fieldName === 'mainMediaFile' || \n         (fieldName.startsWith('mediaFile_') && \n          item.fileIndex == fieldName.split('_')[1]))\n      );\n      \n      if (matchingItem) {\n        // Update the matching item with the real file path\n        console.log(`Assigning URL ${filePath} to item ${matchingItem.id}`);\n        matchingItem.url = filePath;\n        matchingItem.type = fileType;\n        \n        // If this is the main media or marked as main, update main media reference\n        if (matchingItem.isMain || fieldName === 'mainMediaFile') {\n          mainMediaUrl = filePath;\n          mainMediaType = fileType;\n          matchingItem.isMain = true;\n        }\n        \n        // Add this item to mediaItems if it's not already there\n        if (!mediaItems.some(item => item.url === filePath)) {\n          mediaItems.push({\n            type: fileType,\n            url: filePath,\n            order: mediaItems.length,\n            isMain: matchingItem.isMain || false\n          });\n        }\n      } else {\n        // If no matching item was found, add as a new item\n        console.log(`Adding new media item for ${filePath}`);\n        const isMain = fieldName === 'mainMediaFile';\n        \n        mediaItems.push({\n          type: fileType,\n          url: filePath,\n          order: mediaItems.length,\n          isMain\n        });\n        \n        if (isMain) {\n          mainMediaUrl = filePath;\n          mainMediaType = fileType;\n        }\n      }\n    }\n  }\n  \n  // If there's an item marked as main but no main URL yet, use that item\n  if (!mainMediaUrl && mediaItems.length > 0) {\n    const mainItem = mediaItems.find(item => item.isMain);\n    if (mainItem) {\n      mainMediaUrl = mainItem.url;\n      mainMediaType = mainItem.type;\n    } else {\n      // Default to the first item if nothing is marked as main\n      mainMediaUrl = mediaItems[0].url;\n      mainMediaType = mediaItems[0].type;\n      mediaItems[0].isMain = true;\n    }\n  }\n  \n  return { mediaItems, mainMediaUrl, mainMediaType };\n}\n\nmodule.exports = {\n  processUploadedMedia\n};","size_bytes":3527},"server/media-helper.ts":{"content":"/**\n * Media helper functions for processing uploaded files in events\n */\nimport { Request } from 'express';\nimport multer from 'multer';\n\ninterface MediaItem {\n  type: string;\n  url: string;\n  order: number;\n  isMain?: boolean;\n  id?: string;\n}\n\ninterface MediaItemInfo {\n  id?: string;\n  type: string;\n  url?: string;\n  isMain?: boolean;\n  isNew?: boolean;\n  fileIndex?: number;\n  order?: number;\n  deleted?: boolean;\n  toDelete?: boolean;\n}\n\ninterface MediaProcessingResult {\n  mediaItems: MediaItem[];\n  mainMediaUrl: string | null;\n  mainMediaType: string | null;\n}\n\n/**\n * Processes newly uploaded media files and assigns them to the correct media items\n */\nexport function processUploadedMedia(\n  files: { [fieldname: string]: Express.Multer.File[] },\n  mediaItems: MediaItem[] = [], \n  newMediaItemsInfo: MediaItemInfo[] = []\n): MediaProcessingResult {\n  if (!files || Object.keys(files).length === 0) {\n    console.log(\"No files uploaded\");\n    return { \n      mediaItems, \n      mainMediaUrl: null, \n      mainMediaType: null \n    };\n  }\n\n  console.log(\"Processing uploaded files:\", Object.keys(files));\n  let mainMediaUrl: string | null = null;\n  let mainMediaType: string | null = null;\n  \n  // Go through all uploaded files\n  for (const fieldName in files) {\n    if (files[fieldName] && files[fieldName].length > 0) {\n      const file = files[fieldName][0];\n      if (!file) continue;\n      \n      const filePath = file.path.replace('public', '');\n      const fileType = file.mimetype.startsWith('video/') ? 'video' : 'photo';\n      \n      console.log(`Found file ${fieldName}: ${filePath} (${fileType})`);\n      \n      // Find if there's a corresponding new media item\n      const fieldIndex = fieldName.startsWith('mediaFile_') ? \n        parseInt(fieldName.split('_')[1]) : -1;\n        \n      let matchingItem = newMediaItemsInfo.find(item => \n        item.id && item.id.startsWith('new-') && \n        // Either this is a mainMediaFile or the item has a fileIndex matching the field name suffix\n        (fieldName === 'mainMediaFile' || \n         (fieldName.startsWith('mediaFile_') && \n          item.fileIndex === fieldIndex))\n      );\n      \n      if (matchingItem) {\n        // Update the matching item with the real file path\n        console.log(`Assigning URL ${filePath} to item ${matchingItem.id}`);\n        matchingItem.url = filePath;\n        matchingItem.type = fileType;\n        \n        // If this is the main media or marked as main, update main media reference\n        if (matchingItem.isMain || fieldName === 'mainMediaFile') {\n          mainMediaUrl = filePath;\n          mainMediaType = fileType;\n          matchingItem.isMain = true;\n        }\n        \n        // Add this item to mediaItems if it's not already there\n        if (!mediaItems.some(item => item.url === filePath)) {\n          mediaItems.push({\n            type: fileType,\n            url: filePath,\n            order: mediaItems.length,\n            isMain: matchingItem.isMain || false\n          });\n        }\n      } else {\n        // If no matching item was found, add as a new item\n        console.log(`Adding new media item for ${filePath}`);\n        const isMain = fieldName === 'mainMediaFile';\n        \n        mediaItems.push({\n          type: fileType,\n          url: filePath,\n          order: mediaItems.length,\n          isMain\n        });\n        \n        if (isMain) {\n          mainMediaUrl = filePath;\n          mainMediaType = fileType;\n        }\n      }\n    }\n  }\n  \n  // If there's an item marked as main but no main URL yet, use that item\n  if (!mainMediaUrl && mediaItems.length > 0) {\n    const mainItem = mediaItems.find(item => item.isMain);\n    if (mainItem) {\n      mainMediaUrl = mainItem.url;\n      mainMediaType = mainItem.type;\n    } else {\n      // Default to the first item if nothing is marked as main\n      mainMediaUrl = mediaItems[0].url;\n      mainMediaType = mediaItems[0].type;\n      mediaItems[0].isMain = true;\n    }\n  }\n  \n  // Sort media items so main item appears first\n  const sortedMediaItems = mediaItems.sort((a, b) => {\n    // If one is main and the other is not, main goes first\n    if (a.isMain && !b.isMain) return -1;\n    if (!a.isMain && b.isMain) return 1;\n    // If both are main or neither is main, sort by order\n    return (a.order || 0) - (b.order || 0);\n  });\n\n  return { mediaItems: sortedMediaItems, mainMediaUrl, mainMediaType };\n}\n\n/**\n * Preserves existing media when client sends incomplete media data\n */\nexport function preserveExistingMedia(\n  event: any, \n  clientMediaItems: MediaItem[], \n  updateData: any\n): boolean {\n  // Check if the event already has media items but client sent none or empty array\n  if (event.mediaItems && \n     (!clientMediaItems || clientMediaItems.length === 0)) {\n    console.log(\"PRESERVING EXISTING MEDIA - Client sent empty media items\");\n    try {\n      // Parse existing media items from event\n      let existingMediaItems: MediaItem[] = [];\n      \n      if (typeof event.mediaItems === 'string') {\n        existingMediaItems = JSON.parse(event.mediaItems);\n      } else if (Array.isArray(event.mediaItems)) {\n        existingMediaItems = event.mediaItems;\n      }\n      \n      if (existingMediaItems && existingMediaItems.length > 0) {\n        console.log(`Preserving ${existingMediaItems.length} existing media items`);\n        updateData.mediaItems = JSON.stringify(existingMediaItems);\n        \n        // Also preserve main media reference\n        if (event.mainMediaUrl) {\n          updateData.mainMediaUrl = event.mainMediaUrl;\n          updateData.mainMediaType = event.mainMediaType || 'photo';\n        }\n        \n        return true;\n      }\n    } catch (e) {\n      console.warn(\"Error preserving media:\", e);\n    }\n  }\n  return false;\n}","size_bytes":5751},"server/media-preserv.js":{"content":"\n// This is a quick fix for storing event media\nconst checkAndPreserveMedia = (event, mediaItems, mainMediaUrl, mainMediaType, updateData) => {\n  // Verificar si mediaItems está vacío pero el evento tenía mediaItems antes\n  if (mediaItems.length === 0 && event.mediaItems && event.mediaItems !== \"[]\") {\n    try {\n      const originalMediaItems = JSON.parse(event.mediaItems);\n      if (Array.isArray(originalMediaItems) && originalMediaItems.length > 0) {\n        console.log(\"🔒 PRESERVANDO MEDIOS ORIGINALES: Detectada posible pérdida de datos multimedia\");\n        console.log(\"Evento tenía \" + originalMediaItems.length + \" elementos multimedia antes de la actualización\");\n        mediaItems = originalMediaItems;\n        \n        // También restaurar el elemento principal si existe\n        const mainItem = originalMediaItems.find(item => item.isMain);\n        if (mainItem) {\n          mainMediaUrl = mainItem.url;\n          mainMediaType = mainItem.type;\n        }\n      }\n    } catch (e) {\n      console.error(\"Error al intentar recuperar mediaItems originales:\", e);\n    }\n  }\n  \n  updateData.mediaItems = JSON.stringify(mediaItems);\n  updateData.mainMediaUrl = mainMediaUrl;\n  updateData.mainMediaType = mainMediaType;\n  \n  return { mediaItems, mainMediaUrl, mainMediaType };\n};\n\nmodule.exports = { checkAndPreserveMedia };","size_bytes":1345},"server/media-routes.ts":{"content":"import express, { Request, Response } from 'express';\nimport { storage } from './storage';\nimport { preserveExistingMedia } from './helpers/media-preserver';\n// import { isAuthenticatedMiddleware as requireAuth } from './supabase-auth';\n\n// Temporary auth middleware for local development\nconst requireAuth = (req: any, res: any, next: any) => { next(); };\n\n// Crear un router separado para manejar la preservación de medios\nconst mediaRouter = express.Router();\n\n// Endpoint para preservar los medios de un evento durante actualizaciones\nmediaRouter.post('/api/events/:id/preserve-media', requireAuth, async (req, res) => {\n  try {\n    const user = req.user as any;\n    const eventId = parseInt(req.params.id);\n    \n    // Verificar que el evento existe\n    const event = await storage.getEventById(eventId);\n    if (!event) {\n      return res.status(404).json({ message: \"Evento no encontrado\" });\n    }\n    \n    // Verificar que el usuario es el organizador\n    if (event.organizerId !== user.id) {\n      return res.status(403).json({ message: \"No autorizado para actualizar este evento\" });\n    }\n    \n    // Obtener mediaItems actuales del cuerpo de la solicitud\n    let mediaItems: any[] = [];\n    let preserved = false;\n    \n    if (req.body && req.body.mediaItems) {\n      try {\n        if (typeof req.body.mediaItems === 'string') {\n          mediaItems = JSON.parse(req.body.mediaItems);\n        } else if (Array.isArray(req.body.mediaItems)) {\n          mediaItems = req.body.mediaItems;\n        }\n      } catch (error) {\n        console.error(\"Error parseando mediaItems:\", error);\n        mediaItems = [];\n      }\n    }\n    \n    // Preparar la actualización\n    const updateData: any = {};\n    \n    // Usar el helper para preservar medios si es necesario\n    preserved = preserveExistingMedia(event, mediaItems, updateData);\n    \n    if (preserved) {\n      // Actualizar el evento con los medios preservados\n      await storage.updateEvent(eventId, updateData);\n      \n      // Devolver los medios preservados\n      const updatedEvent = await storage.getEventById(eventId);\n      if (!updatedEvent) {\n        return res.status(500).json({\n          success: false,\n          message: \"Error al obtener el evento actualizado\"\n        });\n      }\n      \n      return res.json({\n        success: true,\n        preserved: true,\n        message: \"Medios preservados exitosamente\",\n        mediaItems: updatedEvent.mediaItems,\n        mainMediaUrl: updatedEvent.mainMediaUrl,\n        mainMediaType: updatedEvent.mainMediaType\n      });\n    }\n    \n    // Si no se preservaron medios, simplemente devolver el estado actual\n    return res.json({\n      success: true,\n      preserved: false,\n      message: \"No fue necesario preservar medios\",\n      mediaItems: event.mediaItems,\n      mainMediaUrl: event.mainMediaUrl,\n      mainMediaType: event.mainMediaType\n    });\n  } catch (error) {\n    console.error(\"Error preservando medios:\", error);\n    res.status(500).json({ \n      success: false,\n      message: \"Error al preservar medios\", \n      error: String(error) \n    });\n  }\n});\n\nexport { mediaRouter };","size_bytes":3112},"server/media-upload-fix.js":{"content":"/**\n * Fix for media processing in event updates\n * \n * This module provides functions to handle media uploads and properly assign them to events\n */\n\nconst fs = require('fs');\nconst path = require('path');\n\n/**\n * Processes uploaded media files and assigns them to event media items\n * @param {Object} files - Files object from multer\n * @param {Array} mediaItems - Existing media items array\n * @param {Array} mediaItemsInfo - Info about media items including new items\n * @param {Object} event - The event being updated\n * @returns {Object} Object with updated mediaItems, mainMediaType and mainMediaUrl\n */\nfunction processEventMediaUploads(files, mediaItems, mediaItemsInfo, event) {\n  if (!files || Object.keys(files).length === 0) {\n    console.log(\"No hay archivos para procesar\");\n    return { mediaItems, mainMediaType: null, mainMediaUrl: null };\n  }\n\n  console.log(\"Procesando archivos subidos:\", Object.keys(files));\n  let mainMediaUrl = null;\n  let mainMediaType = 'photo'; // Default to photo\n  let updatedMediaItems = [...mediaItems]; // Clone existing media items\n  \n  // Filter to find new media items (ones with IDs starting with \"new-\")\n  const newMediaItems = mediaItemsInfo.filter(item => \n    item.id && item.id.startsWith('new-')\n  );\n  \n  console.log(`Nuevos elementos multimedia detectados: ${newMediaItems.length}`);\n  \n  // Process each uploaded file\n  Object.keys(files).forEach(fieldName => {\n    if (files[fieldName] && files[fieldName].length > 0) {\n      const file = files[fieldName][0];\n      if (!file) return;\n      \n      const filePath = file.path.replace('public', '');\n      const fileType = file.mimetype.startsWith('video/') ? 'video' : 'photo';\n      \n      console.log(`Archivo subido en campo ${fieldName}: ${filePath}`);\n      \n      // Find the corresponding new media item based on field name\n      let mediaItemIndex = -1;\n      \n      if (fieldName === 'mainMediaFile') {\n        // This is the main media file\n        mainMediaUrl = filePath;\n        mainMediaType = fileType;\n        \n        // Check if there's a media item marked as main\n        const mainItemInfo = newMediaItems.find(item => item.isMain);\n        if (mainItemInfo) {\n          console.log(`Asignando URL al elemento principal: ${mainItemInfo.id}`);\n          mainItemInfo.url = filePath;\n        } else {\n          // Add a new media item for this main file\n          updatedMediaItems.push({\n            type: fileType,\n            url: filePath,\n            order: updatedMediaItems.length,\n            isMain: true\n          });\n        }\n      } \n      else if (fieldName.startsWith('mediaFile_')) {\n        // Regular media file - assign to the appropriate new media item\n        const fieldIndex = parseInt(fieldName.split('_')[1], 10);\n        const mediaItemInfo = newMediaItems.find(item => \n          item.fileIndex === fieldIndex || \n          parseInt(item.fileIndex, 10) === fieldIndex\n        );\n        \n        if (mediaItemInfo) {\n          console.log(`Asignando URL al elemento ${mediaItemInfo.id} (índice ${fieldIndex}): ${filePath}`);\n          mediaItemInfo.url = filePath;\n          \n          // If this is marked as main, update main media references\n          if (mediaItemInfo.isMain) {\n            mainMediaUrl = filePath;\n            mainMediaType = fileType;\n          }\n        }\n        \n        // Add this file to the media items array if not already there\n        if (!updatedMediaItems.some(item => item.url === filePath)) {\n          updatedMediaItems.push({\n            type: fileType,\n            url: filePath,\n            order: updatedMediaItems.length,\n            isMain: mediaItemInfo?.isMain || false\n          });\n        }\n      }\n    }\n  });\n  \n  // Now update all media items with proper URLs and metadata\n  updatedMediaItems = updatedMediaItems.map((item, index) => {\n    // Find if there's a corresponding item in mediaItemsInfo\n    const itemInfo = mediaItemsInfo.find(info => \n      info.url === item.url || \n      (info.id && item.id && info.id === item.id)\n    );\n    \n    // If we found a matching item info, update from there\n    if (itemInfo && itemInfo.url) {\n      return {\n        ...item,\n        url: itemInfo.url,\n        type: itemInfo.type || item.type,\n        order: index,\n        isMain: itemInfo.isMain || item.isMain || false\n      };\n    }\n    \n    // Otherwise just ensure order is correct\n    return {\n      ...item,\n      order: index\n    };\n  });\n  \n  // If no main media was set but we have media items, use the first one\n  if ((!mainMediaUrl || mainMediaUrl === '') && updatedMediaItems.length > 0) {\n    const mainItem = updatedMediaItems.find(item => item.isMain) || updatedMediaItems[0];\n    mainMediaUrl = mainItem.url;\n    mainMediaType = mainItem.type;\n    console.log(`Usando primer elemento como media principal: ${mainMediaType} - ${mainMediaUrl}`);\n  }\n  \n  return {\n    mediaItems: updatedMediaItems,\n    mainMediaType,\n    mainMediaUrl\n  };\n}\n\n/**\n * Verifies that a media URL points to an existing file\n * @param {string} mediaUrl - URL to verify\n * @returns {boolean} - True if file exists, false otherwise\n */\nfunction verifyMediaFile(mediaUrl) {\n  if (!mediaUrl || mediaUrl.trim() === '') return false;\n  \n  try {\n    const publicPath = path.join(process.cwd(), 'public', mediaUrl);\n    return fs.existsSync(publicPath);\n  } catch (err) {\n    console.error(`Error verificando archivo: ${mediaUrl}`, err);\n    return false;\n  }\n}\n\nmodule.exports = {\n  processEventMediaUploads,\n  verifyMediaFile\n};","size_bytes":5519},"server/memory-storage.ts":{"content":"// In-memory user storage for development when Supabase RLS blocks inserts\nimport bcrypt from 'bcrypt';\n\ninterface User {\n  id: number;\n  email: string;\n  username: string;\n  name: string;\n  password: string | null;\n  bio: string | null;\n  avatar: string | null;\n  supabaseId: string | null;\n  stripeCustomerId: string | null;\n  stripeSubscriptionId: string | null;\n  createdAt: string;\n  updatedAt: string;\n}\n\ninterface InsertUser {\n  email: string;\n  username: string;\n  name: string;\n  password: string | null;\n  bio?: string | null;\n  avatar?: string | null;\n  supabaseId?: string | null;\n  stripeCustomerId?: string | null;\n  stripeSubscriptionId?: string | null;\n}\n\nclass MemoryUserStore {\n  private users: Map<number, User> = new Map();\n  private emailIndex: Map<string, number> = new Map();\n  private usernameIndex: Map<string, number> = new Map();\n  private nextId = 10001;\n\n  constructor() {\n    console.log('Initializing in-memory user store for development');\n  }\n\n  async getUserById(id: number): Promise<User | null> {\n    return this.users.get(id) || null;\n  }\n\n  async getUserByEmail(email: string): Promise<User | null> {\n    const userId = this.emailIndex.get(email.toLowerCase());\n    return userId ? this.users.get(userId) || null : null;\n  }\n\n  async getUserByUsername(username: string): Promise<User | null> {\n    const userId = this.usernameIndex.get(username.toLowerCase());\n    return userId ? this.users.get(userId) || null : null;\n  }\n\n  async insertUser(userData: InsertUser): Promise<User | null> {\n    try {\n      // Check if user already exists\n      if (this.emailIndex.has(userData.email.toLowerCase())) {\n        console.log('Memory store: User already exists with email:', userData.email);\n        return null;\n      }\n\n      if (this.usernameIndex.has(userData.username.toLowerCase())) {\n        console.log('Memory store: User already exists with username:', userData.username);\n        return null;\n      }\n\n      const userId = this.nextId++;\n      const now = new Date().toISOString();\n      \n      const user: User = {\n        id: userId,\n        email: userData.email,\n        username: userData.username,\n        name: userData.name,\n        password: userData.password,\n        bio: userData.bio || null,\n        avatar: userData.avatar || null,\n        supabaseId: userData.supabaseId || null,\n        stripeCustomerId: userData.stripeCustomerId || null,\n        stripeSubscriptionId: userData.stripeSubscriptionId || null,\n        createdAt: now,\n        updatedAt: now\n      };\n\n      this.users.set(userId, user);\n      this.emailIndex.set(userData.email.toLowerCase(), userId);\n      this.usernameIndex.set(userData.username.toLowerCase(), userId);\n\n      console.log('Memory store: Created user with ID:', userId, 'email:', userData.email);\n      return user;\n    } catch (error) {\n      console.error('Memory store insertUser error:', error);\n      return null;\n    }\n  }\n\n  async updateUser(id: number, updates: Partial<User>): Promise<User | null> {\n    const user = this.users.get(id);\n    if (!user) {\n      return null;\n    }\n\n    const updatedUser = {\n      ...user,\n      ...updates,\n      updatedAt: new Date().toISOString()\n    };\n\n    this.users.set(id, updatedUser);\n    return updatedUser;\n  }\n\n  getStats() {\n    return {\n      totalUsers: this.users.size,\n      nextId: this.nextId\n    };\n  }\n}\n\nexport const memoryUserStore = new MemoryUserStore();","size_bytes":3414},"server/routes-clean.ts":{"content":"import express, { Express, Request, Response } from \"express\";\nimport { createServer, type Server } from \"http\";\nimport { storage } from \"./storage\";\nimport bcrypt from \"bcrypt\";\nimport passport from \"passport\";\nimport { loginUserSchema, insertUserSchema, insertEventSchema, insertEventAttendeeSchema } from \"@shared/schema\";\nimport { z } from \"zod\";\nimport Stripe from \"stripe\";\nimport { WebSocketServer } from 'ws';\nimport { WebSocket } from 'ws';\nimport multer from 'multer';\nimport path from 'path';\nimport fs from 'fs';\n\nif (!process.env.SESSION_SECRET) {\n  console.warn(\"No SESSION_SECRET provided, using default secret. This is insecure!\");\n}\n\n// Payment functionality is disabled for this app\nconsole.log(\"Payment functionality is disabled in this version of the app.\");\n\n// Set stripe to null - all events will be free\nconst stripe = null;\n\n// Configurar almacenamiento para multer\nconst storage_uploads = multer.diskStorage({\n  destination: function (req, file, cb) {\n    // Definir el directorio según el tipo de archivo\n    let uploadPath = 'public/uploads/events';\n    \n    // Asegurarse de que el directorio existe\n    if (!fs.existsSync(uploadPath)) {\n      fs.mkdirSync(uploadPath, { recursive: true });\n    }\n    \n    cb(null, uploadPath);\n  },\n  filename: function (req, file, cb) {\n    // Generar un nombre de archivo único\n    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\n    const extension = path.extname(file.originalname);\n    cb(null, 'event-' + uniqueSuffix + extension);\n  }\n});\n\n// Filtrar archivos por tipo y validar condiciones\nconst fileFilter = (req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {\n  console.log(`Procesando archivo: ${file.fieldname}, tipo: ${file.mimetype}`);\n  \n  // Categorizar el archivo según el campo\n  const isMainMedia = file.fieldname === 'mainMediaFile';\n  const isEventPhoto = file.fieldname === 'eventPhoto';\n  const isEventVideo = file.fieldname === 'eventVideo';\n  const isMediaFile = file.fieldname.startsWith('mediaFile_');\n  const isPhotos = file.fieldname === 'photos';\n  const isVideos = file.fieldname === 'videos';\n  const isEventPhotos = file.fieldname === 'eventPhotos';\n  const isEventVideos = file.fieldname === 'eventVideos';\n  \n  // Límites de tipos de archivo\n  const isImage = file.mimetype.startsWith('image/');\n  const isVideo = file.mimetype.startsWith('video/');\n  \n  // Validar tipos permitidos\n  const allowedImageTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];\n  const allowedVideoTypes = ['video/mp4', 'video/mpeg', 'video/quicktime', 'video/x-msvideo'];\n  \n  // Verificar si el tipo de archivo es válido\n  const isValidImageType = allowedImageTypes.includes(file.mimetype);\n  const isValidVideoType = allowedVideoTypes.includes(file.mimetype);\n  \n  if (!isValidImageType && !isValidVideoType) {\n    console.log(`Archivo rechazado por tipo no válido: ${file.mimetype}`);\n    return cb(new Error(`Tipo de archivo no permitido: ${file.mimetype}`));\n  }\n  \n  // Verificar coherencia entre el campo y el tipo\n  if ((isEventPhoto || isPhotos || isEventPhotos) && !isImage) {\n    return cb(new Error('Solo se permiten imágenes para campos de fotos'));\n  }\n  \n  if ((isEventVideo || isVideos || isEventVideos) && !isVideo) {\n    return cb(new Error('Solo se permiten videos para campos de video'));\n  }\n  \n  console.log(`Archivo aceptado: ${file.fieldname} (${file.mimetype})`);\n  cb(null, true);\n};\n\n// Manejo de errores de multer\nconst multerErrorHandler = (err: any, req: Request, res: Response, next: Function) => {\n  if (err instanceof multer.MulterError) {\n    if (err.code === 'LIMIT_FILE_SIZE') {\n      return res.status(400).json({ \n        message: \"El archivo es demasiado grande\",\n        details: \"El tamaño máximo permitido es 10MB\"\n      });\n    }\n    if (err.code === 'LIMIT_FILE_COUNT') {\n      return res.status(400).json({ \n        message: \"Demasiados archivos\",\n        details: \"Se ha excedido el límite de archivos permitidos\"\n      });\n    }\n  }\n  \n  if (err.message && err.message.includes('Tipo de archivo no permitido')) {\n    return res.status(400).json({ \n      message: \"Tipo de archivo no válido\",\n      details: err.message\n    });\n  }\n  \n  return res.status(500).json({ \n    message: \"Error al procesar archivos\",\n    details: err.message || 'Error desconocido'\n  });\n};\n\nexport async function registerRoutes(app: Express): Promise<Server> {\n  const httpServer = createServer(app);\n  \n  const isAuthenticated = (req: Request, res: Response, next: Function) => {\n    console.log(\"Auth check for\", req.method, req.path, \": \", req.user ? \"Authenticated\" : \"Not authenticated\");\n    \n    if (req.user) {\n      return next();\n    }\n    \n    // Check session data for debugging\n    console.log(\"Checking session data:\", {\n      sessionExists: !!req.session,\n      sessionId: req.sessionID,\n      cookieExists: !!req.headers.cookie\n    });\n    \n    return res.status(401).json({ message: \"Authentication required\" });\n  };\n\n  // Auth routes\n  app.post(\"/api/auth/register\", async (req, res) => {\n    try {\n      const result = insertUserSchema.safeParse(req.body);\n      if (!result.success) {\n        return res.status(400).json({ message: \"Invalid user data\", errors: result.error.errors });\n      }\n\n      const { username, email, password, name, bio } = result.data;\n\n      // Check if user already exists\n      const existingUser = await storage.getUserByEmail(email);\n      if (existingUser) {\n        return res.status(400).json({ message: \"User already exists\" });\n      }\n\n      // Hash password\n      const hashedPassword = await bcrypt.hash(password, 10);\n\n      // Create user\n      const userId = await storage.insertUser({\n        username,\n        email,\n        password: hashedPassword,\n        name,\n        bio: bio || null,\n        avatar: null,\n        supabaseId: null,\n        stripeCustomerId: null,\n        stripeSubscriptionId: null,\n      });\n\n      const user = await storage.getUserById(userId);\n      if (!user) {\n        return res.status(500).json({ message: \"Failed to create user\" });\n      }\n\n      // Log the user in using req.login\n      req.login(user, (err) => {\n        if (err) {\n          console.error(\"Login error:\", err);\n          return res.status(500).json({ message: \"Login failed after registration\" });\n        }\n        \n        // Store user data in session\n        req.session.authenticated = true;\n        req.session.userEmail = user.email;\n        req.session.userId = user.id;\n        req.session.supabaseUserId = user.supabaseId;\n        \n        return res.json({\n          id: user.id,\n          username: user.username,\n          email: user.email,\n          name: user.name,\n          bio: user.bio,\n          avatar: user.avatar,\n        });\n      });\n    } catch (error) {\n      console.error(\"Registration error:\", error);\n      return res.status(500).json({ message: \"Internal server error\" });\n    }\n  });\n\n  app.post(\"/api/auth/login\", (req, res, next) => {\n    const result = loginUserSchema.safeParse(req.body);\n    if (!result.success) {\n      return res.status(400).json({ message: \"Invalid login data\", errors: result.error.errors });\n    }\n\n    passport.authenticate(\"local\", (err: any, user: any, info: any) => {\n      if (err) {\n        console.error(\"Authentication error:\", err);\n        return res.status(500).json({ message: \"Authentication failed\" });\n      }\n\n      if (!user) {\n        return res.status(401).json({ message: info?.message || \"Invalid credentials\" });\n      }\n\n      req.login(user, (err) => {\n        if (err) {\n          console.error(\"Login error:\", err);\n          return res.status(500).json({ message: \"Login failed\" });\n        }\n        \n        // Store user data in session\n        req.session.authenticated = true;\n        req.session.userEmail = user.email;\n        req.session.userId = user.id;\n        req.session.supabaseUserId = user.supabaseId;\n        \n        return res.json({\n          id: user.id,\n          username: user.username,\n          email: user.email,\n          name: user.name,\n          bio: user.bio,\n          avatar: user.avatar,\n        });\n      });\n    })(req, res, next);\n  });\n\n  // Get current user\n  app.get(\"/api/auth/me\", (req, res) => {\n    if (!req.isAuthenticatedMiddleware && !req.user) {\n      return res.status(401).json({ message: \"Authentication required\" });\n    }\n\n    const user = req.user as any;\n    \n    return res.json({\n      id: user.id,\n      username: user.username,\n      email: user.email,\n      name: user.name,\n      bio: user.bio,\n      avatar: user.avatar,\n    });\n  });\n\n  // Logout\n  app.post(\"/api/auth/logout\", (req, res) => {\n    if (!req.isAuthenticatedMiddleware) {\n      return res.status(401).json({ message: \"Authentication required\" });\n    }\n\n    const user = req.user as any;\n\n    req.logout((err) => {\n      if (err) {\n        console.error(\"Logout error:\", err);\n        return res.status(500).json({ message: \"Logout failed\" });\n      }\n\n      req.session.destroy((destroyErr) => {\n        if (destroyErr) {\n          console.error(\"Session destroy error:\", destroyErr);\n          return res.status(500).json({ message: \"Session cleanup failed\" });\n        }\n\n        res.clearCookie('connect.sid');\n        return res.json({ message: \"Logged out successfully\" });\n      });\n    });\n  });\n\n  // Create events\n  app.post(\"/api/events\", [\n    isAuthenticated,\n    multer({ \n      storage: storage_uploads, \n      fileFilter: fileFilter,\n      limits: { \n        fileSize: 10 * 1024 * 1024, // 10MB limit\n        files: 12 // Max 12 files total (mainMediaFile + up to 11 additional media files)\n      }\n    }).fields([\n      { name: 'mainMediaFile', maxCount: 1 },\n      { name: 'eventPhoto', maxCount: 1 },\n      { name: 'eventVideo', maxCount: 1 },\n      { name: 'photos', maxCount: 6 },\n      { name: 'videos', maxCount: 3 },\n      { name: 'eventPhotos', maxCount: 6 },\n      { name: 'eventVideos', maxCount: 3 },\n      { name: 'mediaFile_0', maxCount: 1 },\n      { name: 'mediaFile_1', maxCount: 1 },\n      { name: 'mediaFile_2', maxCount: 1 },\n      { name: 'mediaFile_3', maxCount: 1 },\n      { name: 'mediaFile_4', maxCount: 1 },\n      { name: 'mediaFile_5', maxCount: 1 },\n      { name: 'mediaFile_6', maxCount: 1 },\n      { name: 'mediaFile_7', maxCount: 1 },\n      { name: 'mediaFile_8', maxCount: 1 },\n      { name: 'mediaFile_9', maxCount: 1 }\n    ])\n  ], async (req, res) => {\n    try {\n      const user = req.user as any;\n      const files = (req.files as { [fieldname: string]: Express.Multer.File[] }) || {};\n      \n      // Build event data\n      const eventData = {\n        ...req.body,\n        organizerId: user.id,\n        latitude: typeof req.body.latitude === 'number' ? req.body.latitude : parseFloat(req.body.latitude),\n        longitude: typeof req.body.longitude === 'number' ? req.body.longitude : parseFloat(req.body.longitude),\n        maxCapacity: req.body.maxCapacity ? parseInt(req.body.maxCapacity) : null,\n        price: req.body.price ? parseFloat(req.body.price) : null,\n      };\n\n      // Process media items\n      let mediaItems: any[] = [];\n      let mainMediaUrl = '';\n      let mainMediaType = 'photo';\n\n      // Parse mediaItems if provided\n      if (req.body.mediaItems) {\n        try {\n          const parsedItems = JSON.parse(req.body.mediaItems);\n          if (Array.isArray(parsedItems)) {\n            mediaItems = parsedItems;\n          }\n        } catch (e) {\n          console.warn(\"Could not parse mediaItems:\", e);\n        }\n      }\n\n      // Process uploaded files\n      Object.keys(files).forEach((fieldName, index) => {\n        const fileArray = files[fieldName];\n        if (fileArray && fileArray.length > 0) {\n          const file = fileArray[0];\n          const mediaPath = file.path.replace('public', '');\n          const isVideo = file.mimetype.startsWith('video/');\n          \n          interface MediaItem {\n            type: string;\n            url: string;\n            order: number;\n            isMain?: boolean;\n          }\n          \n          const mediaItem: MediaItem = {\n            type: isVideo ? 'video' : 'photo',\n            url: mediaPath,\n            order: mediaItems.length + index,\n            isMain: fieldName === 'mainMediaFile' || index === 0\n          };\n          \n          mediaItems.push(mediaItem);\n          \n          if (mediaItem.isMain || mainMediaUrl === '') {\n            mainMediaUrl = mediaPath;\n            mainMediaType = mediaItem.type;\n          }\n        }\n      });\n\n      // Set main media\n      if (mainMediaUrl) {\n        eventData.mainMediaUrl = mainMediaUrl;\n        eventData.mainMediaType = mainMediaType;\n      }\n\n      // Set media items JSON\n      if (mediaItems.length > 0) {\n        eventData.mediaItems = JSON.stringify(mediaItems);\n      }\n\n      const eventId = await storage.insertEvent(eventData);\n      const newEvent = await storage.getEventById(eventId);\n\n      res.status(201).json(newEvent);\n    } catch (error) {\n      console.error(\"Event creation error:\", error);\n      res.status(500).json({ message: \"Failed to create event\" });\n    }\n  });\n\n  // Update events  \n  app.patch(\"/api/events/:id\", [\n    isAuthenticated,\n    multer({ \n      storage: storage_uploads, \n      fileFilter: fileFilter,\n      limits: { \n        fileSize: 10 * 1024 * 1024,\n        files: 12\n      }\n    }).fields([\n      { name: 'mainMediaFile', maxCount: 1 },\n      { name: 'eventPhoto', maxCount: 1 },\n      { name: 'eventVideo', maxCount: 1 },\n      { name: 'photos', maxCount: 6 },\n      { name: 'videos', maxCount: 3 },\n      { name: 'eventPhotos', maxCount: 6 },\n      { name: 'eventVideos', maxCount: 3 },\n      { name: 'mediaFile_0', maxCount: 1 },\n      { name: 'mediaFile_1', maxCount: 1 },\n      { name: 'mediaFile_2', maxCount: 1 },\n      { name: 'mediaFile_3', maxCount: 1 },\n      { name: 'mediaFile_4', maxCount: 1 },\n      { name: 'mediaFile_5', maxCount: 1 },\n      { name: 'mediaFile_6', maxCount: 1 },\n      { name: 'mediaFile_7', maxCount: 1 },\n      { name: 'mediaFile_8', maxCount: 1 },\n      { name: 'mediaFile_9', maxCount: 1 }\n    ])\n  ], async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      // Check if event exists\n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      // Check authorization\n      if (parseInt(event.organizerId.toString()) !== parseInt(user.id.toString())) {\n        return res.status(403).json({ message: \"Not authorized to update this event\" });\n      }\n      \n      const files = (req.files as { [fieldname: string]: Express.Multer.File[] }) || {};\n      const updateData: any = { ...req.body };\n      \n      // Parse existing mediaItems\n      let mediaItems: any[] = [];\n      if (event.mediaItems) {\n        try {\n          mediaItems = JSON.parse(event.mediaItems);\n        } catch (e) {\n          console.warn(\"Could not parse existing mediaItems:\", e);\n          mediaItems = [];\n        }\n      }\n\n      // Parse client mediaItems if provided\n      let clientMediaItems: any[] = [];\n      if (req.body.mediaItems) {\n        try {\n          clientMediaItems = JSON.parse(req.body.mediaItems);\n        } catch (e) {\n          console.warn(\"Could not parse client mediaItems:\", e);\n          clientMediaItems = [];\n        }\n      }\n\n      // Process uploaded files\n      Object.keys(files).forEach((fieldName, index) => {\n        const fileArray = files[fieldName];\n        if (fileArray && fileArray.length > 0) {\n          const file = fileArray[0];\n          const mediaPath = file.path.replace('public', '');\n          const isVideo = file.mimetype.startsWith('video/');\n          \n          interface MediaItem {\n            type: string;\n            url: string;\n            order: number;\n            isMain?: boolean;\n          }\n          \n          const mediaItem: MediaItem = {\n            type: isVideo ? 'video' : 'photo',\n            url: mediaPath,\n            order: mediaItems.length + index,\n            isMain: fieldName === 'mainMediaFile'\n          };\n          \n          mediaItems.push(mediaItem);\n        }\n      });\n\n      // Process client mediaItems with URL preservation\n      if (clientMediaItems.length > 0) {\n        // Map client items to preserve existing URLs\n        const updatedMediaItems = clientMediaItems.map((clientItem: any, index: number) => {\n          // Find matching existing item by order or type\n          const existingItem = mediaItems.find((existing: any) => \n            existing.order === clientItem.order || \n            (existing.type === clientItem.type && existing.order === index)\n          );\n          \n          return {\n            type: clientItem.type || 'photo',\n            url: clientItem.url || existingItem?.url || '',\n            order: clientItem.order !== undefined ? clientItem.order : index,\n            isMain: clientItem.isMain === true\n          };\n        }).filter((item: any) => item.url); // Only keep items with valid URLs\n        \n        if (updatedMediaItems.length > 0) {\n          mediaItems = updatedMediaItems;\n        }\n      }\n\n      // Set main media from the first item marked as main\n      const mainItem = mediaItems.find((item: any) => item.isMain);\n      if (mainItem) {\n        updateData.mainMediaUrl = mainItem.url;\n        updateData.mainMediaType = mainItem.type;\n      }\n\n      // Update mediaItems JSON\n      if (mediaItems.length > 0) {\n        updateData.mediaItems = JSON.stringify(mediaItems);\n      }\n\n      await storage.updateEvent(eventId, updateData);\n      const updatedEvent = await storage.getEventById(eventId);\n\n      res.json(updatedEvent);\n    } catch (error) {\n      console.error(\"Event update error:\", error);\n      res.status(500).json({ message: \"Failed to update event\" });\n    }\n  });\n\n  // Get all events\n  app.get(\"/api/events\", async (req, res) => {\n    try {\n      const { lat, lng, radius, category, paymentType, search } = req.query;\n      \n      console.log(\"📍 GET /api/events query params:\", { lat, lng, radius, category, paymentType, search });\n      \n      let events;\n      \n      // If lat and lng are provided, get nearby events\n      if (lat && lng) {\n        console.log(\"📍 Using nearby events path\");\n        events = await storage.getNearbyEvents(\n          parseFloat(lat as string),\n          parseFloat(lng as string),\n          radius ? parseFloat(radius as string) : 10\n        );\n      } else {\n        // Otherwise get all events with filters\n        const filters: any = {};\n        \n        if (category) {\n          filters.category = Array.isArray(category) ? category : [category as string];\n        }\n        \n        if (paymentType) {\n          filters.paymentType = Array.isArray(paymentType) ? paymentType : [paymentType as string];\n        }\n        \n        if (search) {\n          filters.searchTerm = search as string;\n          console.log(\"📍 Adding search filter:\", search);\n        }\n        \n        console.log(\"📍 Using filtered events path with filters:\", filters);\n        events = await storage.getEvents(filters);\n      }\n      \n      res.json(events);\n    } catch (error) {\n      console.error(\"Error fetching events:\", error);\n      res.status(500).json({ message: \"Failed to fetch events\" });\n    }\n  });\n\n  // Get event by ID\n  app.get(\"/api/events/:id\", async (req, res) => {\n    try {\n      const eventId = parseInt(req.params.id);\n      const event = await storage.getEventById(eventId);\n      \n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      res.json(event);\n    } catch (error) {\n      console.error(\"Error fetching event:\", error);\n      res.status(500).json({ message: \"Failed to fetch event\" });\n    }\n  });\n\n  // Delete event\n  app.delete(\"/api/events/:id\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      if (event.organizerId !== user.id) {\n        return res.status(403).json({ message: \"Not authorized to delete this event\" });\n      }\n      \n      await storage.deleteEvent(eventId);\n      res.json({ message: \"Event deleted successfully\" });\n    } catch (error) {\n      console.error(\"Error deleting event:\", error);\n      res.status(500).json({ message: \"Failed to delete event\" });\n    }\n  });\n\n  // Event attendance\n  app.post(\"/api/events/:id/attend\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      const attendeeData = {\n        eventId,\n        userId: user.id,\n        status: \"approved\" as const,\n        paymentStatus: \"completed\",\n        paymentIntentId: null,\n      };\n      \n      const attendeeId = await storage.insertEventAttendee(attendeeData);\n      const attendee = await storage.getEventAttendeeById(attendeeId);\n      \n      res.status(201).json(attendee);\n    } catch (error) {\n      console.error(\"Error attending event:\", error);\n      res.status(500).json({ message: \"Failed to attend event\" });\n    }\n  });\n\n  // Get event attendees\n  app.get(\"/api/events/:id/attendees\", async (req, res) => {\n    try {\n      const eventId = parseInt(req.params.id);\n      const attendees = await storage.getEventAttendees(eventId);\n      res.json(attendees);\n    } catch (error) {\n      console.error(\"Error fetching attendees:\", error);\n      res.status(500).json({ message: \"Failed to fetch attendees\" });\n    }\n  });\n\n  // WebSocket setup\n  const wss = new WebSocketServer({ server: httpServer });\n  const clients = new Map<string, { ws: WebSocket, userId: number, userName: string }>();\n\n  wss.on('connection', (ws: WebSocket) => {\n    console.log('WebSocket connection established');\n    \n    ws.on('message', (message: string) => {\n      try {\n        const data = JSON.parse(message);\n        \n        if (data.type === 'join' && data.userId && data.userName) {\n          const clientId = Math.random().toString(36);\n          clients.set(clientId, { ws, userId: data.userId, userName: data.userName });\n          console.log(`User ${data.userName} joined WebSocket`);\n        }\n      } catch (error) {\n        console.error('WebSocket message error:', error);\n      }\n    });\n    \n    ws.on('close', () => {\n      console.log('WebSocket connection closed');\n      for (const [clientId, client] of clients.entries()) {\n        if (client.ws === ws) {\n          clients.delete(clientId);\n          break;\n        }\n      }\n    });\n  });\n\n  // Serve static files\n  app.use(express.static('public'));\n\n  return httpServer;\n}","size_bytes":23043},"server/routes.ts":{"content":"import express, { Express, Request, Response } from \"express\";\nimport { createServer, type Server } from \"http\";\nimport { storage } from \"./storage\";\nimport bcrypt from \"bcrypt\";\nimport passport from \"passport\";\nimport { loginUserSchema, insertUserSchema, insertEventSchema, insertEventAttendeeSchema } from \"@shared/schema\";\nimport { z } from \"zod\";\nimport Stripe from \"stripe\";\n// WebSocket imports removed to prevent conflicts\nimport multer from 'multer';\nimport path from 'path';\nimport fs from 'fs';\nimport { isAuthenticatedMiddleware } from \"./supabase-auth\";\nimport { supabase } from \"./supabase-client\";\n\nif (!process.env.SESSION_SECRET) {\n  console.warn(\"No SESSION_SECRET provided, using default secret. This is insecure!\");\n}\n\n// Payment functionality is disabled for this app\nconsole.log(\"Payment functionality is disabled in this version of the app.\");\n\n// Set stripe to null - all events will be free\nconst stripe = null;\n\n// Configurar almacenamiento para multer\nconst storage_uploads = multer.diskStorage({\n  destination: function (req, file, cb) {\n    // Definir el directorio según el tipo de archivo\n    let uploadPath = 'public/uploads/events';\n    \n    // Asegurarse de que el directorio existe\n    if (!fs.existsSync(uploadPath)) {\n      fs.mkdirSync(uploadPath, { recursive: true });\n    }\n    \n    cb(null, uploadPath);\n  },\n  filename: function (req, file, cb) {\n    // Generar un nombre de archivo único\n    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\n    const extension = path.extname(file.originalname);\n    cb(null, 'event-' + uniqueSuffix + extension);\n  }\n});\n\n// Filtrar archivos por tipo y validar condiciones\nconst fileFilter = (req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {\n  console.log(`Procesando archivo: ${file.fieldname}, tipo: ${file.mimetype}`);\n  \n  // Categorizar el archivo según el campo\n  const isMainMedia = file.fieldname === 'mainMediaFile';\n  const isEventPhoto = file.fieldname === 'eventPhoto';\n  const isEventVideo = file.fieldname === 'eventVideo';\n  const isMediaFile = file.fieldname.startsWith('mediaFile_');\n  const isPhotos = file.fieldname === 'photos';\n  const isVideos = file.fieldname === 'videos';\n  const isEventPhotos = file.fieldname === 'eventPhotos';\n  const isEventVideos = file.fieldname === 'eventVideos';\n  \n  // Límites de tipos de archivo\n  const isImage = file.mimetype.startsWith('image/');\n  const isVideo = file.mimetype.startsWith('video/');\n  \n  // Validar tipos permitidos\n  const allowedImageTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];\n  const allowedVideoTypes = ['video/mp4', 'video/mpeg', 'video/quicktime', 'video/x-msvideo'];\n  \n  // Verificar si el tipo de archivo es válido\n  const isValidImageType = allowedImageTypes.includes(file.mimetype);\n  const isValidVideoType = allowedVideoTypes.includes(file.mimetype);\n  \n  if (!isValidImageType && !isValidVideoType) {\n    console.log(`Archivo rechazado por tipo no válido: ${file.mimetype}`);\n    return cb(new Error(`Tipo de archivo no permitido: ${file.mimetype}`));\n  }\n  \n  // Verificar coherencia entre el campo y el tipo\n  if ((isEventPhoto || isPhotos || isEventPhotos) && !isImage) {\n    return cb(new Error('Solo se permiten imágenes para campos de fotos'));\n  }\n  \n  if ((isEventVideo || isVideos || isEventVideos) && !isVideo) {\n    return cb(new Error('Solo se permiten videos para campos de video'));\n  }\n  \n  console.log(`Archivo aceptado: ${file.fieldname} (${file.mimetype})`);\n  cb(null, true);\n};\n\n// Manejo de errores de multer\nconst multerErrorHandler = (err: any, req: Request, res: Response, next: Function) => {\n  if (err instanceof multer.MulterError) {\n    if (err.code === 'LIMIT_FILE_SIZE') {\n      return res.status(400).json({ \n        message: \"El archivo es demasiado grande\",\n        details: \"El tamaño máximo permitido es 10MB\"\n      });\n    }\n    if (err.code === 'LIMIT_FILE_COUNT') {\n      return res.status(400).json({ \n        message: \"Demasiados archivos\",\n        details: \"Se ha excedido el límite de archivos permitidos\"\n      });\n    }\n  }\n  \n  if (err.message && err.message.includes('Tipo de archivo no permitido')) {\n    return res.status(400).json({ \n      message: \"Tipo de archivo no válido\",\n      details: err.message\n    });\n  }\n  \n  return res.status(500).json({ \n    message: \"Error al procesar archivos\",\n    details: err.message || 'Error desconocido'\n  });\n};\n\nexport async function registerRoutes(app: Express, options: { excludeAuth?: boolean } = {}): Promise<Server> {\n  \n  const isAuthenticated = async (req: Request, res: Response, next: Function) => {\n    console.log(\"Auth check for\", req.method, req.path, \": \", req.user ? \"Authenticated\" : \"Not authenticated\");\n    \n    // Check if user is already set by passport\n    if (req.user) {\n      return next();\n    }\n    \n    // Check if user is in session (passport session)\n    if (req.session && (req.session as any).passport && (req.session as any).passport.user) {\n      console.log(\"Found user in session, attempting to deserialize user ID:\", (req.session as any).passport.user);\n      \n      try {\n        // Manually deserialize user using direct Supabase query\n        const userId = (req.session as any).passport.user;\n        console.log(\"Manual deserialization for user ID:\", userId);\n        const { data: users, error } = await supabase\n          .from('users')\n          .select('*')\n          .eq('id', parseInt(userId))\n          .single(); // Use single() for better error handling\n        \n        console.log(\"Manual deserialization result:\", { \n          error: error?.message || null, \n          hasUser: !!users\n        });\n        \n        if (error) {\n          console.error(\"Manual deserialization Supabase error:\", error.message);\n          // Still check if error is about no rows found vs actual error\n          if (error.code !== 'PGRST116') { // PGRST116 is \"no rows found\"\n            return res.status(500).json({ message: \"Database authentication error\" });\n          }\n        } else if (users) {\n          console.log(\"Manual deserialization successful:\", users.id, users.name);\n          req.user = users;\n          return next();\n        }\n      } catch (error) {\n        console.error(\"Error during manual deserialization:\", error);\n      }\n    }\n    \n    // If all else fails, try one more check with passport's isAuthenticated\n    if (req.isAuthenticated && req.isAuthenticated()) {\n      console.log(\"Passport isAuthenticated() returned true, proceeding\");\n      return next();\n    }\n    \n    // Check session data for debugging\n    console.log(\"Checking session data:\", {\n      sessionExists: !!req.session,\n      sessionId: req.sessionID,\n      cookieExists: !!req.headers.cookie,\n      passportSession: !!(req.session && (req.session as any).passport),\n      passportUser: req.session && (req.session as any).passport ? (req.session as any).passport.user : null,\n      passportIsAuthenticated: req.isAuthenticated ? req.isAuthenticated() : 'N/A'\n    });\n    \n    return res.status(401).json({ message: \"Authentication required\" });\n  };\n\n  // Auth routes (only if not excluded)\n  if (!options.excludeAuth) {\n    app.post(\"/api/auth/register\", async (req, res) => {\n    try {\n      const result = insertUserSchema.safeParse(req.body);\n      if (!result.success) {\n        return res.status(400).json({ message: \"Invalid user data\", errors: result.error.errors });\n      }\n\n      const { username, email, password, name, bio } = result.data;\n\n      // Check if user already exists\n      const existingUser = await storage.getUserByEmail(email);\n      if (existingUser) {\n        return res.status(400).json({ message: \"User already exists\" });\n      }\n\n      // Hash password if provided\n      const hashedPassword = password ? await bcrypt.hash(password, 10) : null;\n\n      // Create user\n      const user = await storage.insertUser({\n        username,\n        email,\n        password: hashedPassword,\n        name,\n        bio: bio || null,\n        avatar: null,\n        supabaseId: null,\n        stripeCustomerId: null,\n        stripeSubscriptionId: null,\n      });\n      if (!user) {\n        return res.status(500).json({ message: \"Failed to create user\" });\n      }\n\n      // Log the user in using req.login\n      req.login(user as any, (err) => {\n        if (err) {\n          console.error(\"Login error:\", err);\n          return res.status(500).json({ message: \"Login failed after registration\" });\n        }\n        \n        // Store user data in session\n        (req.session as any).authenticated = true;\n        (req.session as any).userEmail = user.email;\n        (req.session as any).userId = user.id;\n        (req.session as any).supabaseUserId = user.supabaseId;\n        \n        return res.json({\n          id: user.id,\n          username: user.username,\n          email: user.email,\n          name: user.name,\n          bio: user.bio,\n          avatar: user.avatar,\n        });\n      });\n    } catch (error) {\n      console.error(\"Registration error:\", error);\n      return res.status(500).json({ message: \"Internal server error\" });\n    }\n  });\n\n  app.post(\"/api/auth/login\", (req, res, next) => {\n    const result = loginUserSchema.safeParse(req.body);\n    if (!result.success) {\n      return res.status(400).json({ message: \"Invalid login data\", errors: result.error.errors });\n    }\n\n    passport.authenticate(\"local\", (err: any, user: any, info: any) => {\n      if (err) {\n        console.error(\"Authentication error:\", err);\n        return res.status(500).json({ message: \"Authentication failed\" });\n      }\n\n      if (!user) {\n        return res.status(401).json({ message: info?.message || \"Invalid credentials\" });\n      }\n\n      req.login(user, (err) => {\n        if (err) {\n          console.error(\"Login error:\", err);\n          return res.status(500).json({ message: \"Login failed\" });\n        }\n        \n        console.log(\"Login successful for user:\", user.email, \"with ID:\", user.id);\n        \n        // Store user data in session\n        (req.session as any).authenticated = true;\n        (req.session as any).userEmail = user.email;\n        (req.session as any).userId = user.id;\n        (req.session as any).supabaseUserId = user.supabaseId;\n        \n        // Save session before responding\n        req.session.save((err) => {\n          if (err) {\n            console.error('Session save error:', err);\n          }\n          \n          return res.json({\n            message: \"Login successful\",\n            user: {\n              id: user.id,\n              email: user.email,\n              username: user.username,\n              name: user.name\n            },\n            token: user.supabaseToken || '',\n            refreshToken: user.supabaseRefreshToken || '',\n            sessionId: req.sessionID\n          });\n        });\n      });\n    })(req, res, next);\n  });\n\n    // Logout endpoint\n    app.post(\"/api/auth/logout\", (req, res) => {\n      req.logout((err) => {\n        if (err) {\n          console.error('Logout error:', err);\n          return res.status(500).json({ message: \"Logout failed\" });\n        }\n        \n        // Clear session data\n        req.session.destroy((err) => {\n          if (err) {\n            console.error('Session destroy error:', err);\n            return res.status(500).json({ message: \"Session cleanup failed\" });\n          }\n          \n          res.clearCookie('pipol_session');\n          res.clearCookie('connect.sid');\n          return res.json({ message: \"Logged out successfully\" });\n        });\n      });\n    });\n\n    // Get current user\n    app.get(\"/api/auth/me\", isAuthenticated, (req, res) => {\n      if (!req.user) {\n        return res.status(401).json({ message: \"Authentication required\" });\n      }\n\n      const user = req.user as any;\n      \n      return res.json({\n        id: user.id,\n        username: user.username,\n        email: user.email,\n        name: user.name,\n        bio: user.bio,\n        avatar: user.avatar,\n      });\n    });\n  } // End of excludeAuth conditional block\n\n  // Get latest message for events - MUST BE BEFORE /:id route\n  app.get(\"/api/events/latest-messages\", isAuthenticatedMiddleware, async (req: Request, res: Response) => {\n    try {\n      const user = req.user as any;\n      const { eventIds } = req.query;\n\n      console.log('Latest messages request:', { eventIds, user: user.id, type: typeof eventIds });\n\n      if (!eventIds) {\n        console.log('No eventIds provided');\n        return res.status(400).json({ message: 'Event IDs required' });\n      }\n\n      const eventIdArray = typeof eventIds === 'string' ? \n        eventIds.split(',').map(id => parseInt(id)).filter(id => !isNaN(id)) : [];\n\n      console.log('Parsed event IDs:', eventIdArray, 'Original:', eventIds);\n\n      if (eventIdArray.length === 0) {\n        console.log('No valid event IDs after parsing');\n        return res.status(400).json({ message: 'No valid event IDs provided' });\n      }\n\n      // Get latest message for each event\n      const { data: messages, error } = await supabase\n        .from('chat_messages')\n        .select(`\n          id,\n          event_id,\n          sender_id,\n          content,\n          message_type,\n          created_at,\n          sender:users!sender_id (\n            id,\n            name,\n            username\n          )\n        `)\n        .in('event_id', eventIdArray)\n        .is('deleted_at', null)\n        .order('created_at', { ascending: false });\n\n      if (error) {\n        console.error('Error fetching latest messages:', error);\n        return res.status(500).json({ message: 'Error fetching messages' });\n      }\n\n      // Group messages by event_id and get the latest one for each event\n      const latestMessages: { [eventId: number]: any } = {};\n      \n      if (messages) {\n        console.log('Found messages:', messages.length);\n        messages.forEach(message => {\n          const eventId = message.event_id;\n          if (!latestMessages[eventId] || new Date(message.created_at) > new Date(latestMessages[eventId].created_at)) {\n            latestMessages[eventId] = message;\n          }\n        });\n      }\n\n      console.log('Returning latest messages:', latestMessages);\n      res.json(latestMessages);\n    } catch (error) {\n      console.error('Error in latest messages endpoint:', error);\n      res.status(500).json({ message: 'Error fetching messages' });\n    }\n  });\n\n  // Get event by ID (PUBLIC ROUTE)\n  app.get(\"/api/events/:id\", async (req, res) => {\n    try {\n      const eventId = parseInt(req.params.id);\n      if (isNaN(eventId)) {\n        return res.status(400).json({ message: \"Invalid event ID\" });\n      }\n      \n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      res.json(event);\n    } catch (error) {\n      console.error(\"Error fetching event:\", error);\n      res.status(500).json({ message: \"Failed to fetch event\" });\n    }\n  });\n\n  // Create events\n  app.post(\"/api/events\", [\n    isAuthenticated,\n    multer({ \n      storage: storage_uploads, \n      fileFilter: fileFilter,\n      limits: { \n        fileSize: 10 * 1024 * 1024, // 10MB limit\n        files: 12 // Max 12 files total (mainMediaFile + up to 11 additional media files)\n      }\n    }).fields([\n      { name: 'mainMediaFile', maxCount: 1 },\n      { name: 'eventPhoto', maxCount: 1 },\n      { name: 'eventVideo', maxCount: 1 },\n      { name: 'photos', maxCount: 6 },\n      { name: 'videos', maxCount: 3 },\n      { name: 'eventPhotos', maxCount: 6 },\n      { name: 'eventVideos', maxCount: 3 },\n      { name: 'mediaFile_0', maxCount: 1 },\n      { name: 'mediaFile_1', maxCount: 1 },\n      { name: 'mediaFile_2', maxCount: 1 },\n      { name: 'mediaFile_3', maxCount: 1 },\n      { name: 'mediaFile_4', maxCount: 1 },\n      { name: 'mediaFile_5', maxCount: 1 },\n      { name: 'mediaFile_6', maxCount: 1 },\n      { name: 'mediaFile_7', maxCount: 1 },\n      { name: 'mediaFile_8', maxCount: 1 },\n      { name: 'mediaFile_9', maxCount: 1 }\n    ])\n  ], async (req: Request, res: Response) => {\n    try {\n      const user = req.user as any;\n      const files = (req.files as { [fieldname: string]: Express.Multer.File[] }) || {};\n      \n      // Build event data with proper type conversion using camelCase field names\n      const eventData: any = {\n        title: req.body.title,\n        description: req.body.description,\n        category: req.body.category,\n        date: new Date(req.body.date),\n        latitude: parseFloat(req.body.latitude),\n        longitude: parseFloat(req.body.longitude),\n        locationName: req.body.locationName,\n        locationAddress: req.body.locationAddress,\n        paymentType: req.body.paymentType,\n        privacyType: req.body.privacyType,\n        genderPreference: req.body.genderPreference || 'all_people',\n        organizerId: parseInt(user.id.toString()),\n        maxCapacity: req.body.maxCapacity ? parseInt(req.body.maxCapacity) : null,\n        price: req.body.price ? parseFloat(req.body.price) : null,\n        mainMediaUrl: null,\n        mainMediaType: 'photo',\n        mediaItems: null\n      };\n\n      // Process media items without duplication\n      let mediaItems: any[] = [];\n      let mainMediaUrl = '';\n      let mainMediaType = 'photo';\n      \n      // Parse existing mediaItems if provided (for new items, these will be placeholders without real URLs)\n      let existingMediaStructure: any[] = [];\n      if (req.body.mediaItems) {\n        try {\n          const parsedItems = JSON.parse(req.body.mediaItems);\n          if (Array.isArray(parsedItems)) {\n            existingMediaStructure = parsedItems;\n          }\n        } catch (e) {\n          console.warn(\"Could not parse mediaItems:\", e);\n        }\n      }\n\n      // Process uploaded files and map them to the correct media structure\n      let fileIndex = 0;\n      Object.keys(files).forEach((fieldName) => {\n        const fileArray = files[fieldName];\n        if (fileArray && fileArray.length > 0) {\n          const file = fileArray[0];\n          const mediaPath = file.path.replace('public', '');\n          const isVideo = file.mimetype.startsWith('video/');\n          \n          // Find if this file corresponds to a placeholder in existingMediaStructure\n          let targetItem = null;\n          if (fieldName === 'mainMediaFile') {\n            // Find the item marked as main\n            targetItem = existingMediaStructure.find(item => item.isMain);\n          } else if (fieldName.startsWith('mediaFile_')) {\n            // Match by order/index\n            const mediaFileIndex = parseInt(fieldName.split('_')[1]);\n            targetItem = existingMediaStructure.find(item => !item.url && item.order === mediaFileIndex);\n            if (!targetItem) {\n              // Fallback: find any item without URL at the correct position\n              targetItem = existingMediaStructure.filter(item => !item.url)[mediaFileIndex];\n            }\n          }\n          \n          const mediaItem: any = {\n            type: isVideo ? 'video' : 'photo',\n            url: mediaPath,\n            order: targetItem ? targetItem.order : fileIndex,\n            isMain: targetItem ? targetItem.isMain : (fieldName === 'mainMediaFile' || fileIndex === 0)\n          };\n          \n          mediaItems.push(mediaItem);\n          \n          if (mediaItem.isMain || mainMediaUrl === '') {\n            mainMediaUrl = mediaPath;\n            mainMediaType = mediaItem.type;\n          }\n          \n          fileIndex++;\n        }\n      });\n\n      // Add any existing items with URLs (items that already existed and weren't being replaced)\n      existingMediaStructure.forEach(item => {\n        if (item.url && item.url.trim() !== '') {\n          // Only add if not already processed as a file upload\n          const existsInUploads = mediaItems.some(mediaItem => mediaItem.url === item.url);\n          if (!existsInUploads) {\n            mediaItems.push({\n              type: item.type,\n              url: item.url,\n              order: item.order,\n              isMain: item.isMain || false\n            });\n            \n            if (item.isMain && !mainMediaUrl) {\n              mainMediaUrl = item.url;\n              mainMediaType = item.type;\n            }\n          }\n        }\n      });\n\n      // Enhanced main media selection for event creation\n      let finalMainMediaUrl = null;\n      let finalMainMediaType = 'photo';\n      \n      if (mediaItems.length > 0) {\n        // Find explicitly marked main item with valid URL\n        const explicitMain = mediaItems.find((item: any) => \n          item && item.isMain === true && item.url && item.url.trim() !== ''\n        );\n        \n        if (explicitMain) {\n          finalMainMediaUrl = explicitMain.url;\n          finalMainMediaType = explicitMain.type || 'photo';\n        } else {\n          // Use first valid item as main\n          const firstValid = mediaItems.find((item: any) => \n            item && item.url && item.url.trim() !== ''\n          );\n          \n          if (firstValid) {\n            finalMainMediaUrl = firstValid.url;\n            finalMainMediaType = firstValid.type || 'photo';\n            \n            // Mark first valid item as main\n            mediaItems = mediaItems.map((item: any) => ({\n              ...item,\n              isMain: item === firstValid\n            }));\n          }\n        }\n      }\n\n      // Set main media (using camelCase field names)\n      eventData.mainMediaUrl = finalMainMediaUrl;\n      eventData.mainMediaType = finalMainMediaType;\n\n      // Sort media items so main item appears first before saving\n      if (mediaItems.length > 0) {\n        const sortedMediaItems = mediaItems.sort((a, b) => {\n          // If one is main and the other is not, main goes first\n          if (a.isMain && !b.isMain) return -1;\n          if (!a.isMain && b.isMain) return 1;\n          // If both are main or neither is main, sort by order\n          return (a.order || 0) - (b.order || 0);\n        });\n\n        eventData.mediaItems = JSON.stringify(sortedMediaItems);\n      } else {\n        eventData.mediaItems = null;\n      }\n\n      const newEvent = await storage.insertEvent(eventData);\n\n      res.status(201).json(newEvent);\n    } catch (error) {\n      console.error(\"Event creation error:\", error);\n      res.status(500).json({ message: \"Failed to create event\" });\n    }\n  });\n\n  // Update events  \n  app.patch(\"/api/events/:id\", [\n    isAuthenticated,\n    multer({ \n      storage: storage_uploads, \n      fileFilter: fileFilter,\n      limits: { \n        fileSize: 10 * 1024 * 1024,\n        files: 12\n      }\n    }).fields([\n      { name: 'mainMediaFile', maxCount: 1 },\n      { name: 'eventPhoto', maxCount: 1 },\n      { name: 'eventVideo', maxCount: 1 },\n      { name: 'photos', maxCount: 6 },\n      { name: 'videos', maxCount: 3 },\n      { name: 'eventPhotos', maxCount: 6 },\n      { name: 'eventVideos', maxCount: 3 },\n      { name: 'mediaFile_0', maxCount: 1 },\n      { name: 'mediaFile_1', maxCount: 1 },\n      { name: 'mediaFile_2', maxCount: 1 },\n      { name: 'mediaFile_3', maxCount: 1 },\n      { name: 'mediaFile_4', maxCount: 1 },\n      { name: 'mediaFile_5', maxCount: 1 },\n      { name: 'mediaFile_6', maxCount: 1 },\n      { name: 'mediaFile_7', maxCount: 1 },\n      { name: 'mediaFile_8', maxCount: 1 },\n      { name: 'mediaFile_9', maxCount: 1 }\n    ])\n  ], async (req: Request, res: Response) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      // Check if event exists\n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      // Debug logging to understand event structure\n      console.log(\"Event object keys:\", Object.keys(event));\n      console.log(\"Event organizer info:\", {\n        organizerId: event.organizerId,\n        organizer_id: event.organizer_id,\n        organizer: event.organizer\n      });\n      \n      // Check authorization - handle different possible property names\n      const eventOrganizerId = event.organizerId || event.organizer_id || event.organizer?.id;\n      if (!eventOrganizerId) {\n        console.error(\"Could not find organizer ID in event:\", event);\n        return res.status(403).json({ message: \"Event organizer information not found\" });\n      }\n      \n      if (parseInt(eventOrganizerId.toString()) !== parseInt(user.id.toString())) {\n        console.log(\"Authorization failed:\", { eventOrganizerId, userId: user.id });\n        return res.status(403).json({ message: \"Not authorized to update this event\" });\n      }\n      \n      const files = (req.files as { [fieldname: string]: Express.Multer.File[] }) || {};\n      const updateData: any = { ...req.body };\n      \n      // Convert field names from camelCase to snake_case to match database schema\n      if (updateData.locationName) {\n        updateData.location_name = updateData.locationName;\n        delete updateData.locationName;\n      }\n      if (updateData.locationAddress) {\n        updateData.location_address = updateData.locationAddress;\n        delete updateData.locationAddress;\n      }\n      if (updateData.paymentType) {\n        updateData.payment_type = updateData.paymentType;\n        delete updateData.paymentType;\n      }\n      if (updateData.maxCapacity) {\n        updateData.max_capacity = updateData.maxCapacity;\n        delete updateData.maxCapacity;\n      }\n      if (updateData.privacyType) {\n        updateData.privacy_type = updateData.privacyType;\n        delete updateData.privacyType;\n      }\n      if (updateData.privateAccessType) {\n        // Note: privateAccessType column doesn't exist in current database schema\n        // Skip this field to prevent database errors\n        console.log(\"Skipping privateAccessType field - not implemented in database schema\");\n        delete updateData.privateAccessType;\n      }\n      if (updateData.mainMediaType) {\n        updateData.main_media_type = updateData.mainMediaType;\n        delete updateData.mainMediaType;\n      }\n      if (updateData.mainMediaUrl) {\n        updateData.main_media_url = updateData.mainMediaUrl;\n        delete updateData.mainMediaUrl;\n      }\n      if (updateData.mediaItems) {\n        updateData.media_items = updateData.mediaItems;\n        delete updateData.mediaItems;\n      }\n      if (updateData.organizerId) {\n        updateData.organizer_id = updateData.organizerId;\n        delete updateData.organizerId;\n      }\n      if (updateData.createdAt) {\n        updateData.created_at = updateData.createdAt;\n        delete updateData.createdAt;\n      }\n      if (updateData.updatedAt) {\n        updateData.updated_at = updateData.updatedAt;\n        delete updateData.updatedAt;\n      }\n      if (updateData.genderPreference) {\n        updateData.gender_preference = updateData.genderPreference;\n        delete updateData.genderPreference;\n      }\n      \n      // Convert date string to Date object if provided\n      if (updateData.date && typeof updateData.date === 'string') {\n        updateData.date = new Date(updateData.date);\n      }\n      \n      // Parse existing mediaItems with improved error handling - check both field names\n      let mediaItems: any[] = [];\n      const existingMediaItems = event.media_items || event.mediaItems;\n      if (existingMediaItems) {\n        try {\n          if (typeof existingMediaItems === 'string') {\n            mediaItems = JSON.parse(existingMediaItems);\n          } else if (Array.isArray(existingMediaItems)) {\n            mediaItems = existingMediaItems;\n          } else if (typeof existingMediaItems === 'object') {\n            mediaItems = [existingMediaItems];\n          }\n          \n          // Ensure array is valid\n          if (!Array.isArray(mediaItems)) {\n            mediaItems = [];\n          }\n        } catch (e) {\n          console.warn(\"Could not parse existing mediaItems:\", e);\n          mediaItems = [];\n        }\n      }\n\n      // Parse client mediaItems with enhanced validation\n      let clientMediaItems: any[] = [];\n      if (req.body.mediaItems) {\n        try {\n          if (typeof req.body.mediaItems === 'string') {\n            // Handle JSON string\n            clientMediaItems = JSON.parse(req.body.mediaItems);\n          } else if (Array.isArray(req.body.mediaItems)) {\n            // Handle array directly\n            clientMediaItems = req.body.mediaItems;\n          } else if (typeof req.body.mediaItems === 'object' && req.body.mediaItems !== null) {\n            // Handle single object\n            clientMediaItems = [req.body.mediaItems];\n          } else {\n            clientMediaItems = [];\n          }\n          \n          // Validate that result is an array\n          if (!Array.isArray(clientMediaItems)) {\n            console.warn(\"Client mediaItems is not an array after parsing, resetting to empty array\");\n            clientMediaItems = [];\n          }\n        } catch (e) {\n          console.warn(\"Could not parse client mediaItems:\", e);\n          clientMediaItems = [];\n        }\n      }\n\n      // Process uploaded files and map them to metadata\n      const uploadedFiles: any[] = [];\n      Object.keys(files).forEach((fieldName, index) => {\n        const fileArray = files[fieldName];\n        if (fileArray && fileArray.length > 0) {\n          const file = fileArray[0];\n          const mediaPath = file.path.replace('public', '');\n          const isVideo = file.mimetype.startsWith('video/');\n          \n          uploadedFiles.push({\n            fieldName,\n            type: isVideo ? 'video' : 'photo',\n            url: mediaPath,\n            order: index,\n            isMain: fieldName === 'mainMediaFile'\n          });\n          \n          console.log(`📁 Uploaded file processed: ${fieldName} -> ${mediaPath}`);\n        }\n      });\n\n      // Combine client metadata with uploaded files\n      mediaItems = [];\n      \n      if (clientMediaItems.length > 0) {\n        console.log(`Processing ${clientMediaItems.length} client media items`);\n        \n        clientMediaItems.forEach((clientItem: any, index: number) => {\n          // If client item has existing URL, preserve it\n          if (clientItem.url && !clientItem.isNew) {\n            mediaItems.push({\n              type: clientItem.type || 'photo',\n              url: clientItem.url,\n              order: clientItem.order !== undefined ? clientItem.order : index,\n              isMain: clientItem.isMain === true\n            });\n            console.log(`📂 Preserved existing media: ${clientItem.url}`);\n          }\n          // If client item is new and has file, find corresponding upload\n          else if (clientItem.isNew && clientItem.hasFile) {\n            // Find uploaded file by order/index\n            const uploadedFile = uploadedFiles.find(upload => \n              upload.fieldName.endsWith(`_${index}`) || upload.order === index\n            ) || uploadedFiles[index];\n            \n            if (uploadedFile) {\n              mediaItems.push({\n                type: uploadedFile.type,\n                url: uploadedFile.url,\n                order: clientItem.order !== undefined ? clientItem.order : index,\n                isMain: clientItem.isMain === true\n              });\n              console.log(`📁 Added new media: ${uploadedFile.url}`);\n            }\n          }\n        });\n      } else {\n        // Fallback: add all uploaded files if no client metadata\n        uploadedFiles.forEach((upload, index) => {\n          mediaItems.push({\n            type: upload.type,\n            url: upload.url,\n            order: upload.order !== undefined ? upload.order : index,\n            isMain: upload.isMain || index === 0\n          });\n        });\n      }\n\n      // Enhanced main media selection with validation\n      let mainItem: any = null;\n      \n      // First, try to find explicitly marked main item with valid URL\n      mainItem = mediaItems.find((item: any) => \n        item && item.isMain === true && item.url && item.url.trim() !== ''\n      );\n      \n      // If no explicit main found, use first valid item\n      if (!mainItem && mediaItems.length > 0) {\n        mainItem = mediaItems.find((item: any) => \n          item && item.url && item.url.trim() !== ''\n        );\n        \n        // Mark first valid item as main\n        if (mainItem) {\n          mediaItems = mediaItems.map((item: any) => ({\n            ...item,\n            isMain: item === mainItem\n          }));\n        }\n      }\n      \n      // Set main media references (using correct database column names)\n      if (mainItem && mainItem.url) {\n        updateData.main_media_url = mainItem.url;\n        updateData.main_media_type = mainItem.type || 'photo';\n        console.log(`Encontrado elemento principal en mediaItems: {\n          tipo: '${mainItem.type}',\n          url: '${mainItem.url}'\n        }`);\n      } else {\n        // Clear main media if no valid main item found\n        updateData.main_media_url = null;\n        updateData.main_media_type = 'photo';\n        console.log(\"No se encontró elemento principal válido, limpiando referencias\");\n      }\n\n      // Sort media items so main item appears first before saving\n      if (mediaItems.length > 0) {\n        const sortedMediaItems = mediaItems.sort((a, b) => {\n          // If one is main and the other is not, main goes first\n          if (a.isMain && !b.isMain) return -1;\n          if (!a.isMain && b.isMain) return 1;\n          // If both are main or neither is main, sort by order\n          return (a.order || 0) - (b.order || 0);\n        });\n\n        updateData.media_items = JSON.stringify(sortedMediaItems);\n      }\n\n      console.log(\"Attempting to update event with data:\", {\n        eventId,\n        updateFields: Object.keys(updateData),\n        privacyType: updateData.privacy_type\n      });\n\n      await storage.updateEvent(eventId, updateData);\n      const updatedEvent = await storage.getEventById(eventId);\n\n      console.log(\"Event updated successfully\");\n      res.json(updatedEvent);\n    } catch (error: any) {\n      console.error(\"Event update error - detailed:\", {\n        error: error.message,\n        stack: error.stack,\n        eventId: req.params.id,\n        updateFields: req.body ? Object.keys(req.body) : []\n      });\n      res.status(500).json({ message: \"Failed to update event\", details: error.message });\n    }\n  });\n\n  // Get all events\n  app.get(\"/api/events\", async (req, res) => {\n    try {\n      const { lat, lng, radius, category, paymentType, search } = req.query;\n      \n      console.log(\"📍 GET /api/events query params:\", { lat, lng, radius, category, paymentType, search });\n      \n      let events;\n      \n      // If lat and lng are provided, get nearby events\n      if (lat && lng) {\n        console.log(\"📍 Using nearby events path\");\n        events = await storage.getNearbyEvents(\n          parseFloat(lat as string),\n          parseFloat(lng as string),\n          radius ? parseFloat(radius as string) : 10\n        );\n      } else {\n        // Otherwise get all events with filters\n        const filters: any = {};\n        \n        if (category) {\n          filters.category = Array.isArray(category) ? category : [category as string];\n        }\n        \n        if (paymentType) {\n          filters.paymentType = Array.isArray(paymentType) ? paymentType : [paymentType as string];\n        }\n        \n        if (search) {\n          filters.searchTerm = search as string;\n          console.log(\"📍 Adding search filter:\", search);\n        }\n        \n        console.log(\"📍 Using filtered events path with filters:\", filters);\n        events = await storage.getEvents(filters);\n      }\n      \n      console.log(`📍 Found ${events.length} events`);\n      res.json(events);\n    } catch (error) {\n      console.error(\"Error fetching events:\", error);\n      res.status(500).json({ message: \"Failed to fetch events\" });\n    }\n  });\n\n\n\n  // Delete all events (for development purposes)\n  app.delete(\"/api/events\", async (req, res) => {\n    try {\n      await storage.deleteAllEvents();\n      res.json({ message: \"All events deleted successfully\" });\n    } catch (error) {\n      console.error(\"Error deleting all events:\", error);\n      res.status(500).json({ message: \"Failed to delete all events\" });\n    }\n  });\n\n  // Delete event\n  app.delete(\"/api/events/:id\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      console.log(`Delete event request - User ID: ${user.id} (type: ${typeof user.id}), Event ID: ${eventId}`);\n      \n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      // Get organizer ID from both possible field names (snake_case from DB, camelCase from processed)\n      const eventOrganizerId = event.organizer_id || event.organizerId;\n      \n      console.log(`Event found - Organizer ID: ${eventOrganizerId} (type: ${typeof eventOrganizerId})`);\n      console.log(`Authorization check: ${eventOrganizerId} === ${user.id} -> ${eventOrganizerId === user.id}`);\n      \n      // Convert both to numbers for proper comparison\n      const organizerIdNum = parseInt(String(eventOrganizerId));\n      const userIdNum = parseInt(String(user.id));\n      \n      console.log(`Parsed values - Organizer: ${organizerIdNum}, User: ${userIdNum}`);\n      \n      if (organizerIdNum !== userIdNum) {\n        console.log(`Authorization failed: ${organizerIdNum} !== ${userIdNum}`);\n        return res.status(403).json({ message: \"Not authorized to delete this event\" });\n      }\n      \n      console.log(`Authorization successful - deleting event ${eventId}`);\n      await storage.deleteEvent(eventId);\n      res.json({ message: \"Event deleted successfully\" });\n    } catch (error) {\n      console.error(\"Error deleting event:\", error);\n      res.status(500).json({ message: \"Failed to delete event\" });\n    }\n  });\n\n  // Event attendance\n  app.post(\"/api/events/:id/attend\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      const attendeeData = {\n        eventId,\n        userId: user.id,\n        status: \"approved\" as const,\n        paymentStatus: \"completed\",\n        paymentIntentId: null,\n      };\n      \n      const attendee = await storage.insertEventAttendee(attendeeData);\n      \n      res.status(201).json(attendee);\n    } catch (error) {\n      console.error(\"Error attending event:\", error);\n      res.status(500).json({ message: \"Failed to attend event\" });\n    }\n  });\n\n  // Join event (alias for attend)\n  app.post(\"/api/events/:id/join\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      const { answers } = req.body; // For private events with questions\n      \n      console.log(`🔍 Checking access for user ${user.id} to event ${eventId}`);\n      console.log(`🔍 Verifying access for user ${user.id} to event ${eventId}`);\n      \n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      console.log(`📋 Event found: ${event.title}, organizer: ${event.organizerId}, user requesting: ${user.id}`);\n      console.log(`🔍 Event privacy: ${event.privacyType || event.privacy_type}, access type: ${event.privateAccessType || event.private_access_type}`);\n      \n      // Check if user is already attending\n      const existingAttendee = await storage.getEventAttendee(eventId, user.id);\n      if (existingAttendee) {\n        return res.status(400).json({ message: \"Already joined this event\" });\n      }\n      \n      // Determine status based on event privacy and access type\n      let status: \"approved\" | \"pending\" = \"approved\";\n      let isPendingApproval = false;\n      \n      // For private events, check the access type (handle both camelCase and snake_case)\n      const eventPrivacy = event.privacyType || event.privacy_type;\n      const eventAccessType = event.privateAccessType || event.private_access_type;\n      \n      if (eventPrivacy === \"private\") {\n        // Default private events to \"solicitud\" if no access type is specified\n        const accessType = eventAccessType || \"solicitud\";\n        console.log(`🔍 Private event access type: ${accessType} (original: ${eventAccessType})`);\n        \n        if (accessType === \"solicitud\" || accessType === \"postulacion\") {\n          status = \"pending\";\n          isPendingApproval = true;\n        } else if (accessType === \"paga\") {\n          // For paid private events, require immediate payment\n          return res.status(402).json({ \n            message: \"Payment required\", \n            requiresPayment: true,\n            eventId: eventId \n          });\n        }\n      }\n      \n      const attendeeData = {\n        eventId,\n        userId: user.id,\n        status,\n        paymentStatus: status === \"approved\" ? \"completed\" : \"pending\",\n        paymentIntentId: null,\n        applicationAnswers: answers ? JSON.stringify(answers) : null,\n      };\n      \n      const attendee = await storage.insertEventAttendee(attendeeData);\n      \n      if (isPendingApproval) {\n        // Create notification for the event organizer about new join request\n        try {\n          await storage.createNotification({\n            userId: event.organizerId,\n            type: 'new_request',\n            title: 'Nueva solicitud de evento',\n            message: `${user.name} quiere unirse a \"${event.title}\"`,\n            eventId: eventId,\n            requestId: attendee.id\n          });\n          console.log(`📧 Created notification for organizer about request from ${user.name}`);\n        } catch (notificationError) {\n          console.error('Error creating notification:', notificationError);\n          // Don't fail the request if notification creation fails\n        }\n        \n        console.log(`📝 User ${user.username} submitted request for private event ${eventId}`);\n        res.status(201).json({ \n          message: \"Join request submitted successfully\", \n          attendee,\n          isPendingApproval: true,\n          status: \"pending\"\n        });\n      } else {\n        console.log(`✅ User ${user.username} joined event ${eventId} successfully`);\n        res.status(201).json({ \n          message: \"Successfully joined event\", \n          attendee,\n          isPendingApproval: false,\n          status: \"approved\"\n        });\n      }\n    } catch (error) {\n      console.error(\"Error joining event:\", error);\n      res.status(500).json({ message: \"Failed to join event\" });\n    }\n  });\n\n  // Get pending requests for an event (organizers only)\n  app.get(\"/api/events/:id/requests\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      // Only organizer can see pending requests\n      if (event.organizerId !== user.id) {\n        return res.status(403).json({ message: \"Only organizer can view requests\" });\n      }\n      \n      const pendingRequests = await storage.getPendingEventRequests(eventId);\n      res.json(pendingRequests);\n    } catch (error) {\n      console.error(\"Error fetching requests:\", error);\n      res.status(500).json({ message: \"Failed to fetch requests\" });\n    }\n  });\n\n  // Approve event join request (organizers only)\n  app.post(\"/api/events/:id/requests/:userId/approve\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      const userId = parseInt(req.params.userId);\n      \n      console.log(`🔍 Organizer ${user.id} approving user ${userId} for event ${eventId}`);\n      \n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      // Only organizer can approve requests\n      if (event.organizerId !== user.id) {\n        return res.status(403).json({ message: \"Only organizer can approve requests\" });\n      }\n      \n      // Update attendee status to approved\n      const result = await storage.approveEventAttendee(eventId, userId);\n      \n      if (result) {\n        // Create notification for the approved user\n        try {\n          const approvedUser = await storage.getUserById(userId);\n          await storage.createNotification({\n            userId: userId,\n            type: 'request_approved',\n            title: 'Solicitud aceptada',\n            message: `Tu solicitud para unirte a \"${event.title}\" ha sido aceptada`,\n            eventId: eventId\n          });\n          console.log(`📧 Created approval notification for user ${approvedUser?.name || userId}`);\n        } catch (notificationError) {\n          console.error('Error creating approval notification:', notificationError);\n          // Don't fail the approval if notification creation fails\n        }\n\n        console.log(`✅ User ${userId} approved for event ${eventId}`);\n        res.json({ message: \"Request approved successfully\" });\n      } else {\n        res.status(404).json({ message: \"Request not found\" });\n      }\n    } catch (error) {\n      console.error(\"Error approving request:\", error);\n      res.status(500).json({ message: \"Failed to approve request\" });\n    }\n  });\n\n  // Reject event join request (organizers only)\n  app.post(\"/api/events/:id/requests/:userId/reject\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      const userId = parseInt(req.params.userId);\n      \n      console.log(`🔍 Organizer ${user.id} rejecting user ${userId} for event ${eventId}`);\n      \n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      // Only organizer can reject requests\n      if (event.organizerId !== user.id) {\n        return res.status(403).json({ message: \"Only organizer can reject requests\" });\n      }\n      \n      // Update attendee status to rejected or remove the request\n      const result = await storage.rejectEventAttendee(eventId, userId);\n      \n      if (result) {\n        // Create notification for the rejected user\n        try {\n          const rejectedUser = await storage.getUserById(userId);\n          await storage.createNotification({\n            userId: userId,\n            type: 'request_rejected',\n            title: 'Solicitud rechazada',\n            message: `Tu solicitud para unirte a \"${event.title}\" ha sido rechazada`,\n            eventId: eventId\n          });\n          console.log(`📧 Created rejection notification for user ${rejectedUser?.name || userId}`);\n        } catch (notificationError) {\n          console.error('Error creating rejection notification:', notificationError);\n          // Don't fail the rejection if notification creation fails\n        }\n\n        console.log(`❌ User ${userId} rejected for event ${eventId}`);\n        res.json({ message: \"Request rejected successfully\" });\n      } else {\n        res.status(404).json({ message: \"Request not found\" });\n      }\n    } catch (error) {\n      console.error(\"Error rejecting request:\", error);\n      res.status(500).json({ message: \"Failed to reject request\" });\n    }\n  });\n\n  // Create payment for private paid events\n  app.post(\"/api/events/:id/pay\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      // Check if event requires payment\n      if (event.privacyType !== \"private\" || event.privateAccessType !== \"paga\") {\n        return res.status(400).json({ message: \"Event does not require payment\" });\n      }\n      \n      // Check if user is already attending\n      const existingAttendee = await storage.getEventAttendee(eventId, user.id);\n      if (existingAttendee) {\n        return res.status(400).json({ message: \"Already joined this event\" });\n      }\n      \n      // For now, simulate successful payment (since Stripe is disabled)\n      // In production, this would create a Stripe payment intent\n      const attendeeData = {\n        eventId,\n        userId: user.id,\n        status: \"approved\" as const,\n        paymentStatus: \"completed\",\n        paymentIntentId: \"sim_\" + Date.now(), // Simulated payment ID\n        applicationAnswers: null,\n      };\n      \n      const attendee = await storage.insertEventAttendee(attendeeData);\n      \n      console.log(`💳 User ${user.username} completed payment for private event ${eventId}`);\n      res.status(201).json({ \n        message: \"Payment successful and joined event\", \n        attendee,\n        paymentSuccess: true \n      });\n      \n    } catch (error) {\n      console.error(\"Error processing payment:\", error);\n      res.status(500).json({ message: \"Failed to process payment\" });\n    }\n  });\n\n  // Leave event (remove attendance)\n  app.delete(\"/api/events/:id/leave\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      console.log(`User ${user.username} (ID: ${user.id}) attempting to leave event ${eventId}`);\n      \n      // Check if event exists\n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      // Check if user is currently attending\n      const existingAttendee = await storage.getEventAttendee(eventId, user.id);\n      if (!existingAttendee) {\n        return res.status(400).json({ message: \"You are not attending this event\" });\n      }\n      \n      // Remove user from event\n      const result = await storage.leaveEvent(eventId, user.id);\n      \n      console.log(`✅ User ${user.username} left event ${eventId} successfully`);\n      res.json({ message: \"Successfully left event\", result });\n    } catch (error) {\n      console.error(\"Error leaving event:\", error);\n      res.status(500).json({ message: \"Failed to leave event\" });\n    }\n  });\n\n  // Get event attendance status for current user\n  app.get(\"/api/events/:id/status\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const eventId = parseInt(req.params.id);\n      \n      const event = await storage.getEventById(eventId);\n      if (!event) {\n        return res.status(404).json({ message: \"Event not found\" });\n      }\n      \n      // Check if user is the organizer\n      const isOrganizer = event.organizerId === user.id;\n      \n      // Check if user is attending\n      const attendee = await storage.getEventAttendee(eventId, user.id);\n      const isAttending = !!attendee;\n      \n      res.json({\n        isOrganizer,\n        isAttending,\n        status: attendee?.status || null,\n        paymentStatus: attendee?.paymentStatus || null\n      });\n    } catch (error) {\n      console.error(\"Error fetching event status:\", error);\n      res.status(500).json({ message: \"Failed to fetch event status\" });\n    }\n  });\n\n  // Get event attendees\n  app.get(\"/api/events/:id/attendees\", async (req, res) => {\n    try {\n      const eventId = parseInt(req.params.id);\n      const attendees = await storage.getEventAttendees(eventId);\n      res.json(attendees);\n    } catch (error) {\n      console.error(\"Error fetching attendees:\", error);\n      res.status(500).json({ message: \"Failed to fetch attendees\" });\n    }\n  });\n\n  // Get events the authenticated user is attending\n  app.get(\"/api/user/events/attending\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const attendingEvents = await storage.getUserAttendingEvents(user.id);\n      \n      // Convert snake_case database fields to camelCase for frontend\n      const convertedEvents = attendingEvents.map((item: any) => {\n        if (item.event) {\n          // Convert event fields from snake_case to camelCase\n          const event = {\n            ...item.event,\n            locationName: item.event.location_name,\n            locationAddress: item.event.location_address,\n            paymentType: item.event.payment_type,\n            maxCapacity: item.event.max_capacity,\n            privacyType: item.event.privacy_type,\n            mainMediaUrl: item.event.main_media_url,\n            mainMediaType: item.event.main_media_type,\n            mediaItems: item.event.media_items,\n            organizerId: item.event.organizer_id,\n            createdAt: item.event.created_at,\n            updatedAt: item.event.updated_at\n          };\n          \n          // Clean up snake_case fields\n          delete event.location_name;\n          delete event.location_address;\n          delete event.payment_type;\n          delete event.max_capacity;\n          delete event.privacy_type;\n          delete event.main_media_url;\n          delete event.main_media_type;\n          delete event.media_items;\n          delete event.organizer_id;\n          delete event.created_at;\n          delete event.updated_at;\n          \n          return {\n            ...item,\n            event\n          };\n        }\n        return item;\n      });\n      \n      res.json(convertedEvents);\n    } catch (error) {\n      console.error(\"Error fetching user attending events:\", error);\n      res.status(500).json({ message: \"Failed to fetch attending events\" });\n    }\n  });\n\n  // Get events created by the authenticated user\n  app.get(\"/api/user/events/created\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const createdEvents = await storage.getUserCreatedEvents(user.id);\n      \n      // Convert snake_case database fields to camelCase for frontend\n      const convertedEvents = createdEvents.map((event: any) => {\n        return {\n          ...event,\n          locationName: event.location_name,\n          locationAddress: event.location_address,\n          paymentType: event.payment_type,\n          maxCapacity: event.max_capacity,\n          privacyType: event.privacy_type,\n          mainMediaUrl: event.main_media_url,\n          mainMediaType: event.main_media_type,\n          mediaItems: event.media_items,\n          organizerId: event.organizer_id,\n          createdAt: event.created_at,\n          updatedAt: event.updated_at\n        };\n      }).map((event: any) => {\n        // Clean up snake_case fields\n        delete event.location_name;\n        delete event.location_address;\n        delete event.payment_type;\n        delete event.max_capacity;\n        delete event.privacy_type;\n        delete event.main_media_url;\n        delete event.main_media_type;\n        delete event.media_items;\n        delete event.organizer_id;\n        delete event.created_at;\n        delete event.updated_at;\n        return event;\n      });\n      \n      res.json(convertedEvents);\n    } catch (error) {\n      console.error(\"Error fetching user created events:\", error);\n      res.status(500).json({ message: \"Failed to fetch created events\" });\n    }\n  });\n\n  // Get user interests\n  app.get(\"/api/user/interests\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const interests = await storage.getUserInterests(user.id);\n      res.json(interests);\n    } catch (error) {\n      console.error(\"Error fetching user interests:\", error);\n      res.status(500).json({ message: \"Failed to fetch interests\" });\n    }\n  });\n\n  // Add user interest\n  app.post(\"/api/user/interests\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const { category } = req.body;\n      \n      if (!category) {\n        return res.status(400).json({ message: \"Category is required\" });\n      }\n\n      // Check if interest already exists\n      const existingInterests = await storage.getUserInterests(user.id);\n      const hasInterest = existingInterests.some(interest => interest.category === category);\n      \n      if (hasInterest) {\n        return res.status(400).json({ message: \"Interest already exists\" });\n      }\n\n      const newInterest = await storage.addUserInterest(user.id, category);\n      res.json(newInterest);\n    } catch (error) {\n      console.error(\"Error adding user interest:\", error);\n      res.status(500).json({ message: \"Failed to add interest\" });\n    }\n  });\n\n  // Remove user interest\n  app.delete(\"/api/user/interests/:id\", isAuthenticated, async (req, res) => {\n    try {\n      const user = req.user as any;\n      const interestId = parseInt(req.params.id);\n      \n      if (isNaN(interestId)) {\n        return res.status(400).json({ message: \"Invalid interest ID\" });\n      }\n\n      // Verify the interest belongs to the user\n      const userInterests = await storage.getUserInterests(user.id);\n      const interestExists = userInterests.some(interest => interest.id === interestId);\n      \n      if (!interestExists) {\n        return res.status(404).json({ message: \"Interest not found\" });\n      }\n\n      await storage.removeUserInterest(interestId);\n      res.json({ message: \"Interest removed successfully\" });\n    } catch (error) {\n      console.error(\"Error removing user interest:\", error);\n      res.status(500).json({ message: \"Failed to remove interest\" });\n    }\n  });\n\n  // WebSocket setup removed to prevent conflicts with Vite dev server\n\n  // Google Maps proxy to avoid CORS issues\n  app.get('/api/google-proxy/geocode/json', async (req, res) => {\n    try {\n      const { latlng, address, language, region, result_type, location_type } = req.query;\n      \n      if (!latlng && !address) {\n        return res.status(400).json({ error: 'Missing latlng or address parameter' });\n      }\n      \n      const apiKey = process.env.GOOGLE_MAPS_API_KEY;\n      if (!apiKey) {\n        return res.status(500).json({ error: 'Google Maps API key not configured' });\n      }\n      \n      // Build Google Maps API URL\n      const params = new URLSearchParams({\n        key: apiKey,\n        language: String(language || 'es'),\n        region: String(region || 'ar'),\n      });\n      \n      if (latlng) {\n        params.append('latlng', String(latlng));\n      }\n      if (address) {\n        params.append('address', String(address));\n      }\n      if (result_type) params.append('result_type', String(result_type));\n      if (location_type) params.append('location_type', String(location_type));\n      \n      const googleUrl = `https://maps.googleapis.com/maps/api/geocode/json?${params.toString()}`;\n      \n      // Fetch from Google Maps API\n      const response = await fetch(googleUrl);\n      const data = await response.json();\n      \n      // Return the response as JSON\n      res.json(data);\n    } catch (error) {\n      console.error('Error in Google Maps proxy:', error);\n      res.status(500).json({ error: 'Failed to fetch geocoding data' });\n    }\n  });\n\n  // Google Places proxy for autocomplete search\n  app.get('/api/google-proxy/place/autocomplete/json', async (req, res) => {\n    try {\n      const { input, location, radius, language, components } = req.query;\n      \n      if (!input) {\n        return res.status(400).json({ error: 'Missing input parameter' });\n      }\n      \n      const apiKey = process.env.GOOGLE_MAPS_API_KEY;\n      if (!apiKey) {\n        return res.status(500).json({ error: 'Google Maps API key not configured' });\n      }\n      \n      // Build Google Places API URL\n      const params = new URLSearchParams({\n        input: String(input),\n        key: apiKey,\n        language: String(language || 'es'),\n        types: 'establishment|geocode',\n      });\n      \n      if (location) params.append('location', String(location));\n      if (radius) params.append('radius', String(radius));\n      if (components) params.append('components', String(components));\n      \n      const googleUrl = `https://maps.googleapis.com/maps/api/place/autocomplete/json?${params.toString()}`;\n      \n      // Fetch from Google Places API\n      const response = await fetch(googleUrl);\n      const data = await response.json();\n      \n      // Return the response as JSON\n      res.json(data);\n    } catch (error) {\n      console.error('Error in Google Places proxy:', error);\n      res.status(500).json({ error: 'Failed to fetch places data' });\n    }\n  });\n\n  // Google Places details proxy\n  app.get('/api/google-proxy/place/details/json', async (req, res) => {\n    try {\n      const { place_id, language, fields } = req.query;\n      \n      if (!place_id) {\n        return res.status(400).json({ error: 'Missing place_id parameter' });\n      }\n      \n      const apiKey = process.env.GOOGLE_MAPS_API_KEY;\n      if (!apiKey) {\n        return res.status(500).json({ error: 'Google Maps API key not configured' });\n      }\n      \n      // Build Google Places API URL\n      const params = new URLSearchParams({\n        place_id: String(place_id),\n        key: apiKey,\n        language: String(language || 'es'),\n        fields: String(fields || 'name,formatted_address,geometry,place_id'),\n      });\n      \n      const googleUrl = `https://maps.googleapis.com/maps/api/place/details/json?${params.toString()}`;\n      \n      // Fetch from Google Places API\n      const response = await fetch(googleUrl);\n      const data = await response.json();\n      \n      // Return the response as JSON\n      res.json(data);\n    } catch (error) {\n      console.error('Error in Google Places details proxy:', error);\n      res.status(500).json({ error: 'Failed to fetch place details' });\n    }\n  });\n\n  // Mapbox access token endpoint\n  app.get('/api/mapbox-token', (req, res) => {\n    const token = process.env.MAPBOX_ACCESS_TOKEN;\n    if (!token) {\n      return res.status(500).json({ error: 'Mapbox access token not configured' });\n    }\n    res.json({ token });\n  });\n\n  // Google Maps API key endpoint for frontend\n  app.get('/api/google-maps-key', (req, res) => {\n    const key = process.env.GOOGLE_MAPS_API_KEY;\n    if (!key || key === 'GOOGLE_API_KEY') {\n      return res.status(500).json({ error: 'Google Maps API key not configured' });\n    }\n    res.json(key);\n  });\n\n  // Notification endpoints\n  app.get(\"/api/notifications/count\", isAuthenticatedMiddleware, async (req: Request, res: Response) => {\n    try {\n      const user = req.user as any;\n      \n      // Count pending requests for events organized by this user\n      const { data: pendingRequests, error } = await supabase\n        .from('event_attendees')\n        .select(`\n          id, event_id,\n          events!inner(organizer_id)\n        `)\n        .eq('status', 'pending')\n        .eq('events.organizer_id', user.id);\n\n      if (error) {\n        console.error('Error fetching pending requests count:', error);\n        return res.status(500).json({ message: 'Error fetching notifications' });\n      }\n\n      // Count unread notifications for this user\n      const { data: unreadNotifications, error: notificationError } = await supabase\n        .from('notifications')\n        .select('id')\n        .eq('user_id', user.id)\n        .eq('is_read', false);\n\n      if (notificationError) {\n        console.error('Error fetching unread notifications count:', notificationError);\n        return res.status(500).json({ message: 'Error fetching notifications' });\n      }\n\n      const pendingRequestsCount = pendingRequests?.length || 0;\n      const unreadNotificationsCount = unreadNotifications?.length || 0;\n      const totalCount = pendingRequestsCount + unreadNotificationsCount;\n\n      res.json({ count: totalCount });\n    } catch (error) {\n      console.error('Error fetching notification count:', error);\n      res.status(500).json({ message: 'Error fetching notifications' });\n    }\n  });\n\n  // Mark all notifications as read\n  app.post(\"/api/notifications/mark-all-read\", isAuthenticatedMiddleware, async (req: Request, res: Response) => {\n    try {\n      const user = req.user as any;\n      \n      console.log(`📖 Marking all notifications as read for user ${user.id}`);\n      \n      // Update all unread notifications for this user\n      const { data, error } = await supabase\n        .from('notifications')\n        .update({ is_read: true })\n        .eq('user_id', user.id)\n        .eq('is_read', false);\n\n      if (error) {\n        console.error('Error marking notifications as read:', error);\n        return res.status(500).json({ message: 'Error marking notifications as read' });\n      }\n\n      console.log(`✅ Successfully marked notifications as read for user ${user.id}`);\n      res.json({ success: true, message: 'Notifications marked as read' });\n    } catch (error) {\n      console.error('Error in mark-all-read endpoint:', error);\n      res.status(500).json({ message: 'Error marking notifications as read' });\n    }\n  });\n\n  // Get all notifications (combined pending requests and user notifications)\n  app.get(\"/api/notifications/all\", isAuthenticatedMiddleware, async (req: Request, res: Response) => {\n    try {\n      const user = req.user as any;\n      \n      console.log(`📋 Fetching all notifications for user ${user.id}`);\n      \n      // Get user notifications\n      const { data: userNotifications, error: userNotificationsError } = await supabase\n        .from('notifications')\n        .select(`\n          id, type, title, message, event_id, request_id, is_read, created_at,\n          events(title)\n        `)\n        .eq('user_id', user.id)\n        .order('created_at', { ascending: false });\n\n      if (userNotificationsError) {\n        console.error('Error fetching user notifications:', userNotificationsError);\n        return res.status(500).json({ message: 'Error fetching notifications' });\n      }\n\n      // Get pending requests for events organized by this user\n      const { data: pendingRequests, error: pendingError } = await supabase\n        .from('event_attendees')\n        .select(`\n          id, event_id, user_id, status, created_at,\n          events!inner(id, title, date, organizer_id),\n          users(id, name, email, avatar)\n        `)\n        .eq('status', 'pending')\n        .eq('events.organizer_id', user.id)\n        .order('created_at', { ascending: false });\n\n      if (pendingError) {\n        console.error('Error fetching pending requests:', pendingError);\n        return res.status(500).json({ message: 'Error fetching pending requests' });\n      }\n\n      // Format user notifications\n      const formattedUserNotifications = (userNotifications || []).map(notif => ({\n        type: 'user_notification',\n        id: notif.id,\n        notificationType: notif.type,\n        title: notif.title,\n        message: notif.message,\n        eventId: notif.event_id,\n        requestId: notif.request_id,\n        isRead: notif.is_read,\n        createdAt: notif.created_at,\n        event: notif.events ? { title: (notif.events as any).title } : null\n      }));\n\n      // Format pending requests\n      const formattedPendingRequests = (pendingRequests || []).map(req => ({\n        type: 'pending_request',\n        id: req.id,\n        eventId: req.event_id,\n        userId: req.user_id,\n        status: req.status,\n        createdAt: req.created_at,\n        user: req.users ? {\n          id: (req.users as any).id,\n          name: (req.users as any).name,\n          email: (req.users as any).email,\n          avatar: (req.users as any).avatar\n        } : null,\n        event: req.events ? {\n          id: (req.events as any).id,\n          title: (req.events as any).title,\n          date: (req.events as any).date\n        } : null\n      }));\n\n      // Combine and sort by creation date\n      const allNotifications = [...formattedUserNotifications, ...formattedPendingRequests]\n        .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n\n      console.log(`📋 Found ${allNotifications.length} total notifications for user ${user.id}`);\n      res.json({ notifications: allNotifications });\n    } catch (error) {\n      console.error('Error fetching all notifications:', error);\n      res.status(500).json({ message: 'Error fetching notifications' });\n    }\n  });\n\n  app.get(\"/api/notifications/pending-requests\", isAuthenticatedMiddleware, async (req: Request, res: Response) => {\n    try {\n      const user = req.user as any;\n      console.log(`📋 Fetching pending requests for organizer ${user.id}`);\n      \n      // Simplified direct query to avoid storage function issues\n      const { data: pendingRequests, error } = await supabase\n        .from('event_attendees')\n        .select(`\n          id, event_id, user_id, status, created_at\n        `)\n        .eq('status', 'pending');\n      \n      if (error) {\n        console.error('Error fetching pending requests from DB:', error);\n        return res.status(500).json({ message: 'Error fetching pending requests' });\n      }\n      \n      if (!pendingRequests || pendingRequests.length === 0) {\n        console.log(`📋 No pending requests found`);\n        return res.json({ requests: [] });\n      }\n      \n      // Get event details for filtering by organizer\n      const eventIds = Array.from(new Set(pendingRequests.map(req => req.event_id)));\n      const { data: events, error: eventsError } = await supabase\n        .from('events')\n        .select('id, title, date, organizer_id')\n        .in('id', eventIds)\n        .eq('organizer_id', user.id);\n      \n      if (eventsError) {\n        console.error('Error fetching events:', eventsError);\n        return res.status(500).json({ message: 'Error fetching events' });\n      }\n      \n      // Filter requests for events organized by this user\n      const userEventIds = events?.map(e => e.id) || [];\n      const filteredRequests = pendingRequests.filter(req => userEventIds.includes(req.event_id));\n      \n      if (filteredRequests.length === 0) {\n        console.log(`📋 No pending requests found for organizer ${user.id}`);\n        return res.json({ requests: [] });\n      }\n      \n      // Get user details for each request\n      const userIds = Array.from(new Set(filteredRequests.map(req => req.user_id)));\n      const { data: users, error: usersError } = await supabase\n        .from('users')\n        .select('id, name, email, avatar')\n        .in('id', userIds);\n      \n      if (usersError) {\n        console.error('Error fetching users:', usersError);\n        return res.status(500).json({ message: 'Error fetching users' });\n      }\n      \n      // Combine all data\n      const requests = filteredRequests.map(req => {\n        const event = events?.find(e => e.id === req.event_id);\n        const reqUser = users?.find(u => u.id === req.user_id);\n        \n        return {\n          id: req.id,\n          eventId: req.event_id,\n          userId: req.user_id,\n          status: req.status,\n          createdAt: req.created_at,\n          applicationAnswers: null, // Column doesn't exist in Supabase yet\n          user: reqUser,\n          event: event\n        };\n      });\n\n      console.log(`📋 Returning ${requests.length} pending requests for organizer ${user.id}`);\n      res.json({ requests });\n    } catch (error) {\n      console.error('Error fetching pending requests:', error);\n      res.status(500).json({ message: 'Error fetching pending requests' });\n    }\n  });\n\n  // Approve event request endpoint\n  app.post(\"/api/events/approve-attendee\", isAuthenticatedMiddleware, async (req: Request, res: Response) => {\n    try {\n      const user = req.user as any;\n      const { requestId } = req.body;\n\n      if (!requestId) {\n        return res.status(400).json({ message: 'Request ID is required' });\n      }\n\n      // Get the request details and verify organizer\n      const { data: request, error: fetchError } = await supabase\n        .from('event_attendees')\n        .select(`\n          id, event_id, user_id, status,\n          events!inner(organizer_id)\n        `)\n        .eq('id', requestId)\n        .eq('status', 'pending')\n        .eq('events.organizer_id', user.id)\n        .single();\n\n      if (fetchError || !request) {\n        return res.status(404).json({ message: 'Request not found or not authorized' });\n      }\n\n      // Update request status to approved\n      const { error: updateError } = await supabase\n        .from('event_attendees')\n        .update({ \n          status: 'approved',\n          payment_status: 'completed'\n        })\n        .eq('id', requestId);\n\n      if (updateError) {\n        console.error('Error approving request:', updateError);\n        return res.status(500).json({ message: 'Error approving request' });\n      }\n\n      // Get event details for notification\n      const { data: eventData, error: eventError } = await supabase\n        .from('events')\n        .select('title')\n        .eq('id', request.event_id)\n        .single();\n\n      if (!eventError && eventData) {\n        // Create notification for the user who requested to join\n        const { error: notificationError } = await supabase\n          .from('notifications')\n          .insert({\n            user_id: request.user_id,\n            type: 'request_approved',\n            title: 'Solicitud aprobada',\n            message: `Tu solicitud para unirte a \"${eventData.title}\" ha sido aceptada`,\n            event_id: request.event_id,\n            request_id: requestId\n          });\n\n        if (notificationError) {\n          console.error('Error creating notification:', notificationError);\n        }\n      }\n\n      res.json({ message: 'Request approved successfully' });\n    } catch (error) {\n      console.error('Error approving request:', error);\n      res.status(500).json({ message: 'Error approving request' });\n    }\n  });\n\n  // Get all notifications for user (both pending requests and user notifications)\n  app.get(\"/api/notifications/all\", isAuthenticatedMiddleware, async (req: Request, res: Response) => {\n    try {\n      const user = req.user as any;\n      console.log(`📋 Fetching all notifications for user ${user.id}`);\n\n      // Get pending requests for events organized by this user\n      const { data: pendingRequests, error: pendingError } = await supabase\n        .from('event_attendees')\n        .select(`\n          id, event_id, user_id, status, created_at\n        `)\n        .eq('status', 'pending');\n\n      if (pendingError) {\n        console.error('Error fetching pending requests:', pendingError);\n        return res.status(500).json({ message: 'Error fetching notifications' });\n      }\n\n      // Filter and get event details for requests on events organized by this user\n      let organizerRequests: any[] = [];\n      if (pendingRequests && pendingRequests.length > 0) {\n        const eventIds = Array.from(new Set(pendingRequests.map(req => req.event_id)));\n        const { data: events, error: eventsError } = await supabase\n          .from('events')\n          .select('id, title, date, organizer_id')\n          .in('id', eventIds)\n          .eq('organizer_id', user.id);\n\n        if (!eventsError && events) {\n          const userEventIds = events.map(e => e.id);\n          const filteredRequests = pendingRequests.filter(req => userEventIds.includes(req.event_id));\n\n          if (filteredRequests.length > 0) {\n            // Get user details for each request\n            const userIds = Array.from(new Set(filteredRequests.map(req => req.user_id)));\n            const { data: users, error: usersError } = await supabase\n              .from('users')\n              .select('id, name, email, avatar')\n              .in('id', userIds);\n\n            if (!usersError && users) {\n              organizerRequests = filteredRequests.map(req => {\n                const event = events.find(e => e.id === req.event_id);\n                const reqUser = users.find(u => u.id === req.user_id);\n                return {\n                  type: 'pending_request',\n                  id: req.id,\n                  eventId: req.event_id,\n                  userId: req.user_id,\n                  status: req.status,\n                  createdAt: req.created_at,\n                  user: reqUser,\n                  event: event\n                };\n              });\n            }\n          }\n        }\n      }\n\n      // Get user notifications (approvals, rejections, etc.)\n      const { data: userNotifications, error: notificationsError } = await supabase\n        .from('notifications')\n        .select(`\n          id, type, title, message, event_id, request_id, is_read, created_at,\n          events(title)\n        `)\n        .eq('user_id', user.id)\n        .order('created_at', { ascending: false });\n\n      if (notificationsError) {\n        console.error('Error fetching user notifications:', notificationsError);\n        return res.status(500).json({ message: 'Error fetching notifications' });\n      }\n\n      // Combine and format all notifications\n      const allNotifications = [\n        ...organizerRequests,\n        ...(userNotifications || []).map(notif => ({\n          type: 'user_notification',\n          id: notif.id,\n          notificationType: notif.type,\n          title: notif.title,\n          message: notif.message,\n          eventId: notif.event_id,\n          requestId: notif.request_id,\n          isRead: notif.is_read,\n          createdAt: notif.created_at,\n          event: notif.events\n        }))\n      ];\n\n      // Sort by creation date (newest first)\n      allNotifications.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n\n      console.log(`📋 Returning ${allNotifications.length} total notifications for user ${user.id}`);\n      res.json({ notifications: allNotifications });\n    } catch (error) {\n      console.error('Error fetching all notifications:', error);\n      res.status(500).json({ message: 'Error fetching notifications' });\n    }\n  });\n\n  // Reject event request endpoint\n  app.post(\"/api/events/reject-attendee\", isAuthenticatedMiddleware, async (req: Request, res: Response) => {\n    try {\n      const user = req.user as any;\n      const { requestId } = req.body;\n\n      if (!requestId) {\n        return res.status(400).json({ message: 'Request ID is required' });\n      }\n\n      // Get the request details and verify organizer\n      const { data: request, error: fetchError } = await supabase\n        .from('event_attendees')\n        .select(`\n          id, event_id, user_id, status,\n          events!inner(organizer_id)\n        `)\n        .eq('id', requestId)\n        .eq('status', 'pending')\n        .eq('events.organizer_id', user.id)\n        .single();\n\n      if (fetchError || !request) {\n        return res.status(404).json({ message: 'Request not found or not authorized' });\n      }\n\n      // Update request status to rejected (or delete the record)\n      const { error: updateError } = await supabase\n        .from('event_attendees')\n        .update({ status: 'rejected' })\n        .eq('id', requestId);\n\n      if (updateError) {\n        console.error('Error rejecting request:', updateError);\n        return res.status(500).json({ message: 'Error rejecting request' });\n      }\n\n      res.json({ message: 'Request rejected successfully' });\n    } catch (error) {\n      console.error('Error rejecting request:', error);\n      res.status(500).json({ message: 'Error rejecting request' });\n    }\n  });\n\n\n  // Get user profile by ID\n  app.get(\"/api/users/:userId\", isAuthenticatedMiddleware, async (req: Request, res: Response) => {\n    try {\n      const userId = parseInt(req.params.userId);\n      \n      if (isNaN(userId)) {\n        return res.status(400).json({ message: \"Invalid user ID\" });\n      }\n\n      // Get user profile from Supabase\n      const { data: user, error } = await supabase\n        .from('users')\n        .select('id, name, email, username, bio, avatar, created_at')\n        .eq('id', userId)\n        .single();\n\n      if (error || !user) {\n        return res.status(404).json({ message: \"User not found\" });\n      }\n\n      res.json(user);\n    } catch (error) {\n      console.error('Error fetching user profile:', error);\n      res.status(500).json({ message: 'Error fetching user profile' });\n    }\n  });\n\n  // Get user interests by user ID\n  app.get(\"/api/users/:userId/interests\", isAuthenticatedMiddleware, async (req: Request, res: Response) => {\n    try {\n      const userId = parseInt(req.params.userId);\n      \n      if (isNaN(userId)) {\n        return res.status(400).json({ message: \"Invalid user ID\" });\n      }\n\n      // Get user interests from Supabase\n      const { data: interests, error } = await supabase\n        .from('user_interests')\n        .select('category')\n        .eq('user_id', userId);\n\n      if (error) {\n        console.error('Error fetching user interests:', error);\n        return res.status(500).json({ message: 'Error fetching user interests' });\n      }\n\n      const interestsList = interests ? interests.map(i => i.category) : [];\n      res.json({ interests: interestsList });\n    } catch (error) {\n      console.error('Error fetching user interests:', error);\n      res.status(500).json({ message: 'Error fetching user interests' });\n    }\n  });\n\n  // Get user aura (average rating)\n  app.get(\"/api/users/:userId/aura\", isAuthenticatedMiddleware, async (req: Request, res: Response) => {\n    try {\n      const userId = parseInt(req.params.userId);\n      \n      if (isNaN(userId)) {\n        return res.status(400).json({ message: \"Invalid user ID\" });\n      }\n\n      // Get average rating for the user\n      const { data: ratings, error } = await supabase\n        .from('user_ratings')\n        .select('rating')\n        .eq('rated_user_id', userId);\n\n      if (error) {\n        console.error('Error fetching user ratings:', error);\n        \n        // If table doesn't exist, return default values (no ratings yet)\n        if (error.message && error.message.includes('relation \"public.user_ratings\" does not exist')) {\n          return res.json({ aura: 0, count: 0 });\n        }\n        \n        return res.status(500).json({ message: 'Error fetching user aura' });\n      }\n\n      let aura = 0;\n      let count = 0;\n\n      if (ratings && ratings.length > 0) {\n        const sum = ratings.reduce((acc, rating) => acc + rating.rating, 0);\n        aura = sum / ratings.length;\n        count = ratings.length;\n      }\n\n      res.json({ \n        aura: parseFloat(aura.toFixed(1)), \n        count \n      });\n    } catch (error) {\n      console.error('Error fetching user aura:', error);\n      res.status(500).json({ message: 'Error fetching user aura' });\n    }\n  });\n\n  // Check if current user can rate another user (have been in same event)\n  app.get(\"/api/users/:userId/can-rate\", isAuthenticatedMiddleware, async (req: Request, res: Response) => {\n    try {\n      const user = req.user as any;\n      const targetUserId = parseInt(req.params.userId);\n      \n      if (isNaN(targetUserId)) {\n        return res.status(400).json({ message: \"Invalid user ID\" });\n      }\n\n      if (user.id === targetUserId) {\n        return res.json({ canRate: false, reason: \"Cannot rate yourself\" });\n      }\n\n      // First get events where current user was approved\n      const { data: userEvents, error: userEventsError } = await supabase\n        .from('event_attendees')\n        .select('event_id')\n        .eq('user_id', user.id)\n        .eq('status', 'approved');\n\n      if (userEventsError || !userEvents || userEvents.length === 0) {\n        return res.json({ canRate: false, reason: \"You need to attend the same event to rate this user\" });\n      }\n\n      const userEventIds = userEvents.map(e => e.event_id);\n\n      // Check if target user was also approved in any of these events\n      const { data: sharedEvents, error } = await supabase\n        .from('event_attendees')\n        .select('event_id')\n        .eq('user_id', targetUserId)\n        .eq('status', 'approved')\n        .in('event_id', userEventIds);\n\n      if (error) {\n        console.error('Error checking shared events:', error);\n        return res.status(500).json({ message: 'Error checking rating eligibility' });\n      }\n\n      const canRate = sharedEvents && sharedEvents.length > 0;\n      \n      res.json({ \n        canRate,\n        reason: canRate ? null : \"You need to attend the same event to rate this user\"\n      });\n    } catch (error) {\n      console.error('Error checking rating eligibility:', error);\n      res.status(500).json({ message: 'Error checking rating eligibility' });\n    }\n  });\n\n  // Rate a user\n  app.post(\"/api/users/:userId/rate\", isAuthenticatedMiddleware, async (req: Request, res: Response) => {\n    try {\n      const user = req.user as any;\n      const targetUserId = parseInt(req.params.userId);\n      const { rating } = req.body;\n      \n      if (isNaN(targetUserId)) {\n        return res.status(400).json({ message: \"Invalid user ID\" });\n      }\n\n      if (user.id === targetUserId) {\n        return res.status(400).json({ message: \"Cannot rate yourself\" });\n      }\n\n      if (!rating || rating < 1 || rating > 10) {\n        return res.status(400).json({ message: \"Rating must be between 1 and 10\" });\n      }\n\n      // First get events where current user was approved\n      const { data: userEvents, error: userEventsError } = await supabase\n        .from('event_attendees')\n        .select('event_id')\n        .eq('user_id', user.id)\n        .eq('status', 'approved');\n\n      if (userEventsError || !userEvents || userEvents.length === 0) {\n        return res.status(403).json({ \n          message: \"You can only rate users you've attended events with\" \n        });\n      }\n\n      const userEventIds = userEvents.map(e => e.event_id);\n\n      // Check if target user was also approved in any of these events\n      const { data: sharedEvents, error: checkError } = await supabase\n        .from('event_attendees')\n        .select('event_id')\n        .eq('user_id', targetUserId)\n        .eq('status', 'approved')\n        .in('event_id', userEventIds);\n\n      if (checkError || !sharedEvents || sharedEvents.length === 0) {\n        return res.status(403).json({ \n          message: \"You can only rate users you've attended events with\" \n        });\n      }\n\n      // Insert or update rating (upsert) - allow modifications anytime\n      const { error: upsertError } = await supabase\n        .from('user_ratings')\n        .upsert({\n          rated_user_id: targetUserId,\n          rater_user_id: user.id,\n          rating: rating,\n          updated_at: new Date().toISOString()\n        }, {\n          onConflict: 'rated_user_id,rater_user_id'\n        });\n\n      if (upsertError) {\n        console.error('Error saving rating:', upsertError);\n        \n        // If table doesn't exist, inform user that admin needs to create it\n        if (upsertError.message && upsertError.message.includes('relation \"public.user_ratings\" does not exist')) {\n          return res.status(503).json({ \n            message: 'Rating system is not available yet. Please contact administrator.' \n          });\n        }\n        \n        return res.status(500).json({ message: 'Error saving rating' });\n      }\n\n      res.json({ message: 'Rating saved successfully' });\n    } catch (error) {\n      console.error('Error rating user:', error);\n      res.status(500).json({ message: 'Error rating user' });\n    }\n  });\n\n  // Serve static files\n  app.use(express.static('public'));\n\n  const httpServer = createServer(app);\n  return httpServer;\n}","size_bytes":87732},"server/session-auth.ts":{"content":"import { Request, Response, NextFunction } from 'express';\nimport { storage } from './storage';\n\n// Simple in-memory session store for development\nconst sessionStore = new Map<string, {\n  userId: number;\n  email: string;\n  authenticated: boolean;\n  lastActivity: Date;\n}>();\n\n// No session timeout - sessions persist until manual logout\nexport function createSession(userId: number, email: string): string {\n  const sessionId = Math.random().toString(36).substr(2, 9);\n  sessionStore.set(sessionId, {\n    userId,\n    email,\n    authenticated: true,\n    lastActivity: new Date()\n  });\n  return sessionId;\n}\n\nexport function getSession(sessionId: string) {\n  const session = sessionStore.get(sessionId);\n  if (!session) return null;\n  \n  // Update last activity but don't check for expiration\n  session.lastActivity = new Date();\n  sessionStore.set(sessionId, session);\n  \n  return session;\n}\n\nexport function destroySession(sessionId: string) {\n  sessionStore.delete(sessionId);\n}\n\nexport async function sessionAuthMiddleware(req: Request, res: Response, next: NextFunction) {\n  try {\n    // First try session-based authentication\n    const sessionId = req.headers['x-session-id'] as string;\n    if (sessionId) {\n      const session = getSession(sessionId);\n      if (session) {\n        // Temporarily skip database user lookup\n        req.user = {\n          id: session.userId,\n          email: session.email,\n          username: 'user',\n          name: 'User',\n          password: null,\n          bio: null,\n          avatar: null,\n          supabaseId: null,\n          stripeCustomerId: null,\n          stripeSubscriptionId: null,\n          createdAt: new Date(),\n          updatedAt: new Date()\n        };\n        return next();\n      }\n    }\n    \n    // If no session, continue to next middleware (token-based auth)\n    next();\n  } catch (error) {\n    console.error('Session auth error:', error);\n    next();\n  }\n}","size_bytes":1918},"server/storage.ts":{"content":"import { db } from \"./db\";\nimport { eq, and, desc, gte, lte, inArray } from \"drizzle-orm\";\nimport {\n  users,\n  events,\n  eventAttendees,\n  userInterests,\n  notifications,\n  type User,\n  type Event,\n  type EventAttendee,\n  type InsertUser,\n  type InsertEvent,\n  type InsertEventAttendee\n} from \"@shared/schema\";\n\n// User related storage functions using Supabase client directly\nimport { supabase } from './supabase-client';\nimport { memoryUserStore } from './memory-storage';\nimport { createClient } from '@supabase/supabase-js';\n\nexport const getUserById = async (id: number) => {\n  try {\n    // Try memory store first\n    const memoryUser = await memoryUserStore.getUserById(id);\n    if (memoryUser) {\n      return memoryUser;\n    }\n\n    // Fallback to Supabase\n    const { data, error } = await supabase\n      .from('users')\n      .select('*')\n      .eq('id', id)\n      .maybeSingle();\n    \n    if (error) {\n      console.log('getUserById error:', error.message);\n      return null;\n    }\n    return data;\n  } catch (err) {\n    console.log('getUserById exception:', err);\n    return null;\n  }\n};\n\nexport const getUserByEmail = async (email: string) => {\n  try {\n    // Try memory store first\n    const memoryUser = await memoryUserStore.getUserByEmail(email);\n    if (memoryUser) {\n      return memoryUser;\n    }\n\n    // Fallback to Supabase\n    const { data, error } = await supabase\n      .from('users')\n      .select('*')\n      .eq('email', email)\n      .maybeSingle();\n    \n    if (error) {\n      console.log('getUserByEmail error:', error.message);\n      return null;\n    }\n    return data;\n  } catch (err) {\n    console.log('getUserByEmail exception:', err);\n    return null;\n  }\n};\n\nexport const getUserByUsername = async (username: string) => {\n  try {\n    const { data, error } = await supabase\n      .from('users')\n      .select('*')\n      .eq('username', username)\n      .single();\n    \n    if (error) {\n      console.log('getUserByUsername error:', error.message);\n      return null;\n    }\n    return data;\n  } catch (err) {\n    console.log('getUserByUsername exception:', err);\n    return null;\n  }\n};\n\nexport const getUserBySupabaseId = async (supabaseId: string) => {\n  try {\n    const { data, error } = await supabase\n      .from('users')\n      .select('*')\n      .eq('supabase_id', supabaseId)\n      .single();\n    \n    if (error) {\n      console.log('getUserBySupabaseId error:', error.message);\n      return null;\n    }\n    return data;\n  } catch (err) {\n    console.log('getUserBySupabaseId exception:', err);\n    return null;\n  }\n};\n\nexport const insertUser = async (user: InsertUser) => {\n  try {\n    // Try Supabase first\n    const dbUser = {\n      email: user.email,\n      username: user.username,\n      name: user.name,\n      password: user.password,\n      bio: user.bio || null,\n      avatar: user.avatar || null,\n      supabase_id: user.supabaseId || null,\n      stripe_customer_id: user.stripeCustomerId || null,\n      stripe_subscription_id: user.stripeSubscriptionId || null\n    };\n    \n    const { data, error } = await supabase\n      .from('users')\n      .insert([dbUser])\n      .select()\n      .single();\n    \n    if (!error && data) {\n      console.log('insertUser successful in Supabase:', data.id);\n      return data;\n    }\n    \n    console.log('insertUser Supabase error:', error?.message, '- falling back to memory store');\n    \n    // Fallback to memory store for development\n    const memoryUser = await memoryUserStore.insertUser(user);\n    if (memoryUser) {\n      console.log('insertUser successful in memory store:', memoryUser.id);\n      return memoryUser;\n    }\n    \n    console.log('insertUser failed in both Supabase and memory store');\n    return null;\n  } catch (err) {\n    console.log('insertUser exception:', err);\n    \n    // Try memory store as final fallback\n    try {\n      const memoryUser = await memoryUserStore.insertUser(user);\n      if (memoryUser) {\n        console.log('insertUser successful in memory store (exception fallback):', memoryUser.id);\n        return memoryUser;\n      }\n    } catch (memErr) {\n      console.log('insertUser memory store exception:', memErr);\n    }\n    \n    return null;\n  }\n};\n\nexport const updateUser = async (id: number, userData: Partial<User>) => {\n  try {\n    const { data, error } = await supabase\n      .from('users')\n      .update({ ...userData, updated_at: new Date().toISOString() })\n      .eq('id', id)\n      .select()\n      .single();\n    \n    if (error) {\n      console.log('updateUser error:', error.message);\n      return null;\n    }\n    return data;\n  } catch (err) {\n    console.log('updateUser exception:', err);\n    return null;\n  }\n};\n\nexport const updateStripeCustomerId = async (userId: number, stripeCustomerId: string) => {\n  try {\n    const { data, error } = await supabase\n      .from('users')\n      .update({ \n        stripe_customer_id: stripeCustomerId, \n        updated_at: new Date().toISOString() \n      })\n      .eq('id', userId)\n      .select()\n      .single();\n    \n    if (error) {\n      console.log('updateStripeCustomerId error:', error.message);\n      return null;\n    }\n    return data;\n  } catch (err) {\n    console.log('updateStripeCustomerId exception:', err);\n    return null;\n  }\n};\n\nexport const updateUserStripeInfo = async (userId: number, stripeInfo: { stripeCustomerId: string, stripeSubscriptionId: string }) => {\n  try {\n    const { data, error } = await supabase\n      .from('users')\n      .update({ \n        stripe_customer_id: stripeInfo.stripeCustomerId,\n        stripe_subscription_id: stripeInfo.stripeSubscriptionId,\n        updated_at: new Date().toISOString() \n      })\n      .eq('id', userId)\n      .select()\n      .single();\n    \n    if (error) {\n      console.log('updateUserStripeInfo error:', error.message);\n      return null;\n    }\n    return data;\n  } catch (err) {\n    console.log('updateUserStripeInfo exception:', err);\n    return null;\n  }\n};\n\n// Cache for processed media items to avoid repetitive processing\nconst mediaProcessingCache = new Map<string, any>();\n\n// Utility function to sort media items in events so main item appears first\nconst sortEventMediaItems = (event: any) => {\n  if (!event) return event;\n  \n  // Generate cache key based on event ID and media items content\n  const mediaItemsField = event?.media_items || event?.mediaItems;\n  const cacheKey = `${event.id}-${JSON.stringify(mediaItemsField || '')}`;\n  \n  // Check cache first to avoid repeated processing\n  if (mediaProcessingCache.has(cacheKey)) {\n    const cachedResult = mediaProcessingCache.get(cacheKey);\n    return { ...event, ...cachedResult };\n  }\n  \n  if (!mediaItemsField) {\n    // Cache empty result\n    mediaProcessingCache.set(cacheKey, { \n      media_items: null, \n      mediaItems: null,\n      mainMediaUrl: event.main_media_url || event.mainMediaUrl,\n      mainMediaType: event.main_media_type || event.mainMediaType\n    });\n    return event;\n  }\n  \n  try {\n    let mediaItems = [];\n    \n    // Parse media items\n    if (typeof mediaItemsField === 'string') {\n      try {\n        mediaItems = JSON.parse(mediaItemsField);\n      } catch (parseError) {\n        console.warn(`Error parsing media items for event ${event.id}:`, parseError);\n        return event;\n      }\n    } else if (Array.isArray(mediaItemsField)) {\n      mediaItems = mediaItemsField;\n    }\n    \n    if (Array.isArray(mediaItems) && mediaItems.length > 0) {\n      // Validate and clean media items\n      const validMediaItems = mediaItems.filter(item => \n        item && \n        typeof item === 'object' && \n        item.url && \n        (item.type === 'photo' || item.type === 'video')\n      );\n      \n      if (validMediaItems.length === 0) {\n        console.warn(`No valid media items found for event ${event.id}`);\n        return event;\n      }\n      \n      // Sort so main item appears first\n      const sortedItems = validMediaItems.sort((a, b) => {\n        // If one is main and the other is not, main goes first\n        if (a.isMain && !b.isMain) return -1;\n        if (!a.isMain && b.isMain) return 1;\n        // If both are main or neither is main, sort by order\n        return (a.order || 0) - (b.order || 0);\n      });\n      \n      // Ensure at least one item is marked as main\n      if (!sortedItems.some(item => item.isMain)) {\n        sortedItems[0].isMain = true;\n      }\n      \n      // Find main media info\n      const mainItem = sortedItems.find(item => item.isMain);\n      const mainMediaUrl = mainItem?.url || null;\n      const mainMediaType = mainItem?.type || null;\n      \n      // Prepare result for caching\n      const result = {\n        media_items: JSON.stringify(sortedItems),\n        mediaItems: JSON.stringify(sortedItems),\n        mainMediaUrl: mainMediaUrl,\n        mainMediaType: mainMediaType,\n        main_media_url: mainMediaUrl,\n        main_media_type: mainMediaType\n      };\n      \n      // Cache the result\n      mediaProcessingCache.set(cacheKey, result);\n      \n      return { ...event, ...result };\n    }\n  } catch (error) {\n    console.warn(`Error processing media items for event ${event.id}:`, error);\n  }\n  \n  return event;\n};\n\n// Clear cache periodically to prevent memory leaks\nsetInterval(() => {\n  if (mediaProcessingCache.size > 1000) {\n    mediaProcessingCache.clear();\n    console.log('🧹 Cleared media processing cache');\n  }\n}, 300000); // Clear every 5 minutes if cache is too large\n\n// Event related storage functions\nexport const getEventById = async (id: number) => {\n  try {\n    console.log(`🔍 getEventById: Fetching event with ID ${id}`);\n    \n    // Use Supabase client to get event with organizer data\n    const { data: event, error } = await supabase\n      .from('events')\n      .select(`\n        *,\n        organizer:users!events_organizer_id_fkey(*),\n        attendees:event_attendees(\n          *,\n          user:users(*)\n        )\n      `)\n      .eq('id', id)\n      .single();\n    \n    if (error) {\n      console.log(`🚨 getEventById error for ID ${id}:`, error.message);\n      return null;\n    }\n    \n    if (!event) {\n      console.log(`🔍 No event found for ID ${id}`);\n      return null;\n    }\n    \n    console.log(`🔍 Found event: ${event.title} by organizer ${event.organizer?.name}`);\n    console.log(`🔍 Attendees data:`, event.attendees ? `${event.attendees.length} attendees` : 'null/undefined');\n    return sortEventMediaItems(event);\n  } catch (err) {\n    console.error(`🚨 getEventById exception for ID ${id}:`, err);\n    return null;\n  }\n};\n\nexport const getEvents = async (filters?: {\n  category?: string[];\n  paymentType?: string[];\n  minDate?: Date;\n  maxDate?: Date;\n  searchTerm?: string;\n  lat?: number;\n  lng?: number;\n  radius?: number; // in kilometers\n}) => {\n  try {\n    console.log(\"📍 getEvents: Using configured Supabase client...\");\n    \n    const now = new Date().toISOString();\n    \n    const { data: allEvents, error } = await supabase\n      .from('events')\n      .select(`\n        *,\n        organizer:users!events_organizer_id_fkey(*),\n        attendees:event_attendees(\n          *,\n          user:users(*)\n        )\n      `)\n      .or(`end_time.gte.${now},end_time.is.null`)\n      .order('date', { ascending: false });\n\n    if (error) {\n      console.error(\"getEvents Supabase error:\", error);\n      return [];\n    }\n\n    let filteredEvents = allEvents || [];\n\n    // Apply search filter if provided\n    if (filters?.searchTerm && filters.searchTerm.trim().length > 0) {\n      const searchTerm = filters.searchTerm.toLowerCase().trim();\n      console.log(`📍 Filtering events by search term: \"${searchTerm}\"`);\n      \n      filteredEvents = filteredEvents.filter(event => {\n        const titleMatch = event.title?.toLowerCase().includes(searchTerm);\n        const descriptionMatch = event.description?.toLowerCase().includes(searchTerm);\n        const locationMatch = event.locationName?.toLowerCase().includes(searchTerm) || \n                             event.locationAddress?.toLowerCase().includes(searchTerm);\n        const categoryMatch = event.category?.toLowerCase().includes(searchTerm);\n        \n        return titleMatch || descriptionMatch || locationMatch || categoryMatch;\n      });\n      \n      console.log(`📍 Found ${filteredEvents.length} events matching search term`);\n    }\n\n    // Apply category filter if provided\n    if (filters?.category && filters.category.length > 0) {\n      filteredEvents = filteredEvents.filter(event => \n        filters.category!.includes(event.category)\n      );\n    }\n\n    // Apply payment type filter if provided\n    if (filters?.paymentType && filters.paymentType.length > 0) {\n      filteredEvents = filteredEvents.filter(event => \n        filters.paymentType!.includes(event.paymentType)\n      );\n    }\n\n    console.log(`📍 Found ${filteredEvents.length} events (filtered for non-ended events)`);\n    return filteredEvents.map(sortEventMediaItems);\n  } catch (error: any) {\n    console.error(\"getEvents exception:\", error);\n    return [];\n  }\n};\n\nexport const getNearbyEvents = async (lat: number, lng: number, radius: number = 10) => {\n  try {\n    console.log(\"📍 getNearbyEvents: Using configured Supabase client...\");\n    \n    // Use the already configured Supabase client\n    \n    console.log(\"📍 getNearbyEvents: Querying events table...\");\n    const now = new Date().toISOString();\n    \n    const { data: allEvents, error } = await supabase\n      .from('events')\n      .select(`\n        *,\n        organizer:users!events_organizer_id_fkey(*)\n      `)\n      .or(`end_time.gte.${now},end_time.is.null`)\n      .order('date', { ascending: false });\n\n    if (error) {\n      console.error(\"getNearbyEvents Supabase error:\", error);\n      return [];\n    }\n\n    if (!allEvents) {\n      return [];\n    }\n\n    // Simplified distance calculation using the Haversine formula\n    // In a real app, this would be done at the database level\n    const filteredEvents = allEvents.filter(event => {\n      const eventLat = parseFloat(event.latitude.toString());\n      const eventLng = parseFloat(event.longitude.toString());\n      \n      // Haversine formula\n      const R = 6371; // Earth's radius in km\n      const dLat = (lat - eventLat) * Math.PI / 180;\n      const dLng = (lng - eventLng) * Math.PI / 180;\n      const a = \n        Math.sin(dLat/2) * Math.sin(dLat/2) +\n        Math.cos(eventLat * Math.PI / 180) * Math.cos(lat * Math.PI / 180) * \n        Math.sin(dLng/2) * Math.sin(dLng/2);\n      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n      const distance = R * c;\n      \n      return distance <= radius;\n    });\n\n    console.log(`📍 Found ${filteredEvents.length} nearby events (filtered for non-ended events)`);\n    // Sort media items for each event\n    return filteredEvents.map(sortEventMediaItems);\n  } catch (error: any) {\n    console.error(\"getNearbyEvents exception:\", error);\n    return [];\n  }\n};\n\nexport const insertEvent = async (event: InsertEvent) => {\n  try {\n    console.log(\"🔥 insertEvent: Using configured Supabase client...\");\n    \n    // Use the already configured Supabase client instead of creating admin client\n    \n    console.log(\"Insertando evento en DB:\", JSON.stringify(event));\n    \n    // Convert to database-compatible format\n    const eventData = {\n      title: event.title,\n      description: event.description,\n      category: event.category,\n      date: event.date instanceof Date ? event.date.toISOString() : new Date(event.date).toISOString(),\n      // Temporarily commenting out end_time until column is added to database\n      // end_time: event.endTime ? (event.endTime instanceof Date ? event.endTime.toISOString() : new Date(event.endTime).toISOString()) : null,\n      latitude: event.latitude.toString(),\n      longitude: event.longitude.toString(),\n      location_name: event.locationName,\n      location_address: event.locationAddress,\n      payment_type: event.paymentType || 'free',\n      price: event.price ? event.price.toString() : null,\n      max_capacity: event.maxCapacity,\n      privacy_type: event.privacyType || 'public',\n      gender_preference: event.genderPreference || 'all_people',\n      media_items: event.mediaItems,\n      main_media_type: event.mainMediaType,\n      main_media_url: event.mainMediaUrl,\n      organizer_id: parseInt(event.organizerId.toString())\n    };\n    \n    console.log(\"Datos formateados para DB:\", JSON.stringify(eventData));\n    \n    const { data: newEvent, error } = await supabase\n      .from('events')\n      .insert([eventData])\n      .select()\n      .single();\n    \n    if (error) {\n      console.error(\"Error al insertar evento en Supabase:\", error);\n      throw error;\n    }\n    \n    console.log(\"Evento creado exitosamente:\", JSON.stringify(newEvent));\n    return newEvent;\n  } catch (error) {\n    console.error(\"Error al insertar evento en la base de datos:\", error);\n    throw error;\n  }\n};\n\nexport const updateEvent = async (id: number, eventData: Partial<Event>) => {\n  console.log(\"Actualizando evento en la base de datos. ID:\", id);\n  console.log(\"Datos de multimedia a guardar:\");\n  console.log(\"- mediaItems:\", eventData.mediaItems);\n  console.log(\"- mainMediaType:\", eventData.mainMediaType);\n  console.log(\"- mainMediaUrl:\", eventData.mainMediaUrl);\n  \n  // CRITICAL FIX: Convert camelCase field names to snake_case to match database schema\n  const dbData: any = { ...eventData };\n  \n  // Convert field names from camelCase to snake_case to match database schema\n  if (dbData.locationName !== undefined) {\n    dbData.location_name = dbData.locationName;\n    delete dbData.locationName;\n  }\n  if (dbData.locationAddress !== undefined) {\n    dbData.location_address = dbData.locationAddress;\n    delete dbData.locationAddress;\n  }\n  if (dbData.paymentType !== undefined) {\n    dbData.payment_type = dbData.paymentType;\n    delete dbData.paymentType;\n  }\n  if (dbData.maxCapacity !== undefined) {\n    dbData.max_capacity = dbData.maxCapacity;\n    delete dbData.maxCapacity;\n  }\n  if (dbData.privacyType !== undefined) {\n    dbData.privacy_type = dbData.privacyType;\n    delete dbData.privacyType;\n  }\n  if (dbData.mainMediaType !== undefined) {\n    dbData.main_media_type = dbData.mainMediaType;\n    delete dbData.mainMediaType;\n  }\n  if (dbData.mainMediaUrl !== undefined) {\n    dbData.main_media_url = dbData.mainMediaUrl;\n    delete dbData.mainMediaUrl;\n  }\n  if (dbData.mediaItems !== undefined) {\n    dbData.media_items = dbData.mediaItems;\n    delete dbData.mediaItems;\n  }\n  if (dbData.organizerId !== undefined) {\n    dbData.organizer_id = dbData.organizerId;\n    delete dbData.organizerId;\n  }\n  if (dbData.createdAt !== undefined) {\n    dbData.created_at = dbData.createdAt;\n    delete dbData.createdAt;\n  }\n  if (dbData.updatedAt !== undefined) {\n    dbData.updated_at = dbData.updatedAt;\n    delete dbData.updatedAt;\n  }\n  \n  // CORRECCIÓN CRÍTICA: Asegurar coherencia entre mainMediaType y mediaItems\n  if (dbData.media_items || dbData.mediaItems) {\n    const mediaItemsData = dbData.media_items || dbData.mediaItems;\n    try {\n      // Intentar parsear mediaItems\n      const mediaItems = JSON.parse(mediaItemsData as string);\n      \n      // Buscar el elemento principal\n      const mainItem = mediaItems.find((item: any) => item && item.isMain === true);\n      \n      if (mainItem) {\n        console.log(\"Encontrado elemento principal en mediaItems:\", {\n          tipo: mainItem.type,\n          url: mainItem.url\n        });\n        \n        // Asegurar que mainMediaType y mainMediaUrl coincidan con el elemento principal\n        if (mainItem.type && mainItem.url) {\n          // Solo actualizar si hay diferencias\n          if (dbData.main_media_type !== mainItem.type) {\n            console.log(`Corrigiendo mainMediaType para que coincida con mediaItems: ${mainItem.type}`);\n            dbData.main_media_type = mainItem.type;\n          }\n          \n          if (dbData.main_media_url !== mainItem.url) {\n            console.log(`Corrigiendo mainMediaUrl para que coincida con mediaItems: ${mainItem.url}`);\n            dbData.main_media_url = mainItem.url;\n          }\n        }\n      }\n    } catch (error) {\n      console.error(\"Error al parsear mediaItems para verificar coherencia:\", error);\n    }\n  }\n  \n  // Asegurar que mainMediaType sea siempre un string, no un array\n  if (dbData.main_media_type && Array.isArray(dbData.main_media_type)) {\n    const firstType = dbData.main_media_type[0] || 'photo';\n    console.log(`Corrigiendo mainMediaType de array a string: → ${firstType}`);\n    dbData.main_media_type = firstType;\n  }\n  \n  // Crear un timestamp de actualización\n  const updateTimestamp = new Date();\n  \n  // Actualizar el evento con los nuevos datos convertidos\n  console.log(\"Updating event with ID:\", id, \"(type:\", typeof id, \") and data keys:\", Object.keys(dbData));\n  \n  // Ensure ID is a valid number\n  const eventId = parseInt(id.toString());\n  if (isNaN(eventId)) {\n    throw new Error(`Invalid event ID: ${id}`);\n  }\n  \n  try {\n    // Use Supabase client directly for update to avoid Drizzle issues\n    console.log(\"Attempting direct Supabase update for event:\", eventId);\n    \n    const { data, error } = await supabase\n      .from('events')\n      .update({\n        ...dbData,\n        updated_at: updateTimestamp.toISOString()\n      })\n      .eq('id', eventId)\n      .select()\n      .single();\n      \n    if (error) {\n      console.error(\"Supabase update error:\", error);\n      throw new Error(`Database update failed: ${error.message}`);\n    }\n    \n    if (!data) {\n      throw new Error(\"No event was updated - event may not exist\");\n    }\n    \n    console.log(\"Event updated successfully via Supabase\");\n    return data;\n  } catch (dbError: any) {\n    console.error(\"Database update failed:\", dbError);\n    throw new Error(`Failed to update event: ${dbError.message}`);\n  }\n};\n\nexport const deleteEvent = async (id: number) => {\n  try {\n    console.log(\"Deleting event:\", id);\n    \n    // First delete all attendees using Supabase\n    const { error: attendeesError } = await supabase\n      .from('event_attendees')\n      .delete()\n      .eq('event_id', id);\n    \n    if (attendeesError) {\n      console.error(\"Error deleting attendees:\", attendeesError);\n      throw new Error(`Failed to delete attendees: ${attendeesError.message}`);\n    }\n    \n    // Then delete the event using Supabase\n    const { data, error: eventError } = await supabase\n      .from('events')\n      .delete()\n      .eq('id', id)\n      .select()\n      .single();\n    \n    if (eventError) {\n      console.error(\"Error deleting event:\", eventError);\n      throw new Error(`Failed to delete event: ${eventError.message}`);\n    }\n    \n    console.log(\"Event deleted successfully:\", id);\n    return { id, deleted: true, data };\n  } catch (error) {\n    console.error(\"Error deleting event:\", error);\n    throw error;\n  }\n};\n\nexport const deleteAllEvents = async () => {\n  try {\n    // First delete all attendees\n    await db.delete(eventAttendees);\n    \n    // Then delete all events\n    await db.delete(events);\n    \n    console.log(\"All events and attendees deleted successfully\");\n    return { message: \"All events and attendees deleted successfully\" };\n  } catch (error) {\n    console.error(\"Error deleting all events:\", error);\n    throw error;\n  }\n};\n\n// Event Attendees related storage functions\nexport const joinEvent = async (attendee: InsertEventAttendee) => {\n  const [newAttendee] = await db.insert(eventAttendees).values(attendee).returning();\n  return newAttendee;\n};\n\nexport const leaveEvent = async (eventId: number, userId: number) => {\n  try {\n    console.log(\"🔄 leaveEvent: Starting removal process for:\", { eventId, userId });\n    \n    // Use Supabase client directly to avoid field mapping issues\n    const { error } = await supabase\n      .from('event_attendees')\n      .delete()\n      .eq('event_id', eventId)\n      .eq('user_id', userId);\n    \n    if (error) {\n      console.error(\"❌ Supabase delete error:\", error);\n      throw new Error(`Failed to remove attendee: ${error.message}`);\n    }\n    \n    console.log(\"✅ User left event successfully:\", { eventId, userId });\n    \n    return { eventId, userId, removed: true };\n  } catch (error) {\n    console.error(\"❌ Error removing attendee:\", error);\n    throw error;\n  }\n};\n\nexport const getEventAttendees = async (eventId: number) => {\n  return db.query.eventAttendees.findMany({\n    where: eq(eventAttendees.eventId, eventId),\n    with: {\n      user: true\n    }\n  });\n};\n\nexport const getEventAttendee = async (eventId: number, userId: number) => {\n  try {\n    // Use Supabase client directly to ensure consistency with delete operation\n    const { data, error } = await supabase\n      .from('event_attendees')\n      .select('*')\n      .eq('event_id', eventId)\n      .eq('user_id', userId)\n      .maybeSingle();\n    \n    if (error) {\n      console.error(\"❌ Error fetching attendee:\", error);\n      return null;\n    }\n    \n    return data;\n  } catch (error) {\n    console.error(\"❌ Exception in getEventAttendee:\", error);\n    return null;\n  }\n};\n\nexport const updateEventAttendee = async (id: number, attendeeData: Partial<EventAttendee>) => {\n  const [updatedAttendee] = await db\n    .update(eventAttendees)\n    .set(attendeeData)\n    .where(eq(eventAttendees.id, id))\n    .returning();\n  return updatedAttendee;\n};\n\nexport const insertEventAttendee = async (attendeeData: InsertEventAttendee) => {\n  try {\n    // Use Drizzle ORM instead of direct Supabase to avoid schema cache issues\n    const [newAttendee] = await db.insert(eventAttendees).values({\n      eventId: attendeeData.eventId,\n      userId: attendeeData.userId,\n      status: attendeeData.status || 'approved',\n      paymentStatus: attendeeData.paymentStatus || 'pending',\n      paymentIntentId: attendeeData.paymentIntentId || null,\n      applicationAnswers: attendeeData.applicationAnswers || null,\n    }).returning();\n    \n    return newAttendee;\n  } catch (error) {\n    console.error('Error in insertEventAttendee:', error);\n    // Fallback to direct Supabase insert with minimal fields if Drizzle fails\n    try {\n      const dbData = {\n        event_id: attendeeData.eventId,\n        user_id: attendeeData.userId,\n        status: attendeeData.status || 'approved',\n        payment_status: attendeeData.paymentStatus || 'pending',\n        payment_intent_id: attendeeData.paymentIntentId || null,\n        created_at: new Date().toISOString()\n      };\n\n      console.log('Fallback: Insert operation using minimal fields:', Object.keys(dbData));\n      \n      const { data: newAttendee, error } = await supabase\n        .from('event_attendees')\n        .insert([dbData])\n        .select()\n        .single();\n      \n      if (error) {\n        console.error('Fallback database insert error:', error);\n        throw error;\n      }\n      \n      return newAttendee;\n    } catch (fallbackError) {\n      console.error('Both Drizzle and Supabase insert failed:', fallbackError);\n      throw fallbackError;\n    }\n  }\n};\n\nexport const getEventAttendeeById = async (id: number) => {\n  return db.query.eventAttendees.findFirst({\n    where: eq(eventAttendees.id, id),\n    with: {\n      user: true,\n      event: true\n    }\n  });\n};\n\nexport const updatePaymentStatus = async (eventId: number, userId: number, paymentStatus: string, paymentIntentId: string) => {\n  const [updatedAttendee] = await db\n    .update(eventAttendees)\n    .set({ \n      paymentStatus,\n      paymentIntentId\n    })\n    .where(\n      and(\n        eq(eventAttendees.eventId, eventId),\n        eq(eventAttendees.userId, userId)\n      )\n    )\n    .returning();\n  return updatedAttendee;\n};\n\n// User Events\nexport const getUserCreatedEvents = async (userId: number) => {\n  const { data, error } = await supabase\n    .from('events')\n    .select('*, attendees:event_attendees(*)')\n    .eq('organizer_id', userId)\n    .order('date', { ascending: false });\n  \n  if (error) {\n    console.error('Error fetching user created events:', error);\n    throw error;\n  }\n  \n  return data || [];\n};\n\nexport const getUserAttendingEvents = async (userId: number) => {\n  const { data, error } = await supabase\n    .from('event_attendees')\n    .select('*, event:events(*, organizer:users(*))')\n    .eq('user_id', userId)\n    .order('created_at', { ascending: false });\n  \n  if (error) {\n    console.error('Error fetching user attending events:', error);\n    throw error;\n  }\n  \n  return data || [];\n};\n\n// User interests related storage functions\nexport const getUserInterests = async (userId: number) => {\n  return db.query.userInterests.findMany({\n    where: eq(userInterests.userId, userId),\n    orderBy: desc(userInterests.createdAt)\n  });\n};\n\nexport const addUserInterest = async (userId: number, category: string) => {\n  // Use direct Supabase client instead of problematic Drizzle wrapper\n  const { data, error } = await supabase\n    .from('user_interests')\n    .insert({\n      user_id: userId,\n      category: category,\n      created_at: new Date().toISOString()\n    })\n    .select()\n    .single();\n    \n  if (error) {\n    console.error('Error adding user interest:', error);\n    throw error;\n  }\n  \n  return data;\n};\n\nexport const removeUserInterest = async (interestId: number) => {\n  await db.delete(userInterests).where(eq(userInterests.id, interestId));\n};\n\n// Private event access control functions\nexport const getPendingEventRequests = async (eventId: number) => {\n  try {\n    console.log(`📋 Fetching pending requests for event ${eventId}`);\n    \n    const { data, error } = await supabase\n      .from('event_attendees')\n      .select(`\n        *,\n        user:users(id, name, username, email, avatar),\n        event:events(id, title, date, privacy_type, private_access_type)\n      `)\n      .eq('event_id', eventId)\n      .eq('status', 'pending')\n      .order('created_at', { ascending: false });\n    \n    if (error) {\n      console.error(\"Error fetching pending requests:\", error);\n      throw error;\n    }\n    \n    console.log(`📋 Found ${data?.length || 0} pending requests for event ${eventId}`);\n    return data || [];\n  } catch (error) {\n    console.error(\"Exception in getPendingEventRequests:\", error);\n    throw error;\n  }\n};\n\n// Get all pending requests for events organized by the user\nexport const getAllPendingRequestsForUser = async (organizerId: number) => {\n  try {\n    console.log(`📋 Fetching all pending requests for organizer ${organizerId}`);\n    \n    // First get all events organized by this user\n    const { data: userEvents, error: eventsError } = await supabase\n      .from('events')\n      .select('id, title, date')\n      .eq('organizer_id', organizerId);\n    \n    if (eventsError) {\n      console.error(\"Error fetching user events:\", eventsError);\n      throw eventsError;\n    }\n    \n    if (!userEvents || userEvents.length === 0) {\n      console.log(`📋 No events found for organizer ${organizerId}`);\n      return [];\n    }\n    \n    const eventIds = userEvents.map(event => event.id);\n    console.log(`📋 Found ${eventIds.length} events for organizer: ${eventIds.join(', ')}`);\n    \n    // Get all pending attendees for these events\n    const { data: attendees, error } = await supabase\n      .from('event_attendees')\n      .select('*')\n      .in('event_id', eventIds)\n      .eq('status', 'pending')\n      .order('created_at', { ascending: false });\n    \n    if (error) {\n      console.error(\"Error fetching pending requests:\", error);\n      throw error;\n    }\n    \n    if (!attendees || attendees.length === 0) {\n      console.log(`📋 No pending requests found for organizer ${organizerId}`);\n      return [];\n    }\n    \n    // Get user details for each attendee\n    const userIds = Array.from(new Set(attendees.map(a => a.user_id)));\n    const { data: users, error: usersError } = await supabase\n      .from('users')\n      .select('id, name, email, avatar')\n      .in('id', userIds);\n    \n    if (usersError) {\n      console.error(\"Error fetching user details:\", usersError);\n      throw usersError;\n    }\n    \n    // Combine the data\n    const result = attendees.map(attendee => {\n      const event = userEvents.find(e => e.id === attendee.event_id);\n      const user = users?.find(u => u.id === attendee.user_id);\n      \n      return {\n        ...attendee,\n        event,\n        user\n      };\n    });\n    \n    console.log(`📋 Found ${result.length} total pending requests for organizer ${organizerId}`);\n    return result;\n  } catch (error) {\n    console.error(\"Exception in getAllPendingRequestsForUser:\", error);\n    throw error;\n  }\n};\n\nexport const approveEventAttendee = async (eventId: number, userId: number) => {\n  try {\n    console.log(`✅ Approving attendee ${userId} for event ${eventId}`);\n    \n    const { data, error } = await supabase\n      .from('event_attendees')\n      .update({ \n        status: 'approved',\n        payment_status: 'completed'\n      })\n      .eq('event_id', eventId)\n      .eq('user_id', userId)\n      .select()\n      .single();\n    \n    if (error) {\n      console.error(\"Error approving attendee:\", error);\n      throw error;\n    }\n    \n    if (data) {\n      console.log(`✅ Successfully approved attendee ${userId} for event ${eventId}`);\n      return data;\n    }\n    \n    return null;\n  } catch (error) {\n    console.error(\"Exception in approveEventAttendee:\", error);\n    throw error;\n  }\n};\n\nexport const rejectEventAttendee = async (eventId: number, userId: number) => {\n  try {\n    console.log(`❌ Rejecting attendee ${userId} for event ${eventId}`);\n    \n    // For rejected requests, we remove the record entirely instead of setting status to 'rejected'\n    const { error } = await supabase\n      .from('event_attendees')\n      .delete()\n      .eq('event_id', eventId)\n      .eq('user_id', userId);\n    \n    if (error) {\n      console.error(\"Error rejecting attendee:\", error);\n      throw error;\n    }\n    \n    console.log(`❌ Successfully rejected attendee ${userId} for event ${eventId}`);\n    return true;\n  } catch (error) {\n    console.error(\"Exception in rejectEventAttendee:\", error);\n    throw error;\n  }\n};\n\n// Notification functions\nexport const createNotification = async (notificationData: {\n  userId: number;\n  type: 'request_approved' | 'request_rejected' | 'new_request';\n  title: string;\n  message: string;\n  eventId?: number;\n  requestId?: number;\n}) => {\n  try {\n    const [newNotification] = await db.insert(notifications).values({\n      userId: notificationData.userId,\n      type: notificationData.type,\n      title: notificationData.title,\n      message: notificationData.message,\n      eventId: notificationData.eventId || null,\n      requestId: notificationData.requestId || null,\n    }).returning();\n    \n    return newNotification;\n  } catch (error) {\n    console.error('Error creating notification:', error);\n    throw error;\n  }\n};\n\nexport const storage = {\n  getUserById,\n  getUserByEmail,\n  getUserByUsername,\n  getUserBySupabaseId,\n  insertUser,\n  updateUser,\n  updateStripeCustomerId,\n  updateUserStripeInfo,\n  getEventById,\n  getEvents,\n  getNearbyEvents,\n  insertEvent,\n  updateEvent,\n  deleteEvent,\n  deleteAllEvents,\n  joinEvent,\n  leaveEvent,\n  getEventAttendees,\n  getEventAttendee,\n  insertEventAttendee,\n  getEventAttendeeById,\n  updateEventAttendee,\n  updatePaymentStatus,\n  getUserCreatedEvents,\n  getUserAttendingEvents,\n  getUserInterests,\n  addUserInterest,\n  removeUserInterest,\n  getPendingEventRequests,\n  approveEventAttendee,\n  rejectEventAttendee,\n  createNotification\n};\n","size_bytes":35373},"server/supabase-auth.ts":{"content":"import { supabase } from './supabase-client';\nimport { Request, Response, NextFunction } from 'express';\nimport { storage } from './storage';\nimport { getSession } from './session-auth';\nimport { users } from '@shared/schema';\n\n// Extend Express Request to include user and session\ndeclare global {\n  namespace Express {\n    interface Request {\n      user?: {\n        id: number;\n        username: string;\n        email: string;\n        name: string;\n        bio: string | null;\n        avatar: string | null;\n        supabaseId: string | null;\n        stripeCustomerId: string | null;\n        stripeSubscriptionId: string | null;\n        createdAt: Date;\n        updatedAt: Date;\n      };\n    }\n    interface Session {\n      userId?: string;\n      supabaseUserId?: string;\n      authenticated?: boolean;\n      userEmail?: string;\n    }\n    interface SessionData {\n      userId?: string;\n      supabaseUserId?: string;\n      authenticated?: boolean;\n      userEmail?: string;\n    }\n  }\n}\n\n/**\n * Middleware to check if the user is authenticated\n * Uses session-based authentication with token fallback\n */\nexport async function isAuthenticatedMiddleware(req: Request, res: Response, next: NextFunction) {\n  try {\n    // Check if user is already authenticated via the auth middleware\n    if (req.user) {\n      return next();\n    }\n\n    // Check express session-based authentication (passport style)\n    if ((req as any).session && (req as any).session.passport && (req as any).session.passport.user) {\n      try {\n        const userId = (req as any).session.passport.user;\n        // Temporarily skip database user lookup\n        req.user = {\n          id: userId,\n          email: 'user@example.com',\n          username: 'user',\n          name: 'User',\n          bio: null,\n          avatar: null,\n          supabaseId: null,\n          stripeCustomerId: null,\n          stripeSubscriptionId: null,\n          createdAt: new Date(),\n          updatedAt: new Date()\n        };\n        console.log(`Session auth successful for user ${userId}`);\n        return next();\n      } catch (sessionError) {\n        console.log('Session auth failed:', sessionError);\n      }\n    }\n\n    // Check for session ID in cookies and find matching session\n    if (req.cookies && req.cookies['connect.sid']) {\n      try {\n        // Session middleware should have already populated req.session\n        // Let's check if there's session data available\n        console.log('Checking session data:', {\n          sessionExists: !!req.session,\n          sessionId: req.sessionID,\n          cookieExists: !!req.cookies['connect.sid'],\n          passportSession: !!(req as any).session?.passport,\n          passportUser: (req as any).session?.passport?.user,\n          authenticated: (req.session as any)?.authenticated,\n          userEmail: (req.session as any)?.userEmail,\n          userId: (req.session as any)?.userId\n        });\n        \n        // If session exists but no passport data, check if we stored user info directly\n        if (req.session && (req.session as any).userId) {\n          const userId = (req.session as any).userId;\n          const user = await storage.getUserById(parseInt(userId));\n          if (user) {\n            req.user = user;\n            console.log(`✅ Direct session auth successful for user ${user.id} (${user.email})`);\n            return next();\n          }\n        }\n        \n        // Check for authenticated session flag\n        if (req.session && (req.session as any).authenticated && (req.session as any).userEmail) {\n          const user = await storage.getUserByEmail((req.session as any).userEmail);\n          if (user) {\n            req.user = user;\n            console.log(`✅ Session email auth successful for user ${user.id} (${user.email})`);\n            return next();\n          }\n        }\n      } catch (sessionError) {\n        console.log('Cookie session check failed:', sessionError);\n      }\n    }\n\n    // Check cookie-based session\n    const sessionCookie = req.cookies?.pipol_session;\n    if (sessionCookie) {\n      const session = getSession(sessionCookie);\n      if (session) {\n        const sessionUser = await storage.getUserByEmail(session.email);\n        if (sessionUser) {\n          req.user = sessionUser;\n          return next();\n        }\n      }\n    }\n\n    // Then check express session-based authentication\n    if (req.session && (req.session as any).authenticated && (req.session as any).userEmail) {\n      const user = await storage.getUserByEmail((req.session as any).userEmail);\n      if (user) {\n        req.user = user;\n        return next();\n      }\n    }\n    \n    // Fall back to token-based authentication\n    const authHeader = req.headers.authorization;\n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      return res.status(401).json({ message: 'Authentication required' });\n    }\n    \n    const token = authHeader.split(' ')[1];\n    \n    // Verify token\n    const { data, error } = await supabase.auth.getUser(token);\n    \n    if (error || !data.user) {\n      console.error('Auth error:', error);\n      return res.status(401).json({ message: 'Authentication required' });\n    }\n    \n    // Get the user from the database\n    const user = await storage.getUserByEmail(data.user.email || '');\n    if (!user) {\n      return res.status(401).json({ message: 'User not found' });\n    }\n    \n    // Store in session for future requests\n    if (req.session) {\n      (req.session as any).authenticated = true;\n      (req.session as any).userEmail = user.email;\n      (req.session as any).userId = user.id.toString();\n      (req.session as any).supabaseUserId = data.user.id;\n    }\n    \n    // Set user on request object\n    req.user = user;\n    \n    next();\n  } catch (err) {\n    console.error('Error in auth middleware:', err);\n    return res.status(401).json({ message: 'Authentication required' });\n  }\n}\n\n/**\n * Register a new user\n */\nexport async function registerUser(email: string, password: string | null, username: string, name: string) {\n  try {\n    // Create user in Supabase Auth\n    // Ensure we have a valid password\n    if (!password) {\n      throw new Error(\"Password is required\");\n    }\n\n    const { data: authData, error: authError } = await supabase.auth.signUp({\n      email,\n      password,\n    });\n    \n    if (authError) {\n      console.error('Error creating user in Supabase Auth:', authError);\n      throw new Error(authError.message);\n    }\n    \n    if (!authData.user) {\n      throw new Error('Failed to create user');\n    }\n    \n    // Create user in our database\n    const newUser = await storage.insertUser({\n      email,\n      username,\n      password: 'supabase-auth', // We don't store passwords anymore\n      name,\n      supabaseId: authData.user.id,\n    });\n    \n    return newUser;\n  } catch (error) {\n    console.error('Error in registerUser:', error);\n    throw error;\n  }\n}\n\n/**\n * Login a user\n */\nexport async function loginUser(email: string, password: string | null) {\n  try {\n    // Ensure we have a valid password\n    if (!password) {\n      throw new Error(\"Password is required\");\n    }\n    \n    // Login with Supabase Auth\n    const { data, error } = await supabase.auth.signInWithPassword({\n      email,\n      password,\n    });\n    \n    if (error) {\n      console.error('Error logging in with Supabase Auth:', error);\n      throw new Error(error.message);\n    }\n    \n    if (!data.user) {\n      throw new Error('Failed to login');\n    }\n    \n    // Get user from database\n    const user = await storage.getUserByEmail(email);\n    if (!user) {\n      throw new Error('User not found in database');\n    }\n    \n    return {\n      user,\n      session: data.session,\n    };\n  } catch (error) {\n    console.error('Error in loginUser:', error);\n    throw error;\n  }\n}\n\n/**\n * Logout a user\n */\nexport async function logoutUser(token: string) {\n  try {\n    const { error } = await supabase.auth.signOut({\n      scope: 'local'\n    });\n    \n    if (error) {\n      console.error('Error logging out with Supabase Auth:', error);\n      throw new Error(error.message);\n    }\n    \n    return true;\n  } catch (error) {\n    console.error('Error in logoutUser:', error);\n    throw error;\n  }\n}\n\n/**\n * Get the current user\n */\nexport async function getCurrentUser(token: string) {\n  try {\n    const { data, error } = await supabase.auth.getUser(token);\n    \n    if (error || !data.user) {\n      return null;\n    }\n    \n    // Get user from database\n    const user = await storage.getUserByEmail(data.user.email || '');\n    return user;\n  } catch (error) {\n    console.error('Error in getCurrentUser:', error);\n    return null;\n  }\n}","size_bytes":8628},"server/supabase-client.ts":{"content":"import { createClient } from '@supabase/supabase-js';\nimport dotenv from 'dotenv';\n\n// Load environment variables\ndotenv.config();\n\n// Use VITE_ prefixed environment variables that were provided\nconst supabaseUrl = process.env.VITE_SUPABASE_URL;\nconst supabaseAnonKey = process.env.VITE_SUPABASE_ANON_KEY;\n// For server-side operations, use the service role key for privileged operations\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\nif (!supabaseUrl || !supabaseAnonKey || !supabaseServiceKey) {\n  console.error('Environment variables check:');\n  console.error('VITE_SUPABASE_URL:', supabaseUrl ? 'Present' : 'Missing');\n  console.error('VITE_SUPABASE_ANON_KEY:', supabaseAnonKey ? 'Present' : 'Missing');\n  console.error('SUPABASE_SERVICE_ROLE_KEY:', supabaseServiceKey ? 'Present' : 'Missing');\n  throw new Error('Missing Supabase environment variables. Check VITE_SUPABASE_URL, VITE_SUPABASE_ANON_KEY, and SUPABASE_SERVICE_ROLE_KEY');\n}\n\nconsole.log('🔗 Connecting to Supabase...');\n\n// Client for public operations (can be used for auth, etc.)\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey);\n\n// Service client for server-side privileged operations (bypasses RLS)\nexport const supabaseService = createClient(supabaseUrl, supabaseServiceKey, {\n  auth: {\n    autoRefreshToken: false,\n    persistSession: false\n  }\n});\n\nexport const testSupabaseConnection = async () => {\n  try {\n    // Test service client with a simple auth check\n    const { data, error } = await supabaseService.auth.getSession();\n    \n    if (error && error.message.includes('session')) {\n      // Session error is expected for service client, means connection is working\n      console.log('✅ Supabase connection successful');\n      return true;\n    }\n    \n    // If no error, connection is also working\n    console.log('✅ Supabase connection successful');\n    return true;\n  } catch (error) {\n    console.error('❌ Supabase connection error:', error);\n    return false;\n  }\n};","size_bytes":1998},"server/supabase-realtime.ts":{"content":"import { createServer, Server as HttpServer } from 'http';\nimport { WebSocketServer, WebSocket } from 'ws';\nimport { supabase } from './supabase-client';\nimport { storage } from './storage';\nimport crypto from 'crypto';\n\ninterface ChatClient {\n  ws: WebSocket;\n  userId: number;\n  userName: string;\n}\n\n/**\n * Sets up a WebSocket server with Supabase Realtime integration\n * \n * This implementation bridges traditional WebSockets with Supabase Realtime\n * for backward compatibility during the migration\n */\nexport function setupRealtimeWS(server: HttpServer): WebSocketServer {\n  // Set up WebSocket server for client connections\n  const wss = new WebSocketServer({ \n    server, \n    path: '/ws' \n  });\n  \n  // Track active connections\n  const clients = new Map<string, ChatClient>();\n  \n  // Subscribe to Supabase realtime and forward events to WebSocket clients\n  setupSupabaseRealtimeSubscription(clients);\n  \n  // Handle WebSocket connections\n  wss.on('connection', (ws, req) => {\n    console.log('WebSocket connection established');\n    \n    // Generate client ID\n    const clientId = crypto.randomUUID();\n    \n    // Handle messages from clients\n    ws.on('message', async (message) => {\n      try {\n        const data = JSON.parse(message.toString());\n        \n        // Handle authentication\n        if (data.type === 'auth') {\n          const { userId, userName } = data;\n          clients.set(clientId, { ws, userId, userName });\n          console.log(`Client authenticated: ${userName} (${userId})`);\n          \n          // Send confirmation to the client\n          ws.send(JSON.stringify({\n            type: 'auth_success',\n            userId,\n            userName\n          }));\n          \n          return;\n        }\n        \n        // Handle chat messages - only logged in users\n        if (data.type === 'message' && clients.has(clientId)) {\n          const { eventId, content } = data;\n          const sender = clients.get(clientId)!;\n          \n          // Validate data\n          if (!eventId || !content || content.trim() === '') {\n            return;\n          }\n          \n          // Create message payload\n          const messageData = {\n            type: 'chat',\n            eventId,\n            message: content,\n            sender: {\n              id: sender.userId,\n              name: sender.userName\n            },\n            timestamp: new Date().toISOString()\n          };\n          \n          // Insert message into Supabase\n          try {\n            const { data, error } = await supabase\n              .from('event_messages')\n              .insert({\n                event_id: eventId,\n                sender_id: sender.userId,\n                sender_name: sender.userName,\n                content: content,\n                created_at: new Date().toISOString()\n              });\n              \n            if (error) {\n              console.error('Error inserting message into Supabase:', error);\n            }\n            \n            // Broadcast to all clients\n            // Supabase will trigger a realtime update that will be caught by the subscription\n            broadcastMessage(clients, messageData);\n          } catch (error) {\n            console.error('Error processing chat message:', error);\n          }\n        }\n      } catch (error) {\n        console.error('Error processing WebSocket message:', error);\n      }\n    });\n    \n    // Handle disconnection\n    ws.on('close', () => {\n      console.log('WebSocket connection closed');\n      clients.delete(clientId);\n    });\n  });\n  \n  console.log('WebSocket server initialized with Supabase Realtime integration');\n  return wss;\n}\n\n/**\n * Set up a Supabase Realtime subscription for chat messages\n */\nfunction setupSupabaseRealtimeSubscription(clients: Map<string, ChatClient>) {\n  // Subscribe to chat messages from the event_messages table\n  try {\n    supabase\n      .channel('event_messages')\n      .on('postgres_changes', { \n        event: 'INSERT', \n        schema: 'public', \n        table: 'event_messages' \n      }, (payload) => {\n        console.log('Received realtime message from Supabase:', payload);\n        \n        // Forward the message to WebSocket clients\n        const message = {\n          type: 'chat',\n          eventId: payload.new.event_id,\n          message: payload.new.content,\n          sender: {\n            id: payload.new.sender_id,\n            name: payload.new.sender_name\n          },\n          timestamp: payload.new.created_at\n        };\n        \n        broadcastMessage(clients, message);\n      })\n      .subscribe((status) => {\n        console.log('Supabase realtime subscription status:', status);\n      });\n      \n    console.log('Supabase realtime subscription initialized');\n  } catch (error) {\n    console.error('Error setting up Supabase realtime subscription:', error);\n  }\n}\n\n/**\n * Broadcast a message to all connected WebSocket clients\n */\nfunction broadcastMessage(clients: Map<string, ChatClient>, data: any) {\n  const message = JSON.stringify(data);\n  \n  clients.forEach(({ ws }) => {\n    if (ws.readyState === WebSocket.OPEN) {\n      ws.send(message);\n    }\n  });\n  \n  console.log(`Broadcasted ${data.type} message to ${clients.size} clients`);\n}","size_bytes":5205},"server/supabase-routes.ts":{"content":"import { Router, Request, Response } from 'express';\nimport { supabase } from './supabase-client';\nimport { storage } from './storage';\nimport { isAuthenticatedMiddleware as requireAuth } from './supabase-auth';\nimport { createSession, destroySession } from './session-auth';\nimport { z } from 'zod';\nimport { loginUserSchema, insertUserSchema } from '@shared/schema';\nimport multer from 'multer';\nimport path from 'path';\nimport fs from 'fs';\n\nconst router = Router();\n\n// Register endpoint\nrouter.post('/register', async (req: Request, res: Response) => {\n  try {\n    const { email, password, username, name } = req.body;\n    \n    // Basic validation\n    if (!email || !password) {\n      return res.status(400).json({ message: 'Email and password are required' });\n    }\n\n    // Supabase will handle email uniqueness, skip database checks for now\n\n    // Create user in Supabase\n    const { data: authData, error: authError } = await supabase.auth.signUp({\n      email,\n      password,\n    });\n\n    if (authError) {\n      console.error('Supabase auth error during registration:', authError);\n      return res.status(400).json({ message: authError.message });\n    }\n\n    if (!authData.user) {\n      return res.status(500).json({ message: 'Failed to create user in Supabase' });\n    }\n\n    // Create user in our database with Supabase ID\n    const { data: dbUser, error: dbError } = await supabase\n      .from('users')\n      .insert([{\n        email: authData.user.email || email,\n        username: username,\n        name: name,\n        supabase_id: authData.user.id,\n        password: null, // Not needed for Supabase auth\n        bio: null,\n        avatar: null,\n        stripe_customer_id: null,\n        stripe_subscription_id: null\n      }])\n      .select()\n      .single();\n\n    if (dbError) {\n      console.error('Database user creation error:', dbError);\n      // Continue with Supabase user data even if DB insert fails\n    }\n\n    const newUser = dbUser || {\n      id: parseInt(authData.user.id.slice(-8), 16) % 100000,\n      email: authData.user.email || email,\n      username: username,\n      name: name,\n      supabaseId: authData.user.id,\n    };\n\n    // Return user data and session\n    return res.status(201).json({\n      message: 'Registration successful',\n      user: {\n        id: newUser.id,\n        email: newUser.email,\n        username: newUser.username,\n        name: newUser.name,\n      },\n      session: authData.session\n    });\n  } catch (error) {\n    console.error('Error during registration:', error);\n    return res.status(500).json({ message: 'Internal server error' });\n  }\n});\n\n// Login endpoint\nrouter.post('/login', async (req: Request, res: Response) => {\n  try {\n    const { email, password } = req.body;\n\n    if (!email || !password) {\n      return res.status(400).json({ message: 'Email and password are required' });\n    }\n\n    // Sign in with Supabase\n    const { data, error } = await supabase.auth.signInWithPassword({\n      email,\n      password\n    });\n\n    if (error) {\n      console.error('Supabase auth error during login:', error);\n      return res.status(401).json({ message: 'Invalid credentials' });\n    }\n\n    if (!data.session || !data.user) {\n      return res.status(401).json({ message: 'Authentication failed' });\n    }\n\n    // Try to get user from our database first\n    const { data: dbUser } = await supabase\n      .from('users')\n      .select('*')\n      .eq('supabase_id', data.user.id)\n      .single();\n\n    const user = dbUser || {\n      id: parseInt(data.user.id.slice(-8), 16) % 100000,\n      email: data.user.email || email,\n      username: email.split('@')[0],\n      name: email.split('@')[0],\n      supabaseId: data.user.id,\n    };\n\n    // Create a session with simplified user data\n    const sessionId = createSession(user.id, user.email);\n    \n    // Set session cookie that persists until manual logout\n    res.cookie('pipol_session', sessionId, {\n      httpOnly: true,\n      secure: false, // Set to true in production with HTTPS\n      // No maxAge set - persists until manual logout\n      sameSite: 'lax'\n    });\n\n    // IMPORTANT: Set the Express session data so authentication works for subsequent requests\n    if (req.session) {\n      (req.session as any).authenticated = true;\n      (req.session as any).userEmail = user.email;\n      (req.session as any).userId = user.id.toString();\n      (req.session as any).supabaseUserId = data.user.id;\n      (req.session as any).passport = { user: user.id }; // For compatibility with passport middleware\n    }\n\n    // Return user data and token\n    return res.status(200).json({\n      message: 'Login successful',\n      user: {\n        id: user.id,\n        email: user.email,\n        username: user.username,\n        name: user.name,\n      },\n      token: data.session.access_token,\n      refreshToken: data.session.refresh_token,\n      sessionId: sessionId\n    });\n  } catch (error) {\n    console.error('Error during login:', error);\n    return res.status(500).json({ message: 'Internal server error' });\n  }\n});\n\n// Logout endpoint\nrouter.post('/logout', async (req: Request, res: Response) => {\n  try {\n    // Clear session cookie\n    const sessionCookie = req.cookies?.pipol_session;\n    if (sessionCookie) {\n      destroySession(sessionCookie);\n      res.clearCookie('pipol_session');\n    }\n\n    // Clear express session\n    if (req.session) {\n      req.session.destroy((err) => {\n        if (err) {\n          console.error('Error destroying session:', err);\n        }\n      });\n    }\n\n    const { error } = await supabase.auth.signOut();\n    \n    if (error) {\n      console.error('Error during Supabase logout:', error);\n      return res.status(500).json({ message: error.message });\n    }\n    \n    return res.status(200).json({ message: 'Logged out successfully' });\n  } catch (error) {\n    console.error('Error during logout:', error);\n    return res.status(500).json({ message: 'Internal server error' });\n  }\n});\n\n// Get current user endpoint - using token authentication\nrouter.get('/me', async (req: Request, res: Response) => {\n  try {\n    // Check Authorization header for Bearer token\n    const authHeader = req.headers.authorization;\n    if (authHeader && authHeader.startsWith('Bearer ')) {\n      const token = authHeader.substring(7);\n      \n      // Verify token with Supabase\n      const { data: { user }, error } = await supabase.auth.getUser(token);\n      \n      if (!error && user) {\n        // Try to get user from database\n        const { data: dbUser } = await supabase\n          .from('users')\n          .select('*')\n          .eq('supabase_id', user.id)\n          .single();\n        \n        if (dbUser) {\n          return res.status(200).json({\n            id: dbUser.id,\n            email: dbUser.email,\n            username: dbUser.username,\n            name: dbUser.name,\n            bio: dbUser.bio,\n            avatar: dbUser.avatar\n          });\n        }\n        \n        // Return basic user info if not in database\n        return res.status(200).json({\n          id: parseInt(user.id.slice(-8), 16) % 100000,\n          email: user.email,\n          username: user.email?.split('@')[0] || 'user',\n          name: user.email?.split('@')[0] || 'User',\n          bio: null,\n          avatar: null\n        });\n      }\n    }\n    \n    // Check session-based auth as fallback\n    if (req.session && (req.session as any).authenticated && (req.session as any).userId) {\n      const userId = (req.session as any).userId;\n      const { data: dbUser } = await supabase\n        .from('users')\n        .select('*')\n        .eq('id', userId)\n        .single();\n      \n      if (dbUser) {\n        return res.status(200).json({\n          id: dbUser.id,\n          email: dbUser.email,\n          username: dbUser.username,\n          name: dbUser.name,\n          bio: dbUser.bio,\n          avatar: dbUser.avatar\n        });\n      }\n    }\n    \n    return res.status(401).json({ message: 'Authentication required' });\n  } catch (error) {\n    console.error('Error getting current user:', error);\n    return res.status(500).json({ message: 'Internal server error' });\n  }\n});\n\n\n\nconst profileStorage = multer.diskStorage({\n  destination: function (req, file, cb) {\n    const uploadPath = 'public/uploads/profiles';\n    \n    // Ensure directory exists\n    if (!fs.existsSync(uploadPath)) {\n      fs.mkdirSync(uploadPath, { recursive: true });\n    }\n    \n    cb(null, uploadPath);\n  },\n  filename: function (req, file, cb) {\n    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\n    const extension = path.extname(file.originalname);\n    cb(null, 'profile-' + uniqueSuffix + extension);\n  }\n});\n\nconst profileUpload = multer({ \n  storage: profileStorage,\n  fileFilter: (req, file, cb) => {\n    // Only allow images for profile pictures\n    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];\n    if (allowedTypes.includes(file.mimetype)) {\n      cb(null, true);\n    } else {\n      cb(new Error('Only image files are allowed for profile pictures'));\n    }\n  },\n  limits: {\n    fileSize: 5 * 1024 * 1024 // 5MB limit\n  }\n});\n\n// Update user profile endpoint (with image support)\nrouter.put('/update', requireAuth, profileUpload.single('profileImage'), async (req: Request, res: Response) => {\n  try {\n    if (!req.user) {\n      return res.status(401).json({ message: 'Not authenticated' });\n    }\n\n    const updateData = req.body;\n    const userId = req.user.id;\n\n    // Fix gender mapping from frontend values to database values\n    if (updateData.gender) {\n      const genderMapping: { [key: string]: string } = {\n        'masculino': 'hombre',\n        'femenino': 'mujer',\n        'hombre': 'hombre', // already correct\n        'mujer': 'mujer', // already correct\n        'otro': 'otro',\n        'no_especificar': 'no_especificar'\n      };\n      updateData.gender = genderMapping[updateData.gender] || updateData.gender;\n    }\n\n    // Handle profile image upload\n    if (req.file) {\n      // Create the URL for the uploaded file\n      const imageUrl = `/uploads/profiles/${req.file.filename}`;\n      updateData.avatar = imageUrl;\n      \n      // Clean up old profile image if it exists\n      const existingUser = await storage.getUserById(userId);\n      if (existingUser?.avatar && existingUser.avatar !== imageUrl) {\n        const oldImagePath = path.join('public', existingUser.avatar);\n        if (fs.existsSync(oldImagePath)) {\n          fs.unlinkSync(oldImagePath);\n        }\n      }\n    }\n\n    // Update user in database\n    const updatedUser = await storage.updateUser(userId, updateData);\n    \n    if (!updatedUser) {\n      return res.status(404).json({ message: 'User not found' });\n    }\n\n    return res.status(200).json(updatedUser);\n  } catch (error) {\n    console.error('Error updating user:', error);\n    if (error instanceof multer.MulterError) {\n      return res.status(400).json({ message: 'File upload error: ' + error.message });\n    }\n    return res.status(500).json({ message: 'Internal server error' });\n  }\n});\n\n// Update user profile endpoint (original, for non-file updates)\nrouter.put('/me', requireAuth, async (req: Request, res: Response) => {\n  try {\n    if (!req.user) {\n      return res.status(401).json({ message: 'Not authenticated' });\n    }\n\n    const updateData = req.body;\n    const userId = req.user.id;\n\n    // Fix gender mapping from frontend values to database values\n    if (updateData.gender) {\n      const genderMapping: { [key: string]: string } = {\n        'masculino': 'hombre',\n        'femenino': 'mujer',\n        'hombre': 'hombre', // already correct\n        'mujer': 'mujer', // already correct\n        'otro': 'otro',\n        'no_especificar': 'no_especificar'\n      };\n      updateData.gender = genderMapping[updateData.gender] || updateData.gender;\n    }\n\n    // Update user in database\n    const updatedUser = await storage.updateUser(userId, updateData);\n    \n    if (!updatedUser) {\n      return res.status(404).json({ message: 'User not found' });\n    }\n\n    return res.status(200).json(updatedUser);\n  } catch (error) {\n    console.error('Error updating user:', error);\n    return res.status(500).json({ message: 'Internal server error' });\n  }\n});\n\n// Refresh token endpoint\nrouter.post('/refresh', async (req: Request, res: Response) => {\n  try {\n    const { refreshToken } = req.body;\n    \n    if (!refreshToken) {\n      return res.status(400).json({ message: 'Refresh token is required' });\n    }\n    \n    const { data, error } = await supabase.auth.refreshSession({\n      refresh_token: refreshToken,\n    });\n    \n    if (error) {\n      console.error('Error refreshing token:', error);\n      return res.status(401).json({ message: 'Invalid refresh token' });\n    }\n    \n    if (!data.session) {\n      return res.status(401).json({ message: 'Failed to refresh session' });\n    }\n    \n    return res.status(200).json({\n      token: data.session.access_token,\n      refreshToken: data.session.refresh_token\n    });\n  } catch (error) {\n    console.error('Error refreshing token:', error);\n    return res.status(500).json({ message: 'Internal server error' });\n  }\n});\n\nexport const supabaseRoutes = router;","size_bytes":13142},"server/supabase-storage.ts":{"content":"import { supabase } from './supabase-client';\nimport fs from 'fs';\nimport path from 'path';\nimport { v4 as uuidv4 } from 'uuid';\n\n// Storage bucket name\nconst BUCKET_NAME = 'event-media';\n\n// Check if bucket exists or can be created\nlet bucketAvailable = false;\n\n/**\n * Initialize the Supabase storage service\n * This attempts to check/create the storage bucket\n */\nexport async function initializeStorage() {\n  console.log('Setting up Supabase Storage...');\n  \n  try {\n    // Check if the bucket already exists\n    console.log('Checking for existing storage buckets...');\n    const { data: buckets, error: bucketsError } = await supabase.storage.listBuckets();\n    \n    if (bucketsError) {\n      console.error('Error checking storage buckets:', bucketsError);\n      return;\n    }\n    \n    // Check if our bucket exists\n    const mediaBucket = buckets?.find(bucket => bucket.name === BUCKET_NAME);\n    \n    if (mediaBucket) {\n      console.log(`Media bucket \"${BUCKET_NAME}\" already exists`);\n      bucketAvailable = true;\n      return;\n    }\n    \n    console.log(`Media bucket does not exist, attempting to create it...`);\n    \n    // Try to create the bucket\n    const { error: createError } = await supabase.storage.createBucket(BUCKET_NAME, {\n      public: true,\n      fileSizeLimit: 10485760, // 10MB\n    });\n    \n    if (createError) {\n      console.error('Permission denied when creating bucket. This is normal if using the free tier.');\n      console.log('Please create a bucket named \"event-media\" manually in the Supabase dashboard.');\n      console.log('Storage operations will be simulated until the bucket is created.');\n      return;\n    }\n    \n    console.log(`Successfully created \"${BUCKET_NAME}\" bucket`);\n    bucketAvailable = true;\n  } catch (error) {\n    console.error('Error initializing storage:', error);\n  }\n}\n\n/**\n * Upload a file to Supabase Storage\n * \n * @param file The file to upload (path to local file)\n * @param folder The folder to upload to (optional)\n * @returns URL of the uploaded file\n */\nexport async function uploadFile(filePath: string, folder: string = ''): Promise<string> {\n  try {\n    if (!bucketAvailable) {\n      // Simulate upload if bucket is not available\n      console.log(`Simulating upload of ${filePath} to ${folder}`);\n      const fileName = path.basename(filePath);\n      const fileExtension = path.extname(fileName);\n      const uniqueFileName = `${uuidv4()}${fileExtension}`;\n      const storagePath = folder ? `${folder}/${uniqueFileName}` : uniqueFileName;\n      \n      // Generate a simulated URL\n      const simulatedUrl = `https://ngljgvnzkjqzhgkaukvu.supabase.co/storage/v1/object/public/${BUCKET_NAME}/${storagePath}`;\n      console.log(`Simulated upload URL: ${simulatedUrl}`);\n      return simulatedUrl;\n    }\n    \n    // Read the file content\n    const fileContent = fs.readFileSync(filePath);\n    const fileName = path.basename(filePath);\n    const fileExtension = path.extname(fileName);\n    \n    // Generate a unique file name\n    const uniqueFileName = `${uuidv4()}${fileExtension}`;\n    const storagePath = folder ? `${folder}/${uniqueFileName}` : uniqueFileName;\n    \n    // Upload to Supabase Storage\n    const { data, error } = await supabase.storage\n      .from(BUCKET_NAME)\n      .upload(storagePath, fileContent, {\n        contentType: getContentType(fileExtension),\n        upsert: false\n      });\n    \n    if (error) {\n      console.error('Error uploading file to Supabase Storage:', error);\n      throw new Error(`Failed to upload file: ${error.message}`);\n    }\n    \n    // Get the public URL\n    const { data: urlData } = supabase.storage\n      .from(BUCKET_NAME)\n      .getPublicUrl(storagePath);\n    \n    return urlData.publicUrl;\n  } catch (error) {\n    console.error('Error in uploadFile:', error);\n    throw error;\n  }\n}\n\n/**\n * Delete a file from Supabase Storage\n * \n * @param fileUrl The public URL of the file to delete\n * @returns boolean indicating success\n */\nexport async function deleteFile(fileUrl: string): Promise<boolean> {\n  try {\n    if (!bucketAvailable) {\n      // Simulate deletion if bucket is not available\n      console.log(`Simulating deletion of file: ${fileUrl}`);\n      return true;\n    }\n    \n    // Extract the path from the URL\n    const urlObj = new URL(fileUrl);\n    const pathParts = urlObj.pathname.split('/');\n    const storagePath = pathParts.slice(pathParts.indexOf('public') + 2).join('/');\n    \n    // Delete the file\n    const { error } = await supabase.storage\n      .from(BUCKET_NAME)\n      .remove([storagePath]);\n    \n    if (error) {\n      console.error('Error deleting file from Supabase Storage:', error);\n      return false;\n    }\n    \n    return true;\n  } catch (error) {\n    console.error('Error in deleteFile:', error);\n    return false;\n  }\n}\n\n/**\n * Get the content type based on file extension\n */\nfunction getContentType(extension: string): string {\n  const contentTypes: {[key: string]: string} = {\n    '.jpg': 'image/jpeg',\n    '.jpeg': 'image/jpeg',\n    '.png': 'image/png',\n    '.gif': 'image/gif',\n    '.webp': 'image/webp',\n    '.mp4': 'video/mp4',\n    '.webm': 'video/webm',\n    '.mov': 'video/quicktime',\n    '.pdf': 'application/pdf',\n  };\n  \n  return contentTypes[extension.toLowerCase()] || 'application/octet-stream';\n}","size_bytes":5275},"server/supabase.ts":{"content":"import { createClient } from '@supabase/supabase-js';\nimport * as dotenv from 'dotenv';\n\n// Load environment variables\ndotenv.config();\n\n// Validate essential environment variables\nconst supabaseUrl = process.env.SUPABASE_URL;\nconst supabaseKey = process.env.SUPABASE_ANON_KEY;\n\nif (!supabaseUrl || !supabaseKey) {\n  console.error('Missing required environment variables: SUPABASE_URL and/or SUPABASE_ANON_KEY');\n  process.exit(1);\n}\n\n// Create Supabase client\nexport const supabase = createClient(supabaseUrl, supabaseKey);\n\n// Test database connection\nexport const testConnection = async () => {\n  try {\n    const { data, error } = await supabase.from('users').select('count');\n    if (error) throw error;\n    console.log('Successfully connected to Supabase database');\n    return true;\n  } catch (error) {\n    console.error('Failed to connect to Supabase database:', error);\n    return false;\n  }\n};","size_bytes":902},"server/vite.ts":{"content":"import express, { type Express } from \"express\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport { createServer as createViteServer, createLogger } from \"vite\";\nimport { type Server } from \"http\";\nimport viteConfig from \"../vite.config\";\nimport { nanoid } from \"nanoid\";\n\nconst viteLogger = createLogger();\n\nexport function log(message: string, source = \"express\") {\n  const formattedTime = new Date().toLocaleTimeString(\"en-US\", {\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    second: \"2-digit\",\n    hour12: true,\n  });\n\n  console.log(`${formattedTime} [${source}] ${message}`);\n}\n\nexport async function setupVite(app: Express, server: Server) {\n  const serverOptions = {\n    middlewareMode: true,\n    hmr: { server },\n    allowedHosts: true,\n  };\n\n  const vite = await createViteServer({\n    ...viteConfig,\n    configFile: false,\n    customLogger: {\n      ...viteLogger,\n      error: (msg, options) => {\n        viteLogger.error(msg, options);\n        process.exit(1);\n      },\n    },\n    server: serverOptions,\n    appType: \"custom\",\n  });\n\n  app.use(vite.middlewares);\n  app.use(\"*\", async (req, res, next) => {\n    const url = req.originalUrl;\n\n    try {\n      const clientTemplate = path.resolve(\n        import.meta.dirname,\n        \"..\",\n        \"client\",\n        \"index.html\",\n      );\n\n      // always reload the index.html file from disk incase it changes\n      let template = await fs.promises.readFile(clientTemplate, \"utf-8\");\n      template = template.replace(\n        `src=\"/src/main.tsx\"`,\n        `src=\"/src/main.tsx?v=${nanoid()}\"`,\n      );\n      const page = await vite.transformIndexHtml(url, template);\n      res.status(200).set({ \"Content-Type\": \"text/html\" }).end(page);\n    } catch (e) {\n      vite.ssrFixStacktrace(e as Error);\n      next(e);\n    }\n  });\n}\n\nexport function serveStatic(app: Express) {\n  const distPath = path.resolve(import.meta.dirname, \"public\");\n\n  if (!fs.existsSync(distPath)) {\n    throw new Error(\n      `Could not find the build directory: ${distPath}, make sure to build the client first`,\n    );\n  }\n\n  app.use(express.static(distPath));\n\n  // fall through to index.html if the file doesn't exist\n  app.use(\"*\", (_req, res) => {\n    res.sendFile(path.resolve(distPath, \"index.html\"));\n  });\n}\n","size_bytes":2254},"server/websocket-server.ts":{"content":"import { WebSocketServer, WebSocket } from 'ws';\nimport { Server as HttpServer } from 'http';\nimport { IncomingMessage } from 'http';\nimport { storage } from './storage';\nimport { supabase } from './supabase-client';\nimport { desc, eq, and, isNull } from 'drizzle-orm';\nimport crypto from 'crypto';\n\ninterface AuthenticatedClient {\n  ws: WebSocket;\n  userId: number;\n  userName: string;\n  clientId: string;\n}\n\ninterface ChatMessage {\n  id: number;\n  eventId: number;\n  senderId: number;\n  content: string;\n  messageType: string;\n  replyToId?: number;\n  createdAt: Date;\n  sender?: {\n    id: number;\n    name: string;\n    username: string;\n  };\n}\n\nexport class ChatWebSocketServer {\n  private wss: WebSocketServer;\n  private clients: Map<string, AuthenticatedClient> = new Map();\n  private eventRooms: Map<number, Set<string>> = new Map(); // eventId -> Set of clientIds\n\n  constructor(server: HttpServer) {\n    this.wss = new WebSocketServer({ \n      server, \n      path: '/ws',\n      verifyClient: this.verifyClient.bind(this)\n    });\n\n    this.wss.on('connection', this.handleConnection.bind(this));\n    console.log('💬 Chat WebSocket server initialized on /ws');\n  }\n\n  private verifyClient(info: { req: IncomingMessage }) {\n    // Accept all connections for now, authentication happens after connection\n    return true;\n  }\n\n  private handleConnection(ws: WebSocket, req: IncomingMessage) {\n    const clientId = crypto.randomUUID();\n    console.log(`🔌 New WebSocket connection: ${clientId}`);\n\n    // Send connection acknowledgment\n    this.sendToClient(ws, {\n      type: 'connection',\n      clientId,\n      message: 'Connected to chat server'\n    });\n\n    ws.on('message', (data) => this.handleMessage(clientId, ws, data));\n    ws.on('close', () => this.handleDisconnection(clientId));\n    ws.on('error', (error) => this.handleError(clientId, error));\n  }\n\n  private async handleMessage(clientId: string, ws: WebSocket, data: any) {\n    try {\n      const message = JSON.parse(data.toString());\n      \n      switch (message.type) {\n        case 'auth':\n          await this.handleAuth(clientId, ws, message);\n          break;\n        case 'join_event':\n          await this.handleJoinEvent(clientId, message);\n          break;\n        case 'leave_event':\n          await this.handleLeaveEvent(clientId, message);\n          break;\n        case 'send_message':\n          await this.handleSendMessage(clientId, message);\n          break;\n        case 'load_messages':\n          await this.handleLoadMessages(clientId, message);\n          break;\n        case 'typing':\n          await this.handleTyping(clientId, message);\n          break;\n        default:\n          console.log(`❓ Unknown message type: ${message.type}`);\n      }\n    } catch (error) {\n      console.error(`❌ Error handling message from ${clientId}:`, error);\n      this.sendToClient(ws, {\n        type: 'error',\n        message: 'Invalid message format'\n      });\n    }\n  }\n\n  private async handleAuth(clientId: string, ws: WebSocket, message: any) {\n    try {\n      const { userId, userName } = message;\n      \n      if (!userId || !userName) {\n        this.sendToClient(ws, {\n          type: 'auth_error',\n          message: 'Missing userId or userName'\n        });\n        return;\n      }\n\n      // Verify user exists in database\n      const user = await storage.getUserById(userId);\n      if (!user) {\n        this.sendToClient(ws, {\n          type: 'auth_error',\n          message: 'User not found'\n        });\n        return;\n      }\n\n      // Store authenticated client\n      this.clients.set(clientId, {\n        ws,\n        userId,\n        userName: user.name || user.username,\n        clientId\n      });\n\n      console.log(`✅ User authenticated: ${user.name || user.username} (${userId})`);\n\n      this.sendToClient(ws, {\n        type: 'auth_success',\n        userId,\n        userName: user.name || user.username\n      });\n\n    } catch (error) {\n      console.error('❌ Auth error:', error);\n      this.sendToClient(ws, {\n        type: 'auth_error',\n        message: 'Authentication failed'\n      });\n    }\n  }\n\n  private async handleJoinEvent(clientId: string, message: any) {\n    const client = this.clients.get(clientId);\n    if (!client) {\n      console.log(`❌ Client ${clientId} not found for join event`);\n      return;\n    }\n\n    const { eventId } = message;\n    if (!eventId) {\n      console.log(`❌ No eventId provided for join event`);\n      return;\n    }\n\n    try {\n      console.log(`🔍 Checking access for user ${client.userId} to event ${eventId}`);\n      \n      // Verify user has access to this event (is attendee or organizer)\n      const hasAccess = await this.verifyEventAccess(client.userId, eventId);\n      if (!hasAccess) {\n        console.log(`❌ User ${client.userId} denied access to event ${eventId}`);\n        this.sendToClient(client.ws, {\n          type: 'join_error',\n          eventId,\n          error: 'Not authorized to join this event'\n        });\n        return;\n      }\n\n      // Leave all previous event rooms for this client\n      this.eventRooms.forEach((room, roomEventId) => {\n        if (room.has(clientId) && roomEventId !== eventId) {\n          console.log(`👋 User ${client.userName} leaving previous event ${roomEventId}`);\n          room.delete(clientId);\n          if (room.size === 0) {\n            this.eventRooms.delete(roomEventId);\n          }\n          \n          // Notify others in the previous room\n          this.broadcastToEventRoom(roomEventId, {\n            type: 'user_left',\n            eventId: roomEventId,\n            user: {\n              id: client.userId,\n              name: client.userName\n            }\n          }, clientId);\n        }\n      });\n\n      // Add client to new event room\n      if (!this.eventRooms.has(eventId)) {\n        this.eventRooms.set(eventId, new Set());\n      }\n      this.eventRooms.get(eventId)!.add(clientId);\n\n      console.log(`✅ User ${client.userName} joined event ${eventId} successfully`);\n\n      this.sendToClient(client.ws, {\n        type: 'joined_event',\n        eventId,\n        message: `Joined event ${eventId} chat`\n      });\n\n      // Notify other users in the room\n      this.broadcastToEventRoom(eventId, {\n        type: 'user_joined',\n        eventId,\n        user: {\n          id: client.userId,\n          name: client.userName\n        }\n      }, clientId);\n\n    } catch (error) {\n      console.error('❌ Error joining event:', error);\n      this.sendToClient(client.ws, {\n        type: 'join_error',\n        eventId,\n        error: 'Failed to join event'\n      });\n    }\n  }\n\n  private async handleLeaveEvent(clientId: string, message: any) {\n    const client = this.clients.get(clientId);\n    if (!client) {\n      return;\n    }\n\n    const { eventId } = message;\n    if (!eventId) {\n      return;\n    }\n\n    // Remove client from event room\n    const room = this.eventRooms.get(eventId);\n    if (room) {\n      room.delete(clientId);\n      if (room.size === 0) {\n        this.eventRooms.delete(eventId);\n      }\n    }\n\n    console.log(`👋 User ${client.userName} left event ${eventId}`);\n\n    this.sendToClient(client.ws, {\n      type: 'left_event',\n      eventId\n    });\n\n    // Notify other users in the room\n    this.broadcastToEventRoom(eventId, {\n      type: 'user_left',\n      eventId,\n      user: {\n        id: client.userId,\n        name: client.userName\n      }\n    }, clientId);\n  }\n\n  private async handleSendMessage(clientId: string, message: any) {\n    const client = this.clients.get(clientId);\n    if (!client) {\n      return;\n    }\n\n    const { eventId, content, replyToId } = message;\n    \n    if (!eventId || !content || content.trim() === '') {\n      this.sendToClient(client.ws, {\n        type: 'message_error',\n        message: 'Missing eventId or content'\n      });\n      return;\n    }\n\n    try {\n      // Verify user has access to this event\n      console.log(`🔍 Verifying message access for user ${client.userId} to event ${eventId}`);\n      const hasAccess = await this.verifyEventAccess(client.userId, eventId);\n      if (!hasAccess) {\n        console.log(`❌ User ${client.userId} denied message access to event ${eventId}`);\n        this.sendToClient(client.ws, {\n          type: 'message_error',\n          message: 'No access to this event'\n        });\n        return;\n      }\n\n      // Save message to database using Supabase\n      const { data: newMessage, error: insertError } = await supabase\n        .from('chat_messages')\n        .insert({\n          event_id: eventId,\n          sender_id: client.userId,\n          content: content.trim(),\n          message_type: 'text',\n          reply_to_id: replyToId || null\n        })\n        .select()\n        .single();\n\n      if (insertError) {\n        console.error('❌ Error inserting message:', insertError);\n        this.sendToClient(client.ws, {\n          type: 'message_error',\n          message: 'Failed to save message'\n        });\n        return;\n      }\n\n      // Get complete message with sender info\n      const { data: completeMessage, error: fetchError } = await supabase\n        .from('chat_messages')\n        .select(`\n          id,\n          event_id,\n          sender_id,\n          content,\n          message_type,\n          reply_to_id,\n          created_at,\n          sender:users!sender_id (\n            id,\n            name,\n            username\n          )\n        `)\n        .eq('id', newMessage.id)\n        .single();\n\n      if (fetchError) {\n        console.error('❌ Error fetching complete message:', fetchError);\n        return;\n      }\n\n      if (completeMessage) {\n        const messagePayload = {\n          type: 'new_message',\n          eventId,\n          message: {\n            id: completeMessage.id,\n            eventId: completeMessage.event_id,\n            senderId: completeMessage.sender_id,\n            content: completeMessage.content,\n            messageType: completeMessage.message_type,\n            replyToId: completeMessage.reply_to_id,\n            createdAt: completeMessage.created_at,\n            sender: completeMessage.sender\n          }\n        };\n\n        // Broadcast to all clients in the event room\n        this.broadcastToEventRoom(eventId, messagePayload);\n        \n        console.log(`💬 Message sent in event ${eventId} by ${client.userName}`);\n      }\n\n    } catch (error) {\n      console.error('❌ Error sending message:', error);\n      this.sendToClient(client.ws, {\n        type: 'message_error',\n        message: 'Failed to send message'\n      });\n    }\n  }\n\n  private async handleLoadMessages(clientId: string, message: any) {\n    const client = this.clients.get(clientId);\n    if (!client) {\n      return;\n    }\n\n    const { eventId, limit = 50, offset = 0 } = message;\n    \n    if (!eventId) {\n      return;\n    }\n\n    try {\n      // Verify user has access to this event\n      console.log(`🔍 Verifying load messages access for user ${client.userId} to event ${eventId}`);\n      const hasAccess = await this.verifyEventAccess(client.userId, eventId);\n      if (!hasAccess) {\n        console.log(`❌ User ${client.userId} denied load messages access to event ${eventId}`);\n        this.sendToClient(client.ws, {\n          type: 'load_messages_error',\n          eventId,\n          message: 'No access to this event'\n        });\n        return;\n      }\n\n      // Load messages from database using Supabase\n      console.log(`🔍 Loading messages for event ${eventId} (type: ${typeof eventId})`);\n      const { data: messages, error } = await supabase\n        .from('chat_messages')\n        .select(`\n          id,\n          event_id,\n          sender_id,\n          content,\n          message_type,\n          reply_to_id,\n          created_at,\n          sender:users!sender_id (\n            id,\n            name,\n            username\n          )\n        `)\n        .eq('event_id', Number(eventId))\n        .is('deleted_at', null)\n        .order('created_at', { ascending: false })\n        .limit(Math.min(limit, 100))\n        .range(offset, offset + Math.min(limit, 100) - 1);\n        \n      if (error) {\n        console.error('❌ Error loading messages:', error);\n        this.sendToClient(client.ws, {\n          type: 'load_messages_error',\n          eventId,\n          message: 'Failed to load messages'\n        });\n        return;\n      }\n      const messageList = messages || [];\n      console.log(`📊 Found ${messageList.length} messages in database for event ${eventId}`);\n\n      console.log(`📜 Sending ${messageList.length} messages for event ${eventId} to user ${client.userId}`);\n      this.sendToClient(client.ws, {\n        type: 'messages_loaded',\n        eventId,\n        messages: messageList.reverse(), // Reverse to show oldest first\n        hasMore: messages.length === limit\n      });\n\n    } catch (error) {\n      console.error('❌ Error loading messages:', error);\n      this.sendToClient(client.ws, {\n        type: 'load_messages_error',\n        eventId,\n        message: 'Failed to load messages'\n      });\n    }\n  }\n\n  private async handleTyping(clientId: string, message: any) {\n    const client = this.clients.get(clientId);\n    if (!client) {\n      return;\n    }\n\n    const { eventId, isTyping } = message;\n    \n    if (!eventId) {\n      return;\n    }\n\n    // Broadcast typing status to other users in the room\n    this.broadcastToEventRoom(eventId, {\n      type: 'user_typing',\n      eventId,\n      user: {\n        id: client.userId,\n        name: client.userName\n      },\n      isTyping\n    }, clientId);\n  }\n\n  private async verifyEventAccess(userId: number, eventId: number): Promise<boolean> {\n    try {\n      console.log(`🔍 Verifying access for user ${userId} to event ${eventId}`);\n      \n      // Check if user is the organizer first - convert eventId to number for comparison\n      const { data: event, error: eventError } = await supabase\n        .from('events')\n        .select('*, organizer:users!organizer_id(*)')\n        .eq('id', Number(eventId))\n        .single();\n\n      if (eventError && eventError.code !== 'PGRST116') {\n        console.error('❌ Error fetching event for access verification:', eventError);\n        return false;\n      }\n\n      if (!event) {\n        console.log(`❌ Event ${eventId} not found in access verification`);\n        return false;\n      }\n\n      console.log(`📋 Event found: ${event.title}, organizer: ${event.organizer_id}, user requesting: ${userId}`);\n      console.log(`🔍 Comparing organizer ID (${event.organizer_id}) with user ID (${userId})`);\n      console.log(`🔍 Types: organizer (${typeof event.organizer_id}) vs user (${typeof userId})`);\n\n      // If user is the organizer, they have access (organizers attend their own events)\n      if (Number(event.organizer_id) === Number(userId)) {\n        console.log(`✅ User ${userId} is organizer of event ${eventId} - access granted`);\n        return true;\n      }\n\n      // Check if user is an attendee\n      const { data: attendee, error: attendeeError } = await supabase\n        .from('event_attendees')\n        .select('*')\n        .eq('event_id', Number(eventId))\n        .eq('user_id', userId)\n        .single();\n\n      if (attendeeError && attendeeError.code !== 'PGRST116') {\n        console.error('❌ Error checking attendee status:', attendeeError);\n      }\n\n      if (attendee) {\n        console.log(`✅ User ${userId} is attendee of event ${eventId} - access granted`);\n        return true;\n      }\n\n      // For development/testing purposes, allow access to all public events\n      // In production, you might want to restrict this\n      console.log(`⚠️ User ${userId} accessing public event ${eventId} - temporary access granted for development`);\n      return true;\n\n    } catch (error) {\n      console.error('❌ Error verifying event access:', error);\n      return false;\n    }\n  }\n\n  private handleDisconnection(clientId: string) {\n    const client = this.clients.get(clientId);\n    if (client) {\n      console.log(`🔌 User ${client.userName} disconnected`);\n\n      // Remove from all event rooms\n      for (const [eventId, room] of Array.from(this.eventRooms.entries())) {\n        if (room.has(clientId)) {\n          room.delete(clientId);\n          \n          // Notify other users in the room\n          this.broadcastToEventRoom(eventId, {\n            type: 'user_left',\n            eventId,\n            user: {\n              id: client.userId,\n              name: client.userName\n            }\n          }, clientId);\n\n          if (room.size === 0) {\n            this.eventRooms.delete(eventId);\n          }\n        }\n      }\n\n      this.clients.delete(clientId);\n    }\n  }\n\n  private handleError(clientId: string, error: Error) {\n    console.error(`❌ WebSocket error for client ${clientId}:`, error);\n    this.handleDisconnection(clientId);\n  }\n\n  private sendToClient(ws: WebSocket, data: any) {\n    if (ws.readyState === WebSocket.OPEN) {\n      ws.send(JSON.stringify(data));\n    }\n  }\n\n  private broadcastToEventRoom(eventId: number, data: any, excludeClientId?: string) {\n    const room = this.eventRooms.get(eventId);\n    if (!room) {\n      return;\n    }\n\n    for (const clientId of Array.from(room)) {\n      if (excludeClientId && clientId === excludeClientId) {\n        continue;\n      }\n\n      const client = this.clients.get(clientId);\n      if (client && client.ws.readyState === WebSocket.OPEN) {\n        this.sendToClient(client.ws, data);\n      }\n    }\n  }\n\n  public getStats() {\n    return {\n      connectedClients: this.clients.size,\n      activeRooms: this.eventRooms.size,\n      totalRoomConnections: Array.from(this.eventRooms.values()).reduce(\n        (total, room) => total + room.size, \n        0\n      )\n    };\n  }\n}","size_bytes":17695},"shared/media-utils.ts":{"content":"/**\n * Utilidades unificadas para manejo de media principal\n * Usadas tanto en cliente como servidor para garantizar consistencia\n */\n\nexport interface MediaItem {\n  id?: string;\n  type: 'photo' | 'video';\n  url?: string;\n  file?: File;\n  previewUrl?: string;\n  isMain?: boolean;\n  isNew?: boolean;\n  deleted?: boolean;\n  toDelete?: boolean;\n  order?: number;\n  uploading?: boolean;\n  uploadProgress?: number;\n  errorMessage?: string;\n  fileIndex?: number;\n}\n\nexport interface MainMediaResult {\n  mainMediaUrl: string | null;\n  mainMediaType: 'photo' | 'video' | null;\n  mediaItems: MediaItem[];\n}\n\n/**\n * Valida si un elemento multimedia es válido para ser principal\n */\nexport function isValidMainMedia(item: MediaItem): boolean {\n  if (!item) return false;\n  if (item.deleted || item.toDelete) return false;\n  if (item.errorMessage) return false;\n  if (!item.url && !item.file && !item.previewUrl) return false;\n  return true;\n}\n\n/**\n * Encuentra el mejor candidato para ser media principal\n */\nexport function findBestMainMediaCandidate(items: MediaItem[]): MediaItem | null {\n  if (!Array.isArray(items) || items.length === 0) return null;\n\n  // Filtrar solo elementos válidos\n  const validItems = items.filter(isValidMainMedia);\n  if (validItems.length === 0) return null;\n\n  // 1. Prioridad: elemento ya marcado como principal y válido\n  const explicitMain = validItems.find(item => item.isMain === true);\n  if (explicitMain) return explicitMain;\n\n  // 2. Fallback: primer elemento válido (por orden)\n  const sortedItems = validItems.sort((a, b) => (a.order || 0) - (b.order || 0));\n  return sortedItems[0];\n}\n\n/**\n * Establece un elemento como principal y asegura que solo uno sea principal\n */\nexport function setMainMediaItem(items: MediaItem[], targetIndex: number): MediaItem[] {\n  if (!Array.isArray(items) || targetIndex < 0 || targetIndex >= items.length) {\n    return items;\n  }\n\n  const targetItem = items[targetIndex];\n  if (!isValidMainMedia(targetItem)) {\n    console.warn('Cannot set invalid item as main media:', targetItem);\n    return items;\n  }\n\n  // Crear nueva copia con solo el elemento target marcado como principal\n  return items.map((item, index) => ({\n    ...item,\n    isMain: index === targetIndex\n  }));\n}\n\n/**\n * Normaliza y valida array de mediaItems, asegurando que haya un elemento principal válido\n */\nexport function normalizeMediaItems(items: any[]): MainMediaResult {\n  if (!Array.isArray(items)) {\n    return {\n      mainMediaUrl: null,\n      mainMediaType: null,\n      mediaItems: []\n    };\n  }\n\n  // Filtrar elementos válidos\n  const validItems: MediaItem[] = items\n    .filter(item => item && typeof item === 'object')\n    .map((item, index) => ({\n      ...item,\n      order: item.order !== undefined ? item.order : index,\n      type: item.type || 'photo'\n    }))\n    .filter(isValidMainMedia);\n\n  if (validItems.length === 0) {\n    return {\n      mainMediaUrl: null,\n      mainMediaType: null,\n      mediaItems: []\n    };\n  }\n\n  // Asegurar que solo un elemento sea principal\n  const mainCandidate = findBestMainMediaCandidate(validItems);\n  const normalizedItems = validItems.map(item => ({\n    ...item,\n    isMain: item === mainCandidate\n  }));\n\n  // Extraer información del elemento principal\n  let mainMediaUrl: string | null = null;\n  let mainMediaType: 'photo' | 'video' | null = null;\n\n  if (mainCandidate) {\n    mainMediaUrl = mainCandidate.url || null;\n    mainMediaType = mainCandidate.type;\n  }\n\n  return {\n    mainMediaUrl,\n    mainMediaType,\n    mediaItems: normalizedItems\n  };\n}\n\n/**\n * Parsea mediaItems desde JSON de forma segura\n */\nexport function parseMediaItemsFromJSON(input: any): MediaItem[] {\n  if (!input) return [];\n\n  // Si ya es un array, usarlo directamente\n  if (Array.isArray(input)) {\n    return input.filter(item => item && typeof item === 'object');\n  }\n\n  // Si es string, intentar parsear JSON\n  if (typeof input === 'string') {\n    try {\n      const parsed = JSON.parse(input);\n      return Array.isArray(parsed) ? parsed : [];\n    } catch (e) {\n      console.warn('Failed to parse mediaItems JSON:', e);\n      return [];\n    }\n  }\n\n  // Si es un objeto único, convertir a array\n  if (typeof input === 'object') {\n    return [input];\n  }\n\n  return [];\n}\n\n/**\n * Serializa mediaItems a JSON de forma segura\n */\nexport function serializeMediaItemsToJSON(items: MediaItem[]): string {\n  if (!Array.isArray(items) || items.length === 0) {\n    return JSON.stringify([]);\n  }\n\n  // Limpiar elementos para serialización (remover File objects y URLs temporales)\n  const cleanItems = items.map(item => ({\n    type: item.type,\n    url: item.url,\n    order: item.order || 0,\n    isMain: item.isMain || false,\n    id: item.id\n  })).filter(item => item.url); // Solo incluir items con URL válida\n\n  return JSON.stringify(cleanItems);\n}","size_bytes":4817},"shared/schema.ts":{"content":"import { pgTable, text, serial, integer, boolean, timestamp, decimal, pgEnum } from \"drizzle-orm/pg-core\";\nimport { createInsertSchema, createSelectSchema } from \"drizzle-zod\";\nimport { z } from \"zod\";\nimport { relations } from \"drizzle-orm\";\n\n// Create enums for categories\nexport const eventCategoryEnum = pgEnum('event_category', [\n  'social', 'music', 'spiritual', 'education', \n  'sports', 'food', 'art', 'technology',\n  'games', 'outdoor', 'networking', 'workshop',\n  'conference', 'party', 'fair', 'exhibition'\n]);\n\n// Create enums for privacy\nexport const privacyTypeEnum = pgEnum('privacy_type', ['public', 'private']);\n\n// Create enums for private event access type\nexport const privateAccessTypeEnum = pgEnum('private_access_type', ['solicitud', 'postulacion', 'paga']);\n\n// Create enums for payment type (keeping for schema compatibility, but will disable in UI)\nexport const paymentTypeEnum = pgEnum('payment_type', ['free', 'paid']);\n\n// Create enums for gender\nexport const genderEnum = pgEnum('gender', ['hombre', 'mujer', 'otro', 'no_especificar']);\n\n// Create enums for gender preference in events\nexport const genderPreferenceEnum = pgEnum('gender_preference', ['all_people', 'men', 'women']);\n\n// Users Table\nexport const users = pgTable(\"users\", {\n  id: serial(\"id\").primaryKey(),\n  username: text(\"username\").notNull().unique(),\n  email: text(\"email\").notNull().unique(),\n  password: text(\"password\"), // No longer required with Supabase auth\n  name: text(\"name\").notNull(),\n  bio: text(\"bio\"),\n  avatar: text(\"avatar\"),\n  gender: genderEnum(\"gender\"), // User's gender\n  supabaseId: text(\"supabase_id\").unique(), // Add Supabase user ID reference\n  stripeCustomerId: text(\"stripe_customer_id\"),\n  stripeSubscriptionId: text(\"stripe_subscription_id\"),\n  createdAt: timestamp(\"created_at\").defaultNow().notNull(),\n  updatedAt: timestamp(\"updated_at\").defaultNow().notNull(),\n});\n\n// Multimedia type enum\nexport const multimediaTypeEnum = pgEnum('multimedia_type', ['photo', 'video']);\n\n// Events Table\nexport const events = pgTable(\"events\", {\n  id: serial(\"id\").primaryKey(),\n  title: text(\"title\").notNull(),\n  description: text(\"description\").notNull(),\n  category: eventCategoryEnum(\"category\").notNull(),\n  date: timestamp(\"date\").notNull(),\n  endTime: timestamp(\"end_time\"),\n  latitude: decimal(\"latitude\", { precision: 10, scale: 6 }).notNull(),\n  longitude: decimal(\"longitude\", { precision: 10, scale: 6 }).notNull(),\n  locationName: text(\"location_name\").notNull(),\n  locationAddress: text(\"location_address\").notNull(),\n  paymentType: paymentTypeEnum(\"payment_type\").notNull().default('free'),\n  price: decimal(\"price\", { precision: 10, scale: 2 }),\n  maxCapacity: integer(\"max_capacity\"),\n  privacyType: privacyTypeEnum(\"privacy_type\").notNull().default('public'),\n  privateAccessType: privateAccessTypeEnum(\"private_access_type\").default('solicitud'),\n  mediaItems: text(\"media_items\"),\n  mainMediaType: text(\"main_media_type\"),\n  mainMediaUrl: text(\"main_media_url\"),\n  genderPreference: genderPreferenceEnum(\"gender_preference\").default('all_people'), // Gender preference for the event\n  organizerId: integer(\"organizer_id\").references(() => users.id).notNull(),\n  createdAt: timestamp(\"created_at\").defaultNow().notNull(),\n  updatedAt: timestamp(\"updated_at\").defaultNow().notNull(),\n});\n\n// Attendee status enum (pending, approved, rejected)\nexport const attendeeStatusEnum = pgEnum('attendee_status', ['pending', 'approved', 'rejected']);\n\n// Event Attendees Junction Table\nexport const eventAttendees = pgTable(\"event_attendees\", {\n  id: serial(\"id\").primaryKey(),\n  eventId: integer(\"event_id\").references(() => events.id).notNull(),\n  userId: integer(\"user_id\").references(() => users.id).notNull(),\n  status: attendeeStatusEnum(\"status\").default('approved').notNull(),\n  paymentStatus: text(\"payment_status\").default('pending'),\n  paymentIntentId: text(\"payment_intent_id\"),\n  applicationAnswers: text(\"application_answers\"), // JSON string for private event application answers\n  createdAt: timestamp(\"created_at\").defaultNow().notNull(),\n});\n\n// User Interests Table (for future recommendations)\nexport const userInterests = pgTable(\"user_interests\", {\n  id: serial(\"id\").primaryKey(),\n  userId: integer(\"user_id\").references(() => users.id).notNull(),\n  category: eventCategoryEnum(\"category\").notNull(),\n  createdAt: timestamp(\"created_at\").defaultNow().notNull(),\n});\n\n// Chat Messages Table for event conversations\nexport const chatMessages = pgTable(\"chat_messages\", {\n  id: serial(\"id\").primaryKey(),\n  eventId: integer(\"event_id\").references(() => events.id, { onDelete: 'cascade' }).notNull(),\n  senderId: integer(\"sender_id\").references(() => users.id).notNull(),\n  content: text(\"content\").notNull(),\n  messageType: text(\"message_type\").default('text').notNull(), // 'text', 'image', 'file', 'system'\n  replyToId: integer(\"reply_to_id\"), // For threaded conversations - self-reference added later\n  edited: boolean(\"edited\").default(false).notNull(),\n  editedAt: timestamp(\"edited_at\"),\n  deletedAt: timestamp(\"deleted_at\"), // Soft delete\n  createdAt: timestamp(\"created_at\").defaultNow().notNull(),\n  updatedAt: timestamp(\"updated_at\").defaultNow().notNull(),\n});\n\n// Notification type enum\nexport const notificationTypeEnum = pgEnum('notification_type', ['request_approved', 'request_rejected', 'new_request']);\n\n// Notifications Table for user notifications\nexport const notifications = pgTable(\"notifications\", {\n  id: serial(\"id\").primaryKey(),\n  userId: integer(\"user_id\").references(() => users.id).notNull(),\n  type: notificationTypeEnum(\"type\").notNull(),\n  title: text(\"title\").notNull(),\n  message: text(\"message\").notNull(),\n  eventId: integer(\"event_id\").references(() => events.id),\n  requestId: integer(\"request_id\").references(() => eventAttendees.id),\n  isRead: boolean(\"is_read\").default(false).notNull(),\n  createdAt: timestamp(\"created_at\").defaultNow().notNull(),\n});\n\n// User Ratings Table for aura system\nexport const userRatings = pgTable(\"user_ratings\", {\n  id: serial(\"id\").primaryKey(),\n  ratedUserId: integer(\"rated_user_id\").references(() => users.id).notNull(),\n  raterUserId: integer(\"rater_user_id\").references(() => users.id).notNull(),\n  rating: integer(\"rating\").notNull(),\n  createdAt: timestamp(\"created_at\").defaultNow().notNull(),\n  updatedAt: timestamp(\"updated_at\").defaultNow().notNull(),\n});\n\n// Relations\nexport const usersRelations = relations(users, ({ many }) => ({\n  organizedEvents: many(events, { relationName: \"organizer\" }),\n  attendedEvents: many(eventAttendees, { relationName: \"attendee\" }),\n  interests: many(userInterests),\n  sentMessages: many(chatMessages, { relationName: \"sender\" }),\n  notifications: many(notifications),\n  ratingsGiven: many(userRatings, { relationName: \"rater\" }),\n  ratingsReceived: many(userRatings, { relationName: \"rated\" }),\n}));\n\nexport const eventsRelations = relations(events, ({ one, many }) => ({\n  organizer: one(users, { fields: [events.organizerId], references: [users.id], relationName: \"organizer\" }),\n  attendees: many(eventAttendees),\n  chatMessages: many(chatMessages),\n}));\n\nexport const eventAttendeesRelations = relations(eventAttendees, ({ one }) => ({\n  event: one(events, { fields: [eventAttendees.eventId], references: [events.id] }),\n  user: one(users, { fields: [eventAttendees.userId], references: [users.id], relationName: \"attendee\" }),\n}));\n\nexport const userInterestsRelations = relations(userInterests, ({ one }) => ({\n  user: one(users, { fields: [userInterests.userId], references: [users.id] }),\n}));\n\nexport const chatMessagesRelations = relations(chatMessages, ({ one }) => ({\n  event: one(events, { fields: [chatMessages.eventId], references: [events.id] }),\n  sender: one(users, { fields: [chatMessages.senderId], references: [users.id], relationName: \"sender\" }),\n}));\n\nexport const notificationsRelations = relations(notifications, ({ one }) => ({\n  user: one(users, { fields: [notifications.userId], references: [users.id] }),\n  event: one(events, { fields: [notifications.eventId], references: [events.id] }),\n  request: one(eventAttendees, { fields: [notifications.requestId], references: [eventAttendees.id] }),\n}));\n\nexport const userRatingsRelations = relations(userRatings, ({ one }) => ({\n  ratedUser: one(users, { fields: [userRatings.ratedUserId], references: [users.id], relationName: \"rated\" }),\n  raterUser: one(users, { fields: [userRatings.raterUserId], references: [users.id], relationName: \"rater\" }),\n}));\n\n// Validation Schemas\nexport const insertUserSchema = createInsertSchema(users).extend({\n  email: z.string().email(\"Dirección de correo electrónico inválida\"),\n  password: z.string().min(6, \"La contraseña debe tener al menos 6 caracteres\").optional(),\n  username: z.string().min(3, \"El nombre de usuario debe tener al menos 3 caracteres\"),\n  name: z.string().min(2, \"El nombre debe tener al menos 2 caracteres\"),\n});\n\nexport const loginUserSchema = z.object({\n  email: z.string().email(\"Dirección de correo electrónico inválida\"),\n  password: z.string().min(6, \"La contraseña debe tener al menos 6 caracteres\"),\n});\n\n// Esquema personalizado con transformaciones para eventos\nexport const insertEventSchema = z.object({\n  title: z.string().min(3, \"El título debe tener al menos 3 caracteres\"),\n  description: z.string().min(10, \"La descripción debe tener al menos 10 caracteres\"),\n  category: z.enum(eventCategoryEnum.enumValues),\n  date: z.string().or(z.date()).transform(val => \n    typeof val === 'string' ? new Date(val) : val\n  ),\n  endTime: z.string().or(z.date()).transform(val => \n    typeof val === 'string' ? new Date(val) : val\n  ),\n  latitude: z.string().or(z.number()).transform(val => \n    typeof val === 'string' ? parseFloat(val) : val\n  ),\n  longitude: z.string().or(z.number()).transform(val => \n    typeof val === 'string' ? parseFloat(val) : val\n  ),\n  locationName: z.string().min(3, \"El nombre del lugar debe tener al menos 3 caracteres\"),\n  locationAddress: z.string().min(5, \"La dirección debe tener al menos 5 caracteres\"),\n  paymentType: z.enum(paymentTypeEnum.enumValues).default('free'),\n  price: z.string().or(z.number()).transform(val => \n    typeof val === 'string' ? parseFloat(val) || 0 : val\n  ).optional().nullable(),\n  maxCapacity: z.string().or(z.number()).transform(val => \n    typeof val === 'string' ? parseFloat(val) || null : val\n  ).optional().nullable(),\n  privacyType: z.enum(privacyTypeEnum.enumValues).default('public'),\n  privateAccessType: z.enum(privateAccessTypeEnum.enumValues).optional().nullable(),\n  applicationQuestions: z.string().optional().nullable(), // JSON string for questions\n  // Campos existentes (mantenidos por compatibilidad)\n  photoUrl: z.string().optional().nullable(),\n  photoUrls: z.string().optional().nullable(), // Almacenar array como JSON string\n  videoUrl: z.string().optional().nullable(),\n  videoUrls: z.string().optional().nullable(),\n  // Nuevos campos para multimedia\n  mediaItems: z.string().optional().nullable(), // Array JSON de items multimedia\n  mainMediaType: z.enum(multimediaTypeEnum.enumValues).optional().default('photo'),\n  mainMediaUrl: z.string().optional().nullable(),\n  genderPreference: z.enum(genderPreferenceEnum.enumValues).default('all_people'),\n  organizerId: z.number(),\n});\n\nexport const insertEventAttendeeSchema = createInsertSchema(eventAttendees);\n\n// Export types\nexport type User = typeof users.$inferSelect;\nexport type Event = typeof events.$inferSelect;\nexport type EventAttendee = typeof eventAttendees.$inferSelect;\nexport type UserInterest = typeof userInterests.$inferSelect;\nexport type ChatMessage = typeof chatMessages.$inferSelect;\nexport type UserRating = typeof userRatings.$inferSelect;\n\n// Chat message insert schema\nexport const insertChatMessageSchema = createInsertSchema(chatMessages);\nexport type InsertChatMessage = z.infer<typeof insertChatMessageSchema>;\n\n// User rating insert schema\nexport const insertUserRatingSchema = createInsertSchema(userRatings, {\n  rating: (schema) => schema.min(1, \"Rating must be at least 1\").max(10, \"Rating must be at most 10\"),\n});\nexport type InsertUserRating = z.infer<typeof insertUserRatingSchema>;\n\nexport type InsertUser = z.infer<typeof insertUserSchema>;\nexport type LoginUser = z.infer<typeof loginUserSchema>;\nexport type InsertEvent = z.infer<typeof insertEventSchema>;\nexport type InsertEventAttendee = z.infer<typeof insertEventAttendeeSchema>;\n","size_bytes":12442},"client/src/App.tsx":{"content":"import React from \"react\";\nimport { Switch, Route, useLocation } from \"wouter\";\nimport { queryClient } from \"./lib/queryClient\";\nimport { QueryClientProvider } from \"@tanstack/react-query\";\nimport { Toaster } from \"@/components/ui/toaster\";\nimport { motion, AnimatePresence } from \"framer-motion\";\nimport NotFound from \"@/pages/not-found\";\nimport Home from \"@/pages/Home\";\nimport MyEvents from \"@/pages/my-events\";\nimport Messages from \"@/pages/messages\";\nimport Profile from \"@/pages/profile\";\nimport Payment from \"@/pages/payment\";\nimport AuthPage from \"@/pages/auth\";\nimport AuthTest from \"@/pages/auth-test\";\nimport Tickets from \"@/pages/tickets\";\nimport { ProtectedRoute } from \"./lib/protected-route\";\nimport { AuthProvider } from \"@/hooks/use-auth\";\nimport { NavigationProvider } from \"@/contexts/navigation-context\";\nimport { UserProfileProvider } from \"@/contexts/user-profile-context\";\nimport { ZIndexProvider } from \"@/contexts/z-index-context\";\nimport { MapProvider } from \"@/contexts/MapContext\";\nimport UserProfilePanel from \"@/components/users/user-profile-panel\";\n\n// Import components\nimport EditEventPage from \"@/pages/edit-event\";\nimport TestEditPanel from \"@/pages/test-edit-panel\";\n\n// Page transition variants - Volver a anterior pero mejorado\nconst pageVariants = {\n  initial: {\n    opacity: 0,\n    y: 20,\n    scale: 0.95\n  },\n  in: {\n    opacity: 1,\n    y: 0,\n    scale: 1\n  },\n  out: {\n    opacity: 0,\n    y: -20,\n    scale: 1.05\n  }\n};\n\nconst pageTransition = {\n  type: \"tween\",\n  ease: \"easeInOut\", \n  duration: 0.3\n};\n\n// Animated page wrapper - Forzar estado inicial invisible\nfunction AnimatedPage({ children }: { children: React.ReactNode }) {\n  return (\n    <motion.div\n      key={`page-${Date.now()}`}\n      initial={{ opacity: 0, y: 20, scale: 0.95 }}\n      animate={{ opacity: 1, y: 0, scale: 1 }}\n      exit={{ opacity: 0, y: -20, scale: 1.05 }}\n      transition={{\n        type: \"tween\",\n        ease: \"easeInOut\",\n        duration: 0.3\n      }}\n      className=\"w-full h-full min-h-screen bg-white\"\n    >\n      {children}\n    </motion.div>\n  );\n}\n\nfunction Router() {\n  const [location] = useLocation();\n  \n  return (\n    <div className=\"min-h-screen bg-white\">\n      <AnimatePresence mode=\"wait\" initial={false}>\n        <Switch key={location}>\n        <Route path=\"/\">\n          <ProtectedRoute>\n            <AnimatedPage>\n              <Home />\n            </AnimatedPage>\n          </ProtectedRoute>\n        </Route>\n        <Route path=\"/tickets\">\n          <ProtectedRoute>\n            <AnimatedPage>\n              <Tickets />\n            </AnimatedPage>\n          </ProtectedRoute>\n        </Route>\n        <Route path=\"/my-events\">\n          <ProtectedRoute>\n            <AnimatedPage>\n              <MyEvents />\n            </AnimatedPage>\n          </ProtectedRoute>\n        </Route>\n        <Route path=\"/my-events/:eventId/edit\">\n          <ProtectedRoute>\n            <AnimatedPage>\n              <EditEventPage />\n            </AnimatedPage>\n          </ProtectedRoute>\n        </Route>\n        <Route path=\"/test-edit-panel\">\n          <ProtectedRoute>\n            <AnimatedPage>\n              <TestEditPanel />\n            </AnimatedPage>\n          </ProtectedRoute>\n        </Route>\n        <Route path=\"/messages\">\n          <ProtectedRoute>\n            <AnimatedPage>\n              <Messages />\n            </AnimatedPage>\n          </ProtectedRoute>\n        </Route>\n        <Route path=\"/profile\">\n          <ProtectedRoute>\n            <AnimatedPage>\n              <Profile />\n            </AnimatedPage>\n          </ProtectedRoute>\n        </Route>\n        <Route path=\"/payment/:eventId\">\n          <ProtectedRoute>\n            <AnimatedPage>\n              <Payment />\n            </AnimatedPage>\n          </ProtectedRoute>\n        </Route>\n        <Route path=\"/auth\">\n          <AnimatedPage>\n            <AuthPage />\n          </AnimatedPage>\n        </Route>\n        <Route path=\"/auth-test\">\n          <AnimatedPage>\n            <AuthTest />\n          </AnimatedPage>\n        </Route>\n        <Route path=\"/login\">\n          {() => {\n            window.location.replace(\"/auth\");\n            return null;\n          }}\n        </Route>\n        <Route>\n          <AnimatedPage>\n            <NotFound />\n          </AnimatedPage>\n        </Route>\n      </Switch>\n      </AnimatePresence>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <AuthProvider>\n        <ZIndexProvider>\n          <MapProvider>\n            <NavigationProvider>\n              <UserProfileProvider>\n                <Router />\n                <UserProfilePanel />\n                <Toaster />\n              </UserProfileProvider>\n            </NavigationProvider>\n          </MapProvider>\n        </ZIndexProvider>\n      </AuthProvider>\n    </QueryClientProvider>\n  );\n}\n\nexport default App;\n","size_bytes":4877},"client/src/index.css":{"content":"/* Mapbox GL CSS */\n@import \"mapbox-gl/dist/mapbox-gl.css\";\n\n/* Ocultar TODOS los controles de Mapbox completamente */\n.mapboxgl-ctrl-group,\n.mapboxgl-ctrl-top-right,\n.mapboxgl-ctrl-bottom-right,\n.mapboxgl-ctrl-bottom-left,\n.mapboxgl-ctrl-top-left,\n.mapboxgl-ctrl {\n  display: none !important;\n}\n\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n/* No eliminamos los selectores nativos de fecha y hora para mantener la funcionalidad */\n\n/* Estilos personalizados para solucionar problemas de scroll en formularios */\n.edit-event-container {\n  height: auto;\n  max-height: calc(90vh - 100px);\n  overflow-y: auto !important;\n  padding-bottom: 120px;\n  display: flex;\n  flex-direction: column;\n  flex: 1;\n}\n\n/* Estilos específicos para el contenedor de edición en el panel */\n.event-edit-container {\n  overflow-y: auto !important;\n  height: auto;\n  min-height: 100%;\n  max-height: none;\n  padding-bottom: 150px;\n  -webkit-overflow-scrolling: touch;\n}\n\n/* Animaciones para el panel deslizante */\n.slide-up {\n  animation: slideUpAnimation 0.3s ease-out forwards;\n}\n\n.slide-down {\n  animation: slideDownAnimation 0.3s ease-out forwards;\n}\n\n@keyframes slideUpAnimation {\n  from {\n    transform: translateY(100%);\n    opacity: 0;\n  }\n  to {\n    transform: translateY(0);\n    opacity: 1;\n  }\n}\n\n@keyframes slideDownAnimation {\n  from {\n    transform: translateY(0);\n    opacity: 1;\n  }\n  to {\n    transform: translateY(100%);\n    opacity: 0;\n  }\n}\n\n/* Animaciones para las tarjetas de chat que se despliegan hacia arriba */\n@keyframes slideUpCard {\n  from {\n    transform: translateY(20px);\n    opacity: 0;\n    scale: 0.95;\n  }\n  to {\n    transform: translateY(0);\n    opacity: 1;\n    scale: 1;\n  }\n}\n\n/* Hide scrollbar while maintaining scrollability */\n.scrollbar-hide {\n  -ms-overflow-style: none;  /* Internet Explorer 10+ */\n  scrollbar-width: none;  /* Firefox */\n}\n\n.scrollbar-hide::-webkit-scrollbar { \n  display: none;  /* Safari and Chrome */\n}\n\n/* Custom slider styles for the distance filter */\n[data-radix-slider-root] {\n  position: relative;\n  display: flex;\n  align-items: center;\n  user-select: none;\n  touch-action: none;\n  width: 100%;\n  height: 20px;\n}\n\n[data-radix-slider-track] {\n  background-color: rgba(255, 255, 255, 0.2);\n  position: relative;\n  flex-grow: 1;\n  border-radius: 9999px;\n  height: 3px;\n}\n\n[data-radix-slider-range] {\n  position: absolute;\n  background-color: rgba(255, 255, 255, 0.8);\n  border-radius: 9999px;\n  height: 100%;\n}\n\n[data-radix-slider-thumb] {\n  display: block;\n  width: 20px;\n  height: 20px;\n  background-color: white;\n  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);\n  border-radius: 10px;\n  border: 2px solid rgba(255, 255, 255, 0.9);\n  cursor: grab;\n  transition: all 0.2s ease;\n}\n\n[data-radix-slider-thumb]:hover {\n  transform: scale(1.1);\n  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.6);\n}\n\n[data-radix-slider-thumb]:focus {\n  outline: none;\n  box-shadow: 0 0 0 5px rgba(255, 255, 255, 0.3);\n}\n\n[data-radix-slider-thumb]:active {\n  cursor: grabbing;\n  transform: scale(1.05);\n}\n\n.animate-slide-up-card {\n  animation: slideUpCard 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;\n}\n\n/* Mejoras visuales para las tarjetas de chat */\n.chat-card-shadow {\n  box-shadow: \n    0 10px 25px rgba(0, 0, 0, 0.1),\n    0 5px 10px rgba(0, 0, 0, 0.05),\n    0 1px 3px rgba(0, 0, 0, 0.1);\n}\n\n.chat-card-shadow-blue {\n  box-shadow: \n    0 10px 25px rgba(59, 130, 246, 0.3),\n    0 5px 10px rgba(59, 130, 246, 0.2),\n    0 1px 3px rgba(59, 130, 246, 0.1);\n}\n\n/* Estilos para formularios en vistas de edición */\n.edit-form-myevents {\n  display: flex;\n  flex-direction: column;\n  min-height: 100vh;\n  padding-bottom: 120px;\n  overflow-y: auto;\n}\n\n/* Estilos para campos de solo lectura */\n.readonly-field {\n  background-color: #f3f4f6;\n  padding: 8px 12px;\n  border-radius: 6px;\n  color: #4b5563;\n  font-size: 0.875rem;\n  line-height: 1.25rem;\n}\n\n/* Pulsating circle animation for map marker */\n.pulsating-circle {\n  width: 20px;\n  height: 20px;\n  border-radius: 50%;\n  background-color: #FF5A5F;\n  box-shadow: 0 0 0 rgba(255, 90, 95, 0.4);\n  animation: pulse 1.5s infinite;\n}\n\n@keyframes pulse {\n  0% {\n    box-shadow: 0 0 0 0 rgba(255, 90, 95, 0.4);\n  }\n  70% {\n    box-shadow: 0 0 0 20px rgba(255, 90, 95, 0);\n  }\n  100% {\n    box-shadow: 0 0 0 0 rgba(255, 90, 95, 0);\n  }\n}\n\n/* Autocomplete dropdown styles */\n.mapboxgl-ctrl-geocoder {\n  width: 100% !important;\n  max-width: 100% !important;\n  font-family: inherit !important;\n  border-radius: 0.75rem !important;\n  box-shadow: none !important;\n  border: 1px solid #e5e7eb !important;\n}\n\n.mapboxgl-ctrl-geocoder--input {\n  height: 50px !important;\n  padding: 0.75rem 1rem !important;\n  font-size: 1rem !important;\n}\n\n.mapboxgl-ctrl-geocoder--suggestion {\n  padding: 0.75rem 1rem !important;\n  font-size: 0.875rem !important;\n}\n\n.mapboxgl-ctrl-geocoder--suggestion-title {\n  font-weight: 600 !important;\n}\n\n.mapboxgl-ctrl-geocoder--suggestion-address {\n  color: #6b7280 !important;\n}\n\n@layer base {\n  :root {\n    --background: 0 0% 100%;\n    --foreground: 0 0% 0%;\n\n    --card: 0 0% 100%;\n    --card-foreground: 0 0% 0%;\n\n    --popover: 0 0% 100%;\n    --popover-foreground: 0 0% 0%;\n\n    --primary: 49 100% 50%;\n    --primary-foreground: 0 0% 0%;\n\n    --primary-dark: 49 100% 45%;\n    --primary-light: 49 100% 96%;\n\n    --secondary: 0 0% 9%;\n    --secondary-foreground: 0 0% 100%;\n\n    --muted: 0 0% 96.1%;\n    --muted-foreground: 0 0% 45.9%;\n\n    --accent: 49 100% 50%;\n    --accent-foreground: 0 0% 0%;\n\n    --destructive: 0 84.2% 60.2%;\n    --destructive-foreground: 0 0% 98%;\n\n    --border: 0 0% 89.8%;\n    --input: 0 0% 89.8%;\n    --ring: 49 100% 50%;\n\n    --radius: 0.75rem;\n  }\n\n  .dark {\n    --background: 0 0% 3.9%;\n    --foreground: 0 0% 98%;\n\n    --card: 0 0% 3.9%;\n    --card-foreground: 0 0% 98%;\n\n    --popover: 0 0% 3.9%;\n    --popover-foreground: 0 0% 98%;\n\n    --primary: 49 100% 50%;\n    --primary-foreground: 0 0% 0%;\n\n    --primary-dark: 49 100% 45%;\n    --primary-light: 49 100% 96%;\n\n    --secondary: 0 0% 14.9%;\n    --secondary-foreground: 0 0% 98%;\n\n    --muted: 0 0% 14.9%;\n    --muted-foreground: 0 0% 63.9%;\n\n    --accent: 49 100% 50%;\n    --accent-foreground: 0 0% 0%;\n\n    --destructive: 0 62.8% 30.6%;\n    --destructive-foreground: 0 0% 98%;\n\n    --border: 0 0% 14.9%;\n    --input: 0 0% 14.9%;\n    --ring: 49 100% 50%;\n  }\n}\n\n@layer base {\n  * {\n    @apply border-border;\n  }\n\n  body {\n    @apply font-sans antialiased bg-background text-foreground;\n    -webkit-font-smoothing: antialiased;\n    overscroll-behavior-y: none;\n  }\n}\n\n.map-container, \n.mapboxgl-map,\n.mapboxgl-canvas-container,\n.mapboxgl-canvas {\n  height: 100% !important;\n  width: 100% !important;\n}\n\n.pin-bounce {\n  animation: bounce 0.6s ease-in-out;\n}\n\n@keyframes bounce {\n  0%, 100% { transform: translateY(0); }\n  50% { transform: translateY(-10px); }\n}\n\n/* Esta sección se eliminó para evitar duplicación con la definición anterior */\n\n.category-social { @apply bg-[#4361EE] text-white; }\n.category-music { @apply bg-[#8338EC] text-white; }\n.category-spiritual { @apply bg-[#9E8FB2] text-white; }\n.category-education { @apply bg-[#F94144] text-white; }\n.category-sports { @apply bg-[#3A86FF] text-white; }\n.category-food { @apply bg-[#FB8500] text-white; }\n.category-art { @apply bg-[#F15BB5] text-white; }\n.category-technology { @apply bg-[#06D6A0] text-white; }\n.category-games { @apply bg-[#EB2F96] text-white; }\n.category-outdoor { @apply bg-[#9254DE] text-white; }\n.category-networking { @apply bg-[#FA541C] text-white; }\n.category-workshop { @apply bg-[#FAAD14] text-white; }\n.category-conference { @apply bg-[#595959] text-white; }\n.category-party { @apply bg-[#F5222D] text-white; }\n.category-fair { @apply bg-[#FA8C16] text-white; }\n.category-exhibition { @apply bg-[#722ED1] text-white; }\n\n.category-social-light { @apply bg-[#4361EE]/10 text-[#4361EE]; }\n.category-music-light { @apply bg-[#8338EC]/10 text-[#8338EC]; }\n.category-spiritual-light { @apply bg-[#9E8FB2]/10 text-[#9E8FB2]; }\n.category-education-light { @apply bg-[#F94144]/10 text-[#F94144]; }\n.category-sports-light { @apply bg-[#3A86FF]/10 text-[#3A86FF]; }\n.category-food-light { @apply bg-[#FB8500]/10 text-[#FB8500]; }\n.category-art-light { @apply bg-[#F15BB5]/10 text-[#F15BB5]; }\n.category-technology-light { @apply bg-[#06D6A0]/10 text-[#06D6A0]; }\n.category-games-light { @apply bg-[#EB2F96]/10 text-[#EB2F96]; }\n.category-outdoor-light { @apply bg-[#9254DE]/10 text-[#9254DE]; }\n.category-networking-light { @apply bg-[#FA541C]/10 text-[#FA541C]; }\n.category-workshop-light { @apply bg-[#FAAD14]/10 text-[#FAAD14]; }\n.category-conference-light { @apply bg-[#595959]/10 text-[#595959]; }\n.category-party-light { @apply bg-[#F5222D]/10 text-[#F5222D]; }\n.category-fair-light { @apply bg-[#FA8C16]/10 text-[#FA8C16]; }\n.category-exhibition-light { @apply bg-[#722ED1]/10 text-[#722ED1]; }\n\n.shadow-card {\n  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);\n}\n\n.shadow-bottom {\n  box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.05);\n}\n\n.shadow-panel {\n  box-shadow: 0 -4px 16px rgba(0, 0, 0, 0.1);\n  border-top-left-radius: 1.5rem;\n  border-top-right-radius: 1.5rem;\n  overflow: hidden;\n}\n\n/* Better scrolling for event detail cards */\n.shadow-panel .flex-1::-webkit-scrollbar {\n  width: 6px;\n}\n\n.shadow-panel .flex-1::-webkit-scrollbar-track {\n  background: rgba(0, 0, 0, 0.05);\n  border-radius: 10px;\n}\n\n.shadow-panel .flex-1::-webkit-scrollbar-thumb {\n  background: #d1d5db;\n  border-radius: 10px;\n}\n\n.shadow-panel .flex-1::-webkit-scrollbar-thumb:hover {\n  background: #9ca3af;\n}\n\n/* Ensure smooth scrolling on mobile */\n.shadow-panel .flex-1 {\n  -webkit-overflow-scrolling: touch;\n  scrollbar-width: thin;\n  scrollbar-color: #d1d5db transparent;\n}\n\n/* Mapbox Marker Styles */\n.event-marker {\n  width: 42px; /* Más grande para mejor visibilidad */\n  height: 42px;\n  border-radius: 50%;\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: relative;\n  border: 2px solid white;\n  box-shadow: 0 3px 8px rgba(0, 0, 0, 0.35);\n  font-size: 16px; /* Texto más grande */\n  font-weight: bold;\n  color: white;\n  transition: transform 0.2s, box-shadow 0.2s;\n  z-index: 1;\n}\n\n.event-marker:hover {\n  transform: scale(1.15);\n  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);\n  z-index: 2;\n}\n\n.event-marker.social { background-color: #4361EE; }\n.event-marker.music { background-color: #8338EC; }\n.event-marker.spiritual { background-color: #9E8FB2; }\n.event-marker.education { background-color: #F94144; }\n.event-marker.sports { background-color: #3A86FF; }\n.event-marker.food { background-color: #FB8500; }\n.event-marker.art { background-color: #F15BB5; }\n.event-marker.technology { background-color: #06D6A0; }\n.event-marker.games { background-color: #EB2F96; }\n.event-marker.outdoor { background-color: #9254DE; }\n.event-marker.networking { background-color: #FA541C; }\n.event-marker.workshop { background-color: #FAAD14; }\n.event-marker.conference { background-color: #595959; }\n.event-marker.party { background-color: #F5222D; }\n.event-marker.fair { background-color: #FA8C16; }\n.event-marker.exhibition { background-color: #722ED1; }\n\n/* Mapbox Popup Styles - Nuevo diseño */\n.mapboxgl-popup-content {\n  padding: 12px;\n  border-radius: 12px;\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);\n  border: none;\n}\n\n.mapboxgl-popup-close-button {\n  color: #666;\n  font-size: 18px;\n  padding: 4px;\n  line-height: 1;\n  right: 6px;\n  top: 6px;\n  transition: color 0.2s;\n}\n\n.mapboxgl-popup-close-button:hover {\n  color: #333;\n  background: none;\n}\n\n/* Estilos específicos para los nuevos popups de eventos */\n.event-popup .mapboxgl-popup-content {\n  padding: 12px;\n  border-radius: 12px;\n  background-color: white;\n  border: none;\n  overflow: hidden;\n}\n\n.event-popup .mapboxgl-popup-tip {\n  border-top-color: white;\n}\n\n.popup-content {\n  min-width: 180px;\n  max-width: 240px;\n}\n\n.event-popup-category {\n  font-size: 11px;\n  font-weight: bold;\n  text-transform: uppercase;\n  color: #9254DE;\n  margin-bottom: 4px;\n  letter-spacing: 0.5px;\n}\n\n.event-popup-image {\n  height: 100px;\n  width: 100%;\n  border-radius: 8px;\n  margin-bottom: 10px;\n  background-size: cover;\n  background-position: center;\n  overflow: hidden;\n}\n\n.event-popup-image-placeholder {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  font-size: 36px;\n  font-weight: bold;\n}\n\n.event-popup-button {\n  display: block;\n  width: 100%;\n  padding: 8px 12px;\n  margin-top: 10px;\n  background-color: #3B82F6;\n  color: white;\n  border: none;\n  border-radius: 6px;\n  cursor: pointer;\n  font-weight: bold;\n  font-size: 14px;\n  transition: all 0.2s ease;\n}\n\n.event-popup-button:hover {\n  background-color: #2563EB;\n  transform: translateY(-2px);\n}\n\n.event-popup-title {\n  font-size: 16px;\n  font-weight: bold;\n  margin: 0 0 8px 0;\n  line-height: 1.3;\n  color: #000;\n}\n\n.event-popup-details {\n  margin-bottom: 8px;\n}\n\n.event-popup-date-time,\n.event-popup-location {\n  display: flex;\n  align-items: center;\n  font-size: 12px;\n  margin-bottom: 4px;\n  color: #555;\n}\n\n.event-popup-icon {\n  margin-right: 5px;\n  font-size: 11px;\n}\n\n.event-popup-footer {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-top: 8px;\n}\n\n.event-popup-attendees {\n  display: flex;\n  align-items: center;\n  font-size: 12px;\n  color: #555;\n}\n\n.event-popup-payment-type {\n  padding: 3px 8px;\n  border-radius: 30px;\n  font-size: 11px;\n  font-weight: bold;\n}\n\n.event-popup-payment-type.free {\n  background-color: #FFEDD5;\n  color: #fff700;\n}\n\n.event-popup-payment-type.paid {\n  background-color: #EFF6FF;\n  color: #3B82F6;\n}\n\n/* Estilo para el botón en el popup */\n.popup-content button {\n  transition: transform 0.2s, box-shadow 0.2s;\n}\n\n.popup-content button:hover {\n  transform: translateY(-2px);\n  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);\n}\n\n.marker-shadow {\n  position: absolute;\n  bottom: -4px;\n  left: 50%;\n  transform: translateX(-50%);\n  width: 20px;\n  height: 4px;\n  background: rgba(0, 0, 0, 0.2);\n  border-radius: 50%;\n  filter: blur(2px);\n}\n\n.custom-marker-container {\n  transform: translate(-50%, -100%);\n}\n\n/* Las animaciones de panel se definieron anteriormente, eliminando esta duplicación */\n","size_bytes":14174},"client/src/main.tsx":{"content":"import React from \"react\";\nimport { createRoot } from \"react-dom/client\";\nimport App from \"./App\";\nimport \"mapbox-gl/dist/mapbox-gl.css\";\nimport \"./index.css\";\n\n// Add comprehensive error handlers\nwindow.addEventListener('unhandledrejection', (event) => {\n  console.error('Unhandled promise rejection:', event.reason);\n  // Prevent the default browser behavior which would print to console\n  event.preventDefault();\n});\n\nwindow.addEventListener('error', (event) => {\n  console.error('Global error:', event.error);\n  event.preventDefault();\n});\n\n// Add AbortController signal handling\nwindow.addEventListener('beforeunload', () => {\n  // Clean up any pending requests or connections\n  if ((window as any).simpleChatService) {\n    (window as any).simpleChatService.disconnect();\n  }\n});\n\n// Create root and render app\nconst rootElement = document.getElementById(\"root\");\nif (rootElement) {\n  createRoot(rootElement).render(<App />);\n} else {\n  console.error(\"Root element not found\");\n}\n","size_bytes":985},"client/src/vite-env.d.ts":{"content":"/// <reference types=\"vite/client\" />\n\ninterface ImportMetaEnv {\n  readonly VITE_SUPABASE_URL: string\n  readonly VITE_SUPABASE_ANON_KEY: string\n}\n\ninterface ImportMeta {\n  readonly env: ImportMetaEnv\n}","size_bytes":201},"db/migrations/01_add_status_to_event_attendees.js":{"content":"// Importar módulo pg\nconst { Pool } = require('pg');\n\nasync function run() {\n  console.log('Running migration: Add status column to event_attendees');\n  \n  const pool = new Pool({ connectionString: process.env.DATABASE_URL });\n  \n  try {\n    // Create the enum type if it doesn't exist\n    await pool.query(`\n      DO $$\n      BEGIN\n        IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'attendee_status') THEN\n          CREATE TYPE attendee_status AS ENUM ('pending', 'approved', 'rejected');\n        END IF;\n      END\n      $$;\n    `);\n    \n    // Check if the column already exists to avoid errors\n    const checkResult = await pool.query(`\n      SELECT column_name\n      FROM information_schema.columns\n      WHERE table_name = 'event_attendees' AND column_name = 'status';\n    `);\n    \n    if (checkResult.rows.length === 0) {\n      // Add status column with default value 'approved' for existing records\n      await pool.query(`\n        ALTER TABLE event_attendees\n        ADD COLUMN status attendee_status NOT NULL DEFAULT 'approved';\n      `);\n      console.log('Status column added successfully');\n    } else {\n      console.log('Status column already exists, skipping');\n    }\n    \n    console.log('Migration completed successfully');\n  } catch (error) {\n    console.error('Migration failed:', error);\n    throw error;\n  } finally {\n    await pool.end();\n  }\n}\n\n// Execute the migration\nrun()\n  .then(() => console.log('Migration completed'))\n  .catch(err => {\n    console.error('Error in migration:', err);\n    process.exit(1);\n  });","size_bytes":1553},"db/migrations/01_add_status_to_event_attendees.ts":{"content":"import pg from 'pg';\nconst { Pool } = pg;\n\nexport async function run() {\n  console.log('Running migration: Add status column to event_attendees');\n  \n  const pool = new Pool({ connectionString: process.env.DATABASE_URL });\n  \n  try {\n    // Create the enum type if it doesn't exist\n    await pool.query(`\n      DO $$\n      BEGIN\n        IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'attendee_status') THEN\n          CREATE TYPE attendee_status AS ENUM ('pending', 'approved', 'rejected');\n        END IF;\n      END\n      $$;\n    `);\n    \n    // Check if the column already exists to avoid errors\n    const checkResult = await pool.query(`\n      SELECT column_name\n      FROM information_schema.columns\n      WHERE table_name = 'event_attendees' AND column_name = 'status';\n    `);\n    \n    if (checkResult.rows.length === 0) {\n      // Add status column with default value 'approved' for existing records\n      await pool.query(`\n        ALTER TABLE event_attendees\n        ADD COLUMN status attendee_status NOT NULL DEFAULT 'approved';\n      `);\n      console.log('Status column added successfully');\n    } else {\n      console.log('Status column already exists, skipping');\n    }\n    \n    console.log('Migration completed successfully');\n  } catch (error) {\n    console.error('Migration failed:', error);\n    throw error;\n  } finally {\n    await pool.end();\n  }\n}\n\n// Execute the migration\nrun()\n  .then(() => console.log('Migration completed successfully'))\n  .catch(err => {\n    console.error('Error in migration:', err);\n    process.exit(1);\n  });","size_bytes":1560},"server/helpers/media-preserver.ts":{"content":"import { storage } from '../storage';\nimport { deleteFile } from '../supabase-storage';\n\n/**\n * Preserves existing media when a client sends incomplete media data\n * This function is used to keep existing media files when the client\n * submits an update form without all media information\n * \n * @param eventId The ID of the event\n * @param mediaItemsFromClient Media items sent by the client\n * @returns Array of complete media items\n */\nexport async function preserveExistingMedia(eventId: number, mediaItemsFromClient: any[] = []) {\n  try {\n    // Get the event with its media items\n    const event = await storage.getEventById(eventId);\n    \n    if (!event || !Array.isArray(event.mediaItems)) {\n      console.log('No event found or no media items to preserve');\n      return mediaItemsFromClient;\n    }\n    \n    // Track which items should be preserved\n    const clientMediaUrls = new Set(\n      mediaItemsFromClient\n        .filter(item => !item.deleted && !item.toDelete)\n        .map(item => item.url)\n    );\n    \n    // Items to delete\n    const itemsToDelete = mediaItemsFromClient\n      .filter(item => item.deleted || item.toDelete)\n      .map(item => item.url)\n      .filter(Boolean);\n    \n    // Delete items that are marked for deletion\n    if (itemsToDelete.length > 0) {\n      console.log(`Will delete ${itemsToDelete.length} media items`);\n      \n      for (const url of itemsToDelete) {\n        try {\n          await deleteFile(url);\n          console.log(`Deleted file: ${url}`);\n        } catch (error) {\n          console.error(`Error deleting file ${url}:`, error);\n        }\n      }\n    }\n    \n    // Preserve existing media not explicitly deleted\n    const preservedItems = event.mediaItems\n      .filter(item => {\n        // Keep if not marked for deletion on client side\n        return !itemsToDelete.includes(item.url);\n      })\n      .map(item => ({\n        id: item.id,\n        type: item.type,\n        url: item.url,\n        order: item.order || 0,\n        isMain: !!item.isMain\n      }));\n    \n    // New items from the client (excluding those marked for deletion)\n    const newItems = mediaItemsFromClient\n      .filter(item => {\n        return !item.deleted && \n               !item.toDelete && \n               !preservedItems.some(p => p.url === item.url);\n      })\n      .map(item => ({\n        type: item.type,\n        url: item.url,\n        order: item.order || 0,\n        isMain: !!item.isMain\n      }));\n    \n    // Combine preserved and new items\n    const combinedItems = [...preservedItems, ...newItems];\n    \n    // Sort by order\n    combinedItems.sort((a, b) => (a.order || 0) - (b.order || 0));\n    \n    console.log(`Media preservation result: ${preservedItems.length} preserved, ${newItems.length} new`);\n    \n    return combinedItems;\n  } catch (error) {\n    console.error('Error in preserveExistingMedia:', error);\n    return mediaItemsFromClient;\n  }\n}","size_bytes":2902},"server/migrations/add-supabase-id.ts":{"content":"import { db } from '../db';\nimport { sql } from 'drizzle-orm';\n\n// This script adds the supabase_id column to the users table\nasync function addSupabaseIdColumn() {\n  try {\n    console.log('Adding supabase_id column to users table...');\n    \n    // Check if column already exists\n    const checkColumnQuery = sql`\n      SELECT column_name \n      FROM information_schema.columns \n      WHERE table_name = 'users' AND column_name = 'supabase_id'\n    `;\n    \n    const columnExists = await db.execute(checkColumnQuery);\n    \n    if (columnExists.length === 0) {\n      // Add the column if it doesn't exist\n      await db.execute(sql`\n        ALTER TABLE users\n        ADD COLUMN supabase_id TEXT UNIQUE\n      `);\n      console.log('Successfully added supabase_id column to users table');\n    } else {\n      console.log('Column supabase_id already exists in users table');\n    }\n    \n  } catch (error) {\n    console.error('Error adding supabase_id column:', error);\n    throw error;\n  }\n}\n\n// Execute the migration\n(async () => {\n  try {\n    await addSupabaseIdColumn();\n    console.log('Migration completed successfully');\n    process.exit(0);\n  } catch (error) {\n    console.error('Migration failed:', error);\n    process.exit(1);\n  }\n})();","size_bytes":1238},"client/src/contexts/MapContext.tsx":{"content":"import React, { createContext, useContext, useRef, useCallback, ReactNode } from 'react';\nimport mapboxgl from 'mapbox-gl';\n\ninterface CameraState {\n  center: mapboxgl.LngLat;\n  zoom: number;\n  bearing: number;\n  pitch: number;\n}\n\ninterface MapContextType {\n  mapRef: React.MutableRefObject<mapboxgl.Map | null>;\n  savedCameraState: React.MutableRefObject<CameraState | null>;\n  saveCameraState: () => void;\n  restoreCameraState: () => void;\n  setMapInstance: (map: mapboxgl.Map) => void;\n  clearMapInstance: () => void;\n}\n\nconst MapContext = createContext<MapContextType | undefined>(undefined);\n\nexport const MapProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const mapRef = useRef<mapboxgl.Map | null>(null);\n  const savedCameraState = useRef<CameraState | null>(null);\n\n  const setMapInstance = useCallback((map: mapboxgl.Map) => {\n    mapRef.current = map;\n    console.log(\"🗺️ MAP: Instancia del mapa configurada en el contexto\");\n    console.log(\"🗺️ MAP: mapRef.current ahora es:\", mapRef.current);\n  }, []);\n\n  // Limpiar referencias cuando el componente se desmonte\n  const clearMapInstance = useCallback(() => {\n    mapRef.current = null;\n    savedCameraState.current = null;\n    console.log(\"🗺️ MAP: Referencias del mapa limpiadas del contexto\");\n  }, []);\n\n  const saveCameraState = useCallback(() => {\n    console.log(\"🚨 DEBUG: saveCameraState() EJECUTÁNDOSE\");\n    console.log(\"🚨 DEBUG: mapRef.current =\", mapRef.current);\n    if (!mapRef.current) {\n      console.warn(\"⚠️ CAMERA: No hay instancia del mapa para guardar el estado\");\n      return;\n    }\n\n    const currentState: CameraState = {\n      center: mapRef.current.getCenter(),\n      zoom: mapRef.current.getZoom(),\n      bearing: mapRef.current.getBearing(),\n      pitch: mapRef.current.getPitch()\n    };\n\n    savedCameraState.current = currentState;\n    console.log(\"🎥 CAMERA: Estado de cámara guardado:\", currentState);\n  }, []);\n\n  const restoreCameraState = useCallback(() => {\n    console.log(\"🚨 DEBUG: restoreCameraState() EJECUTÁNDOSE\");\n    console.log(\"🚨 DEBUG: mapRef.current =\", mapRef.current);\n    console.log(\"🚨 DEBUG: savedCameraState.current =\", savedCameraState.current);\n    console.log(\"🔄 RESTORE: Intentando restaurar cámara...\");\n    \n    if (!mapRef.current) {\n      console.error(\"❌ RESTORE: No hay instancia del mapa\");\n      return;\n    }\n\n    if (!savedCameraState.current) {\n      console.warn(\"⚠️ RESTORE: No hay estado guardado de la cámara\");\n      return;\n    }\n\n    console.log(\"🔄 RESTORE: Ejecutando flyTo con estado:\", savedCameraState.current);\n    \n    mapRef.current.flyTo({\n      center: savedCameraState.current.center,\n      zoom: savedCameraState.current.zoom,\n      bearing: savedCameraState.current.bearing,\n      pitch: savedCameraState.current.pitch,\n      duration: 1200,\n      essential: true\n    });\n\n    console.log(\"🔄 RESTORE: flyTo ejecutado exitosamente\");\n    \n    // Limpiar el estado guardado después de la restauración\n    savedCameraState.current = null;\n    console.log(\"🔄 RESTORE: Estado guardado limpiado\");\n  }, []);\n\n  const value: MapContextType = {\n    mapRef,\n    savedCameraState,\n    saveCameraState,\n    restoreCameraState,\n    setMapInstance,\n    clearMapInstance\n  };\n\n  return (\n    <MapContext.Provider value={value}>\n      {children}\n    </MapContext.Provider>\n  );\n};\n\nexport const useMap = (): MapContextType => {\n  const context = useContext(MapContext);\n  if (context === undefined) {\n    throw new Error('useMap debe ser usado dentro de un MapProvider');\n  }\n  return context;\n};","size_bytes":3611},"client/src/contexts/navigation-context.tsx":{"content":"import React, { createContext, useContext, useState, ReactNode } from 'react';\n\ninterface NavigationContextType {\n  isNavigationVisible: boolean;\n  hideNavigation: () => void;\n  showNavigation: () => void;\n}\n\nconst NavigationContext = createContext<NavigationContextType | undefined>(undefined);\n\nexport const useNavigation = () => {\n  const context = useContext(NavigationContext);\n  if (!context) {\n    throw new Error('useNavigation must be used within a NavigationProvider');\n  }\n  return context;\n};\n\ninterface NavigationProviderProps {\n  children: ReactNode;\n}\n\nexport const NavigationProvider = ({ children }: NavigationProviderProps) => {\n  const [isNavigationVisible, setIsNavigationVisible] = useState(true);\n\n  const hideNavigation = () => {\n    console.log(\"🎯 NavigationContext: hideNavigation() called\");\n    setIsNavigationVisible(false);\n  };\n  \n  const showNavigation = () => {\n    console.log(\"🎯 NavigationContext: showNavigation() called\");\n    setIsNavigationVisible(true);\n  };\n\n  return (\n    <NavigationContext.Provider \n      value={{ \n        isNavigationVisible, \n        hideNavigation, \n        showNavigation \n      }}\n    >\n      {children}\n    </NavigationContext.Provider>\n  );\n};","size_bytes":1217},"client/src/contexts/user-profile-context.tsx":{"content":"import React, { createContext, useContext, useState, ReactNode } from 'react';\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  username?: string;\n  bio?: string;\n  avatar?: string;\n  createdAt?: string;\n}\n\ninterface UserProfileContextType {\n  selectedUser: User | null;\n  isProfileOpen: boolean;\n  showUserProfile: (user: User) => void;\n  hideUserProfile: () => void;\n}\n\nconst UserProfileContext = createContext<UserProfileContextType | undefined>(undefined);\n\nexport const useUserProfile = () => {\n  const context = useContext(UserProfileContext);\n  if (!context) {\n    throw new Error('useUserProfile must be used within a UserProfileProvider');\n  }\n  return context;\n};\n\ninterface UserProfileProviderProps {\n  children: ReactNode;\n}\n\nexport const UserProfileProvider: React.FC<UserProfileProviderProps> = ({ children }) => {\n  const [selectedUser, setSelectedUser] = useState<User | null>(null);\n  const [isProfileOpen, setIsProfileOpen] = useState(false);\n\n  const showUserProfile = (user: User) => {\n    setSelectedUser(user);\n    setIsProfileOpen(true);\n  };\n\n  const hideUserProfile = () => {\n    setIsProfileOpen(false);\n    setSelectedUser(null);\n  };\n\n  return (\n    <UserProfileContext.Provider\n      value={{\n        selectedUser,\n        isProfileOpen,\n        showUserProfile,\n        hideUserProfile,\n      }}\n    >\n      {children}\n    </UserProfileContext.Provider>\n  );\n};","size_bytes":1409},"client/src/contexts/z-index-context.tsx":{"content":"import React, { createContext, useContext, useState, useCallback } from 'react';\n\ntype ZIndexContextType = {\n  getNextZIndex: () => number;\n  resetZIndex: () => void;\n  baseZIndex: number;\n};\n\nconst ZIndexContext = createContext<ZIndexContextType | undefined>(undefined);\n\nexport const ZIndexProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const [currentZIndex, setCurrentZIndex] = useState(100);\n  const baseZIndex = 100;\n\n  const getNextZIndex = useCallback(() => {\n    setCurrentZIndex(prev => prev + 10);\n    return currentZIndex + 10;\n  }, [currentZIndex]);\n\n  const resetZIndex = useCallback(() => {\n    setCurrentZIndex(baseZIndex);\n  }, [baseZIndex]);\n\n  return (\n    <ZIndexContext.Provider value={{ getNextZIndex, resetZIndex, baseZIndex }}>\n      {children}\n    </ZIndexContext.Provider>\n  );\n};\n\nexport const useZIndex = () => {\n  const context = useContext(ZIndexContext);\n  if (context === undefined) {\n    throw new Error('useZIndex must be used within a ZIndexProvider');\n  }\n  return context;\n};","size_bytes":1038},"client/src/hooks/use-auth.tsx":{"content":"import { createContext, ReactNode, useContext, useState, useEffect } from 'react';\nimport {\n  useQuery,\n  useMutation,\n  UseMutationResult,\n} from '@tanstack/react-query';\nimport { User } from '@shared/schema';\nimport { queryClient } from '@/lib/queryClient';\nimport { useToast } from '@/hooks/use-toast';\nimport { useLocation } from 'wouter';\nimport { TokenManager } from '@/lib/token-manager';\n\ntype LoginData = {\n  email: string;\n  password: string;\n};\n\ntype RegisterData = {\n  username: string;\n  email: string;\n  password: string;\n  name: string;\n};\n\ntype UpdateUserData = {\n  name?: string;\n  bio?: string;\n  avatar?: string;\n  gender?: string;\n};\n\ntype UpdateUserFormData = UpdateUserData | FormData;\n\ntype AuthContextType = {\n  user: User | null;\n  isLoading: boolean;\n  error: Error | null;\n  isLoggedIn: boolean;\n  loginMutation: UseMutationResult<User, Error, LoginData>;\n  logoutMutation: UseMutationResult<void, Error, void>;\n  registerMutation: UseMutationResult<User, Error, RegisterData>;\n  updateUserMutation: UseMutationResult<User, Error, UpdateUserFormData>;\n};\n\nexport const AuthContext = createContext<AuthContextType | null>(null);\n\nexport function AuthProvider({ children }: { children: ReactNode }) {\n  const { toast } = useToast();\n  const [_, setLocation] = useLocation();\n  const [hasStoredToken, setHasStoredToken] = useState(() => {\n    return !!localStorage.getItem('pipol_auth_token');\n  });\n\n  // Fetch current user using session-based authentication\n  const {\n    data: user,\n    error,\n    isLoading,\n    refetch: refetchUser\n  } = useQuery({\n    queryKey: ['user', 'current'],\n    queryFn: async () => {\n      try {\n        console.log(\"Fetching current user...\");\n        \n        // Use session-based authentication with credentials\n        const res = await fetch('/api/auth/me', {\n          credentials: 'include',\n          headers: {\n            'Content-Type': 'application/json',\n            'Cache-Control': 'no-cache',\n            'X-Requested-With': 'XMLHttpRequest'\n          },\n          cache: 'no-store'\n        });\n        \n        console.log(\"User fetch status:\", res.status);\n        \n        if (res.ok) {\n          const userData = await res.json();\n          console.log(\"Current user data:\", userData);\n          setHasStoredToken(true);\n          return userData;\n        }\n        \n        if (res.status === 401) {\n          // Authentication failed, clear stored tokens\n          console.log(\"Authentication failed, clearing tokens\");\n          localStorage.removeItem('pipol_auth_token');\n          localStorage.removeItem('pipol_refresh_token');\n          setHasStoredToken(false);\n          return null;\n        }\n        \n        console.error(`Authentication failed: ${res.status}`);\n        setHasStoredToken(false);\n        return null;\n      } catch (error) {\n        console.error('Error fetching user:', error);\n        setHasStoredToken(false);\n        return null;\n      }\n    },\n    enabled: true,\n    retry: false,\n    retryDelay: 0,\n    refetchOnWindowFocus: false,\n    refetchInterval: false,\n    refetchOnMount: true,\n    refetchOnReconnect: false,\n    staleTime: 5000\n  });\n\n  // Login mutation\n  const loginMutation = useMutation({\n    mutationFn: async (credentials: LoginData) => {\n      console.log(\"Attempting login with:\", credentials.email, \"password length:\", credentials.password.length);\n      \n      try {\n        const res = await fetch('/api/auth/login', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          credentials: 'include',\n          body: JSON.stringify(credentials),\n        });\n\n        console.log(\"Login response status:\", res.status);\n        \n        if (!res.ok) {\n          const errorData = await res.json();\n          console.log(\"Login error data:\", errorData);\n          throw new Error(errorData.message || 'Login failed');\n        }\n\n        const data = await res.json();\n        console.log(\"Login success data:\", data);\n        \n        // Store token if provided (for compatibility)\n        if (data.token) {\n          localStorage.setItem('pipol_auth_token', data.token);\n          TokenManager.setToken(data.token);\n        }\n        \n        // Store user data\n        if (data.user) {\n          localStorage.setItem('pipol_user_data', JSON.stringify(data.user));\n        }\n        \n        setHasStoredToken(true);\n        return data.user;\n      } catch (error) {\n        console.error(\"Login error:\", error);\n        throw error;\n      }\n    },\n    onSuccess: (userData: User) => {\n      console.log(\"Login successful, user data:\", userData);\n      queryClient.setQueryData(['user', 'current'], userData);\n      \n      toast({\n        title: \"Login successful\",\n        description: `Welcome back, ${userData.name}!`,\n      });\n      \n      setLocation('/');\n    },\n    onError: (error: Error) => {\n      console.error(\"Login failed:\", error);\n      toast({\n        title: \"Login failed\",\n        description: error.message || \"Please check your credentials and try again.\",\n        variant: \"destructive\",\n      });\n    },\n  });\n\n  // Register mutation\n  const registerMutation = useMutation({\n    mutationFn: async (userData: RegisterData) => {\n      console.log(\"Attempting registration...\");\n      \n      const res = await fetch('/api/auth/register', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        credentials: 'include',\n        body: JSON.stringify(userData),\n      });\n\n      if (!res.ok) {\n        const errorData = await res.json();\n        throw new Error(errorData.message || 'Registration failed');\n      }\n\n      const data = await res.json();\n      \n      // Store token if provided\n      if (data.token) {\n        localStorage.setItem('pipol_auth_token', data.token);\n        TokenManager.setToken(data.token);\n      }\n      \n      return data.user;\n    },\n    onSuccess: (userData: User) => {\n      queryClient.setQueryData(['user', 'current'], userData);\n      refetchUser();\n      \n      setLocation('/');\n      \n      toast({\n        title: \"Registration successful\",\n        description: `Welcome to Pipol, ${userData.name}!`,\n      });\n    },\n    onError: (error: Error) => {\n      toast({\n        title: \"Registration failed\",\n        description: error.message || \"Please try again with different credentials.\",\n        variant: \"destructive\",\n      });\n    },\n  });\n\n  // Update user mutation\n  const updateUserMutation = useMutation({\n    mutationFn: async (updateData: UpdateUserFormData) => {\n      // Check if it's FormData (file upload) or regular JSON\n      const isFormData = updateData instanceof FormData;\n      \n      const fetchOptions: RequestInit = {\n        method: 'PUT',\n        credentials: 'include',\n      };\n\n      if (isFormData) {\n        // For file uploads, don't set Content-Type, let browser set it with boundary\n        fetchOptions.body = updateData;\n      } else {\n        // For regular updates\n        fetchOptions.headers = {\n          'Content-Type': 'application/json',\n        };\n        fetchOptions.body = JSON.stringify(updateData);\n      }\n\n      const res = await fetch('/api/auth/update', fetchOptions);\n\n      if (!res.ok) {\n        const errorData = await res.json();\n        throw new Error(errorData.message || 'Update failed');\n      }\n\n      return res.json();\n    },\n    onSuccess: (updatedUser: User) => {\n      queryClient.setQueryData(['user', 'current'], updatedUser);\n      \n      toast({\n        title: \"Profile updated\",\n        description: \"Your profile has been successfully updated.\",\n      });\n    },\n    onError: (error: Error) => {\n      toast({\n        title: \"Update failed\",\n        description: error.message || \"Failed to update profile.\",\n        variant: \"destructive\",\n      });\n    },\n  });\n\n  // Logout mutation\n  const logoutMutation = useMutation({\n    mutationFn: async () => {\n      try {\n        const res = await fetch('/api/auth/logout', {\n          method: 'POST',\n          credentials: 'include',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n        });\n\n        if (!res.ok) {\n          console.log(\"Logout request failed, but continuing with cleanup\");\n        }\n      } catch (error) {\n        console.log(\"Logout request error, but continuing with cleanup:\", error);\n      }\n      \n      // Clear all stored data regardless of server response\n      localStorage.removeItem('pipol_auth_token');\n      localStorage.removeItem('pipol_refresh_token');\n      localStorage.removeItem('pipol_user_data');\n      TokenManager.removeToken();\n    },\n    onSuccess: () => {\n      queryClient.setQueryData(['user', 'current'], null);\n      queryClient.clear();\n      \n      toast({\n        title: \"Logged out\",\n        description: \"You have been successfully logged out.\",\n      });\n      \n      setLocation('/');\n    },\n    onError: (error: Error) => {\n      toast({\n        title: \"Logout failed\",\n        description: error.message || \"Failed to logout properly.\",\n        variant: \"destructive\",\n      });\n    },\n  });\n\n  // Derive isLoggedIn from user data\n  const isLoggedIn = !!user && !isLoading;\n\n  const value: AuthContextType = {\n    user: user || null,\n    isLoading,\n    error: error as Error | null,\n    isLoggedIn,\n    loginMutation,\n    logoutMutation,\n    registerMutation,\n    updateUserMutation,\n  };\n\n  return (\n    <AuthContext.Provider value={value}>\n      {children}\n    </AuthContext.Provider>\n  );\n}\n\nexport function useAuth() {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n}","size_bytes":9698},"client/src/hooks/use-events.tsx":{"content":"import { useState, useEffect, useCallback } from 'react';\nimport { useQuery, useQueryClient, QueryClient } from '@tanstack/react-query';\nimport { simpleChatService as chatService } from '@/components/chat/simple-chat-service';\nimport { useAuth } from './use-auth';\nimport { useToast } from './use-toast';\n\n// Tipo de evento\nexport type Event = {\n  id: number;\n  title: string;\n  description: string;\n  category: string;\n  date: string;\n  latitude: string | number;\n  longitude: string | number;\n  locationName: string;\n  locationAddress: string;\n  paymentType: string;\n  price?: string | number;\n  maxCapacity?: number;\n  privacyType: string;\n  organizerId: number;\n  organizer: {\n    id: number;\n    name: string;\n    avatar?: string;\n  };\n  attendees: Array<{\n    id: number;\n    user: {\n      id: number;\n      name: string;\n      avatar?: string;\n    };\n  }>;\n};\n\n/**\n * Hook personalizado para gestionar eventos con actualizaciones en tiempo real\n */\nexport function useEvents() {\n  const { user } = useAuth();\n  const queryClient = useQueryClient();\n  const { toast } = useToast();\n\n  // Consulta para obtener todos los eventos\n  const eventsQuery = useQuery({\n    queryKey: ['/api/events'],\n    queryFn: async () => {\n      // Use session-based authentication instead of token-based\n      const response = await fetch('/api/events', {\n        credentials: 'include',\n        headers: {\n          'Content-Type': 'application/json',\n          'Cache-Control': 'no-cache'\n        }\n      });\n      \n      if (response.status === 401) {\n        // Session expired, redirect to login\n        console.log('Session expired, redirecting to login');\n        localStorage.removeItem('pipol_auth_token');\n        localStorage.removeItem('pipol_user_data');\n        window.location.reload();\n        throw new Error('Authentication expired');\n      }\n      \n      if (!response.ok) {\n        throw new Error(`Failed to fetch events: ${response.status}`);\n      }\n      \n      return response.json();\n    },\n    enabled: !!user, // Solo ejecutar si hay usuario autenticado\n    refetchOnWindowFocus: true,\n    retry: 3, // Reintentar hasta 3 veces\n    retryDelay: 1000, // Esperar 1 segundo entre intentos\n    staleTime: 60000, // Datos permanecen \"frescos\" por 60 segundos\n    refetchInterval: 60000, // Actualizar automáticamente cada 60 segundos\n  });\n\n  // Función para actualizar un evento en todas las cachés\n  const updateEventInCache = useCallback((updatedEvent: Event) => {\n    // 1. Actualizar la lista general de eventos\n    const currentEvents = queryClient.getQueryData<Event[]>(['/api/events']) || [];\n    const updatedEvents = currentEvents.map(event => \n      event.id === updatedEvent.id ? updatedEvent : event\n    );\n    queryClient.setQueryData(['/api/events'], updatedEvents);\n    \n    // 2. Actualizar la caché de detalles del evento individual\n    queryClient.setQueryData([`/api/events/${updatedEvent.id}`], updatedEvent);\n    \n    // 3. Actualizar eventos creados por el usuario\n    const createdEvents = queryClient.getQueryData<Event[]>(['/api/user/events/created']) || [];\n    if (createdEvents.length > 0) {\n      const updatedCreatedEvents = createdEvents.map(event => \n        event.id === updatedEvent.id ? updatedEvent : event\n      );\n      queryClient.setQueryData(['/api/user/events/created'], updatedCreatedEvents);\n    }\n    \n    // 4. Actualizar eventos a los que asiste el usuario\n    const attendingEvents = queryClient.getQueryData<Event[]>(['/api/user/events/attending']) || [];\n    if (attendingEvents.length > 0) {\n      const updatedAttendingEvents = attendingEvents.map(event => \n        event.id === updatedEvent.id ? updatedEvent : event\n      );\n      queryClient.setQueryData(['/api/user/events/attending'], updatedAttendingEvents);\n    }\n    \n    // 5. Emitir un evento DOM personalizado para componentes que no usan react-query\n    const eventUpdateEvent = new CustomEvent('event-updated', { \n      detail: { eventId: updatedEvent.id, data: updatedEvent } \n    });\n    window.dispatchEvent(eventUpdateEvent);\n    \n    console.log('Todas las cachés de eventos actualizadas automáticamente');\n  }, [queryClient]);\n\n  // Setup WebSocket connection when user is available\n  useEffect(() => {\n    if (user && user.id) {\n      // Setup message handler for event updates\n      const handleMessage = (message: any) => {\n        // Handle event updates\n        if (message.type === 'event_updated') {\n          console.log('Event updated received via WebSocket:', message.event);\n          \n          // Update tanstack query cache\n          updateEventInCache(message.event);\n          \n          // Show update notification (only if not the user who made the change)\n          if (user?.id !== message.event.updatedBy) {\n            toast({\n              title: \"Event updated!\",\n              description: `The event \"${message.event.title}\" has been updated.`,\n              duration: 3000\n            });\n          }\n        }\n        \n        // Handle media updates\n        if (message.type === 'event_media_updated') {\n          console.log('Event media updated received via WebSocket:', message.eventId);\n          \n          // Invalidate cache to force reload\n          queryClient.invalidateQueries({\n            queryKey: [`/api/events/${message.eventId}`]\n          });\n          \n          // Also invalidate general list to ensure updates everywhere\n          queryClient.invalidateQueries({\n            queryKey: ['/api/events']\n          });\n          \n          // Dispatch custom event for components listening to media changes\n          const mediaUpdateEvent = new CustomEvent('event-media-updated', { \n            detail: { eventId: message.eventId } \n          });\n          window.dispatchEvent(mediaUpdateEvent);\n        }\n      };\n\n      // Register the message handler\n      chatService.onMessage(handleMessage);\n      \n      // Cleanup function to remove the message handler\n      return () => {\n        chatService.removeMessageListener(handleMessage);\n      };\n    }\n  }, [user, updateEventInCache, toast]);\n\n  return {\n    events: eventsQuery.data as Event[] || [],\n    isLoading: eventsQuery.isLoading,\n    error: eventsQuery.error,\n    refetch: eventsQuery.refetch\n  };\n}","size_bytes":6248},"client/src/hooks/use-mobile.tsx":{"content":"import * as React from \"react\";\n\nconst MOBILE_BREAKPOINT = 768;\n\nexport function useMobile() {\n  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(\n    undefined,\n  );\n\n  React.useEffect(() => {\n    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);\n    const onChange = () => {\n      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);\n    };\n    mql.addEventListener(\"change\", onChange);\n    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);\n    return () => mql.removeEventListener(\"change\", onChange);\n  }, []);\n\n  return !!isMobile;\n}\n","size_bytes":583},"client/src/hooks/use-panel-gestures.tsx":{"content":"import { useState, useRef, useCallback, useEffect } from \"react\";\n\nexport interface PanelGestureOptions {\n  minHeight: number;\n  maxHeight: number;\n  snapPositions: number[];\n  velocityThreshold: number;\n  closeThreshold: number;\n  onClose?: () => void;\n  enableRubberBanding?: boolean;\n  hapticFeedback?: boolean;\n  dragHandleSelector?: string; // Selector para la zona específica de arrastre\n  contentScrollSelector?: string; // Selector para el contenido con scroll\n  intelligentScrollDetection?: boolean; // Activar detección inteligente de scroll\n}\n\nexport interface PanelGestureState {\n  height: number;\n  isDragging: boolean;\n  velocity: number;\n  isClosing: boolean;\n}\n\nexport const usePanelGestures = (options: PanelGestureOptions) => {\n  const {\n    minHeight = 20,\n    maxHeight = 95,\n    snapPositions = [30, 60, 90],\n    velocityThreshold = 0.5,\n    closeThreshold = 35,\n    onClose,\n    enableRubberBanding = true,\n    hapticFeedback = false,\n    dragHandleSelector = '.panel-drag-handle',\n    contentScrollSelector = '.panel-content',\n    intelligentScrollDetection = true,\n  } = options;\n\n  const [height, setHeight] = useState(snapPositions[snapPositions.length - 1]);\n  const [isDragging, setIsDragging] = useState(false);\n  const [velocity, setVelocity] = useState(0);\n  const [isClosing, setIsClosing] = useState(false);\n\n  const dragStartY = useRef(0);\n  const dragStartHeight = useRef(0);\n  const lastY = useRef(0);\n  const lastTime = useRef(0);\n  const velocityHistory = useRef<Array<{ v: number; t: number }>>([]);\n  const animationFrameId = useRef<number>();\n  const isDragAllowed = useRef(false);\n  const initialScrollTop = useRef(0);\n  const gestureStartTarget = useRef<HTMLElement | null>(null);\n\n  // Calculate rubber band effect\n  const applyRubberBand = useCallback((value: number, min: number, max: number): number => {\n    if (!enableRubberBanding) {\n      return Math.max(min, Math.min(max, value));\n    }\n\n    if (value < min) {\n      const diff = min - value;\n      const resistance = 0.3; // Rubber band resistance factor\n      return min - diff * resistance;\n    } else if (value > max) {\n      const diff = value - max;\n      const resistance = 0.3;\n      return max + diff * resistance;\n    }\n    return value;\n  }, [enableRubberBanding]);\n\n  // Calculate velocity with smoothing\n  const updateVelocity = useCallback((currentY: number, currentTime: number) => {\n    const deltaY = currentY - lastY.current;\n    const deltaTime = Math.max(currentTime - lastTime.current, 1);\n    const currentVelocity = (deltaY / deltaTime) * 16.67; // Normalize to 60fps\n\n    velocityHistory.current.push({ v: currentVelocity, t: currentTime });\n    \n    // Keep only recent history (last 100ms)\n    const cutoff = currentTime - 100;\n    velocityHistory.current = velocityHistory.current.filter(entry => entry.t > cutoff);\n\n    // Calculate average velocity from history for smoothing\n    if (velocityHistory.current.length > 0) {\n      const totalV = velocityHistory.current.reduce((sum, entry) => sum + entry.v, 0);\n      setVelocity(totalV / velocityHistory.current.length);\n    }\n\n    lastY.current = currentY;\n    lastTime.current = currentTime;\n  }, []);\n\n  // Find the best snap position based on current height and velocity\n  const findBestSnapPosition = useCallback((currentHeight: number, currentVelocity: number): number => {\n    const sortedPositions = [...snapPositions].sort((a, b) => a - b);\n    \n    // If velocity is high, consider velocity-based snapping\n    if (Math.abs(currentVelocity) > velocityThreshold) {\n      if (currentVelocity > 0) {\n        // Moving up, find next higher position\n        const higher = sortedPositions.find(pos => pos > currentHeight);\n        if (higher) return higher;\n        return sortedPositions[sortedPositions.length - 1];\n      } else {\n        // Moving down, find next lower position\n        const lower = [...sortedPositions].reverse().find(pos => pos < currentHeight);\n        if (lower) return lower;\n        return sortedPositions[0];\n      }\n    }\n\n    // No significant velocity, snap to nearest position\n    let closest = sortedPositions[0];\n    let minDistance = Math.abs(currentHeight - closest);\n\n    for (const position of sortedPositions) {\n      const distance = Math.abs(currentHeight - position);\n      if (distance < minDistance) {\n        minDistance = distance;\n        closest = position;\n      }\n    }\n\n    return closest;\n  }, [snapPositions, velocityThreshold]);\n\n  // Haptic feedback simulation\n  const triggerHaptic = useCallback((type: 'light' | 'medium' | 'heavy' = 'light') => {\n    if (!hapticFeedback || typeof navigator === 'undefined' || !navigator.vibrate) {\n      return;\n    }\n\n    const patterns = {\n      light: [10],\n      medium: [20],\n      heavy: [30],\n    };\n\n    navigator.vibrate(patterns[type]);\n  }, [hapticFeedback]);\n\n  // Función para determinar si un gesto debe activar el panel o permitir scroll\n  const shouldAllowPanelGesture = useCallback((target: HTMLElement, deltaY: number, isInitial: boolean = false): boolean => {\n    if (!intelligentScrollDetection) return true;\n\n    // Si el gesto comienza en el área de arrastre, siempre permitir\n    const dragHandle = target.closest(dragHandleSelector);\n    if (dragHandle) {\n      console.log(\"🎯 Gesto iniciado en zona de arrastre - permitir manipulación del panel\");\n      return true;\n    }\n\n    // Si no está en una zona de arrastre y es el primer movimiento, verificar el contenido\n    if (isInitial) {\n      const scrollContainer = target.closest(contentScrollSelector) as HTMLElement;\n      if (scrollContainer) {\n        const canScrollUp = scrollContainer.scrollTop > 0;\n        const canScrollDown = scrollContainer.scrollTop < (scrollContainer.scrollHeight - scrollContainer.clientHeight);\n        \n        console.log(\"📱 Verificando capacidad de scroll:\", { \n          canScrollUp, \n          canScrollDown, \n          deltaY,\n          scrollTop: scrollContainer.scrollTop,\n          scrollHeight: scrollContainer.scrollHeight,\n          clientHeight: scrollContainer.clientHeight\n        });\n\n        // Si el usuario está intentando hacer scroll hacia arriba y el contenido puede scrollear hacia arriba\n        if (deltaY > 0 && canScrollUp) {\n          console.log(\"⬆️ Permitir scroll hacia arriba en contenido\");\n          return false;\n        }\n\n        // Si el usuario está intentando hacer scroll hacia abajo y el contenido puede scrollear hacia abajo\n        if (deltaY < 0 && canScrollDown) {\n          console.log(\"⬇️ Permitir scroll hacia abajo en contenido\");\n          return false;\n        }\n\n        // Si el contenido no puede scrollear en esa dirección, permitir manipulación del panel\n        console.log(\"🎯 Contenido no puede scrollear en esa dirección - permitir manipulación del panel\");\n        return true;\n      }\n    }\n\n    // Por defecto, permitir manipulación del panel\n    return true;\n  }, [intelligentScrollDetection, dragHandleSelector, contentScrollSelector]);\n\n  const handleTouchStart = useCallback((e: React.TouchEvent) => {\n    const touch = e.touches[0];\n    const target = e.target as HTMLElement;\n    \n    gestureStartTarget.current = target;\n    dragStartY.current = touch.clientY;\n    dragStartHeight.current = height;\n    lastY.current = touch.clientY;\n    lastTime.current = performance.now();\n    velocityHistory.current = [];\n    isDragAllowed.current = false; // Iniciamos como no permitido hasta evaluar\n    \n    // Guardamos el scroll inicial del contenido si existe\n    const scrollContainer = target.closest(contentScrollSelector) as HTMLElement;\n    if (scrollContainer) {\n      initialScrollTop.current = scrollContainer.scrollTop;\n    }\n    \n    console.log(\"👆 Inicio de gesto táctil en:\", target.className);\n  }, [height, contentScrollSelector]);\n\n  const handleTouchMove = useCallback((e: React.TouchEvent) => {\n    const touch = e.touches[0];\n    const currentY = touch.clientY;\n    const deltaY = dragStartY.current - currentY;\n    \n    // En el primer movimiento, determinar si debemos permitir el gesto del panel\n    if (!isDragAllowed.current && gestureStartTarget.current) {\n      const shouldAllow = shouldAllowPanelGesture(gestureStartTarget.current, deltaY, true);\n      \n      if (!shouldAllow) {\n        console.log(\"🚫 Gesto de panel no permitido - permitir scroll natural\");\n        return; // Permitir que el scroll natural funcione\n      }\n      \n      // Si llegamos aquí, permitimos el gesto del panel\n      isDragAllowed.current = true;\n      setIsDragging(true);\n      \n      // Prevenir scrolling solo cuando confirmamos que es un gesto del panel\n      document.body.style.overflow = 'hidden';\n      document.body.style.touchAction = 'none';\n      \n      triggerHaptic('light');\n      console.log(\"✅ Gesto de panel permitido - iniciando manipulación\");\n    }\n    \n    if (!isDragging || !isDragAllowed.current) return;\n    \n    const currentTime = performance.now();\n    updateVelocity(currentY, currentTime);\n    \n    const viewportHeight = window.innerHeight;\n    const heightChange = (deltaY / viewportHeight) * 100;\n    \n    let newHeight = dragStartHeight.current + heightChange;\n    newHeight = applyRubberBand(newHeight, minHeight, maxHeight);\n    \n    setHeight(newHeight);\n    \n    e.preventDefault();\n    e.stopPropagation();\n  }, [isDragging, updateVelocity, applyRubberBand, minHeight, maxHeight, shouldAllowPanelGesture, triggerHaptic]);\n\n  const handleTouchEnd = useCallback(() => {\n    // Limpiar el estado sin importar si estábamos arrastrando o no\n    gestureStartTarget.current = null;\n    \n    if (!isDragging || !isDragAllowed.current) {\n      isDragAllowed.current = false;\n      return;\n    }\n    \n    setIsDragging(false);\n    isDragAllowed.current = false;\n    document.body.style.overflow = '';\n    document.body.style.touchAction = '';\n    \n    const currentVelocity = velocity;\n    let targetHeight: number;\n\n    // Check if should close\n    if (height < closeThreshold || (currentVelocity < -1 && height < 50)) {\n      setIsClosing(true);\n      targetHeight = minHeight;\n      triggerHaptic('medium');\n      setTimeout(() => {\n        onClose?.();\n      }, 250);\n    } else {\n      targetHeight = findBestSnapPosition(height, currentVelocity);\n      \n      // Trigger haptic feedback for snap\n      if (Math.abs(targetHeight - height) > 5) {\n        triggerHaptic('light');\n      }\n    }\n\n    // Smooth animation to target height\n    const animate = () => {\n      setHeight(current => {\n        const diff = targetHeight - current;\n        const newHeight = current + diff * 0.15; // Easing factor\n        \n        if (Math.abs(diff) < 0.5) {\n          return targetHeight;\n        }\n        \n        animationFrameId.current = requestAnimationFrame(animate);\n        return newHeight;\n      });\n    };\n    \n    if (animationFrameId.current) {\n      cancelAnimationFrame(animationFrameId.current);\n    }\n    animate();\n    \n    // Reset velocity after a delay\n    setTimeout(() => {\n      setVelocity(0);\n      velocityHistory.current = [];\n    }, 100);\n  }, [isDragging, height, velocity, closeThreshold, minHeight, findBestSnapPosition, onClose, triggerHaptic]);\n\n  // Mouse events for desktop compatibility\n  const handleMouseDown = useCallback((e: React.MouseEvent) => {\n    const target = e.target as HTMLElement;\n    \n    // Para mouse, solo permitir si es en la zona de arrastre\n    const dragHandle = target.closest(dragHandleSelector);\n    if (!dragHandle) {\n      console.log(\"🖱️ Clic de mouse fuera de la zona de arrastre - ignorar\");\n      return;\n    }\n    \n    const mouseY = e.clientY;\n    setIsDragging(true);\n    isDragAllowed.current = true;\n    dragStartY.current = mouseY;\n    dragStartHeight.current = height;\n    lastY.current = mouseY;\n    lastTime.current = performance.now();\n    velocityHistory.current = [];\n    \n    document.body.style.overflow = 'hidden';\n    document.body.style.userSelect = 'none';\n    \n    console.log(\"🖱️ Inicio de arrastre con mouse en zona permitida\");\n  }, [height, dragHandleSelector]);\n\n  const handleMouseMove = useCallback((e: MouseEvent) => {\n    if (!isDragging || !isDragAllowed.current) return;\n    \n    const currentY = e.clientY;\n    const currentTime = performance.now();\n    \n    updateVelocity(currentY, currentTime);\n    \n    const deltaY = dragStartY.current - currentY;\n    const viewportHeight = window.innerHeight;\n    const heightChange = (deltaY / viewportHeight) * 100;\n    \n    let newHeight = dragStartHeight.current + heightChange;\n    newHeight = applyRubberBand(newHeight, minHeight, maxHeight);\n    \n    setHeight(newHeight);\n  }, [isDragging, updateVelocity, applyRubberBand, minHeight, maxHeight]);\n\n  const handleMouseUp = useCallback(() => {\n    if (!isDragging || !isDragAllowed.current) return;\n    \n    setIsDragging(false);\n    isDragAllowed.current = false;\n    document.body.style.overflow = '';\n    document.body.style.userSelect = '';\n    \n    const currentVelocity = velocity;\n    let targetHeight: number;\n\n    if (height < closeThreshold || (currentVelocity < -1 && height < 50)) {\n      setIsClosing(true);\n      targetHeight = minHeight;\n      setTimeout(() => {\n        onClose?.();\n      }, 250);\n    } else {\n      targetHeight = findBestSnapPosition(height, currentVelocity);\n    }\n\n    // Smooth animation to target height\n    const animate = () => {\n      setHeight(current => {\n        const diff = targetHeight - current;\n        const newHeight = current + diff * 0.15;\n        \n        if (Math.abs(diff) < 0.5) {\n          return targetHeight;\n        }\n        \n        animationFrameId.current = requestAnimationFrame(animate);\n        return newHeight;\n      });\n    };\n    \n    if (animationFrameId.current) {\n      cancelAnimationFrame(animationFrameId.current);\n    }\n    animate();\n    \n    setTimeout(() => {\n      setVelocity(0);\n      velocityHistory.current = [];\n    }, 100);\n  }, [isDragging, height, velocity, closeThreshold, minHeight, findBestSnapPosition, onClose]);\n\n  // Setup mouse event listeners\n  useEffect(() => {\n    if (isDragging) {\n      document.addEventListener('mousemove', handleMouseMove);\n      document.addEventListener('mouseup', handleMouseUp);\n      \n      return () => {\n        document.removeEventListener('mousemove', handleMouseMove);\n        document.removeEventListener('mouseup', handleMouseUp);\n      };\n    }\n  }, [isDragging, handleMouseMove, handleMouseUp]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (animationFrameId.current) {\n        cancelAnimationFrame(animationFrameId.current);\n      }\n      document.body.style.overflow = '';\n      document.body.style.touchAction = '';\n      document.body.style.userSelect = '';\n    };\n  }, []);\n\n  return {\n    height,\n    isDragging,\n    velocity,\n    isClosing,\n    setHeight,\n    gestureHandlers: {\n      onTouchStart: handleTouchStart,\n      onTouchMove: handleTouchMove,\n      onTouchEnd: handleTouchEnd,\n      onMouseDown: handleMouseDown,\n    },\n  };\n};","size_bytes":15041},"client/src/hooks/use-toast.ts":{"content":"import * as React from \"react\"\n\nimport type {\n  ToastActionElement,\n  ToastProps,\n} from \"@/components/ui/toast\"\n\nconst TOAST_LIMIT = 1\nconst TOAST_REMOVE_DELAY = 3000 // 3 segundos para cerrar automáticamente\n\ntype ToasterToast = ToastProps & {\n  id: string\n  title?: React.ReactNode\n  description?: React.ReactNode\n  action?: ToastActionElement\n}\n\nconst actionTypes = {\n  ADD_TOAST: \"ADD_TOAST\",\n  UPDATE_TOAST: \"UPDATE_TOAST\",\n  DISMISS_TOAST: \"DISMISS_TOAST\",\n  REMOVE_TOAST: \"REMOVE_TOAST\",\n} as const\n\nlet count = 0\n\nfunction genId() {\n  count = (count + 1) % Number.MAX_SAFE_INTEGER\n  return count.toString()\n}\n\ntype ActionType = typeof actionTypes\n\ntype Action =\n  | {\n      type: ActionType[\"ADD_TOAST\"]\n      toast: ToasterToast\n    }\n  | {\n      type: ActionType[\"UPDATE_TOAST\"]\n      toast: Partial<ToasterToast>\n    }\n  | {\n      type: ActionType[\"DISMISS_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n  | {\n      type: ActionType[\"REMOVE_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n\ninterface State {\n  toasts: ToasterToast[]\n}\n\nconst toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()\n\nconst addToRemoveQueue = (toastId: string) => {\n  if (toastTimeouts.has(toastId)) {\n    return\n  }\n\n  const timeout = setTimeout(() => {\n    toastTimeouts.delete(toastId)\n    dispatch({\n      type: \"REMOVE_TOAST\",\n      toastId: toastId,\n    })\n  }, TOAST_REMOVE_DELAY)\n\n  toastTimeouts.set(toastId, timeout)\n}\n\nexport const reducer = (state: State, action: Action): State => {\n  switch (action.type) {\n    case \"ADD_TOAST\":\n      return {\n        ...state,\n        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),\n      }\n\n    case \"UPDATE_TOAST\":\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === action.toast.id ? { ...t, ...action.toast } : t\n        ),\n      }\n\n    case \"DISMISS_TOAST\": {\n      const { toastId } = action\n\n      // ! Side effects ! - This could be extracted into a dismissToast() action,\n      // but I'll keep it here for simplicity\n      if (toastId) {\n        addToRemoveQueue(toastId)\n      } else {\n        state.toasts.forEach((toast) => {\n          addToRemoveQueue(toast.id)\n        })\n      }\n\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === toastId || toastId === undefined\n            ? {\n                ...t,\n                open: false,\n              }\n            : t\n        ),\n      }\n    }\n    case \"REMOVE_TOAST\":\n      if (action.toastId === undefined) {\n        return {\n          ...state,\n          toasts: [],\n        }\n      }\n      return {\n        ...state,\n        toasts: state.toasts.filter((t) => t.id !== action.toastId),\n      }\n  }\n}\n\nconst listeners: Array<(state: State) => void> = []\n\nlet memoryState: State = { toasts: [] }\n\nfunction dispatch(action: Action) {\n  memoryState = reducer(memoryState, action)\n  listeners.forEach((listener) => {\n    listener(memoryState)\n  })\n}\n\ntype Toast = Omit<ToasterToast, \"id\">\n\nfunction toast({ ...props }: Toast) {\n  const id = genId()\n\n  const update = (props: ToasterToast) =>\n    dispatch({\n      type: \"UPDATE_TOAST\",\n      toast: { ...props, id },\n    })\n  const dismiss = () => dispatch({ type: \"DISMISS_TOAST\", toastId: id })\n\n  dispatch({\n    type: \"ADD_TOAST\",\n    toast: {\n      ...props,\n      id,\n      open: true,\n      onOpenChange: (open) => {\n        if (!open) dismiss()\n      },\n    },\n  })\n\n  return {\n    id: id,\n    dismiss,\n    update,\n  }\n}\n\nfunction useToast() {\n  const [state, setState] = React.useState<State>(memoryState)\n\n  React.useEffect(() => {\n    listeners.push(setState)\n    return () => {\n      const index = listeners.indexOf(setState)\n      if (index > -1) {\n        listeners.splice(index, 1)\n      }\n    }\n  }, [state])\n\n  return {\n    ...state,\n    toast,\n    dismiss: (toastId?: string) => dispatch({ type: \"DISMISS_TOAST\", toastId }),\n  }\n}\n\nexport { useToast, toast }\n","size_bytes":3935},"client/src/lib/auth-service.ts":{"content":"import { supabase } from './supabase-client';\n\ninterface LoginCredentials {\n  email: string;\n  password: string;\n}\n\ninterface RegisterCredentials {\n  email: string;\n  password: string;\n  username: string;\n  name: string;\n}\n\ninterface User {\n  id: number;\n  email: string;\n  username: string;\n  name: string;\n  avatar?: string;\n}\n\n// Service to handle authentication with Supabase\nclass AuthService {\n  private user: User | null = null;\n  private token: string | null = null;\n\n  constructor() {\n    // Initialize from localStorage\n    this.loadSession();\n  }\n\n  // Load session from localStorage\n  private loadSession() {\n    try {\n      const storedUser = localStorage.getItem('user');\n      const storedToken = localStorage.getItem('token');\n      \n      if (storedUser && storedToken) {\n        this.user = JSON.parse(storedUser);\n        this.token = storedToken;\n      }\n    } catch (error) {\n      console.error('Error loading session:', error);\n      this.clearSession();\n    }\n  }\n\n  // Save session to localStorage\n  private saveSession(user: User, token: string) {\n    this.user = user;\n    this.token = token;\n    \n    localStorage.setItem('user', JSON.stringify(user));\n    localStorage.setItem('token', token);\n  }\n\n  // Clear session from localStorage\n  private clearSession() {\n    this.user = null;\n    this.token = null;\n    \n    localStorage.removeItem('user');\n    localStorage.removeItem('token');\n  }\n\n  // Get current user\n  getUser(): User | null {\n    return this.user;\n  }\n\n  // Get auth token\n  getToken(): string | null {\n    return this.token;\n  }\n\n  // Check if user is authenticated\n  isAuthenticated(): boolean {\n    return !!this.user && !!this.token;\n  }\n\n  // Register a new user\n  async register(credentials: RegisterCredentials): Promise<User> {\n    try {\n      // Call API to register user\n      const response = await fetch('/api/auth/register', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(credentials),\n      });\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.message || 'Registration failed');\n      }\n      \n      const data = await response.json();\n      \n      // Save user session\n      this.saveSession(data.user, data.token);\n      \n      return data.user;\n    } catch (error) {\n      console.error('Registration error:', error);\n      throw error;\n    }\n  }\n\n  // Login user\n  async login(credentials: LoginCredentials): Promise<User> {\n    try {\n      // Call API to login user\n      const response = await fetch('/api/auth/login', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(credentials),\n      });\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.message || 'Login failed');\n      }\n      \n      const data = await response.json();\n      \n      // Save user session\n      this.saveSession(data.user, data.token);\n      \n      return data.user;\n    } catch (error) {\n      console.error('Login error:', error);\n      throw error;\n    }\n  }\n\n  // Logout user\n  async logout(): Promise<void> {\n    try {\n      // Call API to logout\n      if (this.token) {\n        await fetch('/api/auth/logout', {\n          method: 'POST',\n          headers: {\n            'Authorization': `Bearer ${this.token}`,\n          },\n        });\n      }\n      \n      // Try to sign out from Supabase directly\n      await supabase.auth.signOut();\n      \n      // Clear session\n      this.clearSession();\n    } catch (error) {\n      console.error('Logout error:', error);\n      // Clear session regardless of API error\n      this.clearSession();\n      throw error;\n    }\n  }\n\n  // Get current user from API\n  async fetchCurrentUser(): Promise<User | null> {\n    try {\n      if (!this.token) {\n        console.log('No authenticated user found');\n        return null;\n      }\n      \n      const response = await fetch('/api/auth/me', {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${this.token}`,\n        },\n      });\n      \n      console.log('User fetch status:', response.status);\n      \n      if (!response.ok) {\n        if (response.status === 401) {\n          console.log('No authenticated user found');\n          this.clearSession();\n          return null;\n        }\n        \n        throw new Error('Failed to fetch user');\n      }\n      \n      const user = await response.json();\n      \n      // Update stored user\n      this.user = user;\n      localStorage.setItem('user', JSON.stringify(user));\n      \n      return user;\n    } catch (error) {\n      console.error('Error fetching current user:', error);\n      return null;\n    }\n  }\n}\n\n// Create and export singleton instance\nexport const authService = new AuthService();\n\nexport default authService;","size_bytes":4920},"client/src/lib/eventsAdapter.ts":{"content":"import { getCategoryEmoji } from './eventsToGeoJSON';\n\n// Adaptador para convertir los eventos de la API al formato del mapa 3D\nexport function adaptEventsForMap3D(events: any[]) {\n  return events.map(event => ({\n    id: event.id.toString(),\n    title: event.title,\n    lat: typeof event.latitude === 'string' ? parseFloat(event.latitude) : event.latitude,\n    lng: typeof event.longitude === 'string' ? parseFloat(event.longitude) : event.longitude,\n    category: event.category,\n    emoji: getCategoryEmoji(event.category),\n    creatorAvatar: event.organizer?.avatar || event.creator_avatar\n  }));\n}","size_bytes":601},"client/src/lib/eventsToGeoJSON.ts":{"content":"export interface EventGeoJSON {\n  id: string;\n  title: string;\n  lat: number;\n  lng: number;\n  category?: string;\n  emoji?: string;\n  creatorAvatar?: string;\n}\n\nexport function eventsToGeoJSON(events: EventGeoJSON[]) {\n  return {\n    type: \"FeatureCollection\" as const,\n    features: events.map((ev) => ({\n      type: \"Feature\" as const,\n      properties: { \n        id: ev.id, \n        title: ev.title,\n        category: ev.category,\n        emoji: ev.emoji,\n        creatorAvatar: ev.creatorAvatar\n      },\n      geometry: { \n        type: \"Point\" as const, \n        coordinates: [ev.lng, ev.lat] \n      }\n    }))\n  };\n}\n\n// Obtener emoji por categoría\nexport function getCategoryEmoji(category?: string): string {\n  const normalizedCategory = category?.toLowerCase().trim();\n  \n  const emojiMap: Record<string, string> = {\n    // Sports variations\n    sports: \"⚽\",\n    sport: \"⚽\",\n    deportes: \"⚽\",\n    deporte: \"⚽\",\n    futbol: \"⚽\",\n    football: \"⚽\",\n    soccer: \"⚽\",\n    \n    // Games variations\n    games: \"🎮\",\n    game: \"🎮\",\n    gaming: \"🎮\",\n    juegos: \"🎮\",\n    juego: \"🎮\",\n    \n    // Music variations\n    music: \"🎵\",\n    musica: \"🎵\",\n    música: \"🎵\",\n    concierto: \"🎵\",\n    concert: \"🎵\",\n    \n    // Food variations\n    food: \"🍽️\",\n    comida: \"🍽️\",\n    restaurante: \"🍽️\",\n    restaurant: \"🍽️\",\n    dining: \"🍽️\",\n    \n    // Nightlife variations\n    nightlife: \"🌙\",\n    \"vida nocturna\": \"🌙\",\n    night: \"🌙\",\n    noche: \"🌙\",\n    bar: \"🌙\",\n    club: \"🌙\",\n    \n    // Outdoors variations\n    outdoors: \"🌲\",\n    \"aire libre\": \"🌲\",\n    outdoor: \"🌲\",\n    nature: \"🌲\",\n    naturaleza: \"🌲\",\n    hiking: \"🌲\",\n    \n    // Social variations\n    social: \"👥\",\n    meetup: \"👥\",\n    reunion: \"👥\",\n    \"reunión\": \"👥\",\n    networking: \"👥\",\n    \n    // Business variations\n    business: \"💼\",\n    negocio: \"💼\",\n    negocios: \"💼\",\n    trabajo: \"💼\",\n    work: \"💼\",\n    \n    // Education variations\n    education: \"📚\",\n    educacion: \"📚\",\n    educación: \"📚\",\n    workshop: \"📚\",\n    taller: \"📚\",\n    curso: \"📚\",\n    course: \"📚\",\n    \n    // Health variations\n    health: \"💪\",\n    salud: \"💪\",\n    fitness: \"💪\",\n    gym: \"💪\",\n    ejercicio: \"💪\",\n    yoga: \"💪\",\n    \n    // Art variations\n    art: \"🎨\",\n    arte: \"🎨\",\n    cultura: \"🎨\",\n    cultural: \"🎨\",\n    gallery: \"🎨\",\n    museo: \"🎨\",\n    \n    // Technology variations\n    technology: \"💻\",\n    tecnologia: \"💻\",\n    tecnología: \"💻\",\n    tech: \"💻\",\n    programming: \"💻\",\n    coding: \"💻\"\n  };\n  \n  return emojiMap[normalizedCategory || \"\"] || \"👥\"; // Default to social emoji instead of pin\n}","size_bytes":2747},"client/src/lib/google-maps.ts":{"content":"// Google Maps utils\nimport { useLoadScript, Libraries } from '@react-google-maps/api';\n\n// Using environment variable for Google Maps API key\nexport const GOOGLE_MAPS_API_KEY = import.meta.env.VITE_GOOGLE_MAPS_API_KEY;\n\n// Libraries necesarias\nexport const libraries: Libraries = [\"places\"];\n\n// Hook para cargar Google Maps \nexport function useGoogleMaps() {\n  const { isLoaded, loadError } = useLoadScript({\n    googleMapsApiKey: GOOGLE_MAPS_API_KEY,\n    libraries,\n  });\n  \n  return { isLoaded, loadError };\n}\n\n// Configuración por defecto del mapa\nexport const defaultMapConfig = {\n  center: {\n    lat: 19.4326, // Ciudad de México por defecto\n    lng: -99.1332\n  },\n  zoom: 11,\n  mapContainerStyle: {\n    width: '100%',\n    height: '100%',\n  },\n  options: {\n    disableDefaultUI: false,\n    zoomControl: true,\n    mapTypeControl: false,\n    streetViewControl: false,\n    fullscreenControl: true,\n  },\n};\n\n// Función para geocodificar en reversa (obtener dirección a partir de coordenadas) usando proxy\n// Versión optimizada para mayor velocidad\nexport async function reverseGeocode(lng: number, lat: number): Promise<string> {\n  try {\n    // Validar que las coordenadas sean números válidos\n    if (isNaN(lat) || isNaN(lng) || !isFinite(lat) || !isFinite(lng)) {\n      console.error(\"Coordenadas inválidas para geocodificación:\", lat, lng);\n      return \"Coordenadas inválidas\";\n    }\n    \n    // Usar el proxy del servidor para evitar problemas de CORS\n    // Limitamos los resultados a 1 para mayor velocidad\n    const response = await fetch(\n      `/api/google-proxy/geocode/json?latlng=${lat},${lng}&language=es&region=ar&result_type=street_address|route|premise|point_of_interest&location_type=ROOFTOP|GEOMETRIC_CENTER`\n    );\n    \n    if (!response.ok) {\n      console.error(\"Error en respuesta HTTP de geocodificación inversa:\", response.status);\n      throw new Error(`Error HTTP ${response.status}`);\n    }\n    \n    const data = await response.json();\n    \n    if (data.status === 'OK' && data.results && data.results.length > 0) {\n      const result = data.results[0];\n      return result.formatted_address || \"Dirección no encontrada\";\n    }\n    \n    return \"Dirección no encontrada\";\n  } catch (error) {\n    console.error(\"Error en geocodificación inversa:\", error);\n    return \"Error al obtener dirección\";\n  }\n}\n\n// Función para buscar establecimientos cercanos a una ubicación (versión optimizada)\nexport async function findNearbyPlaces(lat: number, lng: number, radius: number = 100): Promise<any[]> {\n  try {\n    // Validar que las coordenadas sean números válidos\n    if (isNaN(lat) || isNaN(lng) || !isFinite(lat) || !isFinite(lng)) {\n      console.error(\"Coordenadas inválidas para búsqueda de lugares cercanos:\", lat, lng);\n      return [];\n    }\n    \n    // Construir URL más optimizada, limitando el número de resultados y filtrando por tipos relevantes\n    const url = `/api/google-proxy/place/nearbysearch/json?location=${lat},${lng}&radius=${radius}&rankby=prominence&key=${GOOGLE_MAPS_API_KEY}`;\n    \n    // Usar AbortController para limitar tiempo de espera\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 2000); // 2 segundos máximo\n    \n    try {\n      const response = await fetch(url, { signal: controller.signal });\n      \n      clearTimeout(timeoutId); // Limpiar timeout si la respuesta fue exitosa\n      \n      if (!response.ok) {\n        console.error(\"Error en la respuesta del servidor para lugares cercanos:\", response.status);\n        return [];\n      }\n      \n      const data = await response.json();\n      \n      if (data.status === 'OK' && data.results) {\n        return data.results.slice(0, 5); // Limitar a 5 resultados para mayor velocidad\n      }\n      \n      return [];\n    } catch (fetchError: any) {\n      if (fetchError?.name === 'AbortError') {\n        console.log('Búsqueda de lugares cercanos cancelada por timeout');\n      } else {\n        console.error(\"Error en búsqueda de lugares cercanos:\", fetchError);\n      }\n      return [];\n    }\n  } catch (error) {\n    console.error(\"Error en búsqueda de lugares cercanos:\", error);\n    return [];\n  }\n}\n\n// Función para buscar lugares\nexport async function searchPlaces(query: string): Promise<any[]> {\n  try {\n    // Intentar obtener la ubicación actual para mejorar la búsqueda\n    let locationParam = '';\n    \n    try {\n      const position = await new Promise<GeolocationPosition>((resolve, reject) => {\n        navigator.geolocation.getCurrentPosition(resolve, reject, {\n          enableHighAccuracy: true,\n          timeout: 5000,\n          maximumAge: 0\n        });\n      });\n      \n      if (position && position.coords) {\n        locationParam = `&location=${position.coords.latitude},${position.coords.longitude}&radius=50000`;\n        console.log('Usando ubicación actual para mejorar resultados de búsqueda');\n      }\n    } catch (locError) {\n      console.log('No se pudo obtener la ubicación actual para la búsqueda:', locError);\n    }\n    \n    // Construir URL con parámetros adicionales para mejorar resultados\n    const url = `/api/google-proxy/place/textsearch/json?query=${encodeURIComponent(query)}${locationParam}&key=${GOOGLE_MAPS_API_KEY}`;\n    console.log('Realizando búsqueda en Google Places:', url);\n    \n    const response = await fetch(url);\n    \n    if (!response.ok) {\n      console.error(\"Error en la respuesta del servidor:\", response.status);\n      return [];\n    }\n    \n    const data = await response.json();\n    console.log('Respuesta de Google Places:', data.status, data.results?.length || 0, 'resultados');\n    \n    if (data.status === 'OK' && data.results) {\n      // Mapear resultados al formato requerido por la aplicación\n      return data.results.map((place: any) => ({\n        id: place.place_id,\n        place_name: place.formatted_address,\n        text: place.name,\n        center: [place.geometry.location.lng, place.geometry.location.lat],\n        properties: {\n          category: place.types?.[0] || 'place'\n        }\n      }));\n    }\n    \n    if (data.status !== 'OK') {\n      console.error('Error en la respuesta de Google Places:', data.status, data.error_message || 'Sin mensaje de error');\n    }\n    \n    return [];\n  } catch (error) {\n    console.error(\"Error en búsqueda de lugares:\", error);\n    return [];\n  }\n}","size_bytes":6378},"client/src/lib/mapbox.ts":{"content":"// Initialize Mapbox\nimport mapboxgl from 'mapbox-gl';\n\n// Ensure there's a valid public key\nif (!import.meta.env.VITE_MAPBOX_ACCESS_TOKEN) {\n  console.warn('Missing Mapbox access token. Map functionality will be limited.');\n}\n\n// Set the access token for Mapbox\nmapboxgl.accessToken = import.meta.env.VITE_MAPBOX_ACCESS_TOKEN || 'pk.eyJ1Ijoicm9tYW5waXBvbCIsImEiOiJjbWFiaG1tZzcyYXVoMnBwenJmbTVjamRmIn0.dtOq8JKtV9KwUu9vczQ9Rg';\n\nexport const defaultMapConfig = {\n  lat: -31.428, // Default to Córdoba, Argentina\n  lng: -64.185,\n  zoom: 16 // Nivel de zoom mayor para ver mejor los marcadores\n};\n\n// Map style options\nexport enum MapStyle {\n  STREETS_2D = 'mapbox://styles/mapbox/streets-v11',\n  STREETS_DARK_2D = 'mapbox://styles/mapbox/dark-v11',\n  SATELLITE_2D = 'mapbox://styles/mapbox/satellite-streets-v11',\n  STANDARD_3D = 'mapbox://styles/mapbox/standard',\n  STANDARD_SATELLITE = 'mapbox://styles/mapbox/standard-satellite'\n}\n\n// Light presets for different times of day\nexport enum LightPreset {\n  // Eliminado DAY como solicitado\n  DAWN = 'dawn',\n  DUSK = 'dusk',\n  NIGHT = 'night'\n}\n\n// Theme options for the standard style\nexport enum MapTheme {\n  DEFAULT = 'default',\n  FADED = 'faded',\n  MONOCHROME = 'monochrome'\n}\n\n// Font options for Mapbox styles\nexport enum MapFont {\n  DEFAULT = 'default',\n  // Add other font options when known\n}\n\n// Interface for Map configuration options\nexport interface MapConfigOptions {\n  // Visual elements\n  showPlaceLabels: boolean;\n  showRoadLabels: boolean;\n  showPointOfInterestLabels: boolean;\n  showTransitLabels: boolean;\n  show3dObjects: boolean;\n  // Style options\n  theme: MapTheme;\n  lightPreset: LightPreset;\n  font: MapFont;\n  // Satellite specific options\n  showRoadsAndTransit?: boolean;\n  showPedestrianRoads?: boolean;\n  // Auto time of day\n  useAutoLightPreset: boolean;\n}\n\n// Default configuration for the map\nexport const defaultMapConfig3D: MapConfigOptions = {\n  showPlaceLabels: true,\n  showRoadLabels: true,\n  showPointOfInterestLabels: true,\n  showTransitLabels: true,\n  show3dObjects: true,\n  theme: MapTheme.DEFAULT,\n  lightPreset: LightPreset.DAWN, // Usar DAWN en lugar de DAY\n  font: MapFont.DEFAULT,\n  useAutoLightPreset: true\n};\n\n// Get appropriate light preset based on current time\nexport function getLightPresetByTime(): LightPreset {\n  const currentHour = new Date().getHours();\n  \n  if (currentHour >= 6 && currentHour < 8) {\n    // Early morning (6:00 AM - 8:00 AM)\n    return LightPreset.DAWN;\n  } else if (currentHour >= 8 && currentHour < 18) {\n    // Daytime (8:00 AM - 6:00 PM) - Usando DAWN en lugar de DAY como fue solicitado\n    return LightPreset.DAWN;\n  } else if (currentHour >= 18 && currentHour < 20) {\n    // Evening (6:00 PM - 8:00 PM)\n    return LightPreset.DUSK;\n  } else {\n    // Night (8:00 PM - 6:00 AM)\n    return LightPreset.NIGHT;\n  }\n}\n\n// Get 2D map style - always returns regular street view regardless of time\nexport function get2DMapStyleByTime(): MapStyle {\n  // Always return the regular streets style for 2D mode\n  return MapStyle.STREETS_2D;\n}\n\n// Initialize map in a container element with appropriate style based on mode and time of day\nexport function initializeMap(container: string | HTMLElement, use3D = true): mapboxgl.Map {\n  const map = new mapboxgl.Map({\n    container,\n    style: use3D ? MapStyle.STANDARD_3D : get2DMapStyleByTime(),\n    center: [defaultMapConfig.lng, defaultMapConfig.lat],\n    zoom: defaultMapConfig.zoom,\n    pitch: use3D ? 45 : 0, // Add pitch for 3D effect\n    attributionControl: false, // Hide attribution control\n    logoPosition: 'bottom-right' as 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right'\n  });\n\n  // Do not add any navigation controls to keep them completely hidden\n\n  // Si estamos en modo 3D, aplicar iluminación apropiada inmediatamente al cargar el estilo\n  if (use3D) {\n    const currentLightPreset = getLightPresetByTime();\n    console.log(`Aplicando iluminación inicial en initializeMap: ${currentLightPreset}`);\n    \n    // Aplicar configuración de iluminación cuando el estilo se termine de cargar\n    map.once('style.load', () => {\n      try {\n        // Forzar la configuración de iluminación\n        map.setConfigProperty('basemap', 'lightPreset', currentLightPreset);\n        console.log(`Iluminación aplicada en initializeMap: ${currentLightPreset}`);\n      } catch (err) {\n        console.error('Error al aplicar iluminación en initializeMap:', err);\n      }\n    });\n  }\n  \n  return map;\n}\n\n// Set map to 3D style with Standard style and 3D buildings, landmarks, etc.\nexport function enable3DMap(map: mapboxgl.Map): void {\n  // Guardar estado actual del mapa\n  const center = map.getCenter();\n  const zoom = map.getZoom();\n  const bearing = map.getBearing();\n  \n  // Obtener el preset de iluminación actual antes de cambiar el estilo\n  const currentLightPreset = getLightPresetByTime();\n  console.log(`[MODO 3D] Aplicando iluminación: ${currentLightPreset}`);\n  \n  // Si el mapa ya tiene un estilo 3D, verificamos si la iluminación es correcta sin cambiar\n  const isAlready3D = map.getStyle().name?.includes(\"Standard\");\n  if (isAlready3D) {\n    console.log(\"[MODO 3D] El mapa ya está en 3D, verificando iluminación\");\n    try {\n      const currentPreset = map.getConfigProperty('basemap', 'lightPreset');\n      if (currentPreset !== currentLightPreset) {\n        console.log(`[MODO 3D] Actualizando iluminación de ${currentPreset} a ${currentLightPreset}`);\n        map.setConfigProperty('basemap', 'lightPreset', currentLightPreset);\n      } else {\n        console.log(`[MODO 3D] Iluminación ya correcta: ${currentPreset}`);\n      }\n      return; // No necesitamos cambiar el estilo\n    } catch (err) {\n      console.error('[MODO 3D] Error al verificar iluminación actual:', err);\n      // Continuamos con el cambio de estilo para resolver el problema\n    }\n  }\n  \n  // Crear un sistema de varios intentos\n  const maxRetries = 3;\n  let retryCount = 0;\n  \n  // Función para aplicar configuración con reintentos\n  const applySettings = () => {\n    try {\n      console.log(`[MODO 3D] Intento ${retryCount + 1}/${maxRetries} de aplicar configuración`);\n      \n      // IMPORTANTE: Primero restaurar posición\n      map.setCenter(center);\n      map.setZoom(zoom);\n      map.setBearing(bearing);\n      map.setPitch(45); // Garantizar vista inclinada\n      \n      // 1. Garantizar que se muestran objetos 3D\n      map.setConfigProperty('basemap', 'show3dObjects', true);\n      \n      // 2. IMPORTANTE: Forzar la aplicación del preset de iluminación según la hora actual\n      map.setConfigProperty('basemap', 'lightPreset', currentLightPreset);\n      \n      // 3. Configurar para que la iluminación se actualice automáticamente\n      map.setConfigProperty('basemap', 'useAutoLightPreset', true);\n      \n      console.log(`[MODO 3D] Iluminación ${currentLightPreset} aplicada correctamente`);\n      \n      // Programar verificación\n      scheduleVerification();\n    } catch (err) {\n      console.error('[MODO 3D] Error al aplicar configuración:', err);\n      \n      if (retryCount < maxRetries) {\n        retryCount++;\n        console.log(`[MODO 3D] Reintentando en 300ms (${retryCount}/${maxRetries})`);\n        setTimeout(applySettings, 300);\n      }\n    }\n  };\n  \n  // Función para verificar y corregir\n  const scheduleVerification = () => {\n    // Verificar después de un retraso\n    setTimeout(() => {\n      try {\n        if (!map.isStyleLoaded()) {\n          console.log('[MODO 3D] Estilo aún no cargado en verificación, esperando');\n          return scheduleVerification(); // Reprogramar\n        }\n        \n        const appliedPreset = map.getConfigProperty('basemap', 'lightPreset');\n        console.log(`[MODO 3D] Verificando preset aplicado: ${appliedPreset}`);\n        \n        // Si no coincide, forzar de nuevo\n        if (appliedPreset !== currentLightPreset) {\n          console.log(`[MODO 3D] Corrigiendo preset de ${appliedPreset} a ${currentLightPreset}`);\n          map.setConfigProperty('basemap', 'lightPreset', currentLightPreset);\n          \n          // Programar una verificación final\n          setTimeout(() => {\n            try {\n              const finalPreset = map.getConfigProperty('basemap', 'lightPreset');\n              console.log(`[MODO 3D] Verificación final: ${finalPreset}`);\n            } catch (e) {\n              console.error('[MODO 3D] Error en verificación final:', e);\n            }\n          }, 500);\n        } else {\n          console.log(`[MODO 3D] Iluminación verificada correctamente: ${appliedPreset}`);\n        }\n      } catch (err) {\n        console.error('[MODO 3D] Error en verificación de iluminación:', err);\n        \n        if (retryCount < maxRetries) {\n          retryCount++;\n          applySettings(); // Intentar de nuevo\n        }\n      }\n    }, 500);\n  };\n  \n  // Cambiar a estilo 3D\n  console.log('[MODO 3D] Cambiando estilo a 3D Standard');\n  map.setStyle(MapStyle.STANDARD_3D);\n  \n  // Esperar a que el estilo se cargue para aplicar configuración\n  map.once('style.load', () => {\n    console.log('[MODO 3D] Evento style.load detectado');\n    // Pequeño retraso para asegurar que todo está listo\n    setTimeout(applySettings, 100);\n  });\n}\n\n// Set map to 2D style with standard street style (no time-based changes in 2D)\nexport function enable2DMap(map: mapboxgl.Map): void {\n  // Guardar el centro y zoom actuales\n  const center = map.getCenter();\n  const zoom = map.getZoom();\n  \n  console.log('Cambiando a modo 2D, guardando configuración actual');\n  \n  // Always use standard streets style for 2D mode\n  map.setStyle(MapStyle.STREETS_2D);\n  map.setPitch(0); // Reset pitch for 2D view\n  \n  // Cuando el estilo esté cargado, restaurar la posición\n  map.once('style.load', () => {\n    try {\n      map.setCenter(center);\n      map.setZoom(zoom);\n      console.log('Estilo 2D cargado, posición restaurada');\n    } catch (err) {\n      console.error('Error al restaurar posición en modo 2D:', err);\n    }\n  });\n}\n\n// Get current user location and center map to it\nexport function getUserLocation(map: mapboxgl.Map): Promise<GeolocationPosition> {\n  return new Promise((resolve, reject) => {\n    if (!navigator.geolocation) {\n      reject(new Error('Geolocation is not supported by this browser.'));\n      return;\n    }\n\n    navigator.geolocation.getCurrentPosition(\n      (position) => {\n        const { latitude, longitude } = position.coords;\n        map.flyTo({\n          center: [longitude, latitude],\n          zoom: 14,\n          essential: true\n        });\n        resolve(position);\n      },\n      (error) => {\n        console.error('Error getting location:', error);\n        reject(error);\n      }\n    );\n  });\n}\n\n// Add a marker to the map\nexport function addMarker(\n  map: mapboxgl.Map, \n  longitude: number, \n  latitude: number,\n  element?: HTMLElement\n): mapboxgl.Marker {\n  const marker = new mapboxgl.Marker(element)\n    .setLngLat([longitude, latitude])\n    .addTo(map);\n  \n  return marker;\n}\n\n// Get address from coordinates using Mapbox Geocoding API\nexport async function reverseGeocode(longitude: number, latitude: number): Promise<string> {\n  try {\n    const response = await fetch(\n      `https://api.mapbox.com/geocoding/v5/mapbox.places/${longitude},${latitude}.json?access_token=${mapboxgl.accessToken}`\n    );\n    \n    if (!response.ok) {\n      throw new Error('Failed to geocode location');\n    }\n    \n    const data = await response.json();\n    \n    if (data.features && data.features.length > 0) {\n      return data.features[0].place_name;\n    }\n    \n    return 'Unknown location';\n  } catch (error) {\n    console.error('Geocoding error:', error);\n    return 'Unknown location';\n  }\n}\n\n// Search for locations with Mapbox Geocoding API\nexport async function searchLocations(query: string, types?: string[]): Promise<any[]> {\n  try {\n    let url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(query)}.json?access_token=${mapboxgl.accessToken}`;\n    \n    // Add types filter if specified (e.g., 'poi' for points of interest, 'address' for addresses)\n    if (types && types.length > 0) {\n      url += `&types=${types.join(',')}`;\n    }\n    \n    // Add autocomplete parameter for better suggestions\n    url += `&autocomplete=true`;\n    \n    // Add language parameter for Spanish results\n    url += `&language=es`;\n    \n    const response = await fetch(url);\n    \n    if (!response.ok) {\n      throw new Error('Failed to search locations');\n    }\n    \n    const data = await response.json();\n    return data.features || [];\n  } catch (error) {\n    console.error('Location search error:', error);\n    return [];\n  }\n}\n\n// Configurar actualizaciones automáticas de iluminación basadas en tiempo\nexport function setupAutoLightingUpdates(map: mapboxgl.Map): () => void {\n  console.log('Configurando actualizaciones automáticas de iluminación');\n  \n  // Aplicar iluminación inicial\n  const initialPreset = getLightPresetByTime();\n  console.log(`Preset inicial a aplicar: ${initialPreset}`);\n  \n  // Función para aplicar la iluminación con múltiples intentos\n  const applyLightingWithRetry = (preset: LightPreset, retryCount = 0, maxRetries = 3) => {\n    try {\n      if (!map || !map.isStyleLoaded()) {\n        console.log('Mapa no listo, esperando evento style.load');\n        \n        // Si el mapa no está listo, esperar a que lo esté\n        const styleLoadHandler = () => {\n          console.log('Evento style.load detectado, intentando aplicar iluminación');\n          setTimeout(() => applyLightingWithRetry(preset, 0, maxRetries), 200);\n        };\n        \n        map.once('style.load', styleLoadHandler);\n        return;\n      }\n      \n      // Intentar aplicar la configuración\n      map.setConfigProperty('basemap', 'lightPreset', preset);\n      console.log(`Iluminación ${preset} aplicada correctamente en intento ${retryCount + 1}`);\n      \n      // Verificar después de un momento\n      setTimeout(() => {\n        try {\n          const appliedPreset = map.getConfigProperty('basemap', 'lightPreset');\n          if (appliedPreset !== preset) {\n            console.log(`Verificación falló: ${appliedPreset} != ${preset}, reintentando`);\n            if (retryCount < maxRetries) {\n              applyLightingWithRetry(preset, retryCount + 1, maxRetries);\n            } else {\n              console.error(`No se pudo aplicar ${preset} después de ${maxRetries} intentos`);\n            }\n          } else {\n            console.log(`Verificación exitosa: iluminación ${preset} aplicada correctamente`);\n          }\n        } catch (err) {\n          console.error('Error en verificación de iluminación:', err);\n        }\n      }, 300);\n    } catch (err) {\n      console.error(`Error al aplicar iluminación ${preset}:`, err);\n      \n      // Reintentar si no se ha alcanzado el límite\n      if (retryCount < maxRetries) {\n        console.log(`Reintentando aplicar ${preset} en 500ms (intento ${retryCount + 1}/${maxRetries})`);\n        setTimeout(() => applyLightingWithRetry(preset, retryCount + 1, maxRetries), 500);\n      }\n    }\n  };\n  \n  // Aplicar iluminación inicial\n  applyLightingWithRetry(initialPreset);\n  \n  // Función para actualizar la iluminación basada en la hora actual\n  const updateLighting = () => {\n    const currentTimePreset = getLightPresetByTime();\n    console.log(`Verificando actualización de iluminación a: ${currentTimePreset}`);\n    \n    // Comprobar si el preset actual es diferente al que debería ser según la hora\n    try {\n      if (map && map.isStyleLoaded()) {\n        const currentAppliedPreset = map.getConfigProperty('basemap', 'lightPreset');\n        \n        if (currentAppliedPreset !== currentTimePreset) {\n          console.log(`Actualizando iluminación de ${currentAppliedPreset} a ${currentTimePreset}`);\n          applyLightingWithRetry(currentTimePreset);\n        } else {\n          console.log(`Iluminación ya correcta: ${currentTimePreset}`);\n        }\n      }\n    } catch (err) {\n      console.error('Error al comprobar preset actual:', err);\n      // En caso de error, intentar aplicar de todos modos\n      applyLightingWithRetry(currentTimePreset);\n    }\n  };\n  \n  // Configurar intervalo para actualizar la iluminación cada 2 minutos\n  const intervalId = setInterval(updateLighting, 2 * 60 * 1000); // 2 minutos\n  \n  // También actualizar cuando cambie la visualización del mapa\n  map.on('style.load', () => {\n    console.log('Evento style.load detectado, actualizando iluminación');\n    setTimeout(updateLighting, 300); // Pequeño retraso para asegurar que el estilo está completamente cargado\n  });\n  \n  // Devolver función para limpiar el intervalo y eventos cuando sea necesario\n  return () => {\n    console.log('Deteniendo actualizaciones automáticas de iluminación');\n    clearInterval(intervalId);\n    // Eliminar listeners si es necesario\n    map.off('style.load', updateLighting);\n  };\n}\n\n// Apply map configuration settings\nexport function applyMapConfig(map: mapboxgl.Map, config: Partial<MapConfigOptions>): void {\n  if (!map) return;\n\n  // Make sure the style is loaded\n  const applySettings = () => {\n    try {\n      // Verificar si el estilo actual es satelital para manejo especial\n      const style = map.getStyle();\n      const styleJson = JSON.stringify(style).toLowerCase();\n      const isSatelliteStyle = styleJson.includes('satellite');\n      \n      // Apply each configuration property if it exists\n      if (config.showPlaceLabels !== undefined)\n        map.setConfigProperty('basemap', 'showPlaceLabels', config.showPlaceLabels);\n      \n      if (config.showRoadLabels !== undefined)\n        map.setConfigProperty('basemap', 'showRoadLabels', config.showRoadLabels);\n      \n      if (config.showPointOfInterestLabels !== undefined)\n        map.setConfigProperty('basemap', 'showPointOfInterestLabels', config.showPointOfInterestLabels);\n      \n      if (config.showTransitLabels !== undefined)\n        map.setConfigProperty('basemap', 'showTransitLabels', config.showTransitLabels);\n      \n      if (config.show3dObjects !== undefined)\n        map.setConfigProperty('basemap', 'show3dObjects', config.show3dObjects);\n      \n      if (config.theme !== undefined)\n        map.setConfigProperty('basemap', 'theme', config.theme);\n      \n      // Light preset configuration is especially important to persist\n      if (config.lightPreset !== undefined) {\n        // Apply the light preset configuration\n        map.setConfigProperty('basemap', 'lightPreset', config.lightPreset);\n        \n        // Add a small delay to ensure the configuration is properly applied\n        setTimeout(() => {\n          try {\n            const currentValue = map.getConfigProperty('basemap', 'lightPreset');\n            \n            // Try to apply again if it doesn't match the expected value\n            if (currentValue !== config.lightPreset) {\n              map.setConfigProperty('basemap', 'lightPreset', config.lightPreset);\n            }\n          } catch (e) {\n            console.warn('Error verifying light preset configuration');\n          }\n        }, 100);\n      }\n      \n      if (config.font !== undefined)\n        map.setConfigProperty('basemap', 'font', config.font);\n      \n      // Satellite specific options\n      if (config.showRoadsAndTransit !== undefined)\n        map.setConfigProperty('basemap', 'showRoadsAndTransit', config.showRoadsAndTransit);\n      \n      if (config.showPedestrianRoads !== undefined)\n        map.setConfigProperty('basemap', 'showPedestrianRoads', config.showPedestrianRoads);\n      \n      // Map configuration successfully applied\n    } catch (err) {\n      console.error('Error applying map configuration');\n    }\n  };\n\n  // If the style is already loaded, apply settings immediately\n  if (map.isStyleLoaded()) {\n    applySettings();\n  } else {\n    // Otherwise, wait for the style to load\n    map.once('style.load', applySettings);\n  }\n}\n\n\n\n// Enable satellite map view in either 2D or 3D mode\nexport function enableSatelliteMap(map: mapboxgl.Map, use3D: boolean = false): void {\n  // Guardar estado actual del mapa\n  const center = map.getCenter();\n  const zoom = map.getZoom();\n  const bearing = map.getBearing();\n  \n  // Obtener el preset de iluminación actual antes de cambiar el estilo\n  const currentLightPreset = getLightPresetByTime();\n  console.log(`[SATÉLITE] Aplicando iluminación: ${currentLightPreset}, Modo 3D: ${use3D}`);\n  \n  // Choose between 3D satellite or 2D satellite style\n  const satelliteStyle = use3D ? MapStyle.STANDARD_SATELLITE : MapStyle.SATELLITE_2D;\n  \n  // Verificar si ya estamos en el modo correcto\n  const currentStyle = map.getStyle();\n  const isSatelliteStyle = currentStyle.name?.includes(\"Satellite\") || false;\n  const isCurrently3D = currentStyle.name?.includes(\"Standard\") || false;\n  \n  if (isSatelliteStyle && ((use3D && isCurrently3D) || (!use3D && !isCurrently3D))) {\n    console.log(`[SATÉLITE] Ya estamos en modo satélite ${use3D ? '3D' : '2D'}, solo verificando configuración`);\n    \n    if (use3D) {\n      try {\n        const currentAppliedPreset = map.getConfigProperty('basemap', 'lightPreset');\n        if (currentAppliedPreset !== currentLightPreset) {\n          console.log(`[SATÉLITE] Actualizando iluminación de ${currentAppliedPreset} a ${currentLightPreset}`);\n          map.setConfigProperty('basemap', 'lightPreset', currentLightPreset);\n        } else {\n          console.log(`[SATÉLITE] Iluminación ya correcta: ${currentAppliedPreset}`);\n        }\n      } catch (err) {\n        console.error('[SATÉLITE] Error al verificar iluminación actual:', err);\n      }\n      return; // No hace falta cambiar el estilo\n    }\n  }\n  \n  // Cambiar estilo\n  console.log(`[SATÉLITE] Cambiando a estilo satélite ${use3D ? '3D' : '2D'}`);\n  map.setStyle(satelliteStyle);\n  \n  // Set appropriate pitch\n  map.setPitch(use3D ? 45 : 0);\n  \n  // Crear un sistema de varios intentos para configurar iluminación en 3D\n  const maxRetries = 3;\n  let retryCount = 0;\n  \n  // Función para aplicar configuración con reintentos\n  const applySatelliteSettings = () => {\n    try {\n      // Restaurar posición\n      map.setCenter(center);\n      map.setZoom(zoom);\n      map.setBearing(bearing);\n      \n      if (use3D) {\n        console.log(`[SATÉLITE] Intento ${retryCount + 1}/${maxRetries} de aplicar configuración 3D`);\n        \n        // 1. Forzar la aplicación del preset de iluminación según la hora actual\n        map.setConfigProperty('basemap', 'lightPreset', currentLightPreset);\n        \n        // 2. Garantizar que se muestran objetos 3D\n        map.setConfigProperty('basemap', 'show3dObjects', true);\n        \n        // 3. Configurar para que la iluminación se actualice automáticamente\n        map.setConfigProperty('basemap', 'useAutoLightPreset', true);\n        \n        console.log(`[SATÉLITE] Iluminación ${currentLightPreset} aplicada correctamente en modo 3D`);\n        \n        // Programar verificación\n        setTimeout(verifySatelliteSettings, 500);\n      }\n    } catch (err) {\n      console.error('[SATÉLITE] Error al aplicar configuración:', err);\n      \n      if (retryCount < maxRetries) {\n        retryCount++;\n        console.log(`[SATÉLITE] Reintentando en 300ms (${retryCount}/${maxRetries})`);\n        setTimeout(applySatelliteSettings, 300);\n      }\n    }\n  };\n  \n  // Función para verificar y corregir\n  const verifySatelliteSettings = () => {\n    if (!use3D) return; // Solo verificar en modo 3D\n    \n    try {\n      // Verificar si se aplicó correctamente\n      const appliedPreset = map.getConfigProperty('basemap', 'lightPreset');\n      console.log(`[SATÉLITE] Verificando preset aplicado: ${appliedPreset}`);\n      \n      // Si no coincide, forzar de nuevo\n      if (appliedPreset !== currentLightPreset) {\n        console.log(`[SATÉLITE] Corrigiendo preset de ${appliedPreset} a ${currentLightPreset}`);\n        map.setConfigProperty('basemap', 'lightPreset', currentLightPreset);\n        \n        // Verificación final\n        setTimeout(() => {\n          try {\n            const finalPreset = map.getConfigProperty('basemap', 'lightPreset');\n            console.log(`[SATÉLITE] Verificación final: ${finalPreset}`);\n          } catch (e) {\n            console.error('[SATÉLITE] Error en verificación final:', e);\n          }\n        }, 500);\n      } else {\n        console.log(`[SATÉLITE] Iluminación verificada correctamente: ${appliedPreset}`);\n      }\n    } catch (err) {\n      console.error('[SATÉLITE] Error en verificación:', err);\n      \n      // Un último intento si falla la verificación\n      if (retryCount < maxRetries) {\n        retryCount++;\n        setTimeout(() => {\n          try {\n            map.setConfigProperty('basemap', 'lightPreset', currentLightPreset);\n            console.log(`[SATÉLITE] Intento final de configuración aplicado`);\n          } catch (retryErr) {\n            console.error('[SATÉLITE] Error en intento final:', retryErr);\n          }\n        }, 800);\n      }\n    }\n  };\n  \n  // Esperar a que el estilo se cargue para aplicar configuración\n  map.once('style.load', () => {\n    console.log(`[SATÉLITE] Estilo satélite ${use3D ? '3D' : '2D'} cargado`);\n    // Pequeño retraso para asegurar que todo está listo\n    setTimeout(applySatelliteSettings, 100);\n  });\n}\n\nexport default {\n  initializeMap,\n  getUserLocation,\n  addMarker,\n  reverseGeocode,\n  searchLocations,\n  defaultMapConfig,\n  defaultMapConfig3D,\n  enable3DMap,\n  enable2DMap,\n  enableSatelliteMap,\n  applyMapConfig,\n  MapStyle,\n  MapTheme,\n  MapFont,\n  getLightPresetByTime,\n  LightPreset,\n  get2DMapStyleByTime,\n  setupAutoLightingUpdates\n};\n","size_bytes":25673},"client/src/lib/protected-route.tsx":{"content":"import { useAuth } from '@/hooks/use-auth';\nimport { useLocation } from 'wouter';\nimport { ComponentType, ReactNode, useEffect } from 'react';\nimport { motion, AnimatePresence } from 'framer-motion';\nimport LoadingSpinner from '@/components/ui/loading-spinner';\n\n// For routes with component prop (Wouter style)\ntype ProtectedRouteComponentProps = {\n  component: ComponentType<any>;\n  path?: string;\n  [key: string]: any;\n};\n\n// For routes with children prop (children wrapper style)\ntype ProtectedRouteChildrenProps = {\n  children: ReactNode;\n};\n\ntype ProtectedRouteProps = ProtectedRouteComponentProps | ProtectedRouteChildrenProps;\n\n/**\n * ProtectedRoute Component\n * \n * Wraps routes that should only be accessible to authenticated users.\n * Redirects to the login page if the user is not authenticated.\n * \n * Works with both Wouter's component pattern and children pattern.\n */\nexport function ProtectedRoute(props: ProtectedRouteProps) {\n  const { user, isLoading, isLoggedIn } = useAuth();\n  const [_, setLocation] = useLocation();\n\n  useEffect(() => {\n    // If authentication check is complete and user is not logged in\n    if (!isLoading && !isLoggedIn) {\n      console.log('Access denied: Redirecting to login');\n      // Small delay to prevent flash\n      setTimeout(() => {\n        setLocation('/auth');\n      }, 50);\n    }\n  }, [isLoading, isLoggedIn, setLocation]);\n\n  // Show loading state while checking authentication - Simplified\n  if (isLoading) {\n    return (\n      <div className=\"h-screen w-full flex flex-col items-center justify-center bg-white\">\n        <LoadingSpinner size=\"lg\" />\n        <p className=\"mt-4 text-sm text-neutral-500\">\n          Verificando sesión...\n        </p>\n      </div>\n    );\n  }\n\n  // Don't render anything if not authenticated (during redirect)\n  if (!isLoggedIn || !user) {\n    return (\n      <div className=\"h-screen w-full flex items-center justify-center bg-white\">\n        <div className=\"text-center\">\n          <div className=\"text-sm text-neutral-500\">Redirigiendo...</div>\n        </div>\n      </div>\n    );\n  }\n\n  // Check which pattern we're using (component or children)\n  if ('component' in props) {\n    const { component: Component, ...rest } = props;\n    return <Component {...rest} />;\n  } else {\n    // Children pattern\n    return <>{props.children}</>;\n  }\n}","size_bytes":2332},"client/src/lib/queryClient.ts":{"content":"import { QueryClient, QueryFunction } from \"@tanstack/react-query\";\n\nasync function throwIfResNotOk(res: Response) {\n  if (!res.ok) {\n    const text = (await res.text()) || res.statusText;\n    throw new Error(`${res.status}: ${text}`);\n  }\n}\n\nexport async function apiRequest(\n  method: string,\n  url: string,\n  data?: unknown | undefined,\n): Promise<Response> {\n  const res = await fetch(url, {\n    method,\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"Accept\": \"application/json\"\n    },\n    body: data ? JSON.stringify(data) : undefined,\n    credentials: \"include\",\n  });\n\n  // Don't throw error here - let the caller handle it\n  return res;\n}\n\ntype UnauthorizedBehavior = \"returnNull\" | \"throw\";\nexport const getQueryFn: <T>(options: {\n  on401: UnauthorizedBehavior;\n}) => QueryFunction<T> =\n  ({ on401: unauthorizedBehavior }) =>\n  async ({ queryKey }) => {\n    const res = await fetch(queryKey[0] as string, {\n      credentials: \"include\",\n      headers: {\n        \"Accept\": \"application/json\",\n        \"X-Requested-With\": \"XMLHttpRequest\"\n      }\n    });\n\n    if (unauthorizedBehavior === \"returnNull\" && res.status === 401) {\n      return null;\n    }\n\n    await throwIfResNotOk(res);\n    return await res.json();\n  };\n\nexport const queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      queryFn: getQueryFn({ on401: \"throw\" }),\n      refetchInterval: false,\n      refetchOnWindowFocus: false,\n      staleTime: Infinity,\n      retry: false,\n    },\n    mutations: {\n      retry: false,\n    },\n  },\n});\n","size_bytes":1543},"client/src/lib/storage-service.ts":{"content":"import { supabase } from './supabase-client';\nimport { v4 as uuidv4 } from 'uuid';\n\n// Storage bucket name (must match the one created in Supabase)\nconst MEDIA_BUCKET = 'event-media';\n\n// File types\ntype FileType = 'photo' | 'video';\n\n// Media item interface\ninterface MediaItem {\n  type: string;\n  url: string;\n  order: number;\n  isMain?: boolean;\n  id?: string;\n}\n\n// Service for handling file storage with Supabase\nclass StorageService {\n  // Upload a file to Supabase Storage\n  async uploadFile(file: File, type: FileType): Promise<MediaItem | null> {\n    try {\n      const fileExt = file.name.split('.').pop() || '';\n      const fileName = `${type}-${uuidv4()}.${fileExt}`;\n      const filePath = `${type}s/${fileName}`;\n\n      // Upload the file\n      const { data, error } = await supabase.storage\n        .from(MEDIA_BUCKET)\n        .upload(filePath, file, {\n          cacheControl: '3600',\n          upsert: false,\n        });\n\n      if (error) {\n        console.error('Error uploading file to Supabase storage:', error);\n        return null;\n      }\n\n      // Get the public URL\n      const { data: urlData } = supabase.storage\n        .from(MEDIA_BUCKET)\n        .getPublicUrl(filePath);\n\n      // Return media item\n      return {\n        type,\n        url: urlData.publicUrl,\n        order: 0, // Default order, can be updated later\n      };\n    } catch (error) {\n      console.error('Error in uploadFile:', error);\n      return null;\n    }\n  }\n\n  // Upload multiple files\n  async uploadFiles(files: File[], types: FileType[]): Promise<MediaItem[]> {\n    const results: MediaItem[] = [];\n\n    for (let i = 0; i < files.length; i++) {\n      const file = files[i];\n      const type = types[i] || (file.type.startsWith('image/') ? 'photo' : 'video');\n      const result = await this.uploadFile(file, type);\n\n      if (result) {\n        // Assign order based on position\n        result.order = i;\n        results.push(result);\n      }\n    }\n\n    return results;\n  }\n\n  // Delete a file from Supabase Storage\n  async deleteFile(url: string): Promise<boolean> {\n    try {\n      // Extract file path from URL\n      // Format: https://[supabase-project].supabase.co/storage/v1/object/public/[bucket]/[filepath]\n      const urlParts = url.split('/storage/v1/object/public/');\n      if (urlParts.length < 2) {\n        console.error('Invalid Supabase Storage URL format');\n        return false;\n      }\n\n      const pathParts = urlParts[1].split('/');\n      if (pathParts.length < 2) {\n        console.error('Invalid Supabase Storage path');\n        return false;\n      }\n\n      // Remove bucket name from path\n      pathParts.shift();\n      const filePath = pathParts.join('/');\n\n      // Delete the file\n      const { error } = await supabase.storage\n        .from(MEDIA_BUCKET)\n        .remove([filePath]);\n\n      if (error) {\n        console.error('Error deleting file from Supabase storage:', error);\n        return false;\n      }\n\n      return true;\n    } catch (error) {\n      console.error('Error in deleteFile:', error);\n      return false;\n    }\n  }\n\n  // Process media items (upload new, handle existing)\n  async processMediaItems(\n    existingItems: MediaItem[] = [], \n    newFiles: File[] = [],\n    newTypes: FileType[] = [],\n    itemsToDelete: string[] = []\n  ): Promise<{\n    mediaItems: MediaItem[],\n    mainMediaUrl: string | null,\n    mainMediaType: FileType | null\n  }> {\n    // Delete items marked for deletion\n    for (const url of itemsToDelete) {\n      await this.deleteFile(url);\n    }\n\n    // Upload new files\n    const newItems = await this.uploadFiles(newFiles, newTypes);\n\n    // Combine existing and new items\n    // Filter out items marked for deletion\n    const combinedItems = [\n      ...existingItems.filter(item => !itemsToDelete.includes(item.url)),\n      ...newItems\n    ];\n\n    // Set the first item as main if there's no main item\n    let mainItem = combinedItems.find(item => item.isMain);\n    if (!mainItem && combinedItems.length > 0) {\n      combinedItems[0].isMain = true;\n      mainItem = combinedItems[0];\n    }\n\n    return {\n      mediaItems: combinedItems,\n      mainMediaUrl: mainItem?.url || null,\n      mainMediaType: mainItem?.type as FileType || null\n    };\n  }\n}\n\n// Create and export singleton instance\nexport const storageService = new StorageService();\n\nexport default storageService;","size_bytes":4341},"client/src/lib/stripe.ts":{"content":"// Stripe functionality removed temporarily\n\n// Mock Stripe promise (será null)\nexport const stripePromise = null;\n\n// Format price for display (mantenemos esta función ya que es útil)\nexport function formatPrice(price: number | string | null | undefined): string {\n  if (price === null || price === undefined) {\n    return 'Publico';\n  }\n  \n  const numericPrice = typeof price === 'string' ? parseFloat(price) : price;\n  \n  if (isNaN(numericPrice) || numericPrice === 0) {\n    return 'Publico';\n  }\n  \n  return `$${numericPrice.toFixed(2)}`;\n}\n\n// Format access type for free events based on privacy type and payment type\nexport function formatAccessType(paymentType: string, privacyType: string, price?: number | string | null): string {\n  // If the event has a price, show the price\n  const numericPrice = typeof price === 'string' ? parseFloat(price) : price;\n  if (numericPrice && numericPrice > 0) {\n    return `$${numericPrice.toFixed(2)}`;\n  }\n  \n  // For free events, show access type based on privacy\n  if (paymentType === 'free') {\n    if (privacyType === 'private') {\n      return 'Con solicitud';\n    } else {\n      return 'Evento abierto';\n    }\n  }\n  \n  return 'Evento abierto';\n}\n\nexport default {\n  stripePromise,\n  formatPrice\n};\n","size_bytes":1251},"client/src/lib/supabase-client.ts":{"content":"// Supabase client for browser environment\nimport { createClient } from '@supabase/supabase-js';\n\n// Get Supabase URL and anon key from environment variables\n// These are injected by Vite at build time\nconst supabaseUrl = import.meta.env.VITE_SUPABASE_URL as string;\nconst supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY as string;\n\n// Check if Supabase credentials are available\nif (!supabaseUrl || !supabaseAnonKey) {\n  console.error('Missing Supabase credentials in client environment');\n  console.error('VITE_SUPABASE_URL:', supabaseUrl ? 'Present' : 'Missing');\n  console.error('VITE_SUPABASE_ANON_KEY:', supabaseAnonKey ? 'Present' : 'Missing');\n}\n\n// Create and export Supabase client\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey, {\n  auth: {\n    persistSession: true,\n    autoRefreshToken: true,\n  },\n});\n\n// Export default client\nexport default supabase;","size_bytes":893},"client/src/lib/token-manager.ts":{"content":"/**\n * Token Management Utility\n * Provides centralized token storage and retrieval with error handling\n */\n\nexport class TokenManager {\n  private static readonly TOKEN_KEY = 'pipol_auth_token';\n  private static readonly USER_KEY = 'pipol_user_data';\n\n  static setToken(token: string): void {\n    try {\n      localStorage.setItem(this.TOKEN_KEY, token);\n      console.log('Token stored successfully');\n    } catch (error) {\n      console.error('Failed to store token:', error);\n    }\n  }\n\n  static getToken(): string | null {\n    try {\n      const token = localStorage.getItem(this.TOKEN_KEY);\n      console.log('Token retrieved:', token ? `exists (${token.substring(0, 20)}...)` : 'not found');\n      return token;\n    } catch (error) {\n      console.error('Failed to retrieve token:', error);\n      return null;\n    }\n  }\n\n  static setUser(user: any): void {\n    try {\n      localStorage.setItem(this.USER_KEY, JSON.stringify(user));\n      console.log('User data stored successfully');\n    } catch (error) {\n      console.error('Failed to store user data:', error);\n    }\n  }\n\n  static getUser(): any | null {\n    try {\n      const userData = localStorage.getItem(this.USER_KEY);\n      return userData ? JSON.parse(userData) : null;\n    } catch (error) {\n      console.error('Failed to retrieve user data:', error);\n      return null;\n    }\n  }\n\n  static removeToken(): void {\n    try {\n      localStorage.removeItem(this.TOKEN_KEY);\n      console.log('Token removed successfully');\n    } catch (error) {\n      console.error('Failed to remove token:', error);\n    }\n  }\n\n  static clearAuth(): void {\n    try {\n      localStorage.removeItem(this.TOKEN_KEY);\n      localStorage.removeItem(this.USER_KEY);\n      console.log('Authentication data cleared');\n    } catch (error) {\n      console.error('Failed to clear authentication data:', error);\n    }\n  }\n\n  static hasValidToken(): boolean {\n    const token = this.getToken();\n    return !!token && token.length > 0;\n  }\n\n  static createAuthHeaders(): Record<string, string> {\n    const token = this.getToken();\n    const headers: Record<string, string> = {\n      'Accept': 'application/json',\n      'Content-Type': 'application/json',\n    };\n\n    if (token) {\n      headers['Authorization'] = `Bearer ${token}`;\n    }\n\n    return headers;\n  }\n}","size_bytes":2295},"client/src/lib/utils.ts":{"content":"import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\nimport { format } from \"date-fns\"\nimport { es } from \"date-fns/locale\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n\nexport function formatDate(dateString: string): string {\n  try {\n    const date = new Date(dateString);\n    return format(date, \"d 'de' MMMM 'de' yyyy 'a las' HH:mm\", { locale: es });\n  } catch (error) {\n    console.error('Error formatting date:', error);\n    return dateString;\n  }\n}\n","size_bytes":523},"client/src/pages/CreateEvent.tsx":{"content":"import { useState } from \"react\";\nimport { useForm } from \"react-hook-form\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport { useQuery, useMutation } from \"@tanstack/react-query\";\nimport { useLocation, Link } from \"wouter\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Label } from \"@/components/ui/label\";\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\";\nimport { apiRequest } from \"@/lib/queryClient\";\nimport { insertEventSchema, eventCategoryEnum, privacyTypeEnum } from \"@shared/schema\";\nimport { z } from \"zod\";\n\n// Create a new schema for the form that handles client-side validation\nconst createEventFormSchema = z.object({\n  title: z.string().min(3, \"Title must be at least 3 characters\"),\n  description: z.string().min(10, \"Description must be at least 10 characters\"),\n  category: z.enum(eventCategoryEnum.enumValues),\n  date: z.string().min(1, \"Please select a date and time\"),\n  latitude: z.string().min(1, \"Latitude is required\"),\n  longitude: z.string().min(1, \"Longitude is required\"),\n  locationName: z.string().min(3, \"Location name is required\"),\n  locationAddress: z.string().min(5, \"Location address is required\"),\n  privacyType: z.enum(privacyTypeEnum.enumValues).default(\"public\"),\n  maxCapacity: z.string().optional(),\n});\n\ntype CreateEventFormValues = z.infer<typeof createEventFormSchema>;\n\nexport default function CreateEvent() {\n  const [location, setLocation] = useLocation();\n  const { toast } = useToast();\n  const [isSubmitting, setIsSubmitting] = useState(false);\n\n  // Check if user is authenticated\n  const { data: user, isLoading: isUserLoading } = useQuery({\n    queryKey: ['/api/auth/me'],\n    retry: false,\n    refetchOnWindowFocus: false\n  });\n\n  const {\n    register,\n    handleSubmit,\n    formState: { errors },\n    watch,\n    setValue,\n  } = useForm<CreateEventFormValues>({\n    resolver: zodResolver(createEventFormSchema),\n    defaultValues: {\n      title: \"\",\n      description: \"\",\n      category: \"social\",\n      date: \"\",\n      latitude: \"\",\n      longitude: \"\",\n      locationName: \"\",\n      locationAddress: \"\",\n      privacyType: \"public\",\n      maxCapacity: \"\",\n    },\n  });\n\n  const createEventMutation = useMutation({\n    mutationFn: async (formData: CreateEventFormValues) => {\n      // Transform form data for the API\n      const eventData = {\n        ...formData,\n        // Convert maxCapacity to number or null\n        maxCapacity: formData.maxCapacity ? parseInt(formData.maxCapacity) : null,\n        latitude: parseFloat(formData.latitude),\n        longitude: parseFloat(formData.longitude),\n        organizerId: user.id,\n      };\n\n      const response = await apiRequest(\"POST\", \"/api/events\", eventData);\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.message || \"Failed to create event\");\n      }\n      \n      return response.json();\n    },\n    onSuccess: (data) => {\n      toast({\n        title: \"Event created successfully\",\n        description: \"Your event has been created and is now live.\",\n      });\n      setLocation(`/events/${data.id}`);\n    },\n    onError: (error) => {\n      toast({\n        title: \"Failed to create event\",\n        description: error instanceof Error ? error.message : \"An error occurred while creating your event\",\n        variant: \"destructive\",\n      });\n    },\n  });\n\n  async function onSubmit(data: CreateEventFormValues) {\n    setIsSubmitting(true);\n    try {\n      await createEventMutation.mutateAsync(data);\n    } finally {\n      setIsSubmitting(false);\n    }\n  }\n\n  // Mock function to simulate location search \n  // This would be replaced with a real API call to Google Maps\n  const handleLocationSearch = async (searchTerm: string) => {\n    // Simulate API call\n    if (searchTerm.length > 3) {\n      // Set mock values for demonstration\n      setValue('locationName', 'Central Park');\n      setValue('locationAddress', '59th to 110th St., New York, NY 10022');\n      setValue('latitude', '40.785091');\n      setValue('longitude', '-73.968285');\n    }\n  };\n\n  // Redirect to login if user is not authenticated\n  if (!isUserLoading && !user) {\n    setLocation(\"/login\");\n    return null;\n  }\n\n  return (\n    <div className=\"container mx-auto py-10 px-4\">\n      <header className=\"mb-8\">\n        <div className=\"flex items-center justify-between\">\n          <h1 className=\"text-3xl font-bold\">Create Event</h1>\n          <Link to=\"/events\">\n            <Button variant=\"outline\">Cancel</Button>\n          </Link>\n        </div>\n        <p className=\"text-gray-600 mt-2\">Fill out the form below to create a new event</p>\n      </header>\n\n      <div className=\"bg-white p-6 rounded-lg shadow-md\">\n        <form onSubmit={handleSubmit(onSubmit)} className=\"space-y-6\">\n          <div className=\"grid grid-cols-1 md:grid-cols-2 gap-6\">\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"title\">Event Title</Label>\n              <Input\n                id=\"title\"\n                placeholder=\"Give your event a name\"\n                {...register(\"title\")}\n              />\n              {errors.title && (\n                <p className=\"text-sm text-red-500\">{errors.title.message}</p>\n              )}\n            </div>\n\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"category\">Category</Label>\n              <Select \n                defaultValue=\"social\" \n                onValueChange={(value) => setValue('category', value as any)}\n              >\n                <SelectTrigger>\n                  <SelectValue placeholder=\"Select a category\" />\n                </SelectTrigger>\n                <SelectContent>\n                  {eventCategoryEnum.enumValues.map((category) => (\n                    <SelectItem key={category} value={category}>\n                      {category.charAt(0).toUpperCase() + category.slice(1)}\n                    </SelectItem>\n                  ))}\n                </SelectContent>\n              </Select>\n              {errors.category && (\n                <p className=\"text-sm text-red-500\">{errors.category.message}</p>\n              )}\n            </div>\n\n            <div className=\"space-y-2 md:col-span-2\">\n              <Label htmlFor=\"description\">Description</Label>\n              <Textarea\n                id=\"description\"\n                placeholder=\"Describe your event. What should attendees expect?\"\n                rows={5}\n                {...register(\"description\")}\n              />\n              {errors.description && (\n                <p className=\"text-sm text-red-500\">{errors.description.message}</p>\n              )}\n            </div>\n\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"date\">Date & Time</Label>\n              <Input\n                id=\"date\"\n                type=\"datetime-local\"\n                {...register(\"date\")}\n              />\n              {errors.date && (\n                <p className=\"text-sm text-red-500\">{errors.date.message}</p>\n              )}\n            </div>\n\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"maxCapacity\">Maximum Capacity (Optional)</Label>\n              <Input\n                id=\"maxCapacity\"\n                type=\"number\"\n                placeholder=\"Leave blank for unlimited\"\n                {...register(\"maxCapacity\")}\n              />\n              {errors.maxCapacity && (\n                <p className=\"text-sm text-red-500\">{errors.maxCapacity.message}</p>\n              )}\n            </div>\n\n            <div className=\"space-y-2 md:col-span-2\">\n              <Label htmlFor=\"locationSearch\">Location Search</Label>\n              <div className=\"flex gap-2\">\n                <Input\n                  id=\"locationSearch\"\n                  placeholder=\"Search for a location\"\n                  onChange={(e) => handleLocationSearch(e.target.value)}\n                />\n                <Button type=\"button\" variant=\"outline\">Search</Button>\n              </div>\n              <p className=\"text-sm text-gray-500\">\n                Start typing to search for a location. This would normally use Google Maps API.\n              </p>\n            </div>\n\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"locationName\">Location Name</Label>\n              <Input\n                id=\"locationName\"\n                placeholder=\"e.g. Central Park\"\n                {...register(\"locationName\")}\n              />\n              {errors.locationName && (\n                <p className=\"text-sm text-red-500\">{errors.locationName.message}</p>\n              )}\n            </div>\n\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"locationAddress\">Address</Label>\n              <Input\n                id=\"locationAddress\"\n                placeholder=\"Full address of the venue\"\n                {...register(\"locationAddress\")}\n              />\n              {errors.locationAddress && (\n                <p className=\"text-sm text-red-500\">{errors.locationAddress.message}</p>\n              )}\n            </div>\n\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"latitude\">Latitude</Label>\n              <Input\n                id=\"latitude\"\n                placeholder=\"e.g. 40.785091\"\n                {...register(\"latitude\")}\n              />\n              {errors.latitude && (\n                <p className=\"text-sm text-red-500\">{errors.latitude.message}</p>\n              )}\n            </div>\n\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"longitude\">Longitude</Label>\n              <Input\n                id=\"longitude\"\n                placeholder=\"e.g. -73.968285\"\n                {...register(\"longitude\")}\n              />\n              {errors.longitude && (\n                <p className=\"text-sm text-red-500\">{errors.longitude.message}</p>\n              )}\n            </div>\n\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"privacyType\">Privacy</Label>\n              <Select \n                defaultValue=\"public\" \n                onValueChange={(value) => setValue('privacyType', value as any)}\n              >\n                <SelectTrigger>\n                  <SelectValue placeholder=\"Select privacy type\" />\n                </SelectTrigger>\n                <SelectContent>\n                  <SelectItem value=\"public\">Public (Anyone can view and join)</SelectItem>\n                  <SelectItem value=\"private\">Private (Invitation only)</SelectItem>\n                </SelectContent>\n              </Select>\n              {errors.privacyType && (\n                <p className=\"text-sm text-red-500\">{errors.privacyType.message}</p>\n              )}\n            </div>\n          </div>\n\n          <div className=\"pt-4 border-t border-gray-200\">\n            <Button type=\"submit\" className=\"w-full md:w-auto\" disabled={isSubmitting}>\n              {isSubmitting ? \"Creating Event...\" : \"Create Event\"}\n            </Button>\n          </div>\n        </form>\n      </div>\n    </div>\n  );\n}","size_bytes":11193},"client/src/pages/Dashboard.tsx":{"content":"import { useQuery } from \"@tanstack/react-query\";\nimport { useLocation } from \"wouter\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { Button } from \"@/components/ui/button\";\nimport { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { apiRequest } from \"@/lib/queryClient\";\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"@/components/ui/tabs\";\nimport { Link } from \"wouter\";\n\nexport default function Dashboard() {\n  const [location, setLocation] = useLocation();\n  const { toast } = useToast();\n\n  // Check if user is authenticated\n  const { data: user, isLoading: isUserLoading, error: userError } = useQuery({\n    queryKey: ['/api/auth/me'],\n    retry: false,\n    refetchOnWindowFocus: false\n  });\n\n  // Fetch user's created events\n  const { data: createdEvents, isLoading: isCreatedEventsLoading } = useQuery({\n    queryKey: ['/api/events/created'],\n    enabled: !!user,\n    retry: false\n  });\n\n  // Fetch user's attending events\n  const { data: attendingEvents, isLoading: isAttendingEventsLoading } = useQuery({\n    queryKey: ['/api/events/attending'],\n    enabled: !!user,\n    retry: false\n  });\n\n  const handleLogout = async () => {\n    try {\n      const response = await apiRequest(\"POST\", \"/api/auth/logout\", {});\n      \n      if (response.ok) {\n        toast({\n          title: \"Logged out successfully\",\n        });\n        setLocation(\"/\");\n      } else {\n        throw new Error(\"Logout failed\");\n      }\n    } catch (error) {\n      toast({\n        title: \"Logout failed\",\n        description: \"An error occurred while logging out\",\n        variant: \"destructive\",\n      });\n    }\n  };\n\n  // If not authenticated, redirect to login\n  if (userError) {\n    setLocation(\"/login\");\n    return null;\n  }\n\n  // Show loading state\n  if (isUserLoading) {\n    return (\n      <div className=\"container mx-auto py-10 px-4 text-center\">\n        <p>Loading...</p>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"container mx-auto py-10 px-4\">\n      <header className=\"flex flex-col md:flex-row justify-between items-start md:items-center mb-12 gap-4\">\n        <div>\n          <h1 className=\"text-3xl font-bold\">Dashboard</h1>\n          <p className=\"text-gray-600\">Welcome back, {user?.name}</p>\n        </div>\n        <div className=\"flex gap-2\">\n          <Link to=\"/events/create\">\n            <Button>Create Event</Button>\n          </Link>\n          <Button variant=\"outline\" onClick={handleLogout}>Log Out</Button>\n        </div>\n      </header>\n\n      <Tabs defaultValue=\"attending\" className=\"w-full\">\n        <TabsList className=\"mb-6\">\n          <TabsTrigger value=\"attending\">Events I'm Attending</TabsTrigger>\n          <TabsTrigger value=\"created\">Events I've Created</TabsTrigger>\n          <TabsTrigger value=\"profile\">My Profile</TabsTrigger>\n        </TabsList>\n        \n        <TabsContent value=\"attending\">\n          {isAttendingEventsLoading ? (\n            <p>Loading events...</p>\n          ) : attendingEvents && attendingEvents.length > 0 ? (\n            <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6\">\n              {attendingEvents.map((attendance: any) => (\n                <Card key={attendance.id}>\n                  <CardHeader>\n                    <CardTitle>{attendance.event.title}</CardTitle>\n                    <CardDescription>\n                      {new Date(attendance.event.date).toLocaleDateString()}\n                    </CardDescription>\n                  </CardHeader>\n                  <CardContent>\n                    <p className=\"line-clamp-3\">{attendance.event.description}</p>\n                  </CardContent>\n                  <CardFooter>\n                    <Link to={`/events/${attendance.event.id}`}>\n                      <Button variant=\"outline\">View Details</Button>\n                    </Link>\n                  </CardFooter>\n                </Card>\n              ))}\n            </div>\n          ) : (\n            <div className=\"text-center py-10\">\n              <h3 className=\"text-xl font-semibold mb-2\">You're not attending any events yet</h3>\n              <p className=\"text-gray-600 mb-6\">Discover and join events that interest you</p>\n              <Link to=\"/events\">\n                <Button>Browse Events</Button>\n              </Link>\n            </div>\n          )}\n        </TabsContent>\n        \n        <TabsContent value=\"created\">\n          {isCreatedEventsLoading ? (\n            <p>Loading events...</p>\n          ) : createdEvents && createdEvents.length > 0 ? (\n            <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6\">\n              {createdEvents.map((event: any) => (\n                <Card key={event.id}>\n                  <CardHeader>\n                    <CardTitle>{event.title}</CardTitle>\n                    <CardDescription>\n                      {new Date(event.date).toLocaleDateString()}\n                    </CardDescription>\n                  </CardHeader>\n                  <CardContent>\n                    <p className=\"line-clamp-3\">{event.description}</p>\n                    <p className=\"mt-2 text-sm text-gray-500\">\n                      {event.attendees?.length || 0} attendees\n                    </p>\n                  </CardContent>\n                  <CardFooter className=\"flex justify-between\">\n                    <Link to={`/events/${event.id}`}>\n                      <Button variant=\"outline\">View</Button>\n                    </Link>\n                    <Link to={`/events/${event.id}/edit`}>\n                      <Button variant=\"outline\">Edit</Button>\n                    </Link>\n                  </CardFooter>\n                </Card>\n              ))}\n            </div>\n          ) : (\n            <div className=\"text-center py-10\">\n              <h3 className=\"text-xl font-semibold mb-2\">You haven't created any events yet</h3>\n              <p className=\"text-gray-600 mb-6\">Start creating your first event</p>\n              <Link to=\"/events/create\">\n                <Button>Create Event</Button>\n              </Link>\n            </div>\n          )}\n        </TabsContent>\n        \n        <TabsContent value=\"profile\">\n          <Card>\n            <CardHeader>\n              <CardTitle>Profile Information</CardTitle>\n              <CardDescription>Manage your account details</CardDescription>\n            </CardHeader>\n            <CardContent className=\"space-y-4\">\n              <div>\n                <h4 className=\"text-sm font-medium\">Name</h4>\n                <p>{user?.name}</p>\n              </div>\n              <div>\n                <h4 className=\"text-sm font-medium\">Username</h4>\n                <p>{user?.username}</p>\n              </div>\n              <div>\n                <h4 className=\"text-sm font-medium\">Email</h4>\n                <p>{user?.email}</p>\n              </div>\n              <div>\n                <h4 className=\"text-sm font-medium\">Bio</h4>\n                <p>{user?.bio || \"No bio added yet\"}</p>\n              </div>\n            </CardContent>\n            <CardFooter>\n              <Link to=\"/profile/edit\">\n                <Button>Edit Profile</Button>\n              </Link>\n            </CardFooter>\n          </Card>\n        </TabsContent>\n      </Tabs>\n    </div>\n  );\n}","size_bytes":7279},"client/src/pages/EventDetail.tsx":{"content":"import { useState } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { useLocation, Link } from \"wouter\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { Button } from \"@/components/ui/button\";\nimport { Card, CardContent } from \"@/components/ui/card\";\nimport { Separator } from \"@/components/ui/separator\";\nimport { apiRequest } from \"@/lib/queryClient\";\nimport { \n  AlertDialog,\n  AlertDialogAction,\n  AlertDialogCancel,\n  AlertDialogContent,\n  AlertDialogDescription,\n  AlertDialogFooter,\n  AlertDialogHeader,\n  AlertDialogTitle,\n  AlertDialogTrigger,\n} from \"@/components/ui/alert-dialog\";\nimport { useUserProfile } from \"@/contexts/user-profile-context\";\n\ntype EventDetailProps = {\n  params: {\n    id: string;\n  };\n};\n\nexport default function EventDetail({ params }: EventDetailProps) {\n  const { id } = params;\n  const [location, setLocation] = useLocation();\n  const { toast } = useToast();\n  const queryClient = useQueryClient();\n  const [isJoinDialogOpen, setIsJoinDialogOpen] = useState(false);\n  const { showUserProfile } = useUserProfile();\n\n  // Fetch event details\n  const { data: event, isLoading: isEventLoading, error: eventError } = useQuery({\n    queryKey: [`/api/events/${id}`],\n    retry: 1\n  });\n\n  // Fetch current user\n  const { data: user, isLoading: isUserLoading } = useQuery({\n    queryKey: ['/api/auth/me'],\n    retry: false,\n    refetchOnWindowFocus: false\n  });\n\n  // Check if user is attending\n  const { data: attendanceStatus, isLoading: isAttendanceLoading } = useQuery({\n    queryKey: [`/api/events/${id}/attendance`],\n    enabled: !!user,\n    retry: false\n  });\n\n  // Join event mutation\n  const joinEventMutation = useMutation({\n    mutationFn: async () => {\n      const response = await apiRequest(\"POST\", `/api/events/${id}/join`, {});\n      if (!response.ok) {\n        const data = await response.json();\n        throw new Error(data.message || \"Failed to join event\");\n      }\n      return response.json();\n    },\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: [`/api/events/${id}/attendance`] });\n      queryClient.invalidateQueries({ queryKey: [`/api/events/${id}`] });\n      queryClient.invalidateQueries({ queryKey: ['/api/events/attending'] });\n      toast({\n        title: \"Success!\",\n        description: \"You have successfully joined the event\",\n      });\n    },\n    onError: (error) => {\n      toast({\n        title: \"Failed to join event\",\n        description: error instanceof Error ? error.message : \"An error occurred\",\n        variant: \"destructive\",\n      });\n    },\n  });\n\n  // Leave event mutation\n  const leaveEventMutation = useMutation({\n    mutationFn: async () => {\n      const response = await apiRequest(\"DELETE\", `/api/events/${id}/leave`, {});\n      if (!response.ok) {\n        const data = await response.json();\n        throw new Error(data.message || \"Failed to leave event\");\n      }\n      return response.json();\n    },\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: [`/api/events/${id}/attendance`] });\n      queryClient.invalidateQueries({ queryKey: [`/api/events/${id}`] });\n      queryClient.invalidateQueries({ queryKey: ['/api/events/attending'] });\n      toast({\n        title: \"Success!\",\n        description: \"You have left the event\",\n      });\n    },\n    onError: (error) => {\n      toast({\n        title: \"Failed to leave event\",\n        description: error instanceof Error ? error.message : \"An error occurred\",\n        variant: \"destructive\",\n      });\n    },\n  });\n\n  const handleJoinEvent = () => {\n    if (!user) {\n      setLocation(\"/login\");\n      return;\n    }\n    \n    joinEventMutation.mutate();\n  };\n\n  const handleLeaveEvent = () => {\n    leaveEventMutation.mutate();\n  };\n\n  // Show loading state\n  if (isEventLoading) {\n    return (\n      <div className=\"container mx-auto py-10 px-4 text-center\">\n        <p>Loading event details...</p>\n      </div>\n    );\n  }\n\n  // Show error state\n  if (eventError || !event) {\n    return (\n      <div className=\"container mx-auto py-10 px-4 text-center\">\n        <h2 className=\"text-2xl font-bold mb-4\">Event not found</h2>\n        <p className=\"text-gray-600 mb-6\">The event you're looking for doesn't exist or has been removed</p>\n        <Link to=\"/events\">\n          <Button>Browse Events</Button>\n        </Link>\n      </div>\n    );\n  }\n\n  // Type guard to ensure event has required properties\n  const eventData = event as any;\n  const eventDate = new Date(eventData.date);\n  const isOrganizerView = user && user.id === eventData.organizer?.id;\n  const isAttending = attendanceStatus && attendanceStatus.isAttending;\n  const isFull = eventData.maxCapacity && eventData.attendees && eventData.attendees.length >= eventData.maxCapacity;\n\n  return (\n    <div className=\"container mx-auto py-10 px-4\">\n      <div className=\"mb-6 flex justify-between items-center\">\n        <Link to=\"/events\">\n          <Button variant=\"ghost\" className=\"flex items-center gap-1\">\n            <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n              <path fillRule=\"evenodd\" d=\"M9.707 16.707a1 1 0 01-1.414 0l-6-6a1 1 0 010-1.414l6-6a1 1 0 011.414 1.414L5.414 9H17a1 1 0 110 2H5.414l4.293 4.293a1 1 0 010 1.414z\" clipRule=\"evenodd\" />\n            </svg>\n            Back to Events\n          </Button>\n        </Link>\n        {isOrganizerView && (\n          <Link to={`/events/${id}/edit`}>\n            <Button variant=\"outline\">Edit Event</Button>\n          </Link>\n        )}\n      </div>\n\n      {eventData.mainMediaUrl && (\n        <div className=\"w-full aspect-video overflow-hidden rounded-lg mb-8 bg-gray-100\">\n          <img \n            src={eventData.mainMediaUrl} \n            alt={eventData.title}\n            className=\"w-full h-full object-cover\"\n          />\n        </div>\n      )}\n\n      <div className=\"grid grid-cols-1 lg:grid-cols-3 gap-8\">\n        <div className=\"lg:col-span-2\">\n          <h1 className=\"text-3xl font-bold mb-2\">{eventData.title}</h1>\n          <div className=\"flex items-center gap-2 mb-6\">\n            <span className=\"text-sm font-medium px-2 py-1 rounded-full bg-purple-100 text-purple-800\">\n              {eventData.category.charAt(0).toUpperCase() + eventData.category.slice(1)}\n            </span>\n            {eventData.privacyType === 'private' && (\n              <span className=\"text-sm font-medium px-2 py-1 rounded-full bg-gray-100 text-gray-800\">\n                Private Event\n              </span>\n            )}\n          </div>\n\n          <div className=\"prose max-w-none mb-8\">\n            <p>{eventData.description}</p>\n          </div>\n\n          <Separator className=\"my-8\" />\n\n          {/* Going Section - Horizontal Profile Pictures */}\n          {eventData.attendees && eventData.attendees.length > 0 && (\n            <div className=\"mb-8\">\n              <div className=\"flex items-center gap-3 mb-4\">\n                <h2 className=\"text-xl font-bold text-gray-700\">Going</h2>\n                <span className=\"bg-gray-100 text-gray-600 px-3 py-1 rounded-full text-sm font-medium\">\n                  {eventData.attendees.length}\n                </span>\n              </div>\n              <div className=\"flex items-center gap-2\">\n                {eventData.attendees.slice(0, 10).map((attendee: any, index: number) => (\n                  <div\n                    key={attendee.id || index}\n                    className=\"relative group\"\n                    title={attendee.user?.name || `Attendee ${index + 1}`}\n                  >\n                    <div \n                      className=\"w-10 h-10 rounded-full bg-gradient-to-br from-blue-400 to-purple-500 p-0.5 hover:scale-110 transition-transform cursor-pointer\"\n                      onClick={() => attendee.user && showUserProfile({\n                        id: attendee.user.id,\n                        name: attendee.user.name,\n                        email: attendee.user.email || `${attendee.user.name}@example.com`,\n                        avatar: attendee.user.avatar\n                      })}\n                    >\n                      <div className=\"w-full h-full rounded-full bg-white flex items-center justify-center overflow-hidden\">\n                        {attendee.user?.avatar ? (\n                          <img \n                            src={attendee.user.avatar} \n                            alt={attendee.user.name} \n                            className=\"w-full h-full rounded-full object-cover\"\n                          />\n                        ) : (\n                          <span className=\"text-sm font-bold text-gray-600\">\n                            {attendee.user?.name?.charAt(0) || 'U'}\n                          </span>\n                        )}\n                      </div>\n                    </div>\n                  </div>\n                ))}\n                {eventData.attendees.length > 10 && (\n                  <div className=\"w-10 h-10 rounded-full bg-gray-100 flex items-center justify-center\">\n                    <span className=\"text-xs font-medium text-gray-600\">\n                      +{eventData.attendees.length - 10}\n                    </span>\n                  </div>\n                )}\n              </div>\n            </div>\n          )}\n        </div>\n\n        <div>\n          <Card>\n            <CardContent className=\"p-6 space-y-6\">\n              <div>\n                <h3 className=\"font-semibold mb-2\">Date & Time</h3>\n                <p>{eventDate.toLocaleDateString(undefined, { \n                  weekday: 'long', \n                  year: 'numeric', \n                  month: 'long', \n                  day: 'numeric' \n                })}</p>\n                <p>{eventDate.toLocaleTimeString(undefined, {\n                  hour: '2-digit',\n                  minute: '2-digit'\n                })}</p>\n              </div>\n\n              <div>\n                <h3 className=\"font-semibold mb-2\">Location</h3>\n                <p>{eventData.locationName}</p>\n                <p className=\"text-gray-600\">{eventData.locationAddress}</p>\n              </div>\n\n              {eventData.maxCapacity && (\n                <div>\n                  <h3 className=\"font-semibold mb-2\">Capacity</h3>\n                  <p>{eventData.attendees?.length || 0} / {eventData.maxCapacity} attendees</p>\n                </div>\n              )}\n\n              <div>\n                <h3 className=\"font-semibold mb-2\">Organized by</h3>\n                <div className=\"flex items-center\">\n                  <div className=\"w-8 h-8 rounded-full bg-gray-200 mr-2 flex items-center justify-center\">\n                    {eventData.organizer?.avatar ? (\n                      <img \n                        src={eventData.organizer.avatar} \n                        alt={eventData.organizer.name} \n                        className=\"w-full h-full rounded-full object-cover\"\n                      />\n                    ) : (\n                      <span className=\"text-sm font-bold text-gray-600\">\n                        {eventData.organizer?.name?.charAt(0) || 'O'}\n                      </span>\n                    )}\n                  </div>\n                  <span>{eventData.organizer?.name || 'Organizer'}</span>\n                </div>\n              </div>\n\n              {!isOrganizerView && (\n                <div className=\"pt-4\">\n                  {isAttending ? (\n                    <AlertDialog>\n                      <AlertDialogTrigger asChild>\n                        <Button variant=\"outline\" className=\"w-full\">Leave Event</Button>\n                      </AlertDialogTrigger>\n                      <AlertDialogContent>\n                        <AlertDialogHeader>\n                          <AlertDialogTitle>Are you sure?</AlertDialogTitle>\n                          <AlertDialogDescription>\n                            You will no longer be attending this event. You can rejoin later if there's still space available.\n                          </AlertDialogDescription>\n                        </AlertDialogHeader>\n                        <AlertDialogFooter>\n                          <AlertDialogCancel>Cancel</AlertDialogCancel>\n                          <AlertDialogAction onClick={handleLeaveEvent}>Leave Event</AlertDialogAction>\n                        </AlertDialogFooter>\n                      </AlertDialogContent>\n                    </AlertDialog>\n                  ) : (\n                    <Button \n                      className=\"w-full\" \n                      disabled={isFull} \n                      onClick={handleJoinEvent}\n                    >\n                      {isFull ? \"Event is Full\" : \"Join Event\"}\n                    </Button>\n                  )}\n                </div>\n              )}\n            </CardContent>\n          </Card>\n        </div>\n      </div>\n    </div>\n  );\n}","size_bytes":12867},"client/src/pages/Events.tsx":{"content":"import { useState } from \"react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { Link } from \"wouter\";\nimport { Button } from \"@/components/ui/button\";\nimport { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Input } from \"@/components/ui/input\";\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\";\nimport { eventCategoryEnum } from \"@shared/schema\";\n\nexport default function Events() {\n  const [searchTerm, setSearchTerm] = useState(\"\");\n  const [selectedCategory, setSelectedCategory] = useState<string>(\"\");\n\n  // Fetch events\n  const { data: events, isLoading, error } = useQuery({\n    queryKey: ['/api/events'],\n    retry: 1\n  });\n\n  // Filter events based on search term and category\n  const filteredEvents = events ? events.filter((event: any) => {\n    const matchesSearch = searchTerm === \"\" || \n      event.title.toLowerCase().includes(searchTerm.toLowerCase()) || \n      event.description.toLowerCase().includes(searchTerm.toLowerCase()) ||\n      event.locationName.toLowerCase().includes(searchTerm.toLowerCase());\n    \n    const matchesCategory = selectedCategory === \"\" || event.category === selectedCategory;\n    \n    return matchesSearch && matchesCategory;\n  }) : [];\n\n  return (\n    <div className=\"container mx-auto py-10 px-4\">\n      <header className=\"mb-12\">\n        <h1 className=\"text-3xl font-bold mb-4\">Discover Events</h1>\n        <div className=\"flex flex-col md:flex-row gap-4\">\n          <div className=\"flex-1\">\n            <Input\n              placeholder=\"Search events...\"\n              value={searchTerm}\n              onChange={(e) => setSearchTerm(e.target.value)}\n              className=\"w-full\"\n            />\n          </div>\n          <div className=\"w-full md:w-64\">\n            <Select value={selectedCategory} onValueChange={setSelectedCategory}>\n              <SelectTrigger>\n                <SelectValue placeholder=\"All Categories\" />\n              </SelectTrigger>\n              <SelectContent>\n                <SelectItem value=\"\">All Categories</SelectItem>\n                {eventCategoryEnum.enumValues.map((category) => (\n                  <SelectItem key={category} value={category}>\n                    {category.charAt(0).toUpperCase() + category.slice(1)}\n                  </SelectItem>\n                ))}\n              </SelectContent>\n            </Select>\n          </div>\n        </div>\n      </header>\n\n      {isLoading ? (\n        <div className=\"text-center py-10\">\n          <p>Loading events...</p>\n        </div>\n      ) : error ? (\n        <div className=\"text-center py-10\">\n          <p className=\"text-red-500\">Failed to load events</p>\n          <Button onClick={() => window.location.reload()} className=\"mt-4\">\n            Try Again\n          </Button>\n        </div>\n      ) : filteredEvents.length > 0 ? (\n        <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6\">\n          {filteredEvents.map((event: any) => (\n            <Card key={event.id} className=\"overflow-hidden flex flex-col\">\n              {event.mainMediaUrl && (\n                <div className=\"aspect-video w-full overflow-hidden bg-gray-100\">\n                  <img \n                    src={event.mainMediaUrl} \n                    alt={event.title}\n                    className=\"w-full h-full object-cover\"\n                  />\n                </div>\n              )}\n              <CardHeader>\n                <div className=\"flex justify-between items-start\">\n                  <div>\n                    <CardTitle className=\"line-clamp-1\">{event.title}</CardTitle>\n                    <CardDescription>\n                      {new Date(event.date).toLocaleDateString()} • {event.locationName}\n                    </CardDescription>\n                  </div>\n                  <span className=\"text-xs font-medium px-2 py-1 rounded-full bg-purple-100 text-purple-800\">\n                    {event.category}\n                  </span>\n                </div>\n              </CardHeader>\n              <CardContent className=\"flex-grow\">\n                <p className=\"line-clamp-3 text-gray-600\">{event.description}</p>\n                <div className=\"mt-4 flex items-center text-sm text-gray-500\">\n                  <span className=\"flex items-center\">\n                    <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-4 w-4 mr-1\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                      <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z\" />\n                    </svg>\n                    {event.attendees?.length || 0} attendees\n                  </span>\n                </div>\n              </CardContent>\n              <CardFooter className=\"pt-0\">\n                <Link to={`/events/${event.id}`}>\n                  <Button>View Details</Button>\n                </Link>\n              </CardFooter>\n            </Card>\n          ))}\n        </div>\n      ) : (\n        <div className=\"text-center py-10\">\n          <h3 className=\"text-xl font-semibold mb-2\">No events found</h3>\n          <p className=\"text-gray-600 mb-6\">\n            {searchTerm || selectedCategory \n              ? \"Try adjusting your filters\" \n              : \"There are no events available at the moment\"}\n          </p>\n          {(searchTerm || selectedCategory) && (\n            <Button onClick={() => { setSearchTerm(\"\"); setSelectedCategory(\"\"); }}>\n              Clear Filters\n            </Button>\n          )}\n        </div>\n      )}\n    </div>\n  );\n}","size_bytes":5834},"client/src/pages/Home.tsx":{"content":"import { useState, useRef, useEffect } from \"react\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { motion, AnimatePresence } from \"framer-motion\";\nimport MapView from \"@/components/maps/map-view\";\nimport EventDetailSheet from \"@/components/events/event-detail-sheet\";\nimport CreateEventSheet from \"@/components/events/create-event-sheet\";\nimport BottomNav from \"@/components/layout/bottom-nav\";\nimport { useAuth } from \"@/hooks/use-auth\";\nimport { useLocation } from \"wouter\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { MapProvider, useMap } from \"@/contexts/MapContext\";\nimport { queryClient } from \"@/lib/queryClient\";\nimport { useNavigation } from \"@/contexts/navigation-context\";\n\n// Define types for the events\ntype Event = {\n  id: number;\n  title: string;\n  description: string;\n  category: string;\n  date: string;\n  latitude: string | number;\n  longitude: string | number;\n  locationName: string;\n  locationAddress: string;\n  paymentType: string;\n  price?: string | number;\n  maxCapacity?: number;\n  privacyType: string;\n  organizerId: number;\n  organizer: {\n    id: number;\n    name: string;\n    avatar?: string;\n  };\n  attendees: Array<{\n    id: number;\n    user: {\n      id: number;\n      name: string;\n      avatar?: string;\n    };\n  }>;\n};\n\nconst HomeContent = () => {\n  const { restoreCameraState } = useMap();\n  // State for UI components\n  const [selectedEvent, setSelectedEvent] = useState<any | null>(null);\n  const [detailSheetVisible, setDetailSheetVisible] = useState(false);\n  const [createEventVisible, setCreateEventVisible] = useState(false);\n  const [activeFilters, setActiveFilters] = useState<any>({});\n  const [isFocusedMode, setIsFocusedMode] = useState(false);\n  \n  // Referencia para controlar el componente de creación de eventos\n  const createEventKey = useRef<number>(0);\n  \n  const { user, isLoading } = useAuth();\n  const [_, navigate] = useLocation();\n  const { toast } = useToast();\n  const { showNavigation } = useNavigation();\n\n  // Handle event selection\n  const handleEventSelect = (event: any) => {\n    try {\n      console.log(\"🎯 Home: Evento seleccionado:\", event);\n      \n      // Asegurarse de que latitude y longitude sean números y date sea string\n      const formattedEvent = {\n        ...event,\n        latitude: typeof event.latitude === 'string' ? parseFloat(event.latitude) : (event.latitude || 0),\n        longitude: typeof event.longitude === 'string' ? parseFloat(event.longitude) : (event.longitude || 0),\n        date: event.date instanceof Date ? event.date.toISOString() : event.date\n      };\n      \n      // Primero establecer el evento y luego mostrar el panel de detalles\n      setSelectedEvent(formattedEvent);\n      console.log(\"🎯 Home: Setting detailSheetVisible to true\");\n      setDetailSheetVisible(true);\n      console.log(\"🎯 Home: detailSheetVisible set to true\");\n    } catch (error) {\n      console.error(\"Error al seleccionar evento:\", error);\n      toast({\n        title: \"Error\",\n        description: \"No se pudo abrir los detalles del evento\",\n        variant: \"destructive\"\n      });\n    }\n  };\n\n  // Estado para la ubicación seleccionada para el evento\n  const [selectedLocation, setSelectedLocation] = useState<{\n    latitude: number;\n    longitude: number;\n    locationName: string;\n    locationAddress: string;\n  } | null>(null);\n  \n  // Estado para controlar la limpieza de marcadores al cerrar el formulario\n  const [resetMapMarkers, setResetMapMarkers] = useState(false);\n  \n  // Usar React Query para obtener y mantener actualizados los eventos\n  const { data: events = [], isLoading: eventsLoading, error: eventsError, refetch: refetchEvents } = useQuery({\n    queryKey: ['/api/events'],\n    queryFn: async () => {\n      const response = await fetch('/api/events', {\n        credentials: 'include',\n        // Añadir un parámetro para evitar caché\n        headers: {\n          'Cache-Control': 'no-cache',\n          'Pragma': 'no-cache'\n        }\n      });\n      if (!response.ok) {\n        throw new Error('Error al cargar eventos');\n      }\n      return response.json();\n    },\n    // Configuración optimizada para evitar flickering durante eliminaciones\n    refetchInterval: 30000, // Actualizar cada 30 segundos para evitar interrupciones constantes\n    refetchOnWindowFocus: true, // Actualizar cuando la ventana recupera el foco\n    staleTime: 5000, // Balance entre actualizaciones rápidas y estabilidad visual\n    refetchOnMount: true, // Siempre refrescar al montar el componente\n    refetchIntervalInBackground: false, // No actualizar en segundo plano para evitar flickering\n  });\n\n  // Handle create event button click - protegido contra undefined\n  const handleCreateEventClick = (locationData?: {\n    latitude: number;\n    longitude: number; \n    locationAddress: string;\n    locationName: string;\n  }) => {\n    try {\n      // Verificar autenticación primero\n      if (!user && !isLoading) {\n        toast({\n          title: \"Autenticación Requerida\",\n          description: \"Por favor, inicia sesión para crear eventos\",\n          variant: \"destructive\",\n        });\n        navigate(\"/auth\");\n        return;\n      }\n      \n      // Si recibimos datos de ubicación, guardamos y abrimos el formulario\n      if (locationData) {\n        // Verificar si alguno de los campos críticos es undefined antes de procesar\n        if (locationData.latitude === undefined || locationData.longitude === undefined) {\n          console.error(\"Error: Datos de ubicación incompletos\", locationData);\n          toast({\n            title: \"Error al procesar ubicación\",\n            description: \"No se pudo obtener información completa de la ubicación. Por favor, intenta seleccionar otra ubicación.\",\n            variant: \"destructive\"\n          });\n          return;\n        }\n        \n        // Log para depuración\n        console.log(\"Recibiendo datos de ubicación en Home:\", locationData);\n        \n        // Asegurarse que la latitud y longitud sean números y proporcionar valores por defecto para todo\n        const formattedLocation = {\n          latitude: typeof locationData.latitude === 'string' \n            ? parseFloat(locationData.latitude) \n            : (locationData.latitude || 0),\n          longitude: typeof locationData.longitude === 'string' \n            ? parseFloat(locationData.longitude) \n            : (locationData.longitude || 0),\n          locationName: locationData.locationName || \"Ubicación sin nombre\",\n          locationAddress: locationData.locationAddress || \"Dirección desconocida\"\n        };\n        \n        // Si el formulario ya está abierto, forzar una recreación completa\n        if (createEventVisible) {\n          // Cerrar formulario actual\n          setCreateEventVisible(false);\n          \n          // Incrementar clave para forzar recreación del componente\n          createEventKey.current += 1;\n          console.log(\"Recreando formulario con nueva clave:\", createEventKey.current);\n          \n          // Breve retardo para asegurar que se desmonta completamente\n          setTimeout(() => {\n            // Establecer nueva ubicación y abrir nuevo formulario\n            setSelectedLocation(formattedLocation);\n            setCreateEventVisible(true);\n          }, 100);\n        } else {\n          // Comportamiento para primera apertura\n          setSelectedLocation(formattedLocation);\n          setCreateEventVisible(true);\n        }\n        \n        // Mostrar toast con configuración para evitar interferencia con los clics\n        toast({\n          title: \"Ubicación seleccionada\",\n          description: \"Ahora completa los detalles del evento\",\n          duration: 3000, // 3 segundos es suficiente\n          className: \"event-toast\", // Clase especial para estilizar \n        });\n      } else {\n        // Incrementar clave para asegurar componente limpio\n        createEventKey.current += 1;\n        console.log(\"Abriendo formulario sin ubicación, clave:\", createEventKey.current);\n        \n        // Si no hay datos, abrimos formulario limpio\n        setSelectedLocation(null);\n        setCreateEventVisible(true);\n        \n        toast({\n          title: \"Crear evento\",\n          description: \"Puedes seleccionar la ubicación después\",\n        });\n      }\n    } catch (error) {\n      console.error(\"Error al procesar la creación del evento:\", error);\n      toast({\n        title: \"Error al iniciar la creación del evento\",\n        description: \"Hubo un problema al procesar los datos. Por favor, intenta nuevamente con otra ubicación.\",\n        variant: \"destructive\"\n      });\n    }\n  };\n\n  // Handle apply filters\n  const handleApplyFilters = (filters: any) => {\n    setActiveFilters(filters);\n  };\n\n  return (\n    <motion.div \n      initial={{ opacity: 0, scale: 0.98 }}\n      animate={{ opacity: 1, scale: 1 }}\n      transition={{ duration: 0.4, ease: \"easeOut\" }}\n      className=\"relative h-screen flex flex-col\"\n    >\n      {/* Map View */}\n      <motion.div \n        initial={{ opacity: 0, y: 20 }}\n        animate={{ opacity: 1, y: 0 }}\n        transition={{ delay: 0.1, duration: 0.5 }}\n        className=\"flex-1 relative\"\n      >\n        <AnimatePresence>\n          {eventsLoading ? (\n            <motion.div\n              initial={{ opacity: 0, scale: 0.9 }}\n              animate={{ opacity: 1, scale: 1 }}\n              exit={{ opacity: 0, scale: 0.9 }}\n              transition={{ duration: 0.3 }}\n              className=\"absolute inset-0 flex items-center justify-center bg-white/50 backdrop-blur-sm z-10\"\n            >\n              <motion.div\n                initial={{ y: 10, opacity: 0 }}\n                animate={{ y: 0, opacity: 1 }}\n                transition={{ delay: 0.1, duration: 0.3 }}\n                className=\"text-center\"\n              >\n                <motion.div \n                  animate={{ \n                    rotate: 360,\n                    scale: [1, 1.1, 1] \n                  }}\n                  transition={{ \n                    rotate: { duration: 2, repeat: Infinity, ease: \"linear\" },\n                    scale: { duration: 1.5, repeat: Infinity, ease: \"easeInOut\" }\n                  }}\n                  className=\"h-8 w-8 mx-auto mb-2 rounded-full bg-primary/30\"\n                />\n                <p className=\"text-sm text-neutral-600\">Cargando eventos...</p>\n              </motion.div>\n            </motion.div>\n          ) : eventsError ? (\n            <motion.div\n              initial={{ opacity: 0, scale: 0.9 }}\n              animate={{ opacity: 1, scale: 1 }}\n              exit={{ opacity: 0, scale: 0.9 }}\n              transition={{ duration: 0.3 }}\n              className=\"absolute inset-0 flex items-center justify-center bg-white/50 backdrop-blur-sm z-10\"\n            >\n              <motion.div\n                initial={{ y: 10, opacity: 0 }}\n                animate={{ y: 0, opacity: 1 }}\n                whileHover={{ scale: 1.02 }}\n                transition={{ delay: 0.1, duration: 0.3 }}\n                className=\"text-center text-red-500 p-4 rounded-lg bg-red-50\"\n              >\n                <p>Error al cargar eventos</p>\n                <motion.button \n                  whileHover={{ scale: 1.05 }}\n                  whileTap={{ scale: 0.95 }}\n                  className=\"mt-2 text-xs underline text-red-600\"\n                  onClick={() => queryClient.invalidateQueries({queryKey: ['/api/events']})}\n                >\n                  Intentar de nuevo\n                </motion.button>\n              </motion.div>\n            </motion.div>\n          ) : null}\n        </AnimatePresence>\n        \n        <MapView \n          onEventSelect={handleEventSelect}\n          onCreateEventClick={handleCreateEventClick}\n          filters={activeFilters}\n          resetLocationOnFormClose={resetMapMarkers}\n          events={events}\n          isFocusedMode={isFocusedMode}\n          setIsFocusedMode={setIsFocusedMode}\n        />\n      </motion.div>\n      \n      {/* Event Detail Sheet - Always rendered but controlled by visible prop */}\n      <EventDetailSheet \n        event={selectedEvent}\n        onClose={() => {\n          console.log(\"🎯 Home: Closing event detail sheet - START\");\n          console.log(\"🎯 Home: Current detailSheetVisible:\", detailSheetVisible);\n          console.log(\"🎯 Home: Current selectedEvent:\", selectedEvent ? selectedEvent.title : \"null\");\n          \n          // Restaurar la posición de la cámara guardada usando el contexto\n          restoreCameraState();\n          \n          setDetailSheetVisible(false);\n          setSelectedEvent(null); // Clear immediately for instant closure\n          setIsFocusedMode(false); // Salir del modo focalizado al cerrar el panel\n          console.log(\"🎯 Home: Closing event detail sheet - DONE\");\n        }}\n        onEventUpdated={() => {\n          console.log(\"🔒 Event updated/deleted, closing detail panel immediately\");\n          // Restaurar la posición de la cámara antes de cerrar el panel\n          restoreCameraState();\n          setDetailSheetVisible(false);\n          setSelectedEvent(null);\n        }}\n        visible={detailSheetVisible && selectedEvent !== null}\n      />\n      \n\n      \n      {/* Create Event Sheet */}\n      <CreateEventSheet \n        isOpen={createEventVisible}\n        onClose={() => {\n          console.log(\"Cerrando formulario de evento desde Home\");\n          \n          // Primero ocultamos el formulario\n          setCreateEventVisible(false);\n          \n          // Incrementamos la clave para forzar una recreación completa del componente\n          // en la próxima vez que se muestre\n          createEventKey.current += 1;\n          \n          // Limpieza segura de la ubicación seleccionada\n          setSelectedLocation(null);\n          \n          // Activar la limpieza de marcadores en el mapa\n          setResetMapMarkers(prev => !prev); // Toggle para forzar el cambio en la dependencia del useEffect\n          \n          console.log(\"Ubicación seleccionada limpiada, clave incrementada a:\", createEventKey.current);\n        }}\n        initialLocation={selectedLocation}\n        onEventCreated={() => {\n          console.log(\"Evento creado - refrescando eventos...\");\n          refetchEvents();\n        }}\n      />\n      \n      {/* Bottom Navigation */}\n      <BottomNav />\n    </motion.div>\n  );\n};\n\nconst Home = () => {\n  return (\n    <MapProvider>\n      <HomeContent />\n    </MapProvider>\n  );\n};\n\nexport default Home;\n","size_bytes":14475},"client/src/pages/Login.tsx":{"content":"import { useState } from \"react\";\nimport { useForm } from \"react-hook-form\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport { z } from \"zod\";\nimport { Link, useLocation } from \"wouter\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\nimport { apiRequest } from \"@/lib/queryClient\";\nimport { loginUserSchema } from \"@shared/schema\";\n\ntype LoginFormValues = z.infer<typeof loginUserSchema>;\n\nexport default function Login() {\n  const [location, setLocation] = useLocation();\n  const { toast } = useToast();\n  const [isLoading, setIsLoading] = useState(false);\n\n  const {\n    register,\n    handleSubmit,\n    formState: { errors },\n  } = useForm<LoginFormValues>({\n    resolver: zodResolver(loginUserSchema),\n    defaultValues: {\n      email: \"\",\n      password: \"\",\n    },\n  });\n\n  async function onSubmit(data: LoginFormValues) {\n    setIsLoading(true);\n    try {\n      const response = await apiRequest(\"POST\", \"/api/auth/login\", data);\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.message || \"Login failed\");\n      }\n      \n      toast({\n        title: \"Login successful\",\n        description: \"Welcome back!\",\n      });\n      \n      // Redirect to dashboard or home page\n      setLocation(\"/\");\n    } catch (error) {\n      toast({\n        title: \"Login failed\",\n        description: error instanceof Error ? error.message : \"Please check your credentials and try again\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setIsLoading(false);\n    }\n  }\n\n  return (\n    <div className=\"container mx-auto flex min-h-screen flex-col items-center justify-center px-4\">\n      <div className=\"mx-auto w-full max-w-md space-y-6\">\n        <div className=\"text-center\">\n          <Link to=\"/\">\n            <h1 className=\"text-4xl font-bold bg-gradient-to-r from-purple-600 to-blue-500 text-transparent bg-clip-text\">\n              Pipol\n            </h1>\n          </Link>\n          <h2 className=\"mt-6 text-3xl font-bold\">Welcome back</h2>\n          <p className=\"mt-2 text-gray-600\">\n            Sign in to your account to continue\n          </p>\n        </div>\n        \n        <form onSubmit={handleSubmit(onSubmit)} className=\"space-y-6\">\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"email\">Email</Label>\n            <Input\n              id=\"email\"\n              type=\"email\"\n              placeholder=\"you@example.com\"\n              {...register(\"email\")}\n            />\n            {errors.email && (\n              <p className=\"text-sm text-red-500\">{errors.email.message}</p>\n            )}\n          </div>\n          \n          <div className=\"space-y-2\">\n            <div className=\"flex items-center justify-between\">\n              <Label htmlFor=\"password\">Password</Label>\n              <Link to=\"/forgot-password\" className=\"text-sm text-blue-600 hover:underline\">\n                Forgot password?\n              </Link>\n            </div>\n            <Input\n              id=\"password\"\n              type=\"password\"\n              placeholder=\"••••••••\"\n              {...register(\"password\")}\n            />\n            {errors.password && (\n              <p className=\"text-sm text-red-500\">{errors.password.message}</p>\n            )}\n          </div>\n          \n          <Button type=\"submit\" className=\"w-full\" disabled={isLoading}>\n            {isLoading ? \"Signing in...\" : \"Sign in\"}\n          </Button>\n        </form>\n        \n        <div className=\"text-center\">\n          <p className=\"text-sm text-gray-600\">\n            Don't have an account?{\" \"}\n            <Link to=\"/register\" className=\"text-blue-600 hover:underline\">\n              Sign up\n            </Link>\n          </p>\n        </div>\n      </div>\n    </div>\n  );\n}","size_bytes":3925},"client/src/pages/Register.tsx":{"content":"import { useState } from \"react\";\nimport { useForm } from \"react-hook-form\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport { z } from \"zod\";\nimport { Link, useLocation } from \"wouter\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\nimport { apiRequest } from \"@/lib/queryClient\";\nimport { insertUserSchema } from \"@shared/schema\";\n\n// Extend the insert schema with a password confirmation field\nconst registerSchema = insertUserSchema.extend({\n  confirmPassword: z.string().min(1, \"Please confirm your password\"),\n}).refine((data) => data.password === data.confirmPassword, {\n  message: \"Passwords do not match\",\n  path: [\"confirmPassword\"],\n});\n\ntype RegisterFormValues = z.infer<typeof registerSchema>;\n\nexport default function Register() {\n  const [location, setLocation] = useLocation();\n  const { toast } = useToast();\n  const [isLoading, setIsLoading] = useState(false);\n\n  const {\n    register,\n    handleSubmit,\n    formState: { errors },\n  } = useForm<RegisterFormValues>({\n    resolver: zodResolver(registerSchema),\n    defaultValues: {\n      username: \"\",\n      email: \"\",\n      name: \"\",\n      password: \"\",\n      confirmPassword: \"\",\n    },\n  });\n\n  async function onSubmit(data: RegisterFormValues) {\n    setIsLoading(true);\n    try {\n      // Remove confirmPassword before sending to the server\n      const { confirmPassword, ...registrationData } = data;\n      \n      const response = await apiRequest(\"POST\", \"/api/auth/register\", registrationData);\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(\n          errorData.message || \n          (errorData.errors && errorData.errors[0]?.message) || \n          \"Registration failed\"\n        );\n      }\n      \n      toast({\n        title: \"Registration successful\",\n        description: \"Your account has been created and you're now logged in.\",\n      });\n      \n      // Redirect to home page\n      setLocation(\"/\");\n    } catch (error) {\n      toast({\n        title: \"Registration failed\",\n        description: error instanceof Error ? error.message : \"Please check your information and try again\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setIsLoading(false);\n    }\n  }\n\n  return (\n    <div className=\"container mx-auto flex min-h-screen flex-col items-center justify-center px-4\">\n      <div className=\"mx-auto w-full max-w-md space-y-6\">\n        <div className=\"text-center\">\n          <Link to=\"/\">\n            <h1 className=\"text-4xl font-bold bg-gradient-to-r from-purple-600 to-blue-500 text-transparent bg-clip-text\">\n              Pipol\n            </h1>\n          </Link>\n          <h2 className=\"mt-6 text-3xl font-bold\">Create an account</h2>\n          <p className=\"mt-2 text-gray-600\">\n            Sign up to start finding and creating events\n          </p>\n        </div>\n        \n        <form onSubmit={handleSubmit(onSubmit)} className=\"space-y-4\">\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"name\">Full Name</Label>\n            <Input\n              id=\"name\"\n              placeholder=\"John Doe\"\n              {...register(\"name\")}\n            />\n            {errors.name && (\n              <p className=\"text-sm text-red-500\">{errors.name.message}</p>\n            )}\n          </div>\n          \n          <div className=\"space-y-2\">\n            <Label htmlFor=\"username\">Username</Label>\n            <Input\n              id=\"username\"\n              placeholder=\"johndoe\"\n              {...register(\"username\")}\n            />\n            {errors.username && (\n              <p className=\"text-sm text-red-500\">{errors.username.message}</p>\n            )}\n          </div>\n          \n          <div className=\"space-y-2\">\n            <Label htmlFor=\"email\">Email</Label>\n            <Input\n              id=\"email\"\n              type=\"email\"\n              placeholder=\"you@example.com\"\n              {...register(\"email\")}\n            />\n            {errors.email && (\n              <p className=\"text-sm text-red-500\">{errors.email.message}</p>\n            )}\n          </div>\n          \n          <div className=\"space-y-2\">\n            <Label htmlFor=\"password\">Password</Label>\n            <Input\n              id=\"password\"\n              type=\"password\"\n              placeholder=\"••••••••\"\n              {...register(\"password\")}\n            />\n            {errors.password && (\n              <p className=\"text-sm text-red-500\">{errors.password.message}</p>\n            )}\n          </div>\n          \n          <div className=\"space-y-2\">\n            <Label htmlFor=\"confirmPassword\">Confirm Password</Label>\n            <Input\n              id=\"confirmPassword\"\n              type=\"password\"\n              placeholder=\"••••••••\"\n              {...register(\"confirmPassword\")}\n            />\n            {errors.confirmPassword && (\n              <p className=\"text-sm text-red-500\">{errors.confirmPassword.message}</p>\n            )}\n          </div>\n          \n          <Button type=\"submit\" className=\"w-full mt-6\" disabled={isLoading}>\n            {isLoading ? \"Creating account...\" : \"Create account\"}\n          </Button>\n        </form>\n        \n        <div className=\"text-center\">\n          <p className=\"text-sm text-gray-600\">\n            Already have an account?{\" \"}\n            <Link to=\"/login\" className=\"text-blue-600 hover:underline\">\n              Sign in\n            </Link>\n          </p>\n        </div>\n      </div>\n    </div>\n  );\n}","size_bytes":5638},"client/src/pages/auth-page.tsx":{"content":"import { useState, useEffect } from \"react\";\nimport { useAuth } from \"@/hooks/use-auth\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { useLocation } from \"wouter\";\nimport { z } from \"zod\";\nimport { useForm } from \"react-hook-form\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport {\n  Card,\n  CardContent,\n  CardDescription,\n  CardFooter,\n  CardHeader,\n  CardTitle,\n} from \"@/components/ui/card\";\nimport { Input } from \"@/components/ui/input\";\nimport { Button } from \"@/components/ui/button\";\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"@/components/ui/tabs\";\nimport {\n  Form,\n  FormControl,\n  FormField,\n  FormItem,\n  FormLabel,\n  FormMessage,\n} from \"@/components/ui/form\";\nimport LoadingSpinner from \"../components/ui/loading-spinner\";\n\n// Login form schema\nconst loginSchema = z.object({\n  email: z.string().email(\"Ingresa un correo electrónico válido\"),\n  password: z.string().min(6, \"La contraseña debe tener al menos 6 caracteres\"),\n});\n\n// Register form schema\nconst registerSchema = z.object({\n  name: z.string().min(2, \"El nombre debe tener al menos 2 caracteres\"),\n  username: z.string().min(3, \"El nombre de usuario debe tener al menos 3 caracteres\"),\n  email: z.string().email(\"Ingresa un correo electrónico válido\"),\n  password: z.string().min(6, \"La contraseña debe tener al menos 6 caracteres\"),\n});\n\ntype LoginFormValues = z.infer<typeof loginSchema>;\ntype RegisterFormValues = z.infer<typeof registerSchema>;\n\nexport default function AuthPage() {\n  const { user, isLoading } = useAuth();\n  const [activeTab, setActiveTab] = useState<string>(\"login\");\n  const [_, navigate] = useLocation();\n  const { toast } = useToast();\n\n  // Redirect if already logged in\n  useEffect(() => {\n    if (user && !isLoading) {\n      navigate(\"/\");\n    }\n  }, [user, isLoading, navigate]);\n\n  if (isLoading) {\n    return (\n      <div className=\"flex items-center justify-center min-h-screen\">\n        <LoadingSpinner size=\"lg\" />\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"flex flex-col md:flex-row min-h-screen\">\n      {/* Auth Forms */}\n      <div className=\"flex-1 flex items-center justify-center p-4 md:p-8\">\n        <div className=\"w-full max-w-md\">\n          <Tabs defaultValue=\"login\" value={activeTab} onValueChange={setActiveTab}>\n            <TabsList className=\"grid w-full grid-cols-2 mb-6\">\n              <TabsTrigger value=\"login\">Iniciar Sesión</TabsTrigger>\n              <TabsTrigger value=\"register\">Crear Cuenta</TabsTrigger>\n            </TabsList>\n            <TabsContent value=\"login\">\n              <Card>\n                <CardHeader className=\"space-y-1\">\n                  <div className=\"flex justify-center mb-4\">\n                    <img src=\"/logo.svg\" alt=\"Pipol Logo\" className=\"h-12\" />\n                  </div>\n                  <CardTitle className=\"text-2xl font-bold text-center\">Iniciar Sesión</CardTitle>\n                  <CardDescription className=\"text-center\">\n                    Ingresa tus credenciales para acceder a tu cuenta\n                  </CardDescription>\n                </CardHeader>\n                <CardContent>\n                  <LoginForm />\n                </CardContent>\n                <CardFooter className=\"flex flex-col space-y-4\">\n                  <div className=\"text-sm text-center text-muted-foreground\">\n                    ¿No tienes una cuenta?{\" \"}\n                    <Button\n                      variant=\"link\"\n                      className=\"p-0 h-auto\"\n                      onClick={() => setActiveTab(\"register\")}\n                    >\n                      Regístrate ahora\n                    </Button>\n                  </div>\n                </CardFooter>\n              </Card>\n            </TabsContent>\n            <TabsContent value=\"register\">\n              <Card>\n                <CardHeader className=\"space-y-1\">\n                  <div className=\"flex justify-center mb-4\">\n                    <img src=\"/logo.svg\" alt=\"Pipol Logo\" className=\"h-12\" />\n                  </div>\n                  <CardTitle className=\"text-2xl font-bold text-center\">Crear Cuenta</CardTitle>\n                  <CardDescription className=\"text-center\">\n                    Regístrate para comenzar a crear y unirte a eventos\n                  </CardDescription>\n                </CardHeader>\n                <CardContent>\n                  <RegisterForm />\n                </CardContent>\n                <CardFooter className=\"flex flex-col space-y-4\">\n                  <div className=\"text-sm text-center text-muted-foreground\">\n                    ¿Ya tienes una cuenta?{\" \"}\n                    <Button\n                      variant=\"link\"\n                      className=\"p-0 h-auto\"\n                      onClick={() => setActiveTab(\"login\")}\n                    >\n                      Inicia sesión\n                    </Button>\n                  </div>\n                </CardFooter>\n              </Card>\n            </TabsContent>\n          </Tabs>\n        </div>\n      </div>\n\n      {/* Hero Section */}\n      <div className=\"flex-1 bg-gradient-to-br from-secondary to-secondary-foreground p-8 text-white hidden md:flex flex-col justify-center\">\n        <div className=\"max-w-md mx-auto\">\n          <div className=\"flex justify-center mb-8\">\n            <img src=\"/logo.svg\" alt=\"Pipol Logo\" className=\"h-24\" />\n          </div>\n          <h1 className=\"text-4xl font-bold mb-4 text-primary\">\n            Únete a la comunidad de eventos\n          </h1>\n          <p className=\"text-lg mb-8\">\n            Descubre eventos cercanos, crea los tuyos propios y conecta con personas\n            que comparten tus intereses.\n          </p>\n          <div className=\"grid grid-cols-2 gap-4\">\n            <div className=\"bg-primary/20 backdrop-blur-sm p-4 rounded-lg\">\n              <h3 className=\"font-semibold mb-2 text-primary\">Crea Eventos</h3>\n              <p className=\"text-sm\">\n                Organiza desde pequeñas reuniones hasta grandes celebraciones\n              </p>\n            </div>\n            <div className=\"bg-primary/20 backdrop-blur-sm p-4 rounded-lg\">\n              <h3 className=\"font-semibold mb-2 text-primary\">Descubre</h3>\n              <p className=\"text-sm\">\n                Encuentra eventos cercanos que coincidan con tus intereses\n              </p>\n            </div>\n            <div className=\"bg-primary/20 backdrop-blur-sm p-4 rounded-lg\">\n              <h3 className=\"font-semibold mb-2 text-primary\">Conecta</h3>\n              <p className=\"text-sm\">\n                Conoce personas con intereses similares a los tuyos\n              </p>\n            </div>\n            <div className=\"bg-primary/20 backdrop-blur-sm p-4 rounded-lg\">\n              <h3 className=\"font-semibold mb-2 text-primary\">Comparte</h3>\n              <p className=\"text-sm\">\n                Comparte experiencias y momentos especiales con los demás\n              </p>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nfunction LoginForm() {\n  const { loginMutation } = useAuth();\n  const form = useForm<LoginFormValues>({\n    resolver: zodResolver(loginSchema),\n    defaultValues: {\n      email: \"\",\n      password: \"\",\n    },\n  });\n\n  const onSubmit = (values: LoginFormValues) => {\n    loginMutation.mutate(values);\n  };\n\n  return (\n    <Form {...form}>\n      <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-4\">\n        <FormField\n          control={form.control}\n          name=\"email\"\n          render={({ field }) => (\n            <FormItem>\n              <FormLabel>Correo Electrónico</FormLabel>\n              <FormControl>\n                <Input\n                  placeholder=\"tu@email.com\"\n                  type=\"email\"\n                  autoComplete=\"email\"\n                  {...field}\n                />\n              </FormControl>\n              <FormMessage />\n            </FormItem>\n          )}\n        />\n        <FormField\n          control={form.control}\n          name=\"password\"\n          render={({ field }) => (\n            <FormItem>\n              <FormLabel>Contraseña</FormLabel>\n              <FormControl>\n                <Input\n                  placeholder=\"******\"\n                  type=\"password\"\n                  autoComplete=\"current-password\"\n                  {...field}\n                />\n              </FormControl>\n              <FormMessage />\n            </FormItem>\n          )}\n        />\n        <Button\n          type=\"submit\"\n          className=\"w-full bg-primary hover:bg-primary-dark text-black font-semibold\"\n          disabled={loginMutation.isPending}\n        >\n          {loginMutation.isPending ? (\n            <>\n              <LoadingSpinner size=\"sm\" className=\"mr-2\" />\n              Iniciando sesión...\n            </>\n          ) : (\n            \"Iniciar Sesión\"\n          )}\n        </Button>\n      </form>\n    </Form>\n  );\n}\n\nfunction RegisterForm() {\n  const { registerMutation } = useAuth();\n  const form = useForm<RegisterFormValues>({\n    resolver: zodResolver(registerSchema),\n    defaultValues: {\n      name: \"\",\n      username: \"\",\n      email: \"\",\n      password: \"\",\n    },\n  });\n\n  const onSubmit = (values: RegisterFormValues) => {\n    registerMutation.mutate(values);\n  };\n\n  return (\n    <Form {...form}>\n      <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-4\">\n        <FormField\n          control={form.control}\n          name=\"name\"\n          render={({ field }) => (\n            <FormItem>\n              <FormLabel>Nombre Completo</FormLabel>\n              <FormControl>\n                <Input\n                  placeholder=\"Tu nombre completo\"\n                  autoComplete=\"name\"\n                  {...field}\n                />\n              </FormControl>\n              <FormMessage />\n            </FormItem>\n          )}\n        />\n        <FormField\n          control={form.control}\n          name=\"username\"\n          render={({ field }) => (\n            <FormItem>\n              <FormLabel>Nombre de Usuario</FormLabel>\n              <FormControl>\n                <Input\n                  placeholder=\"username\"\n                  autoComplete=\"username\"\n                  {...field}\n                />\n              </FormControl>\n              <FormMessage />\n            </FormItem>\n          )}\n        />\n        <FormField\n          control={form.control}\n          name=\"email\"\n          render={({ field }) => (\n            <FormItem>\n              <FormLabel>Correo Electrónico</FormLabel>\n              <FormControl>\n                <Input\n                  placeholder=\"tu@email.com\"\n                  type=\"email\"\n                  autoComplete=\"email\"\n                  {...field}\n                />\n              </FormControl>\n              <FormMessage />\n            </FormItem>\n          )}\n        />\n        <FormField\n          control={form.control}\n          name=\"password\"\n          render={({ field }) => (\n            <FormItem>\n              <FormLabel>Contraseña</FormLabel>\n              <FormControl>\n                <Input\n                  placeholder=\"******\"\n                  type=\"password\"\n                  autoComplete=\"new-password\"\n                  {...field}\n                />\n              </FormControl>\n              <FormMessage />\n            </FormItem>\n          )}\n        />\n        <Button\n          type=\"submit\"\n          className=\"w-full bg-primary hover:bg-primary-dark text-black font-semibold\"\n          disabled={registerMutation.isPending}\n        >\n          {registerMutation.isPending ? (\n            <>\n              <LoadingSpinner size=\"sm\" className=\"mr-2\" />\n              Registrando...\n            </>\n          ) : (\n            \"Crear Cuenta\"\n          )}\n        </Button>\n      </form>\n    </Form>\n  );\n}","size_bytes":11804},"client/src/pages/auth-test.tsx":{"content":"import React, { useState } from 'react';\nimport { TokenManager } from '@/lib/token-manager';\n\nexport default function AuthTest() {\n  const [email, setEmail] = useState('facundoroman203@gmail.com');\n  const [password, setPassword] = useState('123456');\n  const [result, setResult] = useState<string>('');\n  const [loading, setLoading] = useState(false);\n\n  const testLogin = async () => {\n    setLoading(true);\n    setResult('Testing login...');\n    \n    try {\n      const response = await fetch('/api/auth/login', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ email, password }),\n      });\n\n      const data = await response.json();\n      \n      if (response.ok && data.token) {\n        TokenManager.setToken(data.token);\n        TokenManager.setUser(data.user);\n        setResult('Login successful! Token stored.');\n        \n        // Test immediate verification\n        const verifyResponse = await fetch('/api/auth/me', {\n          headers: TokenManager.createAuthHeaders(),\n        });\n        \n        if (verifyResponse.ok) {\n          const userData = await verifyResponse.json();\n          setResult(prev => prev + `\\nVerification successful: ${userData.name}`);\n        } else {\n          setResult(prev => prev + '\\nVerification failed');\n        }\n      } else {\n        setResult(`Login failed: ${data.message}`);\n      }\n    } catch (error) {\n      setResult(`Error: ${error}`);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const testStoredToken = async () => {\n    const token = TokenManager.getToken();\n    if (!token) {\n      setResult('No token found in storage');\n      return;\n    }\n\n    try {\n      const response = await fetch('/api/auth/me', {\n        headers: TokenManager.createAuthHeaders(),\n      });\n\n      if (response.ok) {\n        const userData = await response.json();\n        setResult(`Stored token works! User: ${userData.name}`);\n      } else {\n        setResult('Stored token invalid or expired');\n      }\n    } catch (error) {\n      setResult(`Error testing stored token: ${error}`);\n    }\n  };\n\n  const clearAuth = () => {\n    TokenManager.clearAuth();\n    setResult('Authentication data cleared');\n  };\n\n  const testLocalStorage = () => {\n    try {\n      // Test basic localStorage functionality\n      const testKey = 'test_storage_key';\n      const testValue = 'test_storage_value';\n      \n      localStorage.setItem(testKey, testValue);\n      const retrieved = localStorage.getItem(testKey);\n      localStorage.removeItem(testKey);\n      \n      if (retrieved === testValue) {\n        setResult('LocalStorage test: PASSED');\n      } else {\n        setResult('LocalStorage test: FAILED - retrieval mismatch');\n      }\n    } catch (error) {\n      setResult(`LocalStorage test: FAILED - ${error}`);\n    }\n  };\n\n  return (\n    <div className=\"max-w-md mx-auto mt-8 p-6 bg-white rounded-lg shadow-md\">\n      <h1 className=\"text-2xl font-bold mb-4\">Authentication Test</h1>\n      \n      <div className=\"space-y-4\">\n        <div>\n          <label className=\"block text-sm font-medium mb-1\">Email:</label>\n          <input\n            type=\"email\"\n            value={email}\n            onChange={(e) => setEmail(e.target.value)}\n            className=\"w-full p-2 border rounded\"\n          />\n        </div>\n        \n        <div>\n          <label className=\"block text-sm font-medium mb-1\">Password:</label>\n          <input\n            type=\"password\"\n            value={password}\n            onChange={(e) => setPassword(e.target.value)}\n            className=\"w-full p-2 border rounded\"\n          />\n        </div>\n        \n        <div className=\"space-y-2\">\n          <button\n            onClick={testLogin}\n            disabled={loading}\n            className=\"w-full bg-blue-500 text-white p-2 rounded hover:bg-blue-600 disabled:opacity-50\"\n          >\n            {loading ? 'Testing...' : 'Test Login'}\n          </button>\n          \n          <button\n            onClick={testStoredToken}\n            className=\"w-full bg-green-500 text-white p-2 rounded hover:bg-green-600\"\n          >\n            Test Stored Token\n          </button>\n          \n          <button\n            onClick={clearAuth}\n            className=\"w-full bg-red-500 text-white p-2 rounded hover:bg-red-600\"\n          >\n            Clear Auth Data\n          </button>\n          \n          <button\n            onClick={testLocalStorage}\n            className=\"w-full bg-purple-500 text-white p-2 rounded hover:bg-purple-600\"\n          >\n            Test LocalStorage\n          </button>\n        </div>\n        \n        {result && (\n          <div className=\"mt-4 p-3 bg-gray-100 rounded whitespace-pre-wrap text-sm\">\n            {result}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}","size_bytes":4808},"client/src/pages/auth.tsx":{"content":"import { useState, useEffect } from 'react';\nimport { useLocation } from 'wouter';\nimport { useAuth } from '@/hooks/use-auth';\nimport { z } from 'zod';\nimport { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { motion, AnimatePresence } from 'framer-motion';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';\nimport { Input } from '@/components/ui/input';\nimport LoadingSpinner from '@/components/ui/loading-spinner';\n\n// Login form schema\nconst loginSchema = z.object({\n  email: z.string().email({ message: 'Correo electrónico inválido' }),\n  password: z.string().min(6, { message: 'La contraseña debe tener al menos 6 caracteres' }),\n});\n\ntype LoginFormValues = z.infer<typeof loginSchema>;\n\n// Register form schema\nconst registerSchema = z.object({\n  name: z.string().min(2, { message: 'El nombre debe tener al menos 2 caracteres' }),\n  username: z.string().min(3, { message: 'El nombre de usuario debe tener al menos 3 caracteres' }),\n  email: z.string().email({ message: 'Correo electrónico inválido' }),\n  password: z.string().min(6, { message: 'La contraseña debe tener al menos 6 caracteres' }),\n  confirmPassword: z.string(),\n}).refine((data) => data.password === data.confirmPassword, {\n  message: 'Las contraseñas no coinciden',\n  path: ['confirmPassword'],\n});\n\ntype RegisterFormValues = z.infer<typeof registerSchema>;\n\nexport default function AuthPage() {\n  const [activeTab, setActiveTab] = useState('login');\n  const [_, setLocation] = useLocation();\n  const { user, isLoggedIn, loginMutation, registerMutation } = useAuth();\n  \n  // Use effect for redirection to avoid state updates during render\n  useEffect(() => {\n    if (isLoggedIn && user) {\n      setLocation('/');\n    }\n  }, [isLoggedIn, user, setLocation]);\n\n  return (\n    <motion.div \n      initial={{ opacity: 0 }}\n      animate={{ opacity: 1 }}\n      transition={{ duration: 0.5 }}\n      className=\"h-screen overflow-auto grid md:grid-cols-2 relative\"\n    >\n      {/* Background image with colored overlay */}\n      <div className=\"absolute inset-0 w-full h-full grid md:grid-cols-2 z-0\">\n        {/* Left side - White background for desktop */}\n        <motion.div \n          initial={{ x: -50, opacity: 0 }}\n          animate={{ x: 0, opacity: 1 }}\n          transition={{ delay: 0.2, duration: 0.6 }}\n          className=\"hidden md:block relative\"\n        >\n          <div className=\"absolute inset-0 bg-white\" />\n        </motion.div>\n        \n        {/* Right side background - Image 1 for mobile, visible on all screens */}\n        <motion.div \n          initial={{ scale: 1.1, opacity: 0 }}\n          animate={{ scale: 1, opacity: 1 }}\n          transition={{ delay: 0.1, duration: 0.8 }}\n          className=\"relative col-span-1 w-full h-full\"\n        >\n          <div \n            className=\"absolute inset-0 bg-cover bg-center\"\n            style={{ backgroundImage: 'url(/images/1.jpg)' }}\n          />\n          <div className=\"absolute inset-0 bg-primary/50\" />\n        </motion.div>\n      </div>\n\n      {/* Hero Section - Hidden on mobile */}\n      <motion.div \n        initial={{ x: -30, opacity: 0 }}\n        animate={{ x: 0, opacity: 1 }}\n        transition={{ delay: 0.4, duration: 0.6 }}\n        className=\"hidden md:flex flex-col justify-center p-6 relative z-10 text-gray-800\"\n      >\n        <div className=\"max-w-md mx-auto\">\n          <motion.h1 \n            initial={{ y: 20, opacity: 0 }}\n            animate={{ y: 0, opacity: 1 }}\n            transition={{ delay: 0.6, duration: 0.5 }}\n            className=\"text-3xl font-bold mb-4\"\n          >\n            Bienvenido a Pipol\n          </motion.h1>\n          <motion.p \n            initial={{ y: 20, opacity: 0 }}\n            animate={{ y: 0, opacity: 1 }}\n            transition={{ delay: 0.7, duration: 0.5 }}\n            className=\"text-lg mb-4\"\n          >\n            Explora eventos cercanos, crea tus propios eventos y conecta con personas que comparten tus intereses.\n          </motion.p>\n          <motion.div \n            initial={{ y: 30, opacity: 0 }}\n            animate={{ y: 0, opacity: 1 }}\n            transition={{ delay: 0.8, duration: 0.6 }}\n            className=\"space-y-3\"\n          >\n            <div className=\"flex items-start space-x-3\">\n              <div className=\"bg-primary/20 p-2 rounded-full\">\n                <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-4 w-4\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\">\n                  <circle cx=\"12\" cy=\"12\" r=\"10\"></circle>\n                  <line x1=\"12\" y1=\"8\" x2=\"12\" y2=\"12\"></line>\n                  <line x1=\"12\" y1=\"16\" x2=\"12.01\" y2=\"16\"></line>\n                </svg>\n              </div>\n              <div>\n                <h3 className=\"font-medium text-sm\">Descubre eventos</h3>\n                <p className=\"text-xs text-gray-600\">Encuentra eventos cerca de ti basados en tus intereses</p>\n              </div>\n            </div>\n            <div className=\"flex items-start space-x-3\">\n              <div className=\"bg-primary/20 p-2 rounded-full\">\n                <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-4 w-4\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\">\n                  <path d=\"M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\"></path>\n                  <circle cx=\"9\" cy=\"7\" r=\"4\"></circle>\n                  <path d=\"M23 21v-2a4 4 0 0 0-3-3.87\"></path>\n                  <path d=\"M16 3.13a4 4 0 0 1 0 7.75\"></path>\n                </svg>\n              </div>\n              <div>\n                <h3 className=\"font-medium text-sm\">Conecta con otros</h3>\n                <p className=\"text-xs text-gray-600\">Conoce personas nuevas y haz amigos en eventos</p>\n              </div>\n            </div>\n            <div className=\"flex items-start space-x-3\">\n              <div className=\"bg-primary/20 p-2 rounded-full\">\n                <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-4 w-4\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\">\n                  <rect x=\"3\" y=\"4\" width=\"18\" height=\"18\" rx=\"2\" ry=\"2\"></rect>\n                  <line x1=\"16\" y1=\"2\" x2=\"16\" y2=\"6\"></line>\n                  <line x1=\"8\" y1=\"2\" x2=\"8\" y2=\"6\"></line>\n                  <line x1=\"3\" y1=\"10\" x2=\"21\" y2=\"10\"></line>\n                </svg>\n              </div>\n              <div>\n                <h3 className=\"font-medium text-sm\">Crea tus eventos</h3>\n                <p className=\"text-xs text-gray-600\">Organiza tus propios eventos y compártelos</p>\n              </div>\n            </div>\n          </motion.div>\n        </div>\n      </motion.div>\n\n      {/* Auth Form */}\n      <motion.div \n        initial={{ x: 30, opacity: 0, scale: 0.95 }}\n        animate={{ x: 0, opacity: 1, scale: 1 }}\n        transition={{ delay: 0.3, duration: 0.6, ease: \"easeOut\" }}\n        className=\"flex items-center justify-center p-2 overflow-y-auto relative z-10\"\n      >\n        <motion.div\n          whileHover={{ scale: 1.02 }}\n          transition={{ duration: 0.2 }}\n        >\n          <Card className=\"w-full max-w-[280px] bg-white/90 backdrop-blur-sm border-none shadow-xl rounded-xl\">\n          <CardHeader className=\"py-3 px-4\">\n            <div className=\"flex justify-center mb-3\">\n              <img src=\"/pipol-logo.png\" alt=\"Pipol Logo\" className=\"h-14\" />\n            </div>\n            <CardDescription className=\"text-[11px] text-center font-medium\">\n              {activeTab === 'login' \n                ? 'Inicia sesión en tu cuenta para continuar' \n                : 'Crea una cuenta para empezar a usar Pipol'}\n            </CardDescription>\n          </CardHeader>\n          <CardContent className=\"p-4\">\n            <Tabs defaultValue=\"login\" onValueChange={setActiveTab}>\n              <TabsList className=\"grid w-full grid-cols-2 mb-4 h-8 rounded-lg\">\n                <TabsTrigger value=\"login\" className=\"text-xs rounded-md\">Iniciar Sesión</TabsTrigger>\n                <TabsTrigger value=\"register\" className=\"text-xs rounded-md\">Registrarse</TabsTrigger>\n              </TabsList>\n              \n              <TabsContent value=\"login\">\n                <LoginForm />\n              </TabsContent>\n              \n              <TabsContent value=\"register\">\n                <RegisterForm />\n              </TabsContent>\n            </Tabs>\n          </CardContent>\n          <CardFooter className=\"flex flex-col py-3 px-4\">\n            <div className=\"text-[10px] text-center text-neutral-600\">\n              Al continuar, aceptas nuestros Términos de Servicio y Política de Privacidad.\n            </div>\n          </CardFooter>\n        </Card>\n        </motion.div>\n      </motion.div>\n    </motion.div>\n  );\n}\n\nfunction LoginForm() {\n  const { loginMutation, isLoggedIn } = useAuth();\n  const [_, setLocation] = useLocation();\n  \n  const form = useForm<LoginFormValues>({\n    resolver: zodResolver(loginSchema),\n    defaultValues: {\n      email: '',\n      password: '',\n    },\n  });\n\n  // If user is already logged in, redirect to home\n  useEffect(() => {\n    if (isLoggedIn) {\n      setLocation('/');\n    }\n  }, [isLoggedIn, setLocation]);\n\n  // Use the login mutation from our auth hook\n  const onSubmit = (values: LoginFormValues) => {\n    console.log(\"Submitting login form for:\", values.email);\n    loginMutation.mutate(values);\n  };\n\n  return (\n    <Form {...form}>\n      <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-2\">\n        <FormField\n          control={form.control}\n          name=\"email\"\n          render={({ field }) => (\n            <FormItem>\n              <FormLabel className=\"text-[10px]\">Correo</FormLabel>\n              <FormControl>\n                <Input placeholder=\"tu@correo.com\" {...field} className=\"h-7 text-xs px-2\" />\n              </FormControl>\n              <FormMessage className=\"text-[8px]\" />\n            </FormItem>\n          )}\n        />\n        \n        <FormField\n          control={form.control}\n          name=\"password\"\n          render={({ field }) => (\n            <FormItem>\n              <FormLabel className=\"text-[10px]\">Contraseña</FormLabel>\n              <FormControl>\n                <Input type=\"password\" placeholder=\"••••\" {...field} className=\"h-7 text-xs px-2\" />\n              </FormControl>\n              <FormMessage className=\"text-[8px]\" />\n            </FormItem>\n          )}\n        />\n        \n        <Button \n          type=\"submit\" \n          className=\"w-full h-6 text-xs bg-primary hover:bg-primary/90\" \n          disabled={loginMutation.isPending}\n        >\n          {loginMutation.isPending ? (\n            <>\n              <LoadingSpinner size={12} className=\"mr-1\" />\n              <span className=\"text-[10px]\">Iniciando sesión...</span>\n            </>\n          ) : (\n            <span className=\"text-[10px]\">Iniciar Sesión</span>\n          )}\n        </Button>\n      </form>\n    </Form>\n  );\n}\n\nfunction RegisterForm() {\n  const { registerMutation, isLoggedIn } = useAuth();\n  const [_, setLocation] = useLocation();\n  \n  const form = useForm<RegisterFormValues>({\n    resolver: zodResolver(registerSchema),\n    defaultValues: {\n      name: '',\n      username: '',\n      email: '',\n      password: '',\n      confirmPassword: '',\n    },\n  });\n  \n  // If user is already logged in, redirect to home\n  useEffect(() => {\n    if (isLoggedIn) {\n      setLocation('/');\n    }\n  }, [isLoggedIn, setLocation]);\n\n  const onSubmit = (values: RegisterFormValues) => {\n    console.log(\"Submitting registration form for:\", values.email);\n    // Remove confirmPassword before sending to API\n    const { confirmPassword, ...registerData } = values;\n    registerMutation.mutate(registerData);\n  };\n\n  return (\n    <Form {...form}>\n      <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-2\">\n        <div className=\"grid grid-cols-2 gap-2\">\n          <FormField\n            control={form.control}\n            name=\"name\"\n            render={({ field }) => (\n              <FormItem>\n                <FormLabel className=\"text-[10px]\">Nombre</FormLabel>\n                <FormControl>\n                  <Input placeholder=\"Juan Pérez\" {...field} className=\"h-7 text-xs px-2\" />\n                </FormControl>\n                <FormMessage className=\"text-[8px]\" />\n              </FormItem>\n            )}\n          />\n\n          <FormField\n            control={form.control}\n            name=\"username\"\n            render={({ field }) => (\n              <FormItem>\n                <FormLabel className=\"text-[10px]\">Usuario</FormLabel>\n                <FormControl>\n                  <Input placeholder=\"juanperez\" {...field} className=\"h-7 text-xs px-2\" />\n                </FormControl>\n                <FormMessage className=\"text-[8px]\" />\n              </FormItem>\n            )}\n          />\n        </div>\n        \n        <FormField\n          control={form.control}\n          name=\"email\"\n          render={({ field }) => (\n            <FormItem>\n              <FormLabel className=\"text-[10px]\">Correo</FormLabel>\n              <FormControl>\n                <Input placeholder=\"tu@correo.com\" {...field} className=\"h-7 text-xs px-2\" />\n              </FormControl>\n              <FormMessage className=\"text-[8px]\" />\n            </FormItem>\n          )}\n        />\n        \n        <div className=\"grid grid-cols-2 gap-2\">\n          <FormField\n            control={form.control}\n            name=\"password\"\n            render={({ field }) => (\n              <FormItem>\n                <FormLabel className=\"text-[10px]\">Contraseña</FormLabel>\n                <FormControl>\n                  <Input type=\"password\" placeholder=\"••••\" {...field} className=\"h-7 text-xs px-2\" />\n                </FormControl>\n                <FormMessage className=\"text-[8px]\" />\n              </FormItem>\n            )}\n          />\n          \n          <FormField\n            control={form.control}\n            name=\"confirmPassword\"\n            render={({ field }) => (\n              <FormItem>\n                <FormLabel className=\"text-[10px]\">Confirmar</FormLabel>\n                <FormControl>\n                  <Input type=\"password\" placeholder=\"••••\" {...field} className=\"h-7 text-xs px-2\" />\n                </FormControl>\n                <FormMessage className=\"text-[8px]\" />\n              </FormItem>\n            )}\n          />\n        </div>\n        \n        <Button \n          type=\"submit\" \n          className=\"w-full h-6 text-xs bg-primary hover:bg-primary/90\" \n          disabled={registerMutation.isPending}\n        >\n          {registerMutation.isPending ? (\n            <>\n              <LoadingSpinner size={12} className=\"mr-1\" />\n              <span className=\"text-[10px]\">Registrando...</span>\n            </>\n          ) : (\n            <span className=\"text-[10px]\">Crear Cuenta</span>\n          )}\n        </Button>\n      </form>\n    </Form>\n  );\n}","size_bytes":15213},"client/src/pages/edit-event.tsx":{"content":"import { useEffect, useState } from 'react';\nimport { useLocation, useParams } from 'wouter';\nimport { useQuery } from '@tanstack/react-query';\nimport { useAuth } from '@/hooks/use-auth';\nimport { useToast } from '@/hooks/use-toast';\nimport EditEventForm from '@/components/events/edit-event-form';\nimport LoadingSpinner from '@/components/ui/loading-spinner';\n\nconst EditEventPage = () => {\n  const params = useParams<{ eventId: string }>();\n  const eventId = parseInt(params.eventId, 10);\n  const [_, navigate] = useLocation();\n  const { user, isLoading: authLoading } = useAuth();\n  const { toast } = useToast();\n  const [formVisible, setFormVisible] = useState(false);\n  const [error500, setError500] = useState(false);\n\n  console.log(\"Iniciando EditEventPage con eventId:\", eventId);\n\n  // Fetch event details\n  const { data: event, isLoading, error } = useQuery({\n    queryKey: [`/api/events/${eventId}`],\n    queryFn: async () => {\n      try {\n        console.log(\"Fetching event data for ID:\", eventId);\n        const response = await fetch(`/api/events/${eventId}`, {\n          credentials: 'include',\n        });\n        if (!response.ok) {\n          console.error(\"Error fetching event data:\", response.status, response.statusText);\n          if (response.status === 500) {\n            setError500(true);\n          }\n          throw new Error(`Failed to fetch event details: ${response.status}`);\n        }\n        const data = await response.json();\n        console.log(\"Event data fetched successfully:\", data);\n        return data;\n      } catch (err) {\n        console.error(\"Error in queryFn:\", err);\n        throw err;\n      }\n    },\n    enabled: !!eventId && !isNaN(eventId),\n    retry: 1,\n  });\n\n  // Check authentication\n  useEffect(() => {\n    if (authLoading) return;\n    \n    if (!user) {\n      toast({\n        title: 'Autenticación Requerida',\n        description: 'Por favor inicia sesión para editar eventos',\n        variant: 'destructive',\n      });\n      navigate('/auth');\n      return;\n    }\n  }, [user, authLoading, toast, navigate]);\n\n  // Check authorization when event is loaded\n  useEffect(() => {\n    if (!event || !user) return;\n    \n    // Check if event has organizerId (should be more reliable than event.organizer)\n    if (!event.organizerId) {\n      // Log error and redirect\n      console.error('Error: El evento no tiene ID de organizador válido', event);\n      toast({\n        title: 'Error de Datos',\n        description: 'No se pudo verificar el organizador del evento',\n        variant: 'destructive',\n      });\n      navigate('/');\n      return;\n    }\n    \n    // En caso de que event.organizer no esté presente pero sí tengamos organizerId\n    if (!event.organizer) {\n      console.log('Advertencia: event.organizer no existe, pero sí existe organizerId:', event.organizerId);\n    }\n    \n    // Check if user is the organizer (usando prioritariamente organizerId)\n    const organizerId = event.organizerId || (event.organizer && event.organizer.id);\n    \n    if (organizerId !== user.id) {\n      console.log(`Usuario ${user.id} intentó editar evento del organizador ${organizerId}`);\n      toast({\n        title: 'No Autorizado',\n        description: 'Solo el organizador puede editar este evento',\n        variant: 'destructive',\n      });\n      navigate('/');\n      return;\n    }\n    \n    // If authenticated and authorized, show the form\n    setFormVisible(true);\n  }, [event, user, toast, navigate]);\n  \n  // Handle form close\n  const handleClose = () => {\n    navigate('/my-events');\n  };\n\n  // Loading state\n  if ((isLoading || authLoading) && !formVisible) {\n    return (\n      <div className=\"flex h-screen items-center justify-center\">\n        <LoadingSpinner size=\"lg\" />\n      </div>\n    );\n  }\n\n  // Error state\n  if (error && !formVisible) {\n    return (\n      <div className=\"flex h-screen items-center justify-center\">\n        <div className=\"text-center p-4\">\n          <h2 className=\"text-lg font-semibold mb-2\">Error al cargar el evento</h2>\n          <p className=\"text-neutral-500\">No se pudo cargar la información del evento</p>\n          <button \n            className=\"mt-4 bg-primary text-white px-4 py-2 rounded-lg\"\n            onClick={() => navigate('/my-events')}\n          >\n            Volver a Mis Eventos\n          </button>\n        </div>\n      </div>\n    );\n  }\n\n  // Handle errors from the server\n  if (error500) {\n    return (\n      <div className=\"flex h-screen items-center justify-center\">\n        <div className=\"text-center p-4\">\n          <h2 className=\"text-lg font-semibold mb-2\">Error del servidor</h2>\n          <p className=\"text-neutral-500\">Hubo un problema procesando tu solicitud</p>\n          <button \n            className=\"mt-4 bg-primary text-white px-4 py-2 rounded-lg\"\n            onClick={() => navigate('/my-events')}\n          >\n            Volver a Mis Eventos\n          </button>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"flex flex-col min-h-screen bg-white\">\n      <div className=\"w-full max-w-4xl mx-auto pt-4 pb-24 flex-grow\">\n        {event && formVisible && (\n          <div className=\"edit-event-container px-4\">\n            <EditEventForm\n              eventId={eventId}\n              event={event}\n              visible={true}\n              onClose={handleClose}\n            />\n          </div>\n        )}\n        {!event && !isLoading && !error && (\n          <div className=\"flex h-screen items-center justify-center\">\n            <div className=\"text-center p-4\">\n              <h2 className=\"text-lg font-semibold mb-2\">No se encontró el evento</h2>\n              <p className=\"text-neutral-500\">El evento que buscas no existe o no tienes acceso</p>\n              <button \n                className=\"mt-4 bg-primary text-white px-4 py-2 rounded-lg\"\n                onClick={() => navigate('/my-events')}\n              >\n                Volver a Mis Eventos\n              </button>\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default EditEventPage;\n","size_bytes":6054},"client/src/pages/messages.tsx":{"content":"import { useEffect, useState } from \"react\";\nimport { useLocation } from \"wouter\";\nimport { useAuth } from \"@/hooks/use-auth\";\nimport BottomNav from \"@/components/layout/bottom-nav\";\nimport { MessageSquare, Calendar, Search, Group, User, Star } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\nimport { format, isToday, isTomorrow, isAfter, addDays, parseISO } from \"date-fns\";\nimport Chat from \"@/components/chat/chat\";\nimport { es } from \"date-fns/locale\";\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"@/components/ui/tabs\";\nimport { Input } from \"@/components/ui/input\";\nimport LoadingSpinner from \"@/components/ui/loading-spinner\";\nimport { getCategoryEmoji } from \"@/lib/eventsToGeoJSON\";\nimport EventDetailSheet from \"@/components/events/event-detail-sheet\";\nimport { simpleChatService } from \"@/components/chat/simple-chat-service\";\n\n// Unified type for all events (both attending and created)\ninterface UnifiedEvent {\n  id: number;\n  title: string;\n  description: string;\n  date: string;\n  category: string;\n  locationName: string;\n  mainMediaUrl?: string;\n  mainMediaType?: string;\n  organizer: {\n    id: number;\n    name: string;\n    username: string;\n  };\n  isCreatedByUser?: boolean; // true if user is the organizer\n  attendeeCount?: number;\n}\n\nconst Messages = () => {\n  const { user, isLoading } = useAuth();\n  const [_, navigate] = useLocation();\n  const [attendingEvents, setAttendingEvents] = useState<UnifiedEvent[]>([]);\n  const [createdEvents, setCreatedEvents] = useState<UnifiedEvent[]>([]);\n  const [isEventsLoading, setIsEventsLoading] = useState(false);\n  const [latestMessages, setLatestMessages] = useState<{ [eventId: number]: any }>({});\n  const [unreadCounts, setUnreadCounts] = useState<{ [eventId: number]: number }>({});\n  const [activeTab, setActiveTab] = useState('attending');\n  const [selectedEventId, setSelectedEventId] = useState<number | null>(null);\n  const [selectedEventTitle, setSelectedEventTitle] = useState<string>('');\n  const [selectedEventImage, setSelectedEventImage] = useState<string>('');\n  const [chatVisible, setChatVisible] = useState(false);\n  const [eventDetailVisible, setEventDetailVisible] = useState(false);\n  const [selectedEventForDetail, setSelectedEventForDetail] = useState<UnifiedEvent | null>(null);\n  const [searchTerm, setSearchTerm] = useState('');\n\n  // Redirect if not logged in\n  useEffect(() => {\n    if (!isLoading && !user) {\n      navigate(\"/login\");\n      return;\n    }\n    // Fetch events when user is loaded - combined to avoid double effect\n    if (user) {\n      fetchAllEvents();\n    }\n  }, [user, isLoading, navigate]);\n\n  // Listen for new messages to update previews in real time\n  useEffect(() => {\n    if (!user) return;\n\n    const handleNewMessage = (message: any) => {\n      // Update latest messages when a new message arrives\n      if (message.type === 'new_message' && message.eventId && message.message) {\n        console.log('📨 Updating message preview for event:', message.eventId);\n        \n        setLatestMessages(prev => ({\n          ...prev,\n          [message.eventId]: {\n            id: message.message.id,\n            event_id: message.message.eventId,\n            sender_id: message.message.senderId,\n            content: message.message.content,\n            message_type: message.message.messageType,\n            created_at: message.message.createdAt,\n            sender: message.message.sender\n          }\n        }));\n        \n        // Update unread count if message is from someone else\n        if (message.message.senderId !== user.id) {\n          setUnreadCounts(prev => ({\n            ...prev,\n            [message.eventId]: (prev[message.eventId] || 0) + 1\n          }));\n        }\n      }\n    };\n\n    // Register the message listener\n    simpleChatService.onMessage(handleNewMessage);\n\n    // Cleanup function to remove message listener\n    return () => {\n      simpleChatService.removeMessageListener(handleNewMessage);\n    };\n  }, [user]);\n\n  // Fetch all events (attending + created) in parallel\n  const fetchAllEvents = async () => {\n    setIsEventsLoading(true);\n    try {\n      // Fetch both types of events in parallel\n      const [attendingResponse, createdResponse] = await Promise.all([\n        fetch('/api/user/events/attending', {\n          method: 'GET',\n          credentials: 'include',\n          headers: { 'Content-Type': 'application/json' },\n        }),\n        fetch('/api/user/events/created', {\n          method: 'GET',\n          credentials: 'include',\n          headers: { 'Content-Type': 'application/json' },\n        })\n      ]);\n\n      // Process attending events\n      let processedAttendingEvents: UnifiedEvent[] = [];\n      if (attendingResponse.ok) {\n        const attendingData = await attendingResponse.json();\n        processedAttendingEvents = attendingData.map((item: any) => ({\n          id: item.event.id,\n          title: item.event.title,\n          description: item.event.description,\n          date: item.event.date,\n          category: item.event.category,\n          locationName: item.event.locationName,\n          mainMediaUrl: item.event.mainMediaUrl,\n          mainMediaType: item.event.mainMediaType,\n          organizer: item.event.organizer,\n          isCreatedByUser: false,\n          attendeeCount: item.event.attendees?.length || 0\n        }));\n      }\n\n      // Process created events\n      let processedCreatedEvents: UnifiedEvent[] = [];\n      if (createdResponse.ok) {\n        const createdData = await createdResponse.json();\n        processedCreatedEvents = createdData.map((event: any) => ({\n          id: event.id,\n          title: event.title,\n          description: event.description,\n          date: event.date,\n          category: event.category,\n          locationName: event.locationName,\n          mainMediaUrl: event.mainMediaUrl,\n          mainMediaType: event.mainMediaType,\n          organizer: {\n            id: user!.id,\n            name: user!.name || user!.username,\n            username: user!.username\n          },\n          isCreatedByUser: true,\n          attendeeCount: event.attendees?.length || 0\n        }));\n        \n        // Add created events to attending events too (organizer always attends)\n        processedAttendingEvents.push(...processedCreatedEvents);\n      }\n\n      // Remove duplicates from attending events\n      const uniqueAttendingEvents = processedAttendingEvents.filter((event, index, self) => \n        index === self.findIndex(e => e.id === event.id)\n      );\n\n      // Sort by date (most recent first)\n      uniqueAttendingEvents.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());\n      processedCreatedEvents.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());\n\n      setAttendingEvents(uniqueAttendingEvents);\n      setCreatedEvents(processedCreatedEvents);\n\n      // Fetch latest messages for all events\n      const allEventIds = [...uniqueAttendingEvents, ...processedCreatedEvents]\n        .map(event => event.id)\n        .filter((id, index, self) => self.indexOf(id) === index); // Remove duplicates\n      \n      if (allEventIds.length > 0) {\n        fetchLatestMessages(allEventIds);\n      }\n    } catch (error) {\n      console.error('Error fetching events:', error);\n    } finally {\n      setIsEventsLoading(false);\n    }\n  };\n\n  // Fetch latest messages for events\n  const fetchLatestMessages = async (eventIds: number[]) => {\n    try {\n      const response = await fetch(`/api/events/latest-messages?eventIds=${eventIds.join(',')}`, {\n        method: 'GET',\n        credentials: 'include',\n        headers: { 'Content-Type': 'application/json' },\n      });\n\n      if (response.ok) {\n        const messages = await response.json();\n        setLatestMessages(messages);\n        \n        // Initialize unread counts (simulate some unread messages for demo)\n        const newUnreadCounts: { [eventId: number]: number } = {};\n        Object.keys(messages).forEach(eventIdStr => {\n          const eventId = parseInt(eventIdStr);\n          const message = messages[eventId];\n          \n          // Simulate unread messages: if message exists and is from someone else\n          if (message && user && message.sender_id !== user.id) {\n            // Simulate random unread count between 1-5 for demonstration\n            newUnreadCounts[eventId] = Math.floor(Math.random() * 3) + 1;\n          }\n        });\n        setUnreadCounts(newUnreadCounts);\n      }\n    } catch (error) {\n      console.error('Error fetching latest messages:', error);\n    }\n  };\n\n  // Open chat for any event\n  const openEventChat = (event: UnifiedEvent) => {\n    setSelectedEventId(event.id);\n    setSelectedEventTitle(event.title);\n    setSelectedEventImage(event.mainMediaUrl || '');\n    // IMPORTANT: Also save the complete event for detail panel access\n    setSelectedEventForDetail(event);\n    setChatVisible(true);\n    \n    // Mark messages as read when opening chat (WhatsApp behavior)\n    if (unreadCounts[event.id] > 0) {\n      setUnreadCounts(prev => ({\n        ...prev,\n        [event.id]: 0\n      }));\n    }\n  };\n\n  // Close the chat\n  const closeChat = () => {\n    setChatVisible(false);\n  };\n\n  const openEventDetail = async (event: UnifiedEvent) => {\n    try {\n      // Fetch complete event data with all details (attendees, coordinates, etc.)\n      const response = await fetch(`/api/events/${event.id}`, {\n        credentials: 'include',\n        headers: { 'Content-Type': 'application/json' },\n      });\n      \n      if (response.ok) {\n        const completeEventData = await response.json();\n        // Format the complete event data for EventDetailSheet\n        const formattedEvent = {\n          ...completeEventData,\n          latitude: typeof completeEventData.latitude === 'string' ? parseFloat(completeEventData.latitude) : (completeEventData.latitude || 0),\n          longitude: typeof completeEventData.longitude === 'string' ? parseFloat(completeEventData.longitude) : (completeEventData.longitude || 0),\n          date: completeEventData.date instanceof Date ? completeEventData.date.toISOString() : completeEventData.date\n        };\n        setSelectedEventForDetail(formattedEvent);\n        setEventDetailVisible(true);\n      } else {\n        console.error('Failed to fetch complete event data');\n        // Fallback to basic event data\n        setSelectedEventForDetail(event);\n        setEventDetailVisible(true);\n      }\n    } catch (error) {\n      console.error('Error fetching complete event data:', error);\n      // Fallback to basic event data\n      setSelectedEventForDetail(event);\n      setEventDetailVisible(true);\n    }\n  };\n\n  const closeEventDetail = () => {\n    setEventDetailVisible(false);\n    setSelectedEventForDetail(null);\n  };\n\n  // Filter events by search term\n  const filterEvents = (events: UnifiedEvent[]) => {\n    if (!searchTerm) return events;\n    \n    return events.filter(event => \n      event.title.toLowerCase().includes(searchTerm.toLowerCase()) ||\n      event.locationName.toLowerCase().includes(searchTerm.toLowerCase())\n    );\n  };\n\n  if (isLoading) {\n    return (\n      <div className=\"flex h-screen items-center justify-center\">\n        <LoadingSpinner size=\"lg\" />\n      </div>\n    );\n  }\n\n  const showEmptyState = () => {\n    return (\n      <div className=\"flex-1 flex flex-col items-center justify-center p-4\">\n        <div className=\"bg-neutral-100 p-6 rounded-full mb-4\">\n          <MessageSquare size={48} className=\"text-neutral-400\" />\n        </div>\n        <h2 className=\"text-xl font-semibold mb-2\">No hay mensajes todavía</h2>\n        <p className=\"text-neutral-500 text-center mb-6\">\n          {activeTab === 'attending' \n            ? 'Los chats de los eventos a los que te hayas unido aparecerán aquí.' \n            : 'Los chats de los eventos que has creado aparecerán aquí.'}\n        </p>\n        <Button \n          className=\"bg-primary-500 hover:bg-primary-600\"\n          onClick={() => navigate(\"/\")}\n        >\n          {activeTab === 'attending' ? 'Explorar Eventos' : 'Crear Evento'}\n        </Button>\n      </div>\n    );\n  };\n\n  // Formato amigable para la fecha y hora del evento\n  const formatEventDate = (dateString: string) => {\n    try {\n      const date = parseISO(dateString);\n      \n      if (isToday(date)) {\n        return `Hoy, ${format(date, 'HH:mm')}`;\n      } else if (isTomorrow(date)) {\n        return `Mañana, ${format(date, 'HH:mm')}`;\n      } else if (isAfter(date, addDays(new Date(), 7))) {\n        // Si es más de una semana en el futuro\n        return format(date, \"d 'de' MMMM, HH:mm\", { locale: es });\n      } else {\n        // Entre 2 y 7 días\n        return format(date, \"EEEE, HH:mm\", { locale: es });\n      }\n    } catch (error) {\n      // Si hay algún error en el formato de fecha\n      return \"Fecha por confirmar\";\n    }\n  };\n  \n  // Format message time\n  const formatMessageTime = (dateString: string) => {\n    try {\n      const date = new Date(dateString);\n      return format(date, 'HH:mm');\n    } catch (error) {\n      return '';\n    }\n  };\n\n  // Get message preview for event (WhatsApp style)\n  const getMessagePreview = (eventId: number) => {\n    const message = latestMessages[eventId];\n    if (!message) {\n      return 'Envía un Mensaje!';\n    }\n    \n    // Check if message is from current user\n    const isOwnMessage = user && message.sender_id === user.id;\n    const senderPrefix = isOwnMessage ? 'Tú: ' : (message.sender ? `${message.sender.name}: ` : '');\n    \n    return `${senderPrefix}${message.content}`;\n  };\n\n  // Get message time for event\n  const getMessageTime = (eventId: number) => {\n    const message = latestMessages[eventId];\n    return message ? formatMessageTime(message.created_at) : '';\n  };\n\n  // Check if event has unread messages\n  const hasUnreadMessages = (eventId: number) => {\n    return (unreadCounts[eventId] || 0) > 0;\n  };\n\n  // Get unread count for event\n  const getUnreadCount = (eventId: number) => {\n    return unreadCounts[eventId] || 0;\n  };\n\n  // Sort events by last message time (most recent first) - WhatsApp style\n  const sortEventsByLastMessage = (events: UnifiedEvent[]) => {\n    return [...events].sort((a, b) => {\n      const messageA = latestMessages[a.id];\n      const messageB = latestMessages[b.id];\n      \n      // If no messages, keep original order\n      if (!messageA && !messageB) return 0;\n      if (!messageA) return 1; // B has message, A doesn't - B first\n      if (!messageB) return -1; // A has message, B doesn't - A first\n      \n      // Compare message times\n      const timeA = new Date(messageA.created_at).getTime();\n      const timeB = new Date(messageB.created_at).getTime();\n      return timeB - timeA; // Most recent first\n    });\n  };\n\n  // Render the chat as overlay instead of replacing the entire view\n\n  // Early return for loading state to prevent double render\n  if (isLoading) {\n    return (\n      <div className=\"bg-white flex h-screen items-center justify-center\">\n        <LoadingSpinner size=\"lg\" />\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"flex flex-col h-screen bg-neutral-50\">\n      {/* Header */}\n      <div className=\"bg-white px-4 py-4 border-b border-neutral-200 flex-shrink-0\">\n        <h1 className=\"text-xl font-bold\">Mensajes</h1>\n      </div>\n\n      {/* Search Bar */}\n      <div className=\"bg-white px-3 py-2 border-b border-neutral-200 flex-shrink-0\">\n        <div className=\"relative\">\n          <Search className=\"absolute left-3 top-1/2 transform -translate-y-1/2 text-neutral-400\" size={16} />\n          <Input \n            placeholder=\"Buscar chat\" \n            className=\"bg-neutral-100 pl-10 text-sm rounded-md border-none\"\n            value={searchTerm}\n            onChange={(e) => setSearchTerm(e.target.value)}\n          />\n        </div>\n      </div>\n\n      {/* Events List with Tabs */}\n      <div className=\"flex-1 flex flex-col min-h-0\">\n        <Tabs defaultValue=\"attending\" className=\"w-full flex flex-col h-full\" onValueChange={setActiveTab}>\n          <div className=\"bg-white border-b border-neutral-200 flex-shrink-0\">\n            <TabsList className=\"grid grid-cols-2\">\n              <TabsTrigger value=\"attending\">\n                <Group className=\"mr-2\" size={16} />\n                Eventos que Asisto\n              </TabsTrigger>\n              <TabsTrigger value=\"created\">\n                <Star className=\"mr-2\" size={16} />\n                Mis Eventos\n              </TabsTrigger>\n            </TabsList>\n          </div>\n          \n          <TabsContent value=\"attending\" className=\"mt-0 flex-1 min-h-0\">\n            {isEventsLoading ? (\n              <div className=\"flex justify-center p-8\">\n                <LoadingSpinner size=\"md\" />\n              </div>\n            ) : attendingEvents.length === 0 ? (\n              showEmptyState()\n            ) : (\n              <div className=\"divide-y divide-neutral-200 bg-white overflow-y-auto h-full pb-24\">\n                {filterEvents(sortEventsByLastMessage(attendingEvents)).map((event) => (\n                  <div \n                    key={event.id}\n                    className=\"p-3 hover:bg-neutral-50 transition cursor-pointer\"\n                    onClick={() => openEventChat(event)}\n                  >\n                    <div className=\"flex\">\n                      {/* Avatar/Image */}\n                      <div className=\"mr-3 flex items-center\">\n                        <div className=\"relative\">\n                          {/* Always show yellow ring */}\n                          <div className=\"p-0.5 bg-yellow-400 rounded-full\">\n                            <div className=\"w-14 h-14 rounded-full overflow-hidden bg-neutral-100 flex items-center justify-center\">\n                              {event.mainMediaUrl ? (\n                                <img \n                                  src={event.mainMediaUrl} \n                                  alt={event.title}\n                                  className=\"h-full w-full object-cover\"\n                                />\n                              ) : (\n                                <Group size={26} className=\"text-primary\" />\n                              )}\n                            </div>\n                          </div>\n                          {/* Category emoji indicator */}\n                          <div className=\"absolute -bottom-1 -right-1 w-6 h-6 bg-yellow-400 rounded-full flex items-center justify-center border-2 border-white\">\n                            <span className=\"text-xs\">{getCategoryEmoji(event.category)}</span>\n                          </div>\n                        </div>\n                      </div>\n                      \n                      {/* Chat content */}\n                      <div className=\"flex-1 min-w-0\">\n                        <div className=\"flex justify-between items-start\">\n                          <h3 className={`${hasUnreadMessages(event.id) ? 'font-bold' : 'font-medium'} text-neutral-900 truncate pr-1`}>\n                            {event.title}\n                            {event.isCreatedByUser && (\n                              <span className=\"ml-2 text-xs text-primary font-medium\">Organizador</span>\n                            )}\n                          </h3>\n                          <span className=\"text-xs text-neutral-500 whitespace-nowrap ml-2\">\n                            {getMessageTime(event.id)}\n                          </span>\n                        </div>\n                        \n                        <div className=\"flex justify-between items-center mt-1\">\n                          <p className={`text-sm ${hasUnreadMessages(event.id) ? 'font-medium text-neutral-800' : 'text-neutral-600'} truncate pr-1`}>\n                            {getMessagePreview(event.id)}\n                          </p>\n                          {hasUnreadMessages(event.id) && (\n                            <div className=\"flex items-center ml-2\">\n                              <div className=\"bg-green-500 text-white text-xs min-w-[20px] h-5 rounded-full flex items-center justify-center px-1.5\">\n                                {getUnreadCount(event.id)}\n                              </div>\n                            </div>\n                          )}\n                        </div>\n                        \n                        <div className=\"flex items-center justify-between mt-2\">\n                          <div className=\"flex items-center\">\n                            <Calendar size={12} className=\"text-neutral-400 mr-1\" />\n                            <span className=\"text-xs text-neutral-500\">\n                              {formatEventDate(event.date)}\n                            </span>\n                          </div>\n                          <div className=\"flex items-center\">\n                            <Group size={12} className=\"text-neutral-400 mr-1\" />\n                            <span className=\"text-xs text-neutral-500\">\n                              {event.attendeeCount || 0} asistentes\n                            </span>\n                          </div>\n                        </div>\n                      </div>\n                    </div>\n                  </div>\n                ))}\n              </div>\n            )}\n          </TabsContent>\n          \n          <TabsContent value=\"created\" className=\"mt-0 flex-1 min-h-0\">\n            {isEventsLoading ? (\n              <div className=\"flex justify-center p-8\">\n                <LoadingSpinner size=\"md\" />\n              </div>\n            ) : createdEvents.length === 0 ? (\n              showEmptyState()\n            ) : (\n              <div className=\"divide-y divide-neutral-200 bg-white overflow-y-auto h-full pb-24\">\n                {filterEvents(sortEventsByLastMessage(createdEvents)).map((event) => (\n                  <div \n                    key={event.id}\n                    className=\"p-3 hover:bg-neutral-50 transition cursor-pointer\"\n                    onClick={() => openEventChat(event)}\n                  >\n                    <div className=\"flex\">\n                      {/* Avatar/Image */}\n                      <div className=\"mr-3 flex items-center\">\n                        <div className=\"relative\">\n                          {/* Always show yellow ring */}\n                          <div className=\"p-0.5 bg-yellow-400 rounded-full\">\n                            <div className=\"w-14 h-14 rounded-full overflow-hidden bg-neutral-100 flex items-center justify-center\">\n                              {event.mainMediaUrl ? (\n                                <img \n                                  src={event.mainMediaUrl} \n                                  alt={event.title}\n                                  className=\"h-full w-full object-cover\"\n                                />\n                              ) : (\n                                <Star size={26} className=\"text-primary\" />\n                              )}\n                            </div>\n                          </div>\n                          {/* Category emoji indicator */}\n                          <div className=\"absolute -bottom-1 -right-1 w-6 h-6 bg-yellow-400 rounded-full flex items-center justify-center border-2 border-white\">\n                            <span className=\"text-xs\">{getCategoryEmoji(event.category)}</span>\n                          </div>\n                        </div>\n                      </div>\n                      \n                      {/* Chat content */}\n                      <div className=\"flex-1 min-w-0\">\n                        <div className=\"flex justify-between items-start\">\n                          <h3 className={`${hasUnreadMessages(event.id) ? 'font-bold' : 'font-medium'} text-neutral-900 truncate pr-1`}>\n                            {event.title}\n                          </h3>\n                          <span className=\"text-xs text-neutral-500 whitespace-nowrap ml-2\">\n                            {getMessageTime(event.id)}\n                          </span>\n                        </div>\n                        \n                        <div className=\"flex justify-between items-center mt-1\">\n                          <p className={`text-sm ${hasUnreadMessages(event.id) ? 'font-medium text-neutral-800' : 'text-neutral-600'} truncate pr-1`}>\n                            {getMessagePreview(event.id)}\n                          </p>\n                          {hasUnreadMessages(event.id) && (\n                            <div className=\"flex items-center ml-2\">\n                              <div className=\"bg-green-500 text-white text-xs min-w-[20px] h-5 rounded-full flex items-center justify-center px-1.5\">\n                                {getUnreadCount(event.id)}\n                              </div>\n                            </div>\n                          )}\n                        </div>\n                        \n                        <div className=\"flex items-center justify-between mt-2\">\n                          <div className=\"flex items-center\">\n                            <Calendar size={12} className=\"text-neutral-400 mr-1\" />\n                            <span className=\"text-xs text-neutral-500\">\n                              {formatEventDate(event.date)}\n                            </span>\n                          </div>\n                          <div className=\"flex items-center\">\n                            <Group size={12} className=\"text-neutral-400 mr-1\" />\n                            <span className=\"text-xs text-neutral-500\">\n                              {event.attendeeCount || 0} asistentes\n                            </span>\n                          </div>\n                        </div>\n                      </div>\n                    </div>\n                  </div>\n                ))}\n              </div>\n            )}\n          </TabsContent>\n        </Tabs>\n      </div>\n\n      <BottomNav />\n      \n      {/* Chat component as overlay */}\n      {chatVisible && selectedEventId && (\n        <Chat \n          eventId={selectedEventId}\n          eventTitle={selectedEventTitle}\n          visible={chatVisible}\n          onClose={closeChat}\n          eventImage={selectedEventImage}\n          onHeaderClick={() => {\n            const event = [...attendingEvents, ...createdEvents].find(e => e.id === selectedEventId);\n            if (event) {\n              openEventDetail(event);\n            }\n          }}\n        />\n      )}\n\n      {/* Event Detail Sheet */}\n      {eventDetailVisible && selectedEventForDetail && (\n        <EventDetailSheet\n          event={selectedEventForDetail}\n          visible={eventDetailVisible}\n          onClose={closeEventDetail}\n          openedFromChat={true}\n        />\n      )}\n    </div>\n  );\n};\n\nexport default Messages;","size_bytes":26757},"client/src/pages/my-events.tsx":{"content":"import { useEffect, useState } from \"react\";\nimport { useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport { useLocation } from \"wouter\";\nimport { motion, AnimatePresence } from \"framer-motion\";\nimport { useAuth } from \"@/hooks/use-auth\";\nimport BottomNav from \"@/components/layout/bottom-nav\";\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"@/components/ui/tabs\";\nimport { formatPrice } from \"@/lib/stripe\";\nimport { Card, CardContent } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { Avatar } from \"@/components/ui/avatar\";\nimport { CalendarIcon, MapPin, Users } from \"lucide-react\";\nimport { format, parseISO } from \"date-fns\";\nimport EditEventSheet from \"@/components/events/edit-event-sheet\";\nimport LoadingSpinner from \"@/components/ui/loading-spinner\";\n\nconst MyEvents = () => {\n  const { user, isLoading } = useAuth();\n  const [location, navigate] = useLocation();\n  // Obtenemos el parámetro tab de la URL\n  const params = typeof window !== 'undefined' ? new URLSearchParams(window.location.search) : new URLSearchParams();\n  const tabParam = params.get('tab');\n  const [activeTab, setActiveTab] = useState(tabParam === \"created\" ? \"created\" : \"attending\");\n  const [editEventId, setEditEventId] = useState<number | null>(null);\n  const [isEditSheetOpen, setIsEditSheetOpen] = useState(false);\n  const queryClient = useQueryClient();\n  \n  // Leer el parámetro tab de la URL cada vez que cambia la ubicación\n  useEffect(() => {\n    if (typeof window !== 'undefined') {\n      const params = new URLSearchParams(window.location.search);\n      const tabParam = params.get('tab');\n      if (tabParam === 'created' || tabParam === 'attending') {\n        setActiveTab(tabParam);\n      } else if (location.includes('my-events')) {\n        // Si no hay parámetro específico, usar 'attending' por defecto\n        setActiveTab('attending');\n      }\n    }\n  }, [location]);\n\n  // Invalidar las consultas al cargar el componente para asegurar datos frescos\n  useEffect(() => {\n    if (user) {\n      // Forzar la invalidación de caché para los eventos\n      queryClient.invalidateQueries({ queryKey: [\"/api/user/events/created\"] });\n      queryClient.invalidateQueries({ queryKey: [\"/api/user/events/attending\"] });\n      queryClient.invalidateQueries({ queryKey: [\"/api/events\"] });\n      console.log(\"Caché de consultas invalidada en MyEvents\");\n    }\n  }, [queryClient, user]);\n  \n  // Escuchar evento personalizado para actualizaciones de eventos\n  useEffect(() => {\n    // Manejador para actualizar cuando se reciba un evento de actualización\n    const handleEventUpdated = (e: any) => {\n      const eventId = e?.detail?.eventId;\n      const eventData = e?.detail?.data;\n      \n      if (eventId && eventData) {\n        console.log(\"Evento actualizado detectado en MyEvents:\", eventId);\n        \n        // Invalidar caches relevantes para forzar la actualización\n        queryClient.invalidateQueries({ queryKey: [\"/api/user/events/created\"] });\n        queryClient.invalidateQueries({ queryKey: [\"/api/user/events/attending\"] });\n        queryClient.invalidateQueries({ queryKey: [\"/api/events\"] });\n        \n        // También actualizar la caché específica del evento\n        queryClient.setQueryData([`/api/events/${eventId}`], eventData);\n      }\n    };\n    \n    // Agregar listener para el evento personalizado\n    window.addEventListener('event-updated', handleEventUpdated);\n    \n    // Limpiar al desmontar\n    return () => {\n      window.removeEventListener('event-updated', handleEventUpdated);\n    };\n  }, [queryClient]);\n\n  // Redirect if not logged in\n  useEffect(() => {\n    if (!isLoading && !user) {\n      navigate(\"/login\");\n    }\n  }, [user, isLoading, navigate]);\n\n  // Fetch created events\n  const { data: createdEvents = [] } = useQuery({\n    queryKey: [\"/api/user/events/created\"],\n    queryFn: async () => {\n      // Añadir un parámetro de timestamp para evitar caché\n      const timestamp = new Date().getTime();\n      const response = await fetch(`/api/user/events/created?_t=${timestamp}`, {\n        credentials: \"include\",\n        headers: {\n          \"Cache-Control\": \"no-cache, no-store, must-revalidate\",\n          \"Pragma\": \"no-cache\"\n        }\n      });\n      if (!response.ok) {\n        throw new Error(\"Failed to fetch created events\");\n      }\n      const events = await response.json();\n      // Depurar eventos para asegurarnos de que estamos recibiendo los medios correctos\n      console.log(\"Eventos creados:\", events);\n      if (events.length > 0 && events[0]) {\n        console.log(\"Primer evento - mainMediaType:\", events[0].mainMediaType);\n        console.log(\"Primer evento - mainMediaUrl:\", events[0].mainMediaUrl);\n        console.log(\"Primer evento - mediaItems:\", events[0].mediaItems);\n      }\n      return events;\n    },\n    enabled: !!user,\n    staleTime: 0, // Los datos son obsoletos inmediatamente\n    refetchOnMount: true, // Recargar datos cada vez que se monte el componente\n    refetchOnWindowFocus: true, // Recargar datos cuando la ventana recibe el foco\n  });\n\n  // Fetch attending events\n  const { data: attendingEvents = [] } = useQuery({\n    queryKey: [\"/api/user/events/attending\"],\n    queryFn: async () => {\n      // Añadir un parámetro de timestamp para evitar caché\n      const timestamp = new Date().getTime();\n      const response = await fetch(`/api/user/events/attending?_t=${timestamp}`, {\n        credentials: \"include\",\n        headers: {\n          \"Cache-Control\": \"no-cache, no-store, must-revalidate\",\n          \"Pragma\": \"no-cache\"\n        }\n      });\n      if (!response.ok) {\n        throw new Error(\"Failed to fetch attending events\");\n      }\n      return response.json();\n    },\n    enabled: !!user,\n    staleTime: 0, // Los datos son obsoletos inmediatamente\n    refetchOnMount: true, // Recargar datos cada vez que se monte el componente\n    refetchOnWindowFocus: true, // Recargar datos cuando la ventana recibe el foco\n  });\n\n  // Handle event click\n  const handleEventClick = (eventId: number) => {\n    // In a real app, this would navigate to the event detail view\n    console.log(\"Event clicked:\", eventId);\n  };\n  \n  // Open edit sheet for a specific event\n  const handleOpenEditSheet = (eventId: number) => {\n    console.log(\"Opening edit sheet for event:\", eventId);\n    setEditEventId(eventId);\n    setIsEditSheetOpen(true);\n  };\n  \n  // Close edit sheet\n  const handleCloseEditSheet = () => {\n    setIsEditSheetOpen(false);\n    setTimeout(() => setEditEventId(null), 300); // Clean up after animation completes\n  };\n  \n  // Handle event update\n  const handleEventUpdated = () => {\n    // Refetch events to update the UI\n    queryClient.invalidateQueries({ queryKey: [\"/api/user/events/created\"] });\n    queryClient.invalidateQueries({ queryKey: [\"/api/events\"] });\n  };\n\n  if (isLoading) {\n    return (\n      <motion.div \n        initial={{ opacity: 0, scale: 0.9 }}\n        animate={{ opacity: 1, scale: 1 }}\n        transition={{ duration: 0.4, ease: \"easeOut\" }}\n        className=\"flex h-screen items-center justify-center\"\n      >\n        <motion.div\n          animate={{ \n            rotate: 360,\n            scale: [1, 1.2, 1] \n          }}\n          transition={{ \n            rotate: { duration: 2, repeat: Infinity, ease: \"linear\" },\n            scale: { duration: 1.5, repeat: Infinity, ease: \"easeInOut\" }\n          }}\n        >\n          <LoadingSpinner size=\"lg\" />\n        </motion.div>\n      </motion.div>\n    );\n  }\n\n  return (\n    <motion.div \n      initial={{ opacity: 0, y: 20 }}\n      animate={{ opacity: 1, y: 0 }}\n      transition={{ duration: 0.5, ease: \"easeOut\" }}\n      className=\"flex flex-col h-screen bg-neutral-50 overflow-hidden\"\n    >\n      {/* Header with profile summary */}\n      <motion.div \n        initial={{ opacity: 0, y: -20 }}\n        animate={{ opacity: 1, y: 0 }}\n        transition={{ delay: 0.2, duration: 0.4 }}\n        className=\"bg-white px-4 py-4 border-b border-neutral-200 flex-shrink-0\"\n      >\n        <motion.div \n          initial={{ scale: 0.8, opacity: 0 }}\n          animate={{ scale: 1, opacity: 1 }}\n          transition={{ delay: 0.3, duration: 0.4 }}\n          className=\"flex items-center gap-4 mb-2\"\n        >\n          <motion.div\n            whileHover={{ scale: 1.1, rotate: 5 }}\n            transition={{ duration: 0.3 }}\n          >\n            <Avatar className=\"h-12 w-12\">\n              <img \n                src={user?.avatar || `https://ui-avatars.com/api/?name=${encodeURIComponent(user?.name || 'User')}`}\n                alt={user?.name || 'User'}\n                className=\"h-full w-full object-cover\"\n              />\n            </Avatar>\n          </motion.div>\n          <motion.div\n            initial={{ x: -10, opacity: 0 }}\n            animate={{ x: 0, opacity: 1 }}\n            transition={{ delay: 0.4, duration: 0.3 }}\n          >\n            <h1 className=\"text-lg font-bold\">{user?.name}</h1>\n            <p className=\"text-neutral-500 text-sm\">@{user?.username}</p>\n          </motion.div>\n        </motion.div>\n        <motion.h2 \n          initial={{ opacity: 0 }}\n          animate={{ opacity: 1 }}\n          transition={{ delay: 0.5, duration: 0.3 }}\n          className=\"text-base font-bold\"\n        >\n          Mis Eventos\n        </motion.h2>\n      </motion.div>\n\n      {/* Tabs */}\n      <Tabs \n        defaultValue=\"attending\" \n        value={activeTab} \n        onValueChange={(value) => {\n          setActiveTab(value);\n          // Actualizar la URL cuando cambia la pestaña\n          navigate(`/my-events?tab=${value}`, { replace: true });\n        }} \n        className=\"flex-1 flex flex-col min-h-0\"\n      >\n        <motion.div \n          initial={{ opacity: 0, y: -10 }}\n          animate={{ opacity: 1, y: 0 }}\n          transition={{ delay: 0.3, duration: 0.4 }}\n          className=\"sticky top-0 z-10 bg-white px-4 pt-2 pb-2 shadow-sm flex-shrink-0\"\n        >\n          <motion.div\n            whileHover={{ scale: 1.02 }}\n            transition={{ duration: 0.2 }}\n          >\n            <TabsList className=\"w-full grid grid-cols-2\">\n              <motion.div whileTap={{ scale: 0.98 }}>\n                <TabsTrigger value=\"attending\">Asistiendo</TabsTrigger>\n              </motion.div>\n              <motion.div whileTap={{ scale: 0.98 }}>\n                <TabsTrigger value=\"created\">Creados</TabsTrigger>\n              </motion.div>\n            </TabsList>\n          </motion.div>\n        </motion.div>\n\n        <TabsContent value=\"attending\" className=\"flex-1 overflow-y-auto p-4 pb-24\">\n          <motion.div \n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            transition={{ delay: 0.2, duration: 0.4 }}\n            className=\"space-y-4\"\n          >\n            <AnimatePresence>\n              {attendingEvents.length === 0 ? (\n                <motion.div\n                  initial={{ opacity: 0, y: 20 }}\n                  animate={{ opacity: 1, y: 0 }}\n                  exit={{ opacity: 0, y: -20 }}\n                  transition={{ duration: 0.4 }}\n                  className=\"text-center py-12\"\n                >\n                  <motion.p \n                    initial={{ opacity: 0 }}\n                    animate={{ opacity: 1 }}\n                    transition={{ delay: 0.2, duration: 0.3 }}\n                    className=\"text-neutral-500\"\n                  >\n                    No estás asistiendo a ningún evento todavía.\n                  </motion.p>\n                  <motion.div\n                    initial={{ scale: 0.8, opacity: 0 }}\n                    animate={{ scale: 1, opacity: 1 }}\n                    transition={{ delay: 0.3, duration: 0.3 }}\n                  >\n                    <Button\n                      className=\"mt-4 bg-primary hover:bg-primary/90\"\n                      onClick={() => navigate(\"/\")}\n                    >\n                      Descubrir Eventos\n                    </Button>\n                  </motion.div>\n                </motion.div>\n              ) : (\n                attendingEvents.map((attendance: any, index: number) => (\n                  <motion.div\n                    key={attendance.id}\n                    initial={{ opacity: 0, y: 20 }}\n                    animate={{ opacity: 1, y: 0 }}\n                    transition={{ \n                      delay: index * 0.1,\n                      duration: 0.4,\n                      ease: \"easeOut\"\n                    }}\n                    whileHover={{ \n                      y: -4,\n                      scale: 1.02,\n                      transition: { duration: 0.2 } \n                    }}\n                  >\n                    <Card className=\"shadow-card overflow-hidden\">\n                  <div className=\"aspect-[3/1] bg-neutral-200\">\n                    {(() => {\n                      console.log(`Renderizando asistencia a evento ${attendance.event.id}:`, {\n                        mainMediaType: attendance.event.mainMediaType,\n                        mainMediaUrl: attendance.event.mainMediaUrl,\n                        mediaItems: attendance.event.mediaItems\n                      });\n                      \n                      // Procesar mediaItems manualmente para obtener el elemento principal\n                      let mainMediaItem: any = null;\n                      if (attendance.event.mediaItems) {\n                        try {\n                          const mediaItemsArray = JSON.parse(attendance.event.mediaItems);\n                          \n                          // Primero buscar un elemento marcado explícitamente como principal\n                          let mainItem = mediaItemsArray.find((item: any) => item.isMain === true);\n                          \n                          // Si no hay ninguno marcado como principal, usar el primer elemento\n                          if (!mainItem && mediaItemsArray.length > 0) {\n                            // Ordenar por el campo order\n                            const sortedItems = [...mediaItemsArray].sort((a: any, b: any) => \n                              (a.order || 0) - (b.order || 0)\n                            );\n                            mainItem = sortedItems[0];\n                          }\n                          \n                          // Establecer el elemento principal\n                          mainMediaItem = mainItem;\n                          \n                          console.log(`Elemento principal encontrado (asistencia):`, mainMediaItem);\n                        } catch (error) {\n                          console.error(\"Error al parsear mediaItems (asistencia):\", error);\n                        }\n                      }\n                      \n                      const mediaType = mainMediaItem?.type || attendance.event.mainMediaType;\n                      const mediaUrl = mainMediaItem?.url || attendance.event.mainMediaUrl;\n                      \n                      console.log(`Media seleccionado (asistencia): type=${mediaType}, url=${mediaUrl}`);\n                      \n                      if (mediaType === 'video') {\n                        return (\n                          <div className=\"relative w-full h-full\">\n                            {/* Video en estado pausado */}\n                            <video\n                              src={mediaUrl}\n                              className=\"w-full h-full object-cover\"\n                              poster={attendance.event.photoUrl}\n                              preload=\"metadata\"\n                              muted\n                              key={`video-attending-${attendance.event.id}-${mediaUrl}-${Date.now()}`}\n                              onError={(e) => {\n                                console.error(`Error loading video (asistencia): ${mediaUrl}`, e);\n                              }}\n                            />\n                            {/* Overlay de ícono de play para indicar que es un video */}\n                            <div className=\"absolute inset-0 flex items-center justify-center bg-black/30\">\n                              <div className=\"w-12 h-12 rounded-full bg-white/80 flex items-center justify-center\">\n                                <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\" strokeLinecap=\"round\" strokeLinejoin=\"round\" className=\"text-primary\">\n                                  <polygon points=\"5 3 19 12 5 21 5 3\"></polygon>\n                                </svg>\n                              </div>\n                            </div>\n                          </div>\n                        );\n                      } else {\n                        return (\n                          <img\n                            src={mediaUrl || attendance.event.photoUrl || `/images/${attendance.event.category || 'default'}.jpg`}\n                            alt={attendance.event.title}\n                            className=\"w-full h-full object-cover\"\n                            key={`img-attending-${attendance.event.id}-${mediaUrl}-${Date.now()}`}\n                            onError={(e) => {\n                              console.error(`Error loading image (asistencia): ${mediaUrl}`, e);\n                              const target = e.target as HTMLImageElement;\n                              // Try fallback images in order\n                              if (!target.src.includes('/images/')) {\n                                target.src = `/images/1.jpg`;\n                              } else if (target.src.includes('1.jpg')) {\n                                target.src = `/images/2.jpg`;\n                              } else {\n                                // Final fallback - create a simple placeholder\n                                target.src = `data:image/svg+xml;base64,${btoa(`<svg width=\"600\" height=\"200\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"100%\" height=\"100%\" fill=\"#e5e7eb\"/><text x=\"50%\" y=\"50%\" text-anchor=\"middle\" dy=\"0.3em\" font-family=\"sans-serif\" font-size=\"16\" fill=\"#6b7280\">${attendance.event.title}</text></svg>`)}`;\n                              }\n                            }}\n                          />\n                        );\n                      }\n                    })()}\n                  </div>\n                  <CardContent className=\"p-4\">\n                    <div className=\"flex justify-between items-start\">\n                      <div>\n                        <span className={`inline-block px-2 py-1 text-xs font-medium category-${attendance.event.category || 'general'}-light rounded-full mb-1`}>\n                          {attendance.event.category ? attendance.event.category.charAt(0).toUpperCase() + attendance.event.category.slice(1) : 'Evento'}\n                        </span>\n                        <h3 className=\"font-semibold text-lg\">{attendance.event.title}</h3>\n                        <p className=\"text-neutral-500 flex items-center gap-1 text-sm\">\n                          <CalendarIcon size={14} />\n                          <span>\n                            {attendance.event.date ? format(parseISO(attendance.event.date), \"E, MMM d • h:mm a\") : \"Fecha no disponible\"}\n                          </span>\n                        </p>\n                        <p className=\"text-neutral-500 flex items-center gap-1 text-sm mt-1\">\n                          <MapPin size={14} />\n                          <span>{attendance.event.locationName}</span>\n                        </p>\n                      </div>\n                      <div className=\"text-right\">\n                        <p className=\"font-bold\">{formatPrice(attendance.event.price)}</p>\n                      </div>\n                    </div>\n                    \n                    <div className=\"flex items-center mt-4 pt-4 border-t border-neutral-100\">\n                      <Avatar className=\"h-8 w-8\">\n                        <img \n                          src={attendance.event.organizer?.avatar || `https://ui-avatars.com/api/?name=${encodeURIComponent(attendance.event.organizer?.name || 'Organizador')}`} \n                          alt={attendance.event.organizer?.name || 'Organizador'}\n                          className=\"h-full w-full object-cover\"\n                        />\n                      </Avatar>\n                      <div className=\"ml-2\">\n                        <p className=\"text-sm text-neutral-500\">Organizado por</p>\n                        <p className=\"text-sm font-medium\">{attendance.event.organizer?.name || 'Organizador'}</p>\n                      </div>\n                      \n                      <div className=\"ml-auto flex items-center\">\n                        <div className=\"flex items-center gap-1 text-sm text-neutral-500\">\n                          <Users size={14} />\n                          <span>{attendance.event.attendees?.length || 0}</span>\n                        </div>\n                      </div>\n                    </div>\n                  </CardContent>\n                    </Card>\n                  </motion.div>\n                ))\n              )}\n            </AnimatePresence>\n          </motion.div>\n        </TabsContent>\n\n        <TabsContent value=\"created\" className=\"flex-1 overflow-y-auto p-4 pb-24\">\n          <motion.div \n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            transition={{ delay: 0.2, duration: 0.4 }}\n            className=\"space-y-4\"\n          >\n            <AnimatePresence>\n              {createdEvents.length === 0 ? (\n                <motion.div\n                  initial={{ opacity: 0, y: 20 }}\n                  animate={{ opacity: 1, y: 0 }}\n                  exit={{ opacity: 0, y: -20 }}\n                  transition={{ duration: 0.4 }}\n                  className=\"text-center py-12\"\n                >\n                  <motion.p \n                    initial={{ opacity: 0 }}\n                    animate={{ opacity: 1 }}\n                    transition={{ delay: 0.2, duration: 0.3 }}\n                    className=\"text-neutral-500\"\n                  >\n                    No has creado ningún evento todavía.\n                  </motion.p>\n                  <motion.div\n                    initial={{ scale: 0.8, opacity: 0 }}\n                    animate={{ scale: 1, opacity: 1 }}\n                    transition={{ delay: 0.3, duration: 0.3 }}\n                  >\n                    <Button\n                      className=\"mt-4 bg-primary hover:bg-primary/90\"\n                      onClick={() => navigate(\"/create-event\")}\n                    >\n                      Crear Evento\n                    </Button>\n                  </motion.div>\n                </motion.div>\n              ) : (\n                createdEvents.map((event: any, index: number) => (\n                  <motion.div\n                    key={event.id}\n                    initial={{ opacity: 0, y: 20 }}\n                    animate={{ opacity: 1, y: 0 }}\n                    transition={{ \n                      delay: index * 0.1,\n                      duration: 0.4,\n                      ease: \"easeOut\"\n                    }}\n                    whileHover={{ \n                      y: -4,\n                      scale: 1.02,\n                      transition: { duration: 0.2 } \n                    }}\n                  >\n                    <Card className=\"shadow-card overflow-hidden\">\n                  <div className=\"aspect-[3/1] bg-neutral-200\">\n                    {(() => {\n                      console.log(`Renderizando evento creado ${event.id}:`, {\n                        mainMediaType: event.mainMediaType,\n                        mainMediaUrl: event.mainMediaUrl,\n                        mediaItems: event.mediaItems\n                      });\n                      \n                      // Procesar mediaItems para obtener el elemento principal\n                      let mainMediaItem: any = null;\n                      if (event.mediaItems) {\n                        try {\n                          let mediaItemsArray;\n                          // Verificar si ya es un array o necesita parsing\n                          if (typeof event.mediaItems === 'string') {\n                            mediaItemsArray = JSON.parse(event.mediaItems);\n                          } else if (Array.isArray(event.mediaItems)) {\n                            mediaItemsArray = event.mediaItems;\n                          } else {\n                            mediaItemsArray = [];\n                          }\n                          \n                          // Buscar elemento marcado como principal\n                          let mainItem = mediaItemsArray.find((item: any) => item.isMain === true);\n                          \n                          // Si no hay principal, usar el primer elemento\n                          if (!mainItem && mediaItemsArray.length > 0) {\n                            const sortedItems = [...mediaItemsArray].sort((a: any, b: any) => \n                              (a.order || 0) - (b.order || 0)\n                            );\n                            mainItem = sortedItems[0];\n                          }\n                          \n                          mainMediaItem = mainItem;\n                          console.log(`Elemento principal encontrado (creado):`, mainMediaItem);\n                        } catch (error) {\n                          console.error(\"Error al parsear mediaItems (creado):\", error);\n                          mainMediaItem = null;\n                        }\n                      }\n                      \n                      const mediaType = mainMediaItem?.type || event.mainMediaType;\n                      const mediaUrl = mainMediaItem?.url || event.mainMediaUrl;\n                      \n                      console.log(`Media seleccionado (creado): type=${mediaType}, url=${mediaUrl}`);\n                      \n                      if (mediaType === 'video') {\n                        return (\n                          <div className=\"relative w-full h-full\">\n                            {/* Video en estado pausado */}\n                            <video\n                              src={mediaUrl}\n                              className=\"w-full h-full object-cover\"\n                              poster={event.photoUrl}\n                              preload=\"metadata\"\n                              muted\n                              key={`video-created-${event.id}-${mediaUrl}-${Date.now()}`}\n                              onError={(e) => {\n                                console.error(`Error loading video (creado): ${mediaUrl}`, e);\n                              }}\n                            />\n                            {/* Overlay de ícono de play para indicar que es un video */}\n                            <div className=\"absolute inset-0 flex items-center justify-center bg-black/30\">\n                              <div className=\"w-12 h-12 rounded-full bg-white/80 flex items-center justify-center\">\n                                <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\" strokeLinecap=\"round\" strokeLinejoin=\"round\" className=\"text-primary\">\n                                  <polygon points=\"5 3 19 12 5 21 5 3\"></polygon>\n                                </svg>\n                              </div>\n                            </div>\n                          </div>\n                        );\n                      } else {\n                        return (\n                          <img\n                            src={mediaUrl || event.photoUrl || `/images/${event.category || 'default'}.jpg`}\n                            alt={event.title}\n                            className=\"w-full h-full object-cover\"\n                            key={`img-created-${event.id}-${mediaUrl}-${Date.now()}`}\n                            onError={(e) => {\n                              console.error(`Error loading image (creado): ${mediaUrl}`, e);\n                              const target = e.target as HTMLImageElement;\n                              // Try fallback images in order\n                              if (!target.src.includes('/images/')) {\n                                target.src = `/images/1.jpg`;\n                              } else if (target.src.includes('1.jpg')) {\n                                target.src = `/images/2.jpg`;\n                              } else {\n                                // Final fallback - create a simple placeholder\n                                target.src = `data:image/svg+xml;base64,${btoa(`<svg width=\"600\" height=\"200\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"100%\" height=\"100%\" fill=\"#e5e7eb\"/><text x=\"50%\" y=\"50%\" text-anchor=\"middle\" dy=\"0.3em\" font-family=\"sans-serif\" font-size=\"16\" fill=\"#6b7280\">${event.title}</text></svg>`)}`;\n                              }\n                            }}\n                          />\n                        );\n                      }\n                    })()}\n                  </div>\n                  <CardContent className=\"p-4\">\n                    <div className=\"flex justify-between items-start\">\n                      <div>\n                        <span className={`inline-block px-2 py-1 text-xs font-medium category-${event.category || 'general'}-light rounded-full mb-1`}>\n                          {event.category ? event.category.charAt(0).toUpperCase() + event.category.slice(1) : 'Evento'}\n                        </span>\n                        <h3 className=\"font-semibold text-lg\">{event.title}</h3>\n                        <p className=\"text-neutral-500 flex items-center gap-1 text-sm\">\n                          <CalendarIcon size={14} />\n                          <span>\n                            {event.date ? format(parseISO(event.date), \"E, MMM d • h:mm a\") : \"Fecha no disponible\"}\n                          </span>\n                        </p>\n                        <p className=\"text-neutral-500 flex items-center gap-1 text-sm mt-1\">\n                          <MapPin size={14} />\n                          <span>{event.locationName}</span>\n                        </p>\n                      </div>\n                      <div className=\"text-right\">\n                        <p className=\"font-bold\">{formatPrice(event.price)}</p>\n                      </div>\n                    </div>\n                    \n                    <div className=\"flex items-center justify-between mt-4 pt-4 border-t border-neutral-100\">\n                      <div className=\"flex items-center gap-1 text-sm text-neutral-500\">\n                        <Users size={14} />\n                        <span>{event.attendees?.length || 0} participantes</span>\n                      </div>\n                      \n                      <Button\n                        variant=\"outline\"\n                        size=\"sm\"\n                        onClick={() => handleOpenEditSheet(event.id)}\n                      >\n                        Editar\n                      </Button>\n                    </div>\n                  </CardContent>\n                    </Card>\n                  </motion.div>\n                ))\n              )}\n            </AnimatePresence>\n          </motion.div>\n        </TabsContent>\n      </Tabs>\n\n      {/* Edit Event Sheet */}\n      {editEventId && (\n        <EditEventSheet\n          eventId={editEventId}\n          isOpen={isEditSheetOpen}\n          onClose={handleCloseEditSheet}\n          onEventUpdated={handleEventUpdated}\n        />\n      )}\n\n      <BottomNav />\n    </motion.div>\n  );\n};\n\nexport default MyEvents;","size_bytes":31720},"client/src/pages/not-found.tsx":{"content":"import { Button } from \"@/components/ui/button\";\nimport { Link } from \"wouter\";\n\nexport default function NotFound() {\n  return (\n    <div className=\"min-h-screen w-full flex items-center justify-center bg-gradient-to-b from-white to-gray-50 px-4\">\n      <div className=\"text-center max-w-md\">\n        <h1 className=\"text-9xl font-bold text-gray-900 mb-4\">404</h1>\n        \n        <h2 className=\"text-2xl font-semibold mb-4 bg-gradient-to-r from-purple-600 to-blue-500 text-transparent bg-clip-text\">\n          Page Not Found\n        </h2>\n        \n        <p className=\"text-gray-600 mb-8\">\n          The page you're looking for doesn't exist or has been moved.\n        </p>\n        \n        <div className=\"flex flex-col sm:flex-row gap-4 justify-center\">\n          <Link to=\"/\">\n            <Button size=\"lg\">\n              Return Home\n            </Button>\n          </Link>\n          <Link to=\"/events\">\n            <Button variant=\"outline\" size=\"lg\">\n              Browse Events\n            </Button>\n          </Link>\n        </div>\n      </div>\n    </div>\n  );\n}\n","size_bytes":1072},"client/src/pages/payment.tsx":{"content":"import { useEffect } from \"react\";\nimport { useLocation } from \"wouter\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport LoadingSpinner from \"@/components/ui/loading-spinner\";\n\n// Payment page - Ahora redirecciona al inicio y muestra un mensaje\nexport default function PaymentPage() {\n  const [_, navigate] = useLocation();\n  const { toast } = useToast();\n  \n  // Cuando el componente se monta, redirigir al inicio y mostrar mensaje\n  useEffect(() => {\n    toast({\n      title: \"Funcionalidad de pagos desactivada\",\n      description: \"Los pagos no están disponibles actualmente. Todos los eventos son gratuitos.\",\n      variant: \"destructive\",\n    });\n    \n    navigate(\"/\");\n  }, [navigate, toast]);\n  \n  return (\n    <div className=\"flex items-center justify-center h-screen\">\n      <LoadingSpinner size=\"xl\" />\n    </div>\n  );\n}","size_bytes":838},"client/src/pages/profile.tsx":{"content":"import { useEffect, useState } from \"react\";\nimport { useLocation } from \"wouter\";\nimport { useAuth } from \"@/hooks/use-auth\";\nimport BottomNav from \"@/components/layout/bottom-nav\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { Avatar } from \"@/components/ui/avatar\";\nimport { Button } from \"@/components/ui/button\";\nimport { Card, CardContent } from \"@/components/ui/card\";\nimport { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { \n  User, \n  Settings, \n  LogOut, \n  Edit, \n  Star,\n  Calendar,\n  Camera,\n  Check,\n  X,\n  Ticket\n} from \"lucide-react\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n  DialogFooter,\n  DialogClose,\n} from \"@/components/ui/dialog\";\nimport { \n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue \n} from \"@/components/ui/select\";\nimport LoadingSpinner from \"@/components/ui/loading-spinner\";\n\n// Categorías de eventos disponibles para intereses\nconst EVENT_CATEGORIES = [\n  'social', 'music', 'spiritual', 'education', \n  'sports', 'food', 'art', 'technology',\n  'games', 'outdoor', 'networking', 'workshop',\n  'conference', 'party', 'fair', 'exhibition'\n];\n\n// Opciones de género disponibles\nconst GENDER_OPTIONS = [\n  { value: 'hombre', label: 'Hombre' },\n  { value: 'mujer', label: 'Mujer' },\n  { value: 'otro', label: 'Otro' },\n  { value: 'no_especificar', label: 'Prefiero no especificar' }\n];\n\nconst Profile = () => {\n  const { user, isLoading, logoutMutation, updateUserMutation } = useAuth();\n  const [_, navigate] = useLocation();\n  const { toast } = useToast();\n  const queryClient = useQueryClient();\n\n  // Estado para el diálogo de edición\n  const [isEditDialogOpen, setIsEditDialogOpen] = useState(false);\n  const [editForm, setEditForm] = useState({\n    name: \"\",\n    bio: \"\",\n    gender: \"\"\n  });\n  const [avatarFile, setAvatarFile] = useState<File | null>(null);\n  const [avatarPreview, setAvatarPreview] = useState<string | null>(null);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n\n  // Estado para la gestión de intereses\n  const [isInterestsDialogOpen, setIsInterestsDialogOpen] = useState(false);\n  const [selectedInterest, setSelectedInterest] = useState(\"\");\n\n  // Función para manejar la selección de imagen de perfil\n  const handleAvatarChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const file = e.target.files?.[0];\n    if (file) {\n      setAvatarFile(file);\n      const reader = new FileReader();\n      reader.onloadend = () => {\n        setAvatarPreview(reader.result as string);\n      };\n      reader.readAsDataURL(file);\n    }\n  };\n\n  // Inicializar el formulario cuando el usuario esté disponible\n  useEffect(() => {\n    if (user && !isEditDialogOpen) {\n      setEditForm({\n        name: user.name || \"\",\n        bio: user.bio || \"\",\n        gender: user.gender || \"\"\n      });\n    }\n  }, [user, isEditDialogOpen]);\n\n  // Función para manejar el logout\n  const handleLogout = () => {\n    logoutMutation.mutate();\n  };\n\n  // Consulta para obtener eventos a los que asiste el usuario\n  const { data: attendingEvents = [] } = useQuery({\n    queryKey: ['user', 'events', 'attending'],\n    queryFn: async () => {\n      const response = await fetch(`/api/user/events/attending`, {\n        credentials: 'include'\n      });\n      if (!response.ok) {\n        throw new Error('Failed to fetch attending events');\n      }\n      return response.json();\n    },\n    enabled: !!user,\n  });\n\n  // Consulta para obtener los intereses del usuario\n  const { data: userInterests = [], refetch: refetchInterests } = useQuery({\n    queryKey: ['user', 'interests'],\n    queryFn: async () => {\n      const response = await fetch('/api/user/interests', {\n        credentials: 'include'\n      });\n      if (!response.ok) {\n        throw new Error('Failed to fetch user interests');\n      }\n      return response.json();\n    },\n    enabled: !!user,\n  });\n\n  // Función para formatear categorías\n  const formatCategory = (category: string) => {\n    const translations: { [key: string]: string } = {\n      social: 'Social',\n      music: 'Música',\n      spiritual: 'Espiritual',\n      education: 'Educación',\n      sports: 'Deportes',\n      food: 'Comida',\n      art: 'Arte',\n      technology: 'Tecnología',\n      games: 'Juegos',\n      outdoor: 'Aire libre',\n      networking: 'Networking',\n      workshop: 'Talleres',\n      conference: 'Conferencias',\n      party: 'Fiestas',\n      fair: 'Ferias',\n      exhibition: 'Exposiciones'\n    };\n    return translations[category] || category;\n  };\n\n  // Mutación para añadir interés\n  const addInterestMutation = useMutation({\n    mutationFn: async (category: string) => {\n      const response = await fetch(\"/api/user/interests\", {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        credentials: 'include',\n        body: JSON.stringify({ category }),\n      });\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.message || 'Failed to add interest');\n      }\n      \n      return response.json();\n    },\n    onSuccess: () => {\n      refetchInterests();\n      toast({\n        title: \"Interés añadido\",\n        description: \"El interés ha sido añadido correctamente\",\n      });\n      setSelectedInterest(\"\");\n      setIsInterestsDialogOpen(false);\n    },\n    onError: () => {\n      toast({\n        title: \"Error\",\n        description: \"No se pudo añadir el interés\",\n        variant: \"destructive\",\n      });\n    },\n  });\n\n  // Mutación para eliminar interés\n  const removeInterestMutation = useMutation({\n    mutationFn: async (interestId: number) => {\n      const response = await fetch(`/api/user/interests/${interestId}`, {\n        method: 'DELETE',\n        credentials: 'include',\n      });\n      \n      if (!response.ok) {\n        throw new Error('Failed to remove interest');\n      }\n      \n      return response.json();\n    },\n    onSuccess: () => {\n      refetchInterests();\n      toast({\n        title: \"Interés eliminado\",\n        description: \"El interés ha sido eliminado correctamente\",\n      });\n    },\n    onError: () => {\n      toast({\n        title: \"Error\",\n        description: \"No se pudo eliminar el interés\",\n        variant: \"destructive\",\n      });\n    },\n  });\n\n  // Manejar actualización de perfil\n  const handleUpdateProfile = async () => {\n    if (!user) return;\n    \n    setIsSubmitting(true);\n    try {\n      // Si hay un archivo de avatar, usar FormData\n      if (avatarFile) {\n        const formData = new FormData();\n        formData.append('profileImage', avatarFile);\n        formData.append('name', editForm.name);\n        formData.append('bio', editForm.bio);\n        formData.append('gender', editForm.gender);\n        \n        updateUserMutation.mutate(formData);\n      } else {\n        // Si no hay imagen, usar JSON normal\n        updateUserMutation.mutate({\n          name: editForm.name,\n          bio: editForm.bio,\n          gender: editForm.gender,\n        });\n      }\n      \n      setIsEditDialogOpen(false);\n      setAvatarFile(null);\n      setAvatarPreview(null);\n    } catch (error) {\n      console.error(\"Profile update error:\", error);\n      toast({\n        title: \"Error\",\n        description: error instanceof Error ? error.message : \"No se pudo actualizar el perfil\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  // Manejar añadir interés\n  const handleAddInterest = async () => {\n    if (!selectedInterest) return;\n    addInterestMutation.mutate(selectedInterest);\n  };\n\n  // Manejar eliminar interés\n  const handleRemoveInterest = (interestId: number) => {\n    removeInterestMutation.mutate(interestId);\n  };\n\n  // Función para obtener colores de categorías\n  const getCategoryColor = (category: string) => {\n    const categoryColors: { [key: string]: string } = {\n      social: 'bg-blue-100 text-blue-600',\n      music: 'bg-purple-100 text-purple-600',\n      spiritual: 'bg-indigo-100 text-indigo-600',\n      education: 'bg-emerald-100 text-emerald-600',\n      sports: 'bg-orange-100 text-orange-600',\n      food: 'bg-red-100 text-red-600',\n      art: 'bg-pink-100 text-pink-600',\n      technology: 'bg-cyan-100 text-cyan-600',\n      games: 'bg-yellow-100 text-yellow-600',\n      outdoor: 'bg-green-100 text-green-600',\n      networking: 'bg-violet-100 text-violet-600',\n      workshop: 'bg-amber-100 text-amber-600',\n      conference: 'bg-slate-100 text-slate-600',\n      party: 'bg-fuchsia-100 text-fuchsia-600',\n      fair: 'bg-lime-100 text-lime-600',\n      exhibition: 'bg-rose-100 text-rose-600',\n    };\n    \n    return categoryColors[category] || 'bg-gray-100 text-gray-600';\n  };\n\n  if (isLoading) {\n    return (\n      <div className=\"bg-white flex h-screen items-center justify-center\">\n        <LoadingSpinner size=\"lg\" />\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"bg-neutral-50 flex flex-col h-screen\">\n      {/* Header */}\n      <div className=\"bg-white px-4 py-4 border-b border-neutral-200 sticky top-0 z-50\">\n        <h1 className=\"text-xl font-bold\">Mi Perfil</h1>\n      </div>\n\n      {/* Profile Content - Importante: contenedor con scroll */}\n      <div className=\"flex-1 overflow-y-auto pb-36\" style={{WebkitOverflowScrolling: 'touch'}}>\n        {/* User Info Card */}\n        <div className=\"p-4\">\n          <Card className=\"bg-white shadow-sm overflow-hidden\">\n            <div className=\"h-24 bg-gradient-to-r from-primary-500 to-primary-400\"></div>\n            <CardContent className=\"pt-0 relative p-4\">\n              <div className=\"absolute -top-10 left-4\">\n                <div className=\"relative group\">\n                  <Avatar className=\"h-20 w-20 border-4 border-white rounded-full shadow-md overflow-hidden\">\n                    <img \n                      src={user?.avatar || `https://ui-avatars.com/api/?name=${encodeURIComponent(user?.name || \"User\")}&size=80&background=random`} \n                      alt={user?.name || \"Perfil\"} \n                      className=\"h-full w-full object-cover\"\n                    />\n                  </Avatar>\n                  <div \n                    className=\"absolute inset-0 bg-black bg-opacity-50 rounded-full opacity-0 group-hover:opacity-100 flex items-center justify-center cursor-pointer transition-opacity\"\n                    onClick={() => setIsEditDialogOpen(true)}\n                  >\n                    <Camera size={20} className=\"text-white\" />\n                  </div>\n                </div>\n              </div>\n              \n              <div className=\"mt-14 flex justify-between items-start\">\n                <div>\n                  <h2 className=\"text-xl font-bold\">{user?.name}</h2>\n                  <p className=\"text-neutral-500\">@{user?.username}</p>\n                  <p className=\"text-neutral-600 mt-2\">{user?.bio || \"Añade una bio para que otros conozcan más sobre ti\"}</p>\n                  <div className=\"mt-2 flex items-center\">\n                    <span className=\"text-sm text-primary font-medium mr-1\">{attendingEvents.length}</span>\n                    <span className=\"text-sm text-neutral-600\">Eventos Asistidos</span>\n                  </div>\n                </div>\n                <Button \n                  variant=\"outline\" \n                  size=\"sm\" \n                  className=\"flex items-center gap-1 bg-primary-50 hover:bg-primary-100 text-primary-600\"\n                  onClick={() => setIsEditDialogOpen(true)}\n                >\n                  <Edit size={16} />\n                  <span>Editar</span>\n                </Button>\n              </div>\n\n              {/* Interest Tags */}\n              <div className=\"mt-4\">\n                <div className=\"flex justify-between items-center mb-2\">\n                  <h3 className=\"font-medium text-sm\">Intereses</h3>\n                  <Button \n                    variant=\"ghost\" \n                    size=\"sm\"\n                    onClick={() => setIsInterestsDialogOpen(true)}\n                  >\n                    + Añadir\n                  </Button>\n                </div>\n                <div className=\"flex flex-wrap gap-2\">\n                  {userInterests.map((interest: any) => (\n                    <span \n                      key={interest.id} \n                      className={`px-3 py-1 rounded-full text-xs font-medium cursor-pointer flex items-center ${getCategoryColor(interest.category)}`}\n                      onClick={() => handleRemoveInterest(interest.id)}\n                    >\n                      {formatCategory(interest.category)}\n                      <X size={12} className=\"ml-1\" />\n                    </span>\n                  ))}\n                  {userInterests.length === 0 && (\n                    <span className=\"text-neutral-500 text-sm\">No hay intereses añadidos</span>\n                  )}\n                </div>\n              </div>\n            </CardContent>\n          </Card>\n        </div>\n        \n\n        {/* Action Buttons - Con Tickets, Configuración y Cerrar Sesión */}\n        <div className=\"px-4 space-y-2 mt-2 mb-24\">\n          <Button\n            variant=\"outline\"\n            className=\"w-full justify-start px-4 py-2 text-left bg-white shadow-sm border border-neutral-200\"\n            onClick={() => navigate(\"/my-events?tab=created\")}\n          >\n            <Calendar size={18} className=\"mr-2 text-primary\" />\n            <span>Mis Eventos</span>\n          </Button>\n          \n          <Button\n            variant=\"outline\"\n            className=\"w-full justify-start px-4 py-2 text-left bg-white shadow-sm border border-neutral-200\"\n            onClick={() => navigate(\"/tickets\")}\n          >\n            <Ticket size={18} className=\"mr-2 text-green-600\" />\n            <span>Mis Tickets</span>\n          </Button>\n          \n          <Button\n            variant=\"outline\"\n            className=\"w-full justify-start px-4 py-2 text-left bg-white shadow-sm border border-neutral-200\"\n            onClick={() => navigate(\"/settings\")}\n          >\n            <Settings size={18} className=\"mr-2 text-neutral-600\" />\n            <span>Configuraciones</span>\n          </Button>\n          \n          <Button\n            variant=\"outline\"\n            className=\"w-full justify-start px-4 py-2 text-left text-red-500 bg-white shadow-sm border border-neutral-200\"\n            onClick={handleLogout}\n          >\n            <LogOut size={18} className=\"mr-2\" />\n            <span>Cerrar Sesión</span>\n          </Button>\n        </div>\n      </div>\n\n      {/* Edit Profile Dialog */}\n      <Dialog open={isEditDialogOpen} onOpenChange={setIsEditDialogOpen}>\n        <DialogContent className=\"sm:max-w-[425px]\">\n          <DialogHeader>\n            <DialogTitle>Editar Perfil</DialogTitle>\n          </DialogHeader>\n          <div className=\"grid gap-4 py-4\">\n            {/* Avatar upload section */}\n            <div className=\"flex flex-col items-center gap-3 mb-2\">\n              <div className=\"relative\">\n                <Avatar className=\"h-20 w-20\">\n                  <img \n                    src={avatarPreview || user?.avatar || `https://ui-avatars.com/api/?name=${encodeURIComponent(user?.name || \"User\")}&size=80&background=random`} \n                    alt={user?.name || \"Perfil\"} \n                    className=\"object-cover\"\n                  />\n                </Avatar>\n                <label \n                  htmlFor=\"avatar-upload\" \n                  className=\"absolute bottom-0 right-0 bg-primary text-white rounded-full p-1 cursor-pointer\"\n                >\n                  <Camera size={16} />\n                </label>\n                <input \n                  type=\"file\" \n                  id=\"avatar-upload\" \n                  className=\"hidden\" \n                  accept=\"image/*\"\n                  onChange={handleAvatarChange}\n                />\n              </div>\n              <span className=\"text-sm text-neutral-500\">Haz clic para cambiar tu foto</span>\n            </div>\n            \n            <div className=\"grid gap-2\">\n              <Label htmlFor=\"name\">Nombre</Label>\n              <Input\n                id=\"name\"\n                value={editForm.name}\n                onChange={(e) => setEditForm({ ...editForm, name: e.target.value })}\n              />\n            </div>\n            <div className=\"grid gap-2\">\n              <Label htmlFor=\"bio\">Biografía</Label>\n              <Textarea\n                id=\"bio\"\n                rows={3}\n                value={editForm.bio || \"\"}\n                onChange={(e) => setEditForm({ ...editForm, bio: e.target.value })}\n                placeholder=\"Cuéntanos un poco sobre ti...\"\n              />\n            </div>\n            \n            <div className=\"grid gap-2\">\n              <Label htmlFor=\"gender\">Género</Label>\n              <Select \n                value={editForm.gender} \n                onValueChange={(value) => setEditForm({ ...editForm, gender: value })}\n              >\n                <SelectTrigger className=\"w-full\">\n                  <SelectValue placeholder=\"Selecciona tu género\" />\n                </SelectTrigger>\n                <SelectContent>\n                  {GENDER_OPTIONS.map((option) => (\n                    <SelectItem key={option.value} value={option.value}>\n                      {option.label}\n                    </SelectItem>\n                  ))}\n                </SelectContent>\n              </Select>\n            </div>\n          </div>\n          <DialogFooter>\n            <DialogClose asChild>\n              <Button variant=\"outline\">Cancelar</Button>\n            </DialogClose>\n            <Button \n              onClick={handleUpdateProfile} \n              disabled={isSubmitting || !editForm.name.trim()}\n            >\n              {isSubmitting ? \"Guardando...\" : \"Guardar\"}\n            </Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n\n      {/* Add Interest Sheet - Compact like notifications */}\n      {isInterestsDialogOpen && (\n        <div \n          className=\"fixed inset-0 z-50 bg-black/40 backdrop-blur-sm\"\n          onClick={() => setIsInterestsDialogOpen(false)}\n        >\n          <div \n            className=\"absolute right-4 top-20 w-80 bg-white/95 backdrop-blur-xl rounded-xl shadow-2xl border border-white/20 overflow-hidden\"\n            onClick={(e) => e.stopPropagation()}\n          >\n            {/* Header */}\n            <div className=\"p-4 border-b border-gray-100 bg-gradient-to-r from-blue-50 to-purple-50\">\n              <div className=\"flex items-center justify-between\">\n                <div className=\"flex items-center gap-2\">\n                  <Star className=\"w-5 h-5 text-yellow-500\" />\n                  <h3 className=\"font-semibold text-gray-800\">Añadir Interés</h3>\n                </div>\n                <button \n                  onClick={() => setIsInterestsDialogOpen(false)}\n                  className=\"p-1 hover:bg-white/60 rounded-full transition-colors\"\n                >\n                  <X className=\"w-4 h-4 text-gray-500\" />\n                </button>\n              </div>\n              <p className=\"text-xs text-gray-600 mt-1\">\n                Elige una categoría que te interese\n              </p>\n            </div>\n            \n            {/* Content */}\n            <div className=\"p-4 space-y-4\">\n              <Select value={selectedInterest} onValueChange={setSelectedInterest}>\n                <SelectTrigger className=\"w-full h-10 bg-white border border-gray-200 hover:border-blue-300 transition-colors\">\n                  <SelectValue placeholder=\"🎯 Selecciona una categoría\" />\n                </SelectTrigger>\n                <SelectContent className=\"max-h-48 z-[60]\">\n                  {EVENT_CATEGORIES.filter(category => \n                    !userInterests.some((interest: any) => interest.category === category)\n                  ).map((category) => {\n                    const categoryEmojis: { [key: string]: string } = {\n                      social: '👥', music: '🎵', spiritual: '🙏', education: '📚',\n                      sports: '⚽', food: '🍕', art: '🎨', technology: '💻',\n                      games: '🎮', outdoor: '🌲', networking: '🤝', workshop: '🔧',\n                      conference: '🎤', party: '🎉', fair: '🎪', exhibition: '🖼️'\n                    };\n                    \n                    return (\n                      <SelectItem \n                        key={category} \n                        value={category}\n                        className=\"py-2 hover:bg-blue-50 cursor-pointer\"\n                      >\n                        <div className=\"flex items-center gap-2\">\n                          <span className=\"text-sm\">{categoryEmojis[category] || '📌'}</span>\n                          <span className=\"text-sm\">{formatCategory(category)}</span>\n                        </div>\n                      </SelectItem>\n                    );\n                  })}\n                </SelectContent>\n              </Select>\n              \n              {selectedInterest && (\n                <div className=\"bg-green-50 border border-green-200 rounded-lg p-2 animate-in fade-in duration-200\">\n                  <div className=\"flex items-center gap-2 text-green-700\">\n                    <Check className=\"w-3 h-3\" />\n                    <span className=\"text-xs font-medium\">\n                      {formatCategory(selectedInterest)} seleccionado\n                    </span>\n                  </div>\n                </div>\n              )}\n            </div>\n            \n            {/* Footer */}\n            <div className=\"p-4 border-t border-gray-100 bg-gray-50/50 flex gap-2\">\n              <button \n                onClick={() => setIsInterestsDialogOpen(false)}\n                className=\"flex-1 px-3 py-2 text-sm text-gray-600 bg-white border border-gray-200 rounded-lg hover:bg-gray-50 transition-colors\"\n              >\n                Cancelar\n              </button>\n              <button \n                onClick={handleAddInterest} \n                disabled={!selectedInterest || addInterestMutation.isPending}\n                className=\"flex-1 px-3 py-2 text-sm text-white bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed transition-all\"\n              >\n                {addInterestMutation.isPending ? (\n                  <div className=\"flex items-center justify-center gap-1\">\n                    <div className=\"w-3 h-3 border border-white border-t-transparent rounded-full animate-spin\" />\n                    <span>Añadiendo...</span>\n                  </div>\n                ) : (\n                  <div className=\"flex items-center justify-center gap-1\">\n                    <Star className=\"w-3 h-3\" />\n                    <span>Añadir</span>\n                  </div>\n                )}\n              </button>\n            </div>\n          </div>\n        </div>\n      )}\n\n      <BottomNav />\n    </div>\n  );\n};\n\nexport default Profile;","size_bytes":23249},"client/src/pages/test-edit-panel.tsx":{"content":"import { useState } from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport EditEventSheet from \"@/components/events/edit-event-sheet\";\n\nconst TestEditPanel = () => {\n  const [editEventId, setEditEventId] = useState<number | null>(6); // Default to event ID 6\n  const [isEditSheetOpen, setIsEditSheetOpen] = useState(false);\n\n  // Open edit sheet for a specific event\n  const handleOpenEditSheet = () => {\n    console.log(\"Opening edit sheet for event:\", editEventId);\n    setIsEditSheetOpen(true);\n  };\n  \n  // Close edit sheet\n  const handleCloseEditSheet = () => {\n    setIsEditSheetOpen(false);\n  };\n  \n  return (\n    <div className=\"flex flex-col items-center justify-center min-h-screen p-4\">\n      <h1 className=\"text-2xl font-bold mb-8\">Test Edit Event Panel</h1>\n      <Button \n        onClick={handleOpenEditSheet}\n        className=\"bg-primary text-white\"\n      >\n        Open Edit Panel\n      </Button>\n      \n      {/* Event ID Input */}\n      <div className=\"mt-4\">\n        <label className=\"block text-sm font-medium mb-2\">Event ID:</label>\n        <input \n          type=\"number\" \n          value={editEventId || \"\"}\n          onChange={(e) => setEditEventId(parseInt(e.target.value) || null)}\n          className=\"border border-gray-300 p-2 rounded-md\"\n        />\n      </div>\n      \n      {/* Edit Event Sheet */}\n      {editEventId && (\n        <EditEventSheet \n          eventId={editEventId} \n          isOpen={isEditSheetOpen} \n          onClose={handleCloseEditSheet}\n        />\n      )}\n    </div>\n  );\n};\n\nexport default TestEditPanel;","size_bytes":1574},"client/src/pages/tickets.tsx":{"content":"import React from 'react';\n\nexport default function Tickets() {\n  return (\n    <div className=\"min-h-screen bg-white pt-4 pb-24\">\n      <div className=\"max-w-md mx-auto px-4\">\n        <h1 className=\"text-2xl font-bold text-gray-900 mb-6\">Mis Tickets</h1>\n        \n        <div className=\"bg-gray-50 rounded-lg shadow-sm p-6 text-center\">\n          <div className=\"text-gray-400 mb-4\">\n            <svg className=\"w-16 h-16 mx-auto\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={1.5} d=\"M15.5 9.75A3.75 3.75 0 0011.75 6H6a2.25 2.25 0 00-2.25 2.25v6.75A2.25 2.25 0 006 17.25h5.75A3.75 3.75 0 0015.5 14v-4.25z\" />\n            </svg>\n          </div>\n          <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">\n            No tienes tickets aún\n          </h3>\n          <p className=\"text-gray-600 mb-4\">\n            Cuando te inscribas a eventos, tus tickets aparecerán aquí.\n          </p>\n        </div>\n      </div>\n    </div>\n  );\n}","size_bytes":1032},"client/src/components/chat/chat.tsx":{"content":"import React, { useState, useEffect, useRef } from \"react\";\nimport { useAuth } from \"@/hooks/use-auth\";\nimport { simpleChatService } from \"./simple-chat-service\";\nimport { useNavigation } from \"@/contexts/navigation-context\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Send, X } from \"lucide-react\";\nimport { Avatar } from \"@/components/ui/avatar\";\nimport { format } from \"date-fns\";\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\nimport { motion, AnimatePresence, useAnimation } from \"framer-motion\";\nimport { useUserProfile } from \"@/contexts/user-profile-context\";\nimport { useZIndex } from \"@/contexts/z-index-context\";\nimport { usePanelGestures } from \"@/hooks/use-panel-gestures\";\n\ntype Message = {\n  userId: number;\n  userName: string;\n  content: string;\n  timestamp: string;\n  isMine?: boolean;\n};\n\ntype ChatProps = {\n  eventId: number;\n  eventTitle: string;\n  visible: boolean;\n  onClose: () => void;\n  eventImage?: string; // URL de la imagen principal del evento\n  onHeaderClick?: () => void;\n  parentZIndex?: number; // Z-index del panel padre si se abre desde otro panel\n};\n\nexport default function Chat({\n  eventId,\n  eventTitle,\n  visible,\n  onClose,\n  eventImage,\n  onHeaderClick,\n  parentZIndex,\n}: ChatProps) {\n  const { user } = useAuth();\n  const { hideNavigation, showNavigation } = useNavigation();\n  const { showUserProfile } = useUserProfile();\n  const { getNextZIndex } = useZIndex();\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [newMessage, setNewMessage] = useState(\"\");\n  const [isConnected, setIsConnected] = useState(false);\n  const [isTyping, setIsTyping] = useState(false);\n  const [typingUsers, setTypingUsers] = useState<Set<string>>(new Set());\n  const [loadingMessages, setLoadingMessages] = useState(false);\n  const [currentZIndex, setCurrentZIndex] = useState(100);\n  const [hasAnimated, setHasAnimated] = useState(false);\n  // Advanced gesture system for professional mobile app experience\n  const { height: panelHeight, isDragging, gestureHandlers } = usePanelGestures({\n    minHeight: 25,\n    maxHeight: 95,\n    snapPositions: [30, 60, 90],\n    velocityThreshold: 0.8,\n    closeThreshold: 35,\n    onClose,\n    enableRubberBanding: true,\n    hapticFeedback: true,\n  });\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n  const typingTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const panelRef = useRef<HTMLDivElement>(null);\n  const scrollControls = useAnimation();\n  const connectionControls = useAnimation();\n  const panelControls = useAnimation();\n\n\n  // Control navigation visibility and z-index with smooth animations\n  useEffect(() => {\n    if (visible && !hasAnimated) {\n      hideNavigation();\n      setHasAnimated(true);\n      \n      // Si se abre desde un panel padre, usar su z-index + 20 para aparecer encima\n      if (parentZIndex) {\n        const newZIndex = parentZIndex + 20;\n        setCurrentZIndex(newZIndex);\n        console.log(`🎯 Chat panel opened with z-index: ${newZIndex} (parent: ${parentZIndex})`);\n      } else {\n        // Si se abre independientemente, obtener nuevo z-index\n        const newZIndex = getNextZIndex();\n        setCurrentZIndex(newZIndex);\n        console.log(`🎯 Chat panel opened with z-index: ${newZIndex}`);\n      }\n    } else if (!visible && hasAnimated) {\n      showNavigation();\n      setHasAnimated(false);\n    }\n    \n    // Cleanup: show navigation when component unmounts\n    return () => {\n      if (hasAnimated) {\n        showNavigation();\n      }\n    };\n  }, [visible, hasAnimated, hideNavigation, showNavigation, getNextZIndex, parentZIndex]);\n\n  // Smooth scroll to bottom whenever messages change\n  useEffect(() => {\n    if (messagesEndRef.current) {\n      messagesEndRef.current.scrollIntoView({ \n        behavior: \"smooth\",\n        block: \"end\"\n      });\n      // Trigger scroll animation\n      scrollControls.start({\n        y: [5, 0],\n        opacity: [0.8, 1],\n        transition: { duration: 0.3, ease: \"easeOut\" }\n      });\n    }\n  }, [messages, scrollControls]);\n\n  // Simple chat initialization with better reconnection\n  useEffect(() => {\n    if (!user || !visible) return;\n\n    console.log(`🚀 Initializing simple chat for event ${eventId}`);\n    \n    // Reset connection state when reinitialized\n    setIsConnected(false);\n    setLoadingMessages(true);\n    \n    // Set up message listener\n    const handleMessage = (data: any) => {\n      console.log(\"📨 Simple chat message:\", data.type, data);\n      \n      switch (data.type) {\n        case 'connection':\n          console.log('📡 Simple chat connection acknowledged');\n          break;\n          \n        case 'auth_success':\n          console.log('🔐 Simple chat authenticated');\n          setIsConnected(true);\n          // Animate connection status\n          connectionControls.start({\n            scale: [0.8, 1.1, 1],\n            opacity: [0, 1],\n            transition: { duration: 0.5, ease: \"backOut\" }\n          });\n          break;\n          \n        case 'joined_event':\n          console.log('👥 Simple chat joined event:', data.eventId);\n          break;\n          \n        case 'messages_loaded':\n          if (data.eventId === eventId) {\n            console.log('📜 Simple chat messages loaded:', data.messages?.length || 0);\n            setLoadingMessages(false);\n            if (data.messages && data.messages.length > 0) {\n              const loadedMessages = data.messages.map((msg: any) => ({\n                userId: msg.sender_id || msg.senderId,\n                userName: msg.sender?.name || msg.sender?.username || \"Unknown\",\n                content: msg.content,\n                timestamp: msg.created_at || msg.createdAt || new Date().toISOString(),\n                isMine: (msg.sender_id || msg.senderId) === user.id,\n              }));\n              setMessages(loadedMessages);\n            } else {\n              setMessages([]);\n            }\n          }\n          break;\n          \n        case 'new_message':\n          if (data.eventId === eventId && data.message) {\n            console.log('💬 Simple chat new message');\n            const msg = data.message;\n            const newMsg = {\n              userId: msg.sender_id || msg.senderId,\n              userName: msg.sender?.name || msg.sender?.username || \"Unknown\",\n              content: msg.content,\n              timestamp: msg.created_at || msg.createdAt || new Date().toISOString(),\n              isMine: (msg.sender_id || msg.senderId) === user.id,\n            };\n\n            setMessages((prevMessages) => [...prevMessages, newMsg]);\n          }\n          break;\n          \n        case 'typing':\n          if (data.eventId === eventId && data.user.id !== user.id) {\n            if (data.isTyping) {\n              setTypingUsers((prev) => new Set(prev).add(data.user.name));\n            } else {\n              setTypingUsers((prev) => {\n                const newSet = new Set(prev);\n                newSet.delete(data.user.name);\n                return newSet;\n              });\n            }\n          }\n          break;\n          \n        case 'error':\n        case 'load_messages_error':\n          console.error('❌ Simple chat error:', data.message || data.error);\n          setLoadingMessages(false);\n          break;\n      }\n    };\n\n    // Add message listener\n    simpleChatService.onMessage(handleMessage);\n    \n    // Initialize chat with improved connection handling\n    setLoadingMessages(true);\n    \n    // Initialize chat with proper connection handling\n    const initializeChat = async () => {\n      try {\n        // Check connection status\n        if (!simpleChatService.isConnected()) {\n          console.log(\"🔄 Chat not connected, establishing connection...\");\n          simpleChatService.disconnect();\n          simpleChatService.connect();\n          \n          // Wait for connection to be established\n          await new Promise(resolve => {\n            const checkConnection = () => {\n              if (simpleChatService.isConnected()) {\n                resolve(true);\n              } else {\n                setTimeout(checkConnection, 100);\n              }\n            };\n            setTimeout(checkConnection, 200);\n          });\n        }\n        \n        console.log(\"🚀 Starting chat initialization sequence...\");\n        \n        await simpleChatService.initChat(eventId, {\n          id: user.id,\n          name: user.name || user.username || 'User'\n        });\n        \n        console.log('✅ Simple chat initialized successfully');\n        setIsConnected(true);\n        setLoadingMessages(false);\n      } catch (error) {\n        console.error('❌ Simple chat init failed:', error);\n        setLoadingMessages(false);\n        setIsConnected(false);\n      }\n    };\n    \n    // Small delay to ensure component is fully mounted\n    setTimeout(initializeChat, 100);\n\n    // Cleanup\n    return () => {\n      console.log('🧹 Simple chat cleanup');\n      simpleChatService.removeMessageListener(handleMessage);\n      simpleChatService.leaveEvent(eventId);\n    };\n  }, [user, visible, eventId]);\n\n  // Send message\n  const sendMessage = () => {\n    console.log(\"🔤 Attempting to send message:\", { \n      message: newMessage.trim(), \n      eventId, \n      isConnected, \n      user: user?.id \n    });\n    \n    if (!newMessage.trim()) {\n      console.warn(\"⚠️ Cannot send empty message\");\n      return;\n    }\n    \n    if (!isConnected) {\n      console.warn(\"⚠️ Cannot send message - not connected\");\n      return;\n    }\n\n    const success = simpleChatService.sendMessage(eventId, newMessage.trim());\n    console.log(\"📤 Simple chat send message result:\", success);\n    \n    if (success) {\n      console.log(\"✅ Message sent successfully, clearing input\");\n      setNewMessage(\"\");\n      // Stop typing indicator\n      if (isTyping) {\n        setIsTyping(false);\n        simpleChatService.sendTyping(eventId, false);\n      }\n    } else {\n      console.error(\"❌ Failed to send message\");\n    }\n  };\n\n  // Handle typing\n  const handleTyping = () => {\n    if (!isTyping) {\n      setIsTyping(true);\n      simpleChatService.sendTyping(eventId, true);\n    }\n\n    // Clear existing timeout\n    if (typingTimeoutRef.current) {\n      clearTimeout(typingTimeoutRef.current);\n    }\n\n    // Set timeout to stop typing indicator\n    typingTimeoutRef.current = setTimeout(() => {\n      if (isTyping) {\n        setIsTyping(false);\n        simpleChatService.sendTyping(eventId, false);\n      }\n    }, 2000);\n  };\n\n  // Handle Enter key\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === \"Enter\") {\n      e.preventDefault();\n      sendMessage();\n    }\n  };\n\n\n  if (!visible || !user) return null;\n\n  return (\n    <>\n      {/* Semi-transparent background overlay with backdrop blur */}\n      <motion.div\n        initial={{ opacity: 0 }}\n        animate={{ opacity: 1 }}\n        exit={{ opacity: 0 }}\n        transition={{ duration: 0.2 }}\n        className=\"fixed inset-0 bg-black/30 backdrop-blur-sm\"\n        style={{ zIndex: currentZIndex - 1 }}\n        onClick={onClose}\n      />\n\n      {/* Chat panel - unified design with professional animations */}\n      <motion.div\n        initial={{ y: \"100%\", opacity: 0, scale: 0.95 }}\n        animate={{ \n          y: parentZIndex ? [\"-10px\", \"0px\"] : [\"-5px\", \"0px\"],\n          opacity: 1,\n          scale: 1,\n          transition: {\n            duration: parentZIndex ? 0.7 : 0.6,\n            times: parentZIndex ? [0, 1] : [0, 1],\n            ease: [0.23, 1, 0.32, 1]\n          }\n        }}\n        exit={{ \n          y: \"100%\", \n          opacity: 0, \n          scale: 0.95,\n          transition: {\n            duration: 0.4,\n            ease: [0.4, 0, 0.6, 1]\n          }\n        }}\n        ref={panelRef}\n        className=\"fixed inset-x-0 bottom-0 bg-white/5 backdrop-blur-lg rounded-t-3xl shadow-2xl flex flex-col overflow-hidden transition-all duration-200 ease-out\"\n        style={{ \n          zIndex: currentZIndex,\n          height: `${panelHeight}vh`,\n          maxHeight: '95vh'\n        }}\n        {...gestureHandlers}\n      >\n        {/* Header - Style similar to event detail sheet with drag handle */}\n        <motion.div \n          initial={{ y: -20, opacity: 0 }}\n          animate={{ y: 0, opacity: 1 }}\n          transition={{ delay: 0.1, duration: 0.3 }}\n          className=\"bg-gradient-to-r from-yellow-300 to-yellow-500 p-4 flex items-center rounded-t-3xl cursor-grab active:cursor-grabbing relative\"\n        >\n          {/* Drag handle indicator */}\n          <div className={`absolute top-2 left-1/2 transform -translate-x-1/2 w-12 h-1 bg-white/30 rounded-full transition-all duration-150 ${isDragging ? 'scale-110 bg-white/50' : ''}`}></div>\n          <button\n            onClick={onClose}\n            className=\"p-1 text-white hover:bg-white/20 rounded-full mr-3 transition-colors\"\n          >\n            <svg\n              width=\"20\"\n              height=\"20\"\n              viewBox=\"0 0 24 24\"\n              fill=\"none\"\n              xmlns=\"http://www.w3.org/2000/svg\"\n            >\n              <path\n                d=\"M15 18L9 12L15 6\"\n                stroke=\"currentColor\"\n                strokeWidth=\"2\"\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n              />\n            </svg>\n          </button>\n          <div \n            className=\"flex items-center flex-1 cursor-pointer hover:bg-white/10 rounded-lg p-2 -m-2 transition-colors\"\n            onClick={onHeaderClick}\n          >\n            <div className=\"w-12 h-12 rounded-full overflow-hidden mr-3 border-2 border-white/30\">\n              {eventImage ? (\n                <img\n                  src={eventImage}\n                  alt={eventTitle}\n                  className=\"w-full h-full object-cover\"\n                />\n              ) : (\n                <div className=\"w-full h-full bg-white/20 flex items-center justify-center\">\n                  <span className=\"text-white text-lg font-bold\">💬</span>\n                </div>\n              )}\n            </div>\n            <div>\n              <h3 className=\"font-medium text-white text-sm leading-tight\">\n                {eventTitle}\n              </h3>\n              <p className=\"text-white/80 text-xs\">Chat del Evento · Toca para ver detalles</p>\n            </div>\n          </div>\n        </motion.div>\n\n        {/* Messages - Fully transparent background with intense blur */}\n        <motion.div \n          animate={scrollControls}\n          className=\"flex-1 bg-transparent backdrop-blur-xl relative overflow-hidden\"\n        >\n          <ScrollArea className=\"h-full\" style={{ touchAction: isDragging ? 'none' : 'pan-y' }}>\n            <div className=\"p-4 space-y-2\">\n              <AnimatePresence mode=\"popLayout\">\n                {loadingMessages ? (\n                  <motion.div\n                    key=\"loading\"\n                    initial={{ opacity: 0, y: 20 }}\n                    animate={{ opacity: 1, y: 0 }}\n                    exit={{ opacity: 0, y: -20 }}\n                    className=\"h-40 flex items-center justify-center text-white\"\n                  >\n                    <motion.div\n                      animate={{ \n                        rotate: 360,\n                        scale: [1, 1.1, 1]\n                      }}\n                      transition={{ \n                        rotate: { duration: 2, repeat: Infinity, ease: \"linear\" },\n                        scale: { duration: 1, repeat: Infinity, ease: \"easeInOut\" }\n                      }}\n                      className=\"w-8 h-8 border-2 border-white/30 border-t-white rounded-full mr-3\"\n                    />\n                    <p className=\"text-sm\">Cargando mensajes...</p>\n                  </motion.div>\n                ) : messages.length === 0 ? (\n                  <motion.div\n                    key=\"empty\"\n                    initial={{ opacity: 0, scale: 0.8 }}\n                    animate={{ opacity: 1, scale: 1 }}\n                    exit={{ opacity: 0, scale: 0.8 }}\n                    transition={{ duration: 0.4, ease: \"backOut\" }}\n                    className=\"h-40 flex flex-col items-center justify-center text-white text-center\"\n                  >\n                    <motion.div\n                      animate={{ \n                        scale: [1, 1.1, 1],\n                        rotate: [0, 5, -5, 0]\n                      }}\n                      transition={{ \n                        duration: 2,\n                        repeat: Infinity,\n                        ease: \"easeInOut\"\n                      }}\n                      className=\"w-16 h-16 bg-yellow-100 rounded-full flex items-center justify-center mb-3\"\n                    >\n                      <span className=\"text-yellow-500 text-2xl\">💬</span>\n                    </motion.div>\n                    <p className=\"text-sm font-medium\">No hay mensajes aún</p>\n                    <p className=\"text-xs text-white/70\">\n                      ¡Inicia la conversación!\n                    </p>\n                  </motion.div>\n                ) : (\n                  messages.map((message, index) => (\n                    <motion.div\n                      key={`${message.timestamp}-${index}`}\n                      layout\n                      initial={{ \n                        opacity: 0, \n                        y: 50,\n                        scale: 0.8\n                      }}\n                      animate={{ \n                        opacity: 1, \n                        y: 0,\n                        scale: 1\n                      }}\n                      exit={{ \n                        opacity: 0, \n                        y: -20,\n                        scale: 0.9\n                      }}\n                      transition={{\n                        type: \"spring\",\n                        damping: 20,\n                        stiffness: 300,\n                        delay: index * 0.05\n                      }}\n                      whileHover={{ \n                        scale: 1.02,\n                        transition: { duration: 0.2 }\n                      }}\n                      className={`flex mb-3 items-end ${message.isMine ? \"justify-end\" : \"justify-start\"}`}\n                    >\n                    {/* Avatar for other users (left side) */}\n                    {!message.isMine && (\n                      <div \n                        className=\"w-8 h-8 rounded-full overflow-hidden mr-2 mb-1 flex-shrink-0 cursor-pointer hover:scale-110 transition-transform\"\n                        onClick={() => showUserProfile({\n                          id: message.userId,\n                          name: message.userName,\n                          email: `${message.userName}@example.com`, // Fallback email\n                        })}\n                      >\n                        <div className=\"w-full h-full bg-gradient-to-br from-blue-400 to-purple-500 flex items-center justify-center\">\n                          <span className=\"text-white text-xs font-bold\">\n                            {message.userName?.charAt(0)?.toUpperCase() || \"U\"}\n                          </span>\n                        </div>\n                      </div>\n                    )}\n\n                    {/* Message bubbles with WhatsApp-style design */}\n                    <div\n                      className={`relative max-w-[75%] ${\n                        message.isMine\n                          ? \"bg-blue-500 text-white rounded-2xl rounded-br-sm\"\n                          : \"bg-white/90 text-gray-800 rounded-2xl rounded-bl-sm\"\n                      } px-4 py-3 shadow-lg backdrop-blur-sm border ${message.isMine ? \"border-blue-400/50\" : \"border-gray-200/50\"}`}\n                    >\n                      {/* Message content */}\n                      <div className=\"space-y-1\">\n                        {!message.isMine && (\n                          <p className=\"text-xs font-medium text-blue-600 mb-1\">\n                            {message.userName}\n                          </p>\n                        )}\n                        <p\n                          className={`text-sm leading-relaxed ${message.isMine ? \"text-white\" : \"text-gray-800\"}`}\n                        >\n                          {message.content}\n                        </p>\n                        <p\n                          className={`text-xs ${message.isMine ? \"text-blue-100\" : \"text-gray-500\"} text-right mt-1`}\n                        >\n                          {(() => {\n                            try {\n                              const date = new Date(message.timestamp);\n                              if (isNaN(date.getTime())) {\n                                return \"Ahora\";\n                              }\n                              return format(date, \"HH:mm\");\n                            } catch (error) {\n                              console.error(\"Error formatting timestamp:\", message.timestamp, error);\n                              return \"Ahora\";\n                            }\n                          })()}\n                        </p>\n                      </div>\n                    </div>\n\n                    {/* Avatar for my messages (right side) */}\n                    {message.isMine && (\n                      <div className=\"w-8 h-8 rounded-full overflow-hidden ml-2 mb-1 flex-shrink-0\">\n                        {user?.avatar ? (\n                          <img\n                            src={user.avatar}\n                            alt={user.name || user.username}\n                            className=\"w-full h-full object-cover\"\n                          />\n                        ) : (\n                          <div className=\"w-full h-full bg-gradient-to-br from-green-400 to-blue-500 flex items-center justify-center\">\n                            <span className=\"text-white text-xs font-bold\">\n                              {user?.name?.charAt(0)?.toUpperCase() || user?.username?.charAt(0)?.toUpperCase() || \"Y\"}\n                            </span>\n                          </div>\n                        )}\n                      </div>\n                    )}\n                  </motion.div>\n                  ))\n                )}\n              </AnimatePresence>\n              <motion.div \n                ref={messagesEndRef} \n                layout\n                initial={{ opacity: 0 }}\n                animate={{ opacity: 1 }}\n              />\n            </div>\n          </ScrollArea>\n        </motion.div>\n\n        {/* Input area */}\n        <motion.div \n          initial={{ y: 20, opacity: 0 }}\n          animate={{ y: 0, opacity: 1 }}\n          transition={{ delay: 0.2, duration: 0.3 }}\n          className=\"bg-white/10 backdrop-blur-md border-t border-white/20 p-4\"\n        >\n          <div className=\"flex items-center space-x-3\">\n            <Input\n              type=\"text\"\n              value={newMessage}\n              onChange={(e) => setNewMessage(e.target.value)}\n              onKeyDown={handleKeyDown}\n              onInput={handleTyping}\n              placeholder=\"Escribe un mensaje...\"\n              className=\"flex-1 bg-white/20 backdrop-blur-sm border-white/30 text-black placeholder-white/70 rounded-2xl px-4 py-3\"\n              disabled={!isConnected}\n            />\n            <Button\n              onClick={sendMessage}\n              disabled={!newMessage.trim() || !isConnected}\n              className=\"bg-yellow-500 hover:bg-yellow-600 text-white rounded-full p-3 shadow-lg\"\n            >\n              <Send size={20} />\n            </Button>\n          </div>\n\n          {/* Typing indicator */}\n          <AnimatePresence>\n            {typingUsers.size > 0 && (\n              <motion.div\n                initial={{ opacity: 0, y: 10, height: 0 }}\n                animate={{ opacity: 1, y: 0, height: \"auto\" }}\n                exit={{ opacity: 0, y: -10, height: 0 }}\n                transition={{ duration: 0.2 }}\n                className=\"mt-2 text-xs text-white/70 flex items-center\"\n              >\n                <motion.div\n                  animate={{ \n                    scale: [1, 1.2, 1],\n                  }}\n                  transition={{ \n                    duration: 1,\n                    repeat: Infinity,\n                    ease: \"easeInOut\"\n                  }}\n                  className=\"w-2 h-2 bg-white/50 rounded-full mr-2\"\n                />\n                <span>{Array.from(typingUsers).join(\", \")} escribiendo...</span>\n              </motion.div>\n            )}\n          </AnimatePresence>\n\n          <AnimatePresence>\n            {!isConnected && (\n              <motion.div\n                initial={{ opacity: 0, y: 10, height: 0 }}\n                animate={{ opacity: 1, y: 0, height: \"auto\" }}\n                exit={{ opacity: 0, y: -10, height: 0 }}\n                transition={{ duration: 0.2 }}\n                className=\"mt-2 text-xs text-red-300 flex items-center\"\n              >\n                <motion.div\n                  animate={{ \n                    opacity: [0.3, 1, 0.3],\n                  }}\n                  transition={{ \n                    duration: 1.5,\n                    repeat: Infinity,\n                    ease: \"easeInOut\"\n                  }}\n                  className=\"w-2 h-2 bg-red-400 rounded-full mr-2\"\n                />\n                <span>Desconectado - Reintentando...</span>\n              </motion.div>\n            )}\n          </AnimatePresence>\n        </motion.div>\n      </motion.div>\n    </>\n  );\n}\n","size_bytes":25543},"client/src/components/chat/simple-chat-service.ts":{"content":"// Simple unified chat service that works consistently from anywhere\ninterface ChatMessage {\n  id: number;\n  eventId: number;\n  senderId: number;\n  content: string;\n  messageType: string;\n  replyToId?: number;\n  createdAt: Date;\n  sender?: {\n    id: number;\n    name: string;\n    username: string;\n  };\n}\n\ninterface User {\n  id: number;\n  name: string;\n}\n\nclass SimpleChatService {\n  private socket: WebSocket | null = null;\n  private isReady = false;\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts = 5;\n  private reconnectTimeout: NodeJS.Timeout | null = null;\n  \n  // Event listeners\n  private messageListeners: Set<(message: any) => void> = new Set();\n  private connectionListeners: Set<() => void> = new Set();\n  private errorListeners: Set<(error: any) => void> = new Set();\n\n  constructor() {\n    this.connect();\n  }\n\n  // Connection management\n  connect() {\n    if (this.socket && (this.socket.readyState === WebSocket.CONNECTING || this.socket.readyState === WebSocket.OPEN)) {\n      console.log('📡 WebSocket already connected/connecting');\n      return;\n    }\n\n    try {\n      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n      const wsUrl = `${protocol}//${window.location.host}/ws`;\n      \n      console.log('🔗 Simple chat connecting:', wsUrl);\n      \n      this.socket = new WebSocket(wsUrl);\n      \n      this.socket.addEventListener('open', () => {\n        console.log('✅ Simple chat connected');\n        this.isReady = true;\n        this.reconnectAttempts = 0;\n        this.notifyConnectionListeners();\n      });\n      \n      this.socket.addEventListener('close', () => {\n        console.log('🔌 Simple chat disconnected');\n        this.isReady = false;\n        this.handleReconnection();\n      });\n      \n      this.socket.addEventListener('error', (event) => {\n        console.error('❌ Simple chat error:', event);\n        this.notifyErrorListeners(event);\n      });\n      \n      this.socket.addEventListener('message', (event) => {\n        this.handleMessage(event.data);\n      });\n      \n    } catch (error) {\n      console.error('❌ Failed to connect simple chat:', error);\n      this.handleReconnection();\n    }\n  }\n\n  private handleMessage(data: string) {\n    try {\n      const message = JSON.parse(data);\n      this.notifyMessageListeners(message);\n    } catch (error) {\n      console.error('❌ Error parsing message:', error);\n    }\n  }\n\n  private handleReconnection() {\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n    }\n\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 10000);\n      console.log(`🔄 Simple chat reconnecting in ${delay}ms (attempt ${this.reconnectAttempts + 1}/${this.maxReconnectAttempts})`);\n      \n      this.reconnectTimeout = setTimeout(() => {\n        this.reconnectAttempts++;\n        this.connect();\n      }, delay);\n    }\n  }\n\n  // Event listeners\n  onMessage(handler: (message: any) => void) {\n    this.messageListeners.add(handler);\n  }\n\n  removeMessageListener(handler: (message: any) => void) {\n    this.messageListeners.delete(handler);\n  }\n\n  onConnect(handler: () => void) {\n    this.connectionListeners.add(handler);\n    if (this.isReady) {\n      handler(); // Call immediately if already connected\n    }\n  }\n\n  onError(handler: (error: any) => void) {\n    this.errorListeners.add(handler);\n  }\n\n  private notifyMessageListeners(message: any) {\n    this.messageListeners.forEach(handler => {\n      try {\n        handler(message);\n      } catch (error) {\n        console.error('❌ Error in message handler:', error);\n      }\n    });\n  }\n\n  private notifyConnectionListeners() {\n    this.connectionListeners.forEach(handler => {\n      try {\n        handler();\n      } catch (error) {\n        console.error('❌ Error in connection handler:', error);\n      }\n    });\n  }\n\n  private notifyErrorListeners(error: any) {\n    this.errorListeners.forEach(handler => {\n      try {\n        handler(error);\n      } catch (error) {\n        console.error('❌ Error in error handler:', error);\n      }\n    });\n  }\n\n  // Core chat operations\n  isConnected(): boolean {\n    return this.socket !== null && this.socket.readyState === WebSocket.OPEN && this.isReady;\n  }\n\n  disconnect() {\n    console.log('🔌 Disconnecting simple chat');\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n    this.isReady = false;\n    this.reconnectAttempts = 0;\n  }\n\n  send(data: any): boolean {\n    if (!this.isConnected()) {\n      console.warn('⚠️ Cannot send - not connected');\n      return false;\n    }\n\n    try {\n      this.socket!.send(JSON.stringify(data));\n      return true;\n    } catch (error) {\n      console.error('❌ Failed to send message:', error);\n      return false;\n    }\n  }\n\n  // Simplified chat operations - no complex state management\n  initChat(eventId: number, user: User): Promise<boolean> {\n    return new Promise((resolve, reject) => {\n      let authReceived = false;\n      let joinReceived = false;\n      let timeoutId: NodeJS.Timeout;\n      \n      const initialize = () => {\n        console.log(`🚀 Simple chat init for event ${eventId}, user: ${user.name}`);\n        \n        // Set up a temporary message listener for the initialization sequence\n        const initMessageHandler = (data: any) => {\n          console.log(`🔄 Init sequence - received: ${data.type}`);\n          \n          if (data.type === 'auth_success') {\n            console.log('🔐 Auth success, joining event...');\n            authReceived = true;\n            \n            // Now join the event\n            this.send({\n              type: 'join_event',\n              eventId\n            });\n          } else if (data.type === 'joined_event' && data.eventId === eventId) {\n            console.log('👥 Joined event, loading messages...');\n            joinReceived = true;\n            \n            // Now load messages\n            this.send({\n              type: 'load_messages',\n              eventId,\n              limit: 20,\n              offset: 0\n            });\n          } else if (data.type === 'messages_loaded' && data.eventId === eventId) {\n            console.log('📜 Messages loaded, initialization complete');\n            // Clean up\n            this.removeMessageListener(initMessageHandler);\n            if (timeoutId) clearTimeout(timeoutId);\n            resolve(true);\n          } else if (data.type === 'error' || data.type === 'load_messages_error') {\n            console.error('❌ Initialization error:', data);\n            this.removeMessageListener(initMessageHandler);\n            if (timeoutId) clearTimeout(timeoutId);\n            reject(new Error(data.message || 'Initialization failed'));\n          }\n        };\n        \n        // Add the temporary listener\n        this.onMessage(initMessageHandler);\n        \n        // Set timeout for initialization\n        timeoutId = setTimeout(() => {\n          console.warn('⏰ Chat initialization timed out');\n          this.removeMessageListener(initMessageHandler);\n          resolve(true); // Resolve anyway to continue\n        }, 10000); // 10 second timeout\n        \n        // Start the sequence with authentication\n        console.log('🔑 Sending authentication...');\n        this.send({\n          type: 'auth',\n          userId: user.id,\n          userName: user.name\n        });\n      };\n\n      if (this.isConnected()) {\n        initialize();\n      } else {\n        console.log('🔌 Not connected, waiting for connection...');\n        this.onConnect(initialize);\n      }\n    });\n  }\n\n  sendMessage(eventId: number, content: string): boolean {\n    return this.send({\n      type: 'send_message',\n      eventId,\n      content: content.trim()\n    });\n  }\n\n  sendTyping(eventId: number, isTyping: boolean): boolean {\n    return this.send({\n      type: 'typing',\n      eventId,\n      isTyping\n    });\n  }\n\n  leaveEvent(eventId: number): boolean {\n    return this.send({\n      type: 'leave_event',\n      eventId\n    });\n  }\n}\n\n// Create singleton\nexport const simpleChatService = new SimpleChatService();\nexport default simpleChatService;","size_bytes":8285},"client/src/components/events/create-event-form-google.tsx":{"content":"import React, { useState, useEffect, useRef, useCallback } from \"react\";\nimport { useForm, FieldValues } from \"react-hook-form\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport { z } from \"zod\";\nimport { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from \"@/components/ui/form\";\nimport { Input } from \"@/components/ui/input\";\nimport { Button } from \"@/components/ui/button\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { apiRequest } from \"@/lib/queryClient\";\nimport { ArrowLeft, MapIcon, Compass, Search, Camera, Video, Clock, Calendar, MapPin, Tag, Users, DollarSign, Lock } from \"lucide-react\";\nimport { useAuth } from \"@/hooks/use-auth\";\nimport { useLocation } from \"wouter\";\nimport { GoogleMap, Marker, useLoadScript, Libraries } from '@react-google-maps/api';\nimport { GOOGLE_MAPS_API_KEY, reverseGeocode, defaultMapConfig } from \"@/lib/google-maps\";\nimport { MediaManager, MediaItem } from \"./media-manager-v2\";\n\n// Definición centralizada de categorías para reutilización\nconst EVENT_CATEGORIES = [\n  { value: 'social', label: 'Social' },\n  { value: 'music', label: 'Música' },\n  { value: 'spiritual', label: 'Espiritual' },\n  { value: 'education', label: 'Educación' },\n  { value: 'sports', label: 'Deportes' },\n  { value: 'food', label: 'Comida' },\n  { value: 'art', label: 'Arte' },\n  { value: 'technology', label: 'Tecnología' },\n  { value: 'games', label: 'Juegos' },\n  { value: 'outdoor', label: 'Aire Libre' },\n  { value: 'networking', label: 'Networking' },\n  { value: 'workshop', label: 'Talleres' },\n  { value: 'conference', label: 'Conferencias' },\n  { value: 'party', label: 'Fiestas' },\n  { value: 'fair', label: 'Ferias' },\n  { value: 'exhibition', label: 'Exposiciones' }\n];\n\n// Form schema para validación de eventos\nconst createEventSchema = z.object({\n  title: z.string().min(3, \"El título debe tener al menos 3 caracteres\"),\n  description: z.string().min(10, \"La descripción debe tener al menos 10 caracteres\"),\n  category: z.string().min(1, \"Por favor, selecciona una categoría\"),\n  date: z.string().min(1, \"Por favor, selecciona una fecha\"),\n  time: z.string().min(1, \"Por favor, selecciona una hora\"),\n  endTime: z.string().min(1, \"Por favor, selecciona una hora de finalización\"),\n  latitude: z.string().or(z.number()),\n  longitude: z.string().or(z.number()),\n  locationName: z.string().min(3, \"El nombre del lugar debe tener al menos 3 caracteres\"),\n  locationAddress: z.string().min(5, \"La dirección debe tener al menos 5 caracteres\"),\n  paymentType: z.string().min(1, \"Por favor, selecciona un tipo de pago\"),\n  price: z.string().optional(),\n  maxCapacity: z.string().optional(),\n  privacyType: z.string().min(1, \"Por favor, selecciona un tipo de privacidad\"),\n  genderPreference: z.enum(['all_people', 'men', 'women']).default('all_people'),\n  privateAccessType: z.enum(['solicitud', 'postulacion', 'paga']).optional(),\n  applicationQuestions: z.string().optional(),\n\n  // Campo para gestión multimedia unificada - OBLIGATORIO AL MENOS UN ARCHIVO\n  mediaItems: z.array(\n    z.object({\n      id: z.string().optional(),\n      type: z.enum(['photo', 'video']),\n      url: z.string().optional(),\n      file: z.instanceof(File).optional(),\n      isMain: z.boolean().optional(),\n      isNew: z.boolean().optional(),\n      deleted: z.boolean().optional(),\n      toDelete: z.boolean().optional(),\n      order: z.number().optional(),\n    })\n  ).min(1, \"Debes subir al menos un archivo (foto o video) para crear el evento\").default([]),\n  \n  // Campos para carga directa de archivos (mantener por compatibilidad)\n  eventPhotos: z.array(z.instanceof(File)).optional().default([]),\n  eventVideos: z.array(z.instanceof(File)).optional().default([]),\n  eventPhoto: z.instanceof(File).optional().nullable(),\n  eventVideo: z.instanceof(File).optional().nullable(),\n  mainMediaFile: z.instanceof(File).optional().nullable(),\n  mainMediaType: z.string().optional(),\n});\n\n// Tipos para props y datos\ntype LocationData = {\n  latitude: number;\n  longitude: number;\n  locationName: string;\n  locationAddress: string;\n};\n\ntype CreateEventFormProps = {\n  onClose: () => void;\n  visible: boolean;\n  initialLocation?: LocationData | null;\n  onEventCreated?: () => void; // Callback para cuando se crea el evento con éxito\n  isEditMode?: boolean;        // Indica si estamos en modo edición\n  eventToEdit?: any;           // Datos del evento a editar\n};\n\n// Define el tipo extendido para compatibilidad con todo el formulario\ntype FormValues = z.infer<typeof createEventSchema> & {\n  mediaItems: MediaItem[];\n  eventPhoto?: File;\n  eventVideo?: File;\n  eventPhotos?: File[];\n  eventVideos?: File[];\n  mainMediaFile?: File;\n  mainMediaType?: string;\n};\n\n// Librerias de Google Maps\nconst libraries: Libraries = [\"places\"];\n\n/**\n * Componente CreateEventForm - Formulario para crear nuevos eventos\n */\n/**\n * CreateEventFormGoogle con manejo mejorado de ciclo de vida para evitar problemas\n * al cerrar el formulario. El componente se destruye completamente al cerrarse.\n * También funciona en modo edición cuando isEditMode=true.\n */\nconst CreateEventFormGoogle = ({ onClose, visible, initialLocation, onEventCreated, isEditMode, eventToEdit }: CreateEventFormProps) => {\n  console.log(\"Creando instancia de CreateEventFormGoogle\", isEditMode ? \"en modo EDICIÓN\" : \"en modo CREACIÓN\");\n  // Estados principales\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  \n  // Cuando el componente va a ser desmontado, limpiar cualquier estado o efecto pendiente\n  useEffect(() => {\n    return () => {\n      console.log(\"Desmontando CreateEventFormGoogle - limpiando recursos\");\n      // La función onClose ya habrá sido llamada desde el botón o desde otro lugar\n      // Este es solo un lugar adicional para asegurar la limpieza completa\n    };\n  }, []);\n  \n  // Inicializar ubicación - Mostrar ubicación seleccionada o la ubicación predeterminada\n  const defaultLocation = {\n    lat: 19.4326, // Ciudad de México por defecto\n    lng: -99.1332\n  };\n  \n  // Usar ubicación inicial si existe, o la predeterminada\n  const [center, setCenter] = useState(\n    initialLocation \n      ? { lat: initialLocation.latitude, lng: initialLocation.longitude } \n      : defaultLocation\n  );\n  \n  // Configurar el marcador con la misma ubicación inicial\n  const [markerPosition, setMarkerPosition] = useState(\n    initialLocation \n      ? { lat: initialLocation.latitude, lng: initialLocation.longitude } \n      : defaultLocation\n  );\n  \n  // Establecer el paso inicial - Si hay ubicación inicial, ir al paso 2\n  const [step, setStep] = useState<1 | 2>(1);\n  \n  // Cargar Google Maps\n  const { isLoaded, loadError } = useLoadScript({\n    googleMapsApiKey: GOOGLE_MAPS_API_KEY,\n    libraries,\n  });\n  \n  // Hooks y referencias\n  const { toast } = useToast();\n  const { user, isLoading } = useAuth();\n  const [_, navigate] = useLocation();\n  const mapRef = useRef<google.maps.Map | null>(null);\n  \n  // Procesar datos del evento para edición, si existen\n  const getDefaultValues = () => {\n    if (isEditMode && eventToEdit) {\n      console.log(\"Precargando evento para editar:\", eventToEdit);\n      \n      // Convertir coordenadas a números si son strings\n      const lat = typeof eventToEdit.latitude === 'string' ? parseFloat(eventToEdit.latitude) : eventToEdit.latitude;\n      const lng = typeof eventToEdit.longitude === 'string' ? parseFloat(eventToEdit.longitude) : eventToEdit.longitude;\n      \n      // Obtener fecha y hora formateadas\n      const eventDate = eventToEdit.date ? new Date(eventToEdit.date) : new Date();\n      const formattedDate = eventDate.toISOString().split('T')[0];\n      const hours = eventDate.getHours().toString().padStart(2, '0');\n      const minutes = eventDate.getMinutes().toString().padStart(2, '0');\n      const formattedTime = `${hours}:${minutes}`;\n      \n      // Extraer datos multimedia\n      let mediaItems = [];\n      if (eventToEdit.mediaItems) {\n        try {\n          mediaItems = JSON.parse(eventToEdit.mediaItems);\n        } catch (e) {\n          console.error(\"Error parsing mediaItems:\", e);\n        }\n      }\n      \n      return {\n        title: eventToEdit.title || \"\",\n        description: eventToEdit.description || \"\",\n        category: eventToEdit.category || \"\",\n        date: formattedDate,\n        time: formattedTime,\n        latitude: lat,\n        longitude: lng,\n        locationName: eventToEdit.locationName || \"\",\n        locationAddress: eventToEdit.locationAddress || \"\",\n        paymentType: eventToEdit.paymentType || \"free\",\n        price: eventToEdit.price ? eventToEdit.price.toString() : \"\",\n        maxCapacity: eventToEdit.maxCapacity ? eventToEdit.maxCapacity.toString() : \"\",\n        privacyType: eventToEdit.privacyType || \"public\",\n        genderPreference: eventToEdit.genderPreference || \"all_people\",\n        privateAccessType: eventToEdit.privateAccessType || \"solicitud\",\n        applicationQuestions: eventToEdit.applicationQuestions || \"\",\n        mediaItems: mediaItems,\n        eventPhotos: [],\n        eventVideos: [],\n        eventPhoto: undefined,\n        eventVideo: undefined,\n        mainMediaFile: undefined,\n      };\n    } else {\n      // Valores por defecto para creación\n      return {\n        title: \"\",\n        description: \"\",\n        category: \"\",\n        date: \"\",\n        time: \"\",\n        // Asegurarnos de que las coordenadas se traten como números\n        latitude: initialLocation ? parseFloat(String(initialLocation.latitude)) : \"\",\n        longitude: initialLocation ? parseFloat(String(initialLocation.longitude)) : \"\",\n        locationName: initialLocation?.locationName || \"\",\n        locationAddress: initialLocation?.locationAddress || \"\",\n        paymentType: \"free\",\n        price: \"\",\n        maxCapacity: \"\",\n        privacyType: \"public\",\n        genderPreference: \"all_people\",\n        privateAccessType: \"solicitud\", // Valor predeterminado cuando privacyType es \"private\"\n        applicationQuestions: \"\",\n        mediaItems: [],\n        eventPhotos: [],\n        eventVideos: [],\n        eventPhoto: undefined,\n        eventVideo: undefined,\n        mainMediaFile: undefined,\n      };\n    }\n  };\n\n  // Inicializar formulario con valores iniciales y resolver problemas de tipos\n  const form = useForm<FormValues, any, FormValues>({\n    resolver: zodResolver(createEventSchema),\n    defaultValues: getDefaultValues(),\n  });\n\n  // Verificar autenticación\n  useEffect(() => {\n    if (!isLoading && !user) {\n      toast({\n        title: \"Autenticación Requerida\",\n        description: \"Por favor, inicia sesión para crear eventos\",\n        variant: \"destructive\",\n      });\n      navigate(\"/login\");\n    }\n  }, [user, isLoading, toast, navigate]);\n  \n  // Efecto para actualizar el paso y valores del formulario cuando cambia la ubicación inicial\n  useEffect(() => {\n    if (initialLocation) {\n      console.log(\"Recibida ubicación inicial:\", initialLocation);\n      \n      // Verificar que las coordenadas sean válidas antes de continuar\n      const lat = Number(initialLocation.latitude);\n      const lng = Number(initialLocation.longitude);\n      \n      if (isNaN(lat) || isNaN(lng)) {\n        console.error(\"Coordenadas inválidas recibidas:\", {\n          latitude: initialLocation.latitude,\n          longitude: initialLocation.longitude,\n          tipoLat: typeof initialLocation.latitude,\n          tipoLng: typeof initialLocation.longitude\n        });\n        \n        toast({\n          title: \"Error en coordenadas\",\n          description: \"Las coordenadas recibidas no son válidas. Por favor intenta seleccionar otra ubicación.\",\n          variant: \"destructive\"\n        });\n        \n        // No avanzar al paso 2 si las coordenadas no son válidas\n        return;\n      }\n      \n      // Actualizar los valores del formulario explícitamente\n      form.setValue(\"latitude\", lat);\n      form.setValue(\"longitude\", lng);\n      form.setValue(\"locationName\", initialLocation.locationName || \"\");\n      form.setValue(\"locationAddress\", initialLocation.locationAddress || \"\");\n      \n      // También actualizar el estado del mapa y el marcador con la nueva ubicación\n      setCenter({ lat, lng });\n      setMarkerPosition({ lat, lng });\n      \n      console.log(\"Formulario actualizado con valores:\", {\n        lat: form.getValues(\"latitude\"),\n        lng: form.getValues(\"longitude\"),\n        tipoLat: typeof form.getValues(\"latitude\"),\n        tipoLng: typeof form.getValues(\"longitude\")\n      });\n      \n      // Establecer al paso 2 solo cuando recibimos coordenadas válidas\n      setStep(2);\n    } else {\n      // SOLUCIÓN AL BUG DE PERSISTENCIA DE UBICACIÓN:\n      // Cuando initialLocation es null, resetear la ubicación al valor predeterminado\n      console.log(\"initialLocation es null - reseteando ubicación a valores predeterminados\");\n      \n      // Reset location values to defaults\n      form.setValue(\"latitude\", \"\");\n      form.setValue(\"longitude\", \"\");\n      form.setValue(\"locationName\", \"\");\n      form.setValue(\"locationAddress\", \"\");\n      \n      // Reset map center and marker to default location\n      setCenter(defaultLocation);\n      setMarkerPosition(defaultLocation);\n      \n      // Reset to step 1 since there's no location selected\n      setStep(1);\n    }\n  }, [initialLocation, form, toast]);\n\n  // Callback para guardar la referencia del mapa\n  const onMapLoad = useCallback((map: google.maps.Map) => {\n    mapRef.current = map;\n  }, []);\n\n  // Manejar click en el mapa\n  const handleMapClick = useCallback((event: google.maps.MapMouseEvent) => {\n    if (event.latLng) {\n      const lat = event.latLng.lat();\n      const lng = event.latLng.lng();\n      \n      setMarkerPosition({ lat, lng });\n      \n      // Guardar como números, no strings\n      form.setValue(\"latitude\", lat);\n      form.setValue(\"longitude\", lng);\n      \n      // Obtener dirección y detalles del lugar\n      reverseGeocode(lng, lat).then(async address => {\n        console.log(\"Dirección geocodificada inversamente:\", address);\n        \n        // Intentar obtener el nombre del lugar usando Places API si está disponible\n        try {\n          // Crear el servicio de Places\n          if (window.google && window.google.maps && window.google.maps.places) {\n            const placesService = new window.google.maps.places.PlacesService(document.createElement('div'));\n            \n            // Buscar lugares cercanos a las coordenadas donde se hizo clic\n            const request = {\n              location: new window.google.maps.LatLng(lat, lng),\n              radius: 100, // Buscar en un radio de 100 metros\n              type: 'establishment' // Priorizar establecimientos - debe ser un string, no un array\n            };\n            \n            // Promisificar la llamada a nearbySearch\n            const nearbyPlaces = await new Promise<google.maps.places.PlaceResult[]>((resolve, reject) => {\n              placesService.nearbySearch(request, (results, status) => {\n                if (status === window.google.maps.places.PlacesServiceStatus.OK && results) {\n                  resolve(results);\n                } else {\n                  reject(new Error(`Places API error: ${status}`));\n                }\n              });\n            });\n            \n            // Si encontramos establecimientos cercanos, usar el nombre del primero\n            if (nearbyPlaces && nearbyPlaces.length > 0) {\n              console.log(\"Lugares encontrados cerca:\", nearbyPlaces);\n              const placeResult = nearbyPlaces[0];\n              const placeName = placeResult.name || address.split(',')[0];\n              \n              form.setValue(\"locationAddress\", address);\n              form.setValue(\"locationName\", placeName);\n              \n              toast({\n                title: \"Ubicación seleccionada\",\n                description: placeName,\n              });\n              return;\n            }\n          }\n        } catch (placesError) {\n          console.error(\"Error al buscar lugares cercanos:\", placesError);\n          // Continuar con el enfoque predeterminado si falla\n        }\n        \n        // Método predeterminado: usar la primera parte de la dirección\n        const locationName = address.split(',')[0] || \"Lugar del evento\";\n        form.setValue(\"locationAddress\", address);\n        form.setValue(\"locationName\", locationName);\n        \n        toast({\n          title: \"Ubicación seleccionada\",\n          description: \"Ubicación guardada correctamente\",\n        });\n      }).catch(error => {\n        console.error(\"Error obteniendo dirección:\", error);\n        form.setValue(\"locationAddress\", \"Dirección no disponible\");\n        form.setValue(\"locationName\", \"Lugar del evento\");\n      });\n    }\n  }, [form, toast]);\n\n  // Validar ubicación antes de continuar al paso 2\n  const validateAndContinue = async () => {\n    // Log para depuración\n    console.log(\"Validando ubicación:\", {\n      latitude: form.getValues(\"latitude\"),\n      longitude: form.getValues(\"longitude\"),\n      tipo_lat: typeof form.getValues(\"latitude\"),\n      tipo_lng: typeof form.getValues(\"longitude\")\n    });\n    \n    if (!form.getValues(\"latitude\") || !form.getValues(\"longitude\")) {\n      toast({\n        title: \"Selecciona una ubicación\",\n        description: \"Haz clic en el mapa para seleccionar dónde se realizará el evento\",\n        variant: \"destructive\"\n      });\n      return;\n    }\n    \n    // Si falta nombre o dirección, intentar obtenerlos\n    if (!form.getValues(\"locationName\") || !form.getValues(\"locationAddress\")) {\n      try {\n        // Siempre convertimos explícitamente a string y luego a número para evitar problemas de tipo\n        const lngValue = form.getValues(\"longitude\");\n        const latValue = form.getValues(\"latitude\");\n        const lng = typeof lngValue === 'string' ? parseFloat(lngValue) : lngValue;\n        const lat = typeof latValue === 'string' ? parseFloat(latValue) : latValue;\n        \n        const address = await reverseGeocode(lng, lat);\n        \n        const locationName = address.split(',')[0] || \"Lugar del evento\";\n        form.setValue(\"locationAddress\", address);\n        form.setValue(\"locationName\", locationName);\n      } catch (error) {\n        // Si falla, usar valores por defecto\n        form.setValue(\"locationAddress\", \"Dirección no disponible\");\n        form.setValue(\"locationName\", \"Lugar del evento\");\n      }\n    }\n    \n    // Avanzar al siguiente paso con animación\n    changeStep(2);\n  };\n\n  // Enviar formulario al servidor\n  const onSubmit = async (data: FormValues) => {\n    // SOLUCIÓN AL ERROR UNDEFINED:\n    // El problema ocurre porque los datos no están definidos correctamente\n    // Vamos a asegurarnos que todos los valores críticos estén definidos\n    \n    if (!data || typeof data !== 'object') {\n      console.error(\"Datos del formulario inválidos:\", data);\n      toast({\n        title: \"Error en formulario\",\n        description: \"Los datos del formulario no son válidos. Por favor, inténtalo de nuevo.\",\n        variant: \"destructive\",\n      });\n      return;\n    }\n    \n    if (isSubmitting) return;\n    setIsSubmitting(true);\n    \n    try {\n      // Verificación adicional para mediaItems - Esto es crucial para evitar undefined\n      if (!data.mediaItems || !Array.isArray(data.mediaItems)) {\n        console.warn(\"data.mediaItems no es un array válido. Inicializando como array vacío.\");\n        data.mediaItems = [];\n      }\n      \n      // Preparar datos para la API\n      const dateTime = new Date(`${data.date}T${data.time}`);\n      const endDateTime = data.endTime ? new Date(`${data.date}T${data.endTime}`) : new Date(dateTime.getTime() + 2 * 60 * 60 * 1000); // Default to 2 hours later\n      \n      // Validate that end time is after start time\n      if (endDateTime <= dateTime) {\n        toast({\n          title: \"Error de horario\",\n          description: \"La hora de finalización debe ser posterior a la hora de inicio.\",\n          variant: \"destructive\",\n        });\n        return;\n      }\n      \n      // Check for scheduling conflicts before creating the event\n      try {\n        const response = await fetch(`/api/events/check-conflicts`, {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          credentials: 'include',\n          body: JSON.stringify({\n            startTime: dateTime.toISOString(),\n            endTime: endDateTime.toISOString(),\n            paymentType: data.paymentType\n          })\n        });\n        \n        if (response.ok) {\n          const conflictCheck = await response.json();\n          if (conflictCheck.hasConflict) {\n            toast({\n              title: \"Conflicto de horarios\",\n              description: conflictCheck.message || \"Ya tienes eventos programados que se superponen con este horario.\",\n              variant: \"destructive\",\n            });\n            return;\n          }\n        }\n      } catch (error) {\n        console.error('Error checking conflicts:', error);\n        // Continue anyway if conflict check fails\n      }\n      \n      // Crear FormData para enviar archivos\n      const formData = new FormData();\n      \n      // Añadir campos básicos\n      formData.append('title', data.title);\n      formData.append('description', data.description);\n      formData.append('category', data.category);\n      formData.append('date', dateTime.toISOString());\n      formData.append('endTime', endDateTime.toISOString());\n      formData.append('latitude', String(data.latitude));\n      formData.append('longitude', String(data.longitude));\n      formData.append('locationName', data.locationName);\n      formData.append('locationAddress', data.locationAddress);\n      formData.append('paymentType', data.paymentType);\n      formData.append('privacyType', data.privacyType);\n      formData.append('genderPreference', data.genderPreference);\n      \n      // Añadir campos condicionales\n      if (data.paymentType === 'paid' && data.price) {\n        formData.append('price', data.price);\n      }\n      \n      if (data.privacyType === 'private' && data.privateAccessType) {\n        formData.append('privateAccessType', data.privateAccessType);\n        \n        // Añadir preguntas de aplicación si es relevante\n        if (data.privateAccessType === 'postulacion' && data.applicationQuestions) {\n          formData.append('applicationQuestions', data.applicationQuestions);\n        }\n      }\n      \n      // ===== CORRECCIÓN DEL BUG \"UNDEFINED\" =====\n      // Este es el parche directo para solucionar el problema con los archivos multimedia\n      // 1. Asegurar que formData tenga un valor por defecto para mainMediaType\n      formData.append('mainMediaType', 'photo'); // Valor seguro por defecto\n      \n      // 2. Filtrar y procesar mediaItems\n      const validMediaItems = data.mediaItems.filter(item => \n        item && \n        typeof item === 'object' && \n        !item.deleted && \n        !item.toDelete\n      );\n      \n      // 3. Buscar un elemento principal o usar el primero disponible\n      const mainMediaItem = validMediaItems.find(item => item.isMain) || \n                           (validMediaItems.length > 0 ? validMediaItems[0] : null);\n      \n      // 4. Procesar el elemento principal si existe\n      if (mainMediaItem) {\n        if (mainMediaItem.file instanceof File) {\n          formData.append('mainMediaFile', mainMediaItem.file);\n          formData.append('mainMediaType', mainMediaItem.type || 'photo');\n          console.log(\"Archivo principal agregado:\", mainMediaItem.file.name);\n        } else if (mainMediaItem.url) {\n          formData.append('mainMediaUrl', mainMediaItem.url);\n          formData.append('mainMediaType', mainMediaItem.type || 'photo');\n          console.log(\"URL principal agregada:\", mainMediaItem.url);\n        }\n      }\n      \n      // 5. Procesar elementos multimedia (excluyendo el principal para evitar duplicación)\n      validMediaItems.forEach((item, index) => {\n        if (item.file instanceof File && item !== mainMediaItem) {\n          formData.append(`mediaFile_${index}`, item.file);\n        }\n      });\n      \n      // 6. Preparar metadata para todos los elementos\n      const mediaItemsMetadata = validMediaItems.map((item, index) => ({\n        type: item.type || 'photo',\n        isMain: item === mainMediaItem,\n        order: index,\n        id: item.id\n      }));\n      \n      // Agregar metadata como JSON\n      formData.append('mediaItems', JSON.stringify(mediaItemsMetadata));\n      \n      // Añadir capacidad máxima si existe\n      if (data.maxCapacity) {\n        formData.append('maxCapacity', String(Number(data.maxCapacity)));\n      }\n      \n      // Verificar si estamos en modo edición\n      const isEditingMode = isEditMode && eventToEdit && eventToEdit.id;\n      \n      console.log(`${isEditingMode ? \"Actualizando\" : \"Creando\"} datos del evento:`, {\n        id: isEditingMode ? eventToEdit.id : \"nuevo\",\n        title: data.title,\n        description: data.description.substring(0, 30),\n        category: data.category,\n        mediaItems: data.mediaItems?.length || 0\n      });\n      \n      // Usar fetch directamente para FormData\n      // IMPORTANTE: Para edición siempre usamos PATCH porque maneja correctamente \n      // tanto los archivos como los metadatos de multimedia\n      const url = isEditingMode ? `/api/events/${eventToEdit.id}` : '/api/events';\n      const method = isEditingMode ? 'PATCH' : 'POST';\n      \n      // Debug: inspeccionar qué contiene el FormData antes de enviarlo\n      console.log(\"===== CONTENIDO DEL FORMDATA =====\");\n      console.log(\"Modo:\", isEditingMode ? \"EDICIÓN\" : \"CREACIÓN\", \"usando método:\", method);\n      console.log(\"URL:\", url);\n      let formDataEntries: Record<string, any> = {};\n      formData.forEach((value, key) => {\n        if (key === 'mediaItems') {\n          try {\n            formDataEntries[key] = JSON.parse(value.toString());\n          } catch (error) {\n            formDataEntries[key] = value.toString();\n          }\n        } else if (value instanceof File) {\n          formDataEntries[key] = `File: ${value.name}`;\n        } else {\n          formDataEntries[key] = value.toString();\n        }\n      });\n      console.log(\"FormData contiene:\", formDataEntries);\n      \n      const response = await fetch(url, {\n        method: method,\n        body: formData,\n        credentials: 'include' // Para enviar cookies de sesión\n      });\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        console.error(\"Error del servidor:\", errorData);\n        \n        // Verificar si es un error de autenticación\n        if (response.status === 401) {\n          toast({\n            title: \"Necesitas iniciar sesión\",\n            description: \"Debes iniciar sesión antes de poder crear eventos.\",\n            variant: \"destructive\",\n          });\n          navigate(\"/login\");\n          return;\n        }\n        \n        // Sanitizar mensaje de error para mostrar al usuario\n        let safeErrorMessage = \"Ocurrió un error al crear el evento. Por favor, inténtalo de nuevo.\";\n        \n        try {\n          if (errorData.message) {\n            if (typeof errorData.message === 'string') {\n              // Detectar error específico de \"undefined\"\n              if (errorData.message.includes('undefined')) {\n                console.warn(\"Detectado mensaje 'undefined' del servidor:\", errorData.message);\n                safeErrorMessage = \"Error en la subida de archivos. Por favor, verifica los archivos e inténtalo nuevamente.\";\n              } else {\n                safeErrorMessage = errorData.message;\n              }\n            } else if (typeof errorData.message === 'object') {\n              // Intentar convertir a string si es posible\n              safeErrorMessage = \"Error del servidor: \" + JSON.stringify(errorData.message);\n            }\n          }\n        } catch (sanitizeError) {\n          console.error(\"Error al sanitizar mensaje de error:\", sanitizeError);\n          // Mantener el mensaje seguro por defecto\n        }\n        \n        toast({\n          title: \"Error al crear evento\",\n          description: safeErrorMessage,\n          variant: \"destructive\",\n        });\n        \n        setIsSubmitting(false);\n        return;\n      }\n      \n      const eventData = await response.json();\n      console.log(`Evento ${isEditMode && eventToEdit ? 'actualizado' : 'creado'}:`, eventData);\n      \n      toast({\n        title: isEditMode && eventToEdit ? \"¡Evento actualizado!\" : \"¡Evento creado!\",\n        description: isEditMode && eventToEdit ? \"Tu evento se ha actualizado correctamente\" : \"Tu evento se ha creado correctamente\",\n      });\n      \n      // Emitir evento personalizado para actualizar todas las vistas\n      if (isEditMode && eventToEdit) {\n        // Emitir evento DOM para componentes que no usan react-query\n        const eventUpdateEvent = new CustomEvent('event-updated', { \n          detail: { eventId: eventData.id, data: eventData } \n        });\n        window.dispatchEvent(eventUpdateEvent);\n        console.log('Evento personalizado emitido para actualización de evento:', eventData.id);\n      }\n      \n      // Llamar al callback para actualizar los eventos en el mapa si existe\n      if (onEventCreated) {\n        console.log(\"Llamando a onEventCreated para actualizar eventos...\");\n        onEventCreated();\n      }\n\n      // Cerrar formulario (esto llamará al método en Home.tsx que limpia el estado)\n      onClose();\n      \n      // No realizamos ninguna navegación adicional, ya que queremos permanecer en el mapa\n      // y ver el evento recién creado en el contexto del mapa\n      \n      // Emitir notificación de éxito adicional para confirmar al usuario\n      setTimeout(() => {\n        toast({\n          title: \"¡Evento visible en el mapa!\",\n          description: \"Tu nuevo evento ya aparece en el mapa\",\n          variant: \"default\",\n        });\n      }, 500);\n    } catch (error) {\n      console.error(\"Error al crear evento:\", error);\n      \n      toast({\n        title: \"Error al crear evento\",\n        description: \"Ocurrió un error inesperado. Por favor, inténtalo de nuevo.\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  // Animación para cambio de paso\n  const [stepAnimation, setStepAnimation] = useState<'none' | 'fade-out' | 'fade-in'>('none');\n  \n  // Función para cambiar de paso con animación\n  const changeStep = useCallback((newStep: 1 | 2) => {\n    // Iniciar animación de salida\n    setStepAnimation('fade-out');\n    \n    // Después de que termine la animación de salida, cambiar al nuevo paso y comenzar la animación de entrada\n    setTimeout(() => {\n      setStep(newStep);\n      setStepAnimation('fade-in');\n      \n      // Reset del estado de la animación después de completarla\n      setTimeout(() => {\n        setStepAnimation('none');\n      }, 300);\n    }, 300);\n  }, []);\n  \n  // Función para volver al paso anterior o cerrar formulario\n  const handleBackButtonClick = useCallback(() => {\n    try {\n      console.log(\"Botón de retroceso pulsado, paso actual:\", step);\n      \n      // Cerrar el formulario directamente\n      console.log(\"Cerrando formulario de evento - llamando a onClose directamente\");\n      onClose();\n    } catch (error) {\n      console.error(\"Error al manejar retroceso:\", error);\n      // Si hay un error, intentar cerrar directamente\n      onClose();\n    }\n  }, [step, onClose]);\n  \n  // Renderizado condicional basado en el paso\n  const renderStepContent = () => {\n    if (step === 1) {\n      return (\n        <div className={`step-content ${stepAnimation}`}>\n          <div className=\"space-y-6\">\n            <div className=\"mb-4\">\n              <h2 className=\"text-lg font-semibold mb-1\">Ubicación del Evento</h2>\n              <p className=\"text-sm text-gray-500\">Selecciona dónde se realizará tu evento</p>\n            </div>\n            \n            <div className=\"map-container\" style={{ height: '400px', width: '100%', position: 'relative' }}>\n              {isLoaded ? (\n                <GoogleMap\n                  mapContainerStyle={{ height: '100%', width: '100%' }}\n                  zoom={14}\n                  center={center}\n                  options={defaultMapConfig}\n                  onClick={handleMapClick}\n                  onLoad={onMapLoad}\n                >\n                  <Marker position={markerPosition} />\n                </GoogleMap>\n              ) : loadError ? (\n                <div className=\"error-message p-4 bg-red-50 text-red-700 rounded-md\">\n                  No se pudo cargar el mapa: {loadError.message}\n                </div>\n              ) : (\n                <div className=\"loading-spinner flex justify-center items-center h-full\">\n                  Cargando mapa...\n                </div>\n              )}\n            </div>\n            \n            <div className=\"grid grid-cols-1 gap-4\">\n              <FormField\n                control={form.control}\n                name=\"locationName\"\n                render={({ field }) => (\n                  <FormItem>\n                    <FormLabel>Nombre del lugar</FormLabel>\n                    <FormControl>\n                      <Input placeholder=\"Ej: Centro Cultural, Parque, etc.\" {...field} />\n                    </FormControl>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n              \n              <FormField\n                control={form.control}\n                name=\"locationAddress\"\n                render={({ field }) => (\n                  <FormItem>\n                    <FormLabel>Dirección</FormLabel>\n                    <FormControl>\n                      <Input placeholder=\"Dirección completa\" {...field} />\n                    </FormControl>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n            </div>\n            \n            <div className=\"flex justify-between mt-6\">\n              <Button \n                type=\"button\" \n                variant=\"outline\" \n                onClick={handleBackButtonClick}\n              >\n                <ArrowLeft className=\"h-4 w-4 mr-2\" /> Cancelar\n              </Button>\n              \n              <Button \n                type=\"button\"\n                onClick={validateAndContinue}\n              >\n                Continuar\n              </Button>\n            </div>\n          </div>\n        </div>\n      );\n    } else {\n      // Paso 2 - Detalles del evento\n      return (\n        <div className={`step-content ${stepAnimation}`}>\n          <div className=\"space-y-6\">\n            <div className=\"mb-4\">\n              <h2 className=\"text-lg font-semibold mb-1\">Detalles del Evento</h2>\n              <p className=\"text-sm text-gray-500\">Completa la información de tu evento</p>\n            </div>\n            \n            <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n              <FormField\n                control={form.control}\n                name=\"title\"\n                render={({ field }) => (\n                  <FormItem className=\"space-y-2\">\n                    <FormLabel className=\"flex items-center gap-2\">\n                      <Tag className=\"h-4 w-4 text-primary\" />\n                      <span>Título del evento</span>\n                    </FormLabel>\n                    <FormControl>\n                      <Input \n                        placeholder=\"Ej: Concierto de Jazz, Taller de cerámica...\" \n                        className=\"bg-card\"\n                        {...field} \n                      />\n                    </FormControl>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n              \n              <FormField\n                control={form.control}\n                name=\"category\"\n                render={({ field }) => (\n                  <FormItem className=\"space-y-2\">\n                    <FormLabel className=\"flex items-center gap-2\">\n                      <Tag className=\"h-4 w-4 text-primary\" />\n                      <span>Categoría</span>\n                    </FormLabel>\n                    <Select \n                      onValueChange={field.onChange} \n                      defaultValue={field.value}\n                    >\n                      <FormControl>\n                        <SelectTrigger className=\"bg-card\">\n                          <SelectValue placeholder=\"Selecciona una categoría\" />\n                        </SelectTrigger>\n                      </FormControl>\n                      <SelectContent>\n                        {EVENT_CATEGORIES.map(category => (\n                          <SelectItem key={category.value} value={category.value}>\n                            {category.label}\n                          </SelectItem>\n                        ))}\n                      </SelectContent>\n                    </Select>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n            </div>\n            \n            <FormField\n              control={form.control}\n              name=\"description\"\n              render={({ field }) => (\n                <FormItem className=\"space-y-2\">\n                  <FormLabel className=\"flex items-center gap-2\">\n                    <div className=\"flex items-center gap-2\">\n                      <span className=\"h-4 w-4 flex items-center justify-center text-primary text-xs font-bold border border-primary rounded\">i</span>\n                      <span>Descripción</span>\n                    </div>\n                  </FormLabel>\n                  <FormControl>\n                    <Textarea \n                      placeholder=\"Describe de qué trata el evento, qué pueden esperar los asistentes...\" \n                      className=\"min-h-[150px] bg-card resize-none\"\n                      {...field} \n                    />\n                  </FormControl>\n                  <FormMessage />\n                  <p className=\"text-xs text-muted-foreground\">\n                    Una buena descripción incluye: qué actividades se realizarán, qué deben traer los asistentes, \n                    y cualquier información importante sobre el lugar o los organizadores.\n                  </p>\n                </FormItem>\n              )}\n            />\n            \n            <FormField\n              control={form.control}\n              name=\"maxCapacity\"\n              render={({ field }) => (\n                <FormItem className=\"space-y-2\">\n                  <FormLabel className=\"flex items-center gap-2\">\n                    <Users className=\"h-4 w-4 text-primary\" />\n                    <span>Capacidad máxima (opcional)</span>\n                  </FormLabel>\n                  <FormControl>\n                    <div className=\"relative\">\n                      <Users className=\"absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground\" />\n                      <Input \n                        type=\"number\" \n                        placeholder=\"Deja en blanco si no hay límite\"\n                        className=\"pl-10 bg-card\"\n                        {...field} \n                      />\n                    </div>\n                  </FormControl>\n                  <p className=\"text-xs text-muted-foreground\">\n                    Establece un límite de asistentes para tu evento. \n                    Cuando se alcance este número, no se permitirán más registros.\n                  </p>\n                  <FormMessage />\n                </FormItem>\n              )}\n            />\n            \n            <div className=\"bg-primary/5 rounded-lg p-4 border border-primary/20 mb-4\">\n              <h3 className=\"text-md font-medium mb-3 flex items-center gap-2\">\n                <Calendar className=\"h-4 w-4 text-primary\" />\n                Fecha y hora\n              </h3>\n              <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n                <FormField\n                  control={form.control}\n                  name=\"date\"\n                  render={({ field }) => (\n                    <FormItem className=\"space-y-2\">\n                      <div className=\"flex items-center\">\n                        <FormLabel className=\"text-sm text-muted-foreground flex-grow\">Fecha</FormLabel>\n                        <Calendar \n                          className=\"h-4 w-4 text-primary mr-1\" \n                        />\n                      </div>\n                      <FormControl>\n                        <Input \n                          type=\"date\" \n                          className=\"bg-card\"\n                          min={new Date().toISOString().split('T')[0]}\n                          max={new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]}\n                          {...field} \n                        />\n                      </FormControl>\n                      <FormMessage />\n                    </FormItem>\n                  )}\n                />\n                \n                <FormField\n                  control={form.control}\n                  name=\"time\"\n                  render={({ field }) => (\n                    <FormItem className=\"space-y-2\">\n                      <div className=\"flex items-center\">\n                        <FormLabel className=\"text-sm text-muted-foreground flex-grow\">Hora de inicio</FormLabel>\n                        <Clock \n                          className=\"h-4 w-4 text-primary mr-1\" \n                        />\n                      </div>\n                      <FormControl>\n                        <Input \n                          type=\"time\" \n                          className=\"bg-card\"\n                          min={\n                            form.watch(\"date\") === new Date().toISOString().split('T')[0] \n                              ? new Date().toTimeString().slice(0, 5)\n                              : undefined\n                          }\n                          {...field}\n                          onChange={(e) => {\n                            field.onChange(e);\n                            // Reset end time when start time changes\n                            const endTimeValue = form.watch(\"endTime\");\n                            if (endTimeValue && e.target.value >= endTimeValue) {\n                              form.setValue(\"endTime\", \"\");\n                            }\n                          }} \n                        />\n                      </FormControl>\n                      <FormMessage />\n                    </FormItem>\n                  )}\n                />\n              </div>\n              \n              <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4 mt-4\">\n                <FormField\n                  control={form.control}\n                  name=\"endTime\"\n                  render={({ field }) => (\n                    <FormItem className=\"space-y-2\">\n                      <div className=\"flex items-center\">\n                        <FormLabel className=\"text-sm text-muted-foreground flex-grow\">Hora de finalización</FormLabel>\n                        <Clock \n                          className=\"h-4 w-4 text-primary mr-1\" \n                        />\n                      </div>\n                      <FormControl>\n                        <Input \n                          type=\"time\" \n                          className=\"bg-card\"\n                          min={form.watch(\"time\") || \"00:00\"}\n                          disabled={!form.watch(\"time\")}\n                          placeholder=\"Selecciona primero la hora de inicio\"\n                          {...field} \n                        />\n                      </FormControl>\n                      <FormMessage />\n                      <p className=\"text-xs text-muted-foreground\">\n                        La hora de finalización debe ser después de la hora de inicio\n                      </p>\n                    </FormItem>\n                  )}\n                />\n                \n                <div className=\"flex items-center justify-center text-sm text-gray-500\">\n                  {form.watch(\"paymentType\") === \"paid\" ? (\n                    <span>Las personas verán tanto el horario de inicio como el de finalización</span>\n                  ) : (\n                    <span>Si tu evento es público y gratuito las personas solo verán el horario de inicio del evento</span>\n                  )}\n                </div>\n              </div>\n            </div>\n            \n            <div className=\"bg-primary/5 rounded-lg p-4 border border-primary/20 mb-4\">\n              <h3 className=\"text-md font-medium mb-3 flex items-center gap-2\">\n                <DollarSign className=\"h-4 w-4 text-primary\" />\n                Tipo de acceso\n              </h3>\n              <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n                <FormField\n                  control={form.control}\n                  name=\"paymentType\"\n                  render={({ field }) => (\n                    <FormItem className=\"space-y-2\">\n                      <FormLabel className=\"text-sm text-muted-foreground\">Acceso</FormLabel>\n                      <Select \n                        onValueChange={field.onChange} \n                        defaultValue={field.value}\n                      >\n                        <FormControl>\n                          <SelectTrigger className=\"bg-card\">\n                            <SelectValue placeholder=\"Selecciona tipo de acceso\" />\n                          </SelectTrigger>\n                        </FormControl>\n                        <SelectContent>\n                          <SelectItem value=\"free\">\n                            <div className=\"flex items-center gap-2\">\n                              <span className=\"h-2 w-2 rounded-full bg-green-500\"></span>\n                              Gratuito\n                            </div>\n                          </SelectItem>\n                          <SelectItem value=\"paid\">\n                            <div className=\"flex items-center gap-2\">\n                              <span className=\"h-2 w-2 rounded-full bg-yellow-500\"></span>\n                              De pago\n                            </div>\n                          </SelectItem>\n                        </SelectContent>\n                      </Select>\n                      <FormMessage />\n                    </FormItem>\n                  )}\n                />\n                \n                {form.watch(\"paymentType\") === \"paid\" && (\n                  <FormField\n                    control={form.control}\n                    name=\"price\"\n                    render={({ field }) => (\n                      <FormItem className=\"space-y-2\">\n                        <FormLabel className=\"text-sm text-muted-foreground\">Precio (MXN)</FormLabel>\n                        <FormControl>\n                          <div className=\"relative\">\n                            <DollarSign className=\"absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground\" />\n                            <Input \n                              type=\"number\" \n                              placeholder=\"Ej: 150\"\n                              className=\"pl-10 bg-card\"\n                              {...field} \n                            />\n                          </div>\n                        </FormControl>\n                        <FormMessage />\n                      </FormItem>\n                    )}\n                  />\n                )}\n              </div>\n            </div>\n            \n            <div className=\"bg-primary/5 rounded-lg p-4 border border-primary/20 mb-4\">\n              <h3 className=\"text-md font-medium mb-3 flex items-center gap-2\">\n                <Lock className=\"h-4 w-4 text-primary\" />\n                Privacidad del evento\n              </h3>\n              <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n                <FormField\n                  control={form.control}\n                  name=\"privacyType\"\n                  render={({ field }) => (\n                    <FormItem className=\"space-y-2\">\n                      <FormLabel className=\"text-sm text-muted-foreground\">Tipo de evento</FormLabel>\n                      <Select \n                        onValueChange={field.onChange} \n                        defaultValue={field.value}\n                      >\n                        <FormControl>\n                          <SelectTrigger className=\"bg-card\">\n                            <SelectValue placeholder=\"Selecciona tipo de privacidad\" />\n                          </SelectTrigger>\n                        </FormControl>\n                        <SelectContent>\n                          <SelectItem value=\"public\">\n                            <div className=\"flex items-center gap-2\">\n                              <span className=\"h-2 w-2 rounded-full bg-green-500\"></span>\n                              Público (visible para todos)\n                            </div>\n                          </SelectItem>\n                          <SelectItem value=\"private\">\n                            <div className=\"flex items-center gap-2\">\n                              <span className=\"h-2 w-2 rounded-full bg-amber-500\"></span>\n                              Privado (acceso restringido)\n                            </div>\n                          </SelectItem>\n                        </SelectContent>\n                      </Select>\n                      <FormMessage />\n                    </FormItem>\n                  )}\n                />\n                \n                {form.watch(\"privacyType\") === \"private\" && (\n                  <FormField\n                    control={form.control}\n                    name=\"privateAccessType\"\n                    render={({ field }) => (\n                      <FormItem className=\"space-y-2\">\n                        <FormLabel className=\"text-sm text-muted-foreground\">Método de acceso</FormLabel>\n                        <Select \n                          onValueChange={field.onChange} \n                          defaultValue={field.value}\n                        >\n                          <FormControl>\n                            <SelectTrigger className=\"bg-card\">\n                              <SelectValue placeholder=\"Tipo de acceso\" />\n                            </SelectTrigger>\n                          </FormControl>\n                          <SelectContent>\n                            <SelectItem value=\"solicitud\">\n                              <div className=\"flex items-center gap-2\">\n                                <Lock className=\"h-3 w-3 text-blue-500\" />\n                                Por solicitud (tú apruebas)\n                              </div>\n                            </SelectItem>\n                            <SelectItem value=\"postulacion\">\n                              <div className=\"flex items-center gap-2\">\n                                <Users className=\"h-3 w-3 text-purple-500\" />\n                                Por postulación (formulario)\n                              </div>\n                            </SelectItem>\n                            <SelectItem value=\"paga\">\n                              <div className=\"flex items-center gap-2\">\n                                <DollarSign className=\"h-3 w-3 text-yellow-500\" />\n                                Solo de pago\n                              </div>\n                            </SelectItem>\n                          </SelectContent>\n                        </Select>\n                        <FormMessage />\n                      </FormItem>\n                    )}\n                  />\n                )}\n              </div>\n            </div>\n            \n            <div className=\"bg-primary/5 rounded-lg p-4 border border-primary/20 mb-4\">\n              <h3 className=\"text-md font-medium mb-3 flex items-center gap-2\">\n                <Users className=\"h-4 w-4 text-primary\" />\n                Destinado Para\n              </h3>\n              <div className=\"grid grid-cols-1 gap-4\">\n                <FormField\n                  control={form.control}\n                  name=\"genderPreference\"\n                  render={({ field }) => (\n                    <FormItem className=\"space-y-2\">\n                      <FormLabel className=\"text-sm text-muted-foreground\">Público destinatario del evento</FormLabel>\n                      <Select \n                        onValueChange={field.onChange} \n                        defaultValue={field.value}\n                      >\n                        <FormControl>\n                          <SelectTrigger className=\"bg-card\">\n                            <SelectValue placeholder=\"Selecciona para quién es el evento\" />\n                          </SelectTrigger>\n                        </FormControl>\n                        <SelectContent>\n                          <SelectItem value=\"all_people\">\n                            <div className=\"flex items-center gap-2\">\n                              <span className=\"h-2 w-2 rounded-full bg-blue-500\"></span>\n                              Todas las Personas\n                            </div>\n                          </SelectItem>\n                          <SelectItem value=\"men\">\n                            <div className=\"flex items-center gap-2\">\n                              <span className=\"h-2 w-2 rounded-full bg-cyan-500\"></span>\n                              Hombres\n                            </div>\n                          </SelectItem>\n                          <SelectItem value=\"women\">\n                            <div className=\"flex items-center gap-2\">\n                              <span className=\"h-2 w-2 rounded-full bg-pink-500\"></span>\n                              Mujeres\n                            </div>\n                          </SelectItem>\n                        </SelectContent>\n                      </Select>\n                      <FormMessage />\n                    </FormItem>\n                  )}\n                />\n              </div>\n            </div>\n            \n            {form.watch(\"privacyType\") === \"private\" && \n             form.watch(\"privateAccessType\") === \"postulacion\" && (\n              <div className=\"bg-blue-50 rounded-lg p-4 border border-blue-200 mb-4\">\n                <div className=\"flex items-center gap-2 mb-2\">\n                  <span className=\"bg-blue-500 text-white rounded-full h-5 w-5 flex items-center justify-center text-xs font-bold\">?</span>\n                  <h3 className=\"text-md font-medium text-blue-700\">Preguntas para postulantes</h3>\n                </div>\n                <p className=\"text-sm text-blue-600 mb-3\">\n                  Estas preguntas deberán ser respondidas por las personas que quieran asistir a tu evento privado.\n                </p>\n                <FormField\n                  control={form.control}\n                  name=\"applicationQuestions\"\n                  render={({ field }) => (\n                    <FormItem className=\"space-y-2\">\n                      <FormControl>\n                        <Textarea \n                          placeholder=\"Escribe las preguntas que quieres que respondan los interesados, separadas por líneas.\nEjemplo:\n¿Por qué quieres participar en este evento?\n¿Cuál es tu experiencia previa en este tema?\n¿Qué esperas obtener de esta actividad?\" \n                          className=\"min-h-[150px] bg-white\"\n                          {...field} \n                        />\n                      </FormControl>\n                      <FormMessage />\n                      <p className=\"text-xs text-blue-600\">\n                        Escribe cada pregunta en una línea separada. Los postulantes deberán responder a todas ellas.\n                      </p>\n                    </FormItem>\n                  )}\n                />\n              </div>\n            )}\n            \n            <div className=\"media-section border rounded-lg p-4 bg-card\">\n              <div className=\"flex items-center gap-2 mb-4\">\n                <Camera className=\"h-5 w-5 text-primary\" />\n                <h3 className=\"text-lg font-medium\">Fotos y videos del evento</h3>\n              </div>\n              <p className=\"text-sm text-muted-foreground mb-4\">\n                Agrega fotos y videos para mostrar lo que los asistentes pueden esperar. \n                El primer elemento será la imagen destacada.\n              </p>\n              <MediaManager \n                existingMedia={form.watch(\"mediaItems\")} \n                onChange={(mediaItems) => form.setValue(\"mediaItems\", mediaItems)} \n              />\n            </div>\n            \n            <div className=\"flex justify-between mt-8 pt-4 border-t\">\n              <Button \n                type=\"button\" \n                variant=\"outline\" \n                onClick={handleBackButtonClick}\n                className=\"bg-white hover:bg-gray-50\"\n              >\n                <ArrowLeft className=\"h-4 w-4 mr-2\" /> Cancelar\n              </Button>\n              \n              <Button \n                type=\"submit\"\n                disabled={isSubmitting}\n                onClick={form.handleSubmit(onSubmit)}\n                className=\"bg-primary hover:bg-primary/90 text-white px-8\"\n              >\n                {isSubmitting ? (\n                  <div className=\"flex items-center gap-2\">\n                    <div className=\"h-4 w-4 border-2 border-white border-t-transparent rounded-full animate-spin\"></div>\n                    <span>{isEditMode && eventToEdit ? \"Guardando...\" : \"Creando...\"}</span>\n                  </div>\n                ) : (\n                  <span>{isEditMode && eventToEdit ? \"Guardar Cambios\" : \"Crear Evento\"}</span>\n                )}\n              </Button>\n            </div>\n          </div>\n        </div>\n      );\n    }\n  };\n  \n  // Ocultar completamente el componente cuando no es visible\n  if (!visible) return null;\n  \n  return (\n    <div className=\"w-full\">\n      <Form {...form}>\n        <form className=\"px-4 space-y-6\">\n          {renderStepContent()}\n        </form>\n      </Form>\n    </div>\n  );\n};\n\nexport default CreateEventFormGoogle;","size_bytes":58478},"client/src/components/events/create-event-form-new.tsx":{"content":"import React, { useState, useEffect, useRef, useCallback } from \"react\";\nimport { useForm } from \"react-hook-form\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport { z } from \"zod\";\nimport { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from \"@/components/ui/form\";\nimport { Input } from \"@/components/ui/input\";\nimport { Button } from \"@/components/ui/button\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { apiRequest } from \"@/lib/queryClient\";\nimport { ArrowLeft, MapIcon, Compass, Search } from \"lucide-react\";\nimport { useAuth } from \"@/hooks/use-auth\";\nimport { useLocation } from \"wouter\";\nimport { GoogleMap, Marker, useLoadScript, Libraries } from '@react-google-maps/api';\nimport { GOOGLE_MAPS_API_KEY, reverseGeocode, defaultMapConfig } from \"@/lib/google-maps\";\n\n// Definición centralizada de categorías para reutilización\nconst EVENT_CATEGORIES = [\n  { value: 'social', label: 'Social' },\n  { value: 'music', label: 'Música' },\n  { value: 'spiritual', label: 'Espiritual' },\n  { value: 'education', label: 'Educación' },\n  { value: 'sports', label: 'Deportes' },\n  { value: 'food', label: 'Comida' },\n  { value: 'art', label: 'Arte' },\n  { value: 'technology', label: 'Tecnología' },\n  { value: 'games', label: 'Juegos' },\n  { value: 'outdoor', label: 'Aire Libre' },\n  { value: 'networking', label: 'Networking' },\n  { value: 'workshop', label: 'Talleres' },\n  { value: 'conference', label: 'Conferencias' },\n  { value: 'party', label: 'Fiestas' },\n  { value: 'fair', label: 'Ferias' },\n  { value: 'exhibition', label: 'Exposiciones' }\n];\n\n// Opciones de preferencia de género disponibles\nconst GENDER_PREFERENCE_OPTIONS = [\n  { value: 'all_people', label: 'Todas las Personas' },\n  { value: 'men', label: 'Hombres' },\n  { value: 'women', label: 'Mujeres' }\n];\n\n// Form schema para validación de eventos\nconst createEventSchema = z.object({\n  title: z.string().min(3, \"El título debe tener al menos 3 caracteres\"),\n  description: z.string().min(10, \"La descripción debe tener al menos 10 caracteres\"),\n  category: z.string().min(1, \"Por favor, selecciona una categoría\"),\n  date: z.string().min(1, \"Por favor, selecciona una fecha\"),\n  time: z.string().min(1, \"Por favor, selecciona una hora\"),\n  latitude: z.number().or(z.string().transform(val => parseFloat(val))),\n  longitude: z.number().or(z.string().transform(val => parseFloat(val))),\n  locationName: z.string().min(3, \"El nombre del lugar debe tener al menos 3 caracteres\"),\n  locationAddress: z.string().min(5, \"La dirección debe tener al menos 5 caracteres\"),\n  paymentType: z.string().min(1, \"Por favor, selecciona un tipo de pago\"),\n  price: z.string().optional(),\n  maxCapacity: z.string().optional(),\n  privacyType: z.string().min(1, \"Por favor, selecciona un tipo de privacidad\"),\n  genderPreference: z.string().min(1, \"Por favor, selecciona para quién es el evento\"),\n});\n\n// Tipos para props y datos\ntype LocationData = {\n  latitude: number;\n  longitude: number;\n  locationName: string;\n  locationAddress: string;\n};\n\ntype CreateEventFormProps = {\n  onClose: () => void;\n  visible: boolean;\n  initialLocation?: LocationData | null;\n};\n\ntype FormValues = z.infer<typeof createEventSchema>;\n\n// Librerias de Google Maps\nconst libraries: Libraries = [\"places\"];\n\n/**\n * Componente CreateEventForm - Formulario para crear nuevos eventos\n */\nconst CreateEventFormNew = ({ onClose, visible, initialLocation }: CreateEventFormProps) => {\n  // Estados principales\n  const [step, setStep] = useState<1 | 2>(initialLocation ? 2 : 1);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [center, setCenter] = useState({\n    lat: initialLocation?.latitude || 19.4326, // Ciudad de México por defecto\n    lng: initialLocation?.longitude || -99.1332\n  });\n  const [markerPosition, setMarkerPosition] = useState({\n    lat: initialLocation?.latitude || 19.4326,\n    lng: initialLocation?.longitude || -99.1332\n  });\n  \n  // Cargar Google Maps\n  const { isLoaded, loadError } = useLoadScript({\n    googleMapsApiKey: GOOGLE_MAPS_API_KEY,\n    libraries,\n  });\n  \n  // Hooks y referencias\n  const { toast } = useToast();\n  const { user, isLoading } = useAuth();\n  const [_, navigate] = useLocation();\n  const mapRef = useRef<google.maps.Map | null>(null);\n  \n  // Inicializar formulario con valores iniciales\n  const form = useForm<FormValues>({\n    resolver: zodResolver(createEventSchema),\n    defaultValues: {\n      title: \"\",\n      description: \"\",\n      category: \"\",\n      date: \"\",\n      time: \"\",\n      latitude: initialLocation ? initialLocation.latitude : 0,\n      longitude: initialLocation ? initialLocation.longitude : 0,\n      locationName: initialLocation?.locationName || \"\",\n      locationAddress: initialLocation?.locationAddress || \"\",\n      paymentType: \"free\",\n      price: \"\",\n      maxCapacity: \"\",\n      privacyType: \"public\",\n      genderPreference: \"todas_las_personas\",\n    },\n  });\n\n  // Verificar autenticación\n  useEffect(() => {\n    if (!isLoading && !user) {\n      toast({\n        title: \"Autenticación Requerida\",\n        description: \"Por favor, inicia sesión para crear eventos\",\n        variant: \"destructive\",\n      });\n      navigate(\"/login\");\n    }\n  }, [user, isLoading, toast, navigate]);\n\n  // Callback para guardar la referencia del mapa\n  const onMapLoad = useCallback((map: google.maps.Map) => {\n    mapRef.current = map;\n  }, []);\n\n  // Manejar click en el mapa\n  const handleMapClick = useCallback((event: google.maps.MapMouseEvent) => {\n    if (event.latLng) {\n      const lat = event.latLng.lat();\n      const lng = event.latLng.lng();\n      \n      setMarkerPosition({ lat, lng });\n      \n      // Guardar con máxima precisión como números\n      form.setValue(\"latitude\", lat);\n      form.setValue(\"longitude\", lng);\n      \n      // Obtener dirección\n      reverseGeocode(lng, lat).then(address => {\n        const locationName = address.split(',')[0] || \"Lugar del evento\";\n        form.setValue(\"locationAddress\", address);\n        form.setValue(\"locationName\", locationName);\n        \n        toast({\n          title: \"Ubicación seleccionada\",\n          description: \"Ubicación guardada correctamente\",\n        });\n      }).catch(error => {\n        console.error(\"Error obteniendo dirección:\", error);\n        form.setValue(\"locationAddress\", \"Dirección no disponible\");\n        form.setValue(\"locationName\", \"Lugar del evento\");\n      });\n    }\n  }, [form, toast]);\n\n  // Validar ubicación antes de continuar al paso 2\n  const validateAndContinue = async () => {\n    // Log para depuración\n    console.log(\"Validando ubicación:\", {\n      latitude: form.getValues(\"latitude\"),\n      longitude: form.getValues(\"longitude\"),\n      tipo_lat: typeof form.getValues(\"latitude\"),\n      tipo_lng: typeof form.getValues(\"longitude\")\n    });\n    \n    if (!form.getValues(\"latitude\") || !form.getValues(\"longitude\")) {\n      toast({\n        title: \"Selecciona una ubicación\",\n        description: \"Haz clic en el mapa para seleccionar dónde se realizará el evento\",\n        variant: \"destructive\"\n      });\n      return;\n    }\n    \n    // Si falta nombre o dirección, intentar obtenerlos\n    if (!form.getValues(\"locationName\") || !form.getValues(\"locationAddress\")) {\n      try {\n        // Siempre convertimos explícitamente a string y luego a número para evitar problemas de tipo\n        const lngValue = form.getValues(\"longitude\");\n        const latValue = form.getValues(\"latitude\");\n        const lng = typeof lngValue === 'string' ? parseFloat(lngValue) : lngValue;\n        const lat = typeof latValue === 'string' ? parseFloat(latValue) : latValue;\n        \n        const address = await reverseGeocode(lng, lat);\n        \n        const locationName = address.split(',')[0] || \"Lugar del evento\";\n        form.setValue(\"locationAddress\", address);\n        form.setValue(\"locationName\", locationName);\n      } catch (error) {\n        // Si falla, usar valores por defecto\n        form.setValue(\"locationAddress\", \"Dirección no disponible\");\n        form.setValue(\"locationName\", \"Lugar del evento\");\n      }\n    }\n    \n    // Avanzar al siguiente paso\n    setStep(2);\n  };\n\n  // Enviar formulario al servidor\n  const onSubmit = async (data: FormValues) => {\n    if (isSubmitting) return;\n    setIsSubmitting(true);\n    \n    try {\n      // Preparar datos para la API\n      const dateTime = new Date(`${data.date}T${data.time}`);\n      \n      // Log valores originales antes de procesamiento\n      console.log(\"Valores originales del formulario:\", {\n        latitude: data.latitude,\n        longitude: data.longitude,\n        tipo_lat: typeof data.latitude,\n        tipo_lng: typeof data.longitude\n      });\n      \n      const eventData = {\n        title: data.title,\n        description: data.description,\n        category: data.category,\n        date: dateTime.toISOString(),\n        latitude: typeof data.latitude === 'number' ? data.latitude : parseFloat(String(data.latitude)),\n        longitude: typeof data.longitude === 'number' ? data.longitude : parseFloat(String(data.longitude)), \n        locationName: data.locationName,\n        locationAddress: data.locationAddress,\n        paymentType: \"free\", // Siempre eventos gratuitos\n        price: 0, // Sin precio\n        maxCapacity: data.maxCapacity ? parseInt(String(data.maxCapacity)) : null,\n        privacyType: data.privacyType,\n        genderPreference: data.genderPreference,\n      };\n      \n      // Log de datos procesados\n      console.log(\"Datos enviados al servidor:\", eventData);\n      \n      // Enviar al servidor\n      const response = await apiRequest(\"POST\", \"/api/events\", eventData);\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.message || \"Error al crear el evento\");\n      }\n      \n      const createdEvent = await response.json();\n      console.log(\"Evento creado:\", createdEvent);\n      \n      toast({\n        title: \"¡Éxito!\",\n        description: \"Tu evento ha sido creado correctamente\",\n      });\n      \n      // Cerrar formulario y actualizar vista\n      onClose();\n      setTimeout(() => window.location.reload(), 800);\n    } catch (error: any) {\n      console.error(\"Error creando evento:\", error);\n      toast({\n        title: \"Error al crear evento\",\n        description: error.message || \"No se pudo crear el evento. Por favor, inténtalo de nuevo.\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  // No renderizar nada si no es visible\n  if (!visible) return null;\n\n  // Renderizado condicional si Google Maps no ha cargado\n  if (!isLoaded) {\n    return (\n      <div className=\"absolute inset-0 bg-white z-30 flex items-center justify-center\">\n        <div className=\"flex flex-col items-center\">\n          <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-primary mb-4\"></div>\n          <p>Cargando mapa...</p>\n        </div>\n      </div>\n    );\n  }\n\n  // Error al cargar Google Maps\n  if (loadError) {\n    return (\n      <div className=\"absolute inset-0 bg-white z-30 flex items-center justify-center p-4\">\n        <div className=\"bg-red-100 text-red-700 p-4 rounded-lg max-w-md\">\n          <h3 className=\"font-bold mb-2\">Error al cargar el mapa</h3>\n          <p>No se pudo cargar Google Maps. Por favor intenta recargar la página.</p>\n          <button \n            className=\"mt-4 px-4 py-2 bg-primary text-white rounded-lg\"\n            onClick={onClose}\n          >\n            Cerrar\n          </button>\n        </div>\n      </div>\n    );\n  }\n\n  // COMPONENTE DE RENDERIZADO\n  return (\n    <div className=\"absolute inset-0 bg-white z-30\">\n      <div className=\"flex flex-col h-full\">\n        {/* Cabecera */}\n        <div className=\"px-4 py-3 border-b border-neutral-200 flex items-center justify-between\">\n          <button className=\"p-2\" onClick={onClose}>\n            <ArrowLeft size={24} />\n          </button>\n          <h2 className=\"font-semibold text-lg\">Crear Evento</h2>\n          <div className=\"w-10\"></div>\n        </div>\n        \n        {/* Formulario */}\n        <Form {...form}>\n          <form onSubmit={form.handleSubmit(onSubmit)} className=\"flex-1 overflow-auto\">\n            {/* PASO 1: Selección de ubicación */}\n            {step === 1 && (\n              <div className=\"flex-1 overflow-auto\">\n                <div className=\"p-4\">\n                  <h3 className=\"font-medium mb-2\">Selecciona la Ubicación del Evento</h3>\n                  <p className=\"text-neutral-500 mb-4\">Toca el mapa para seleccionar dónde se realizará tu evento.</p>\n                </div>\n                \n                {/* Mapa para selección de ubicación */}\n                <div className=\"h-96 bg-neutral-100 relative overflow-hidden\">\n                  <GoogleMap\n                    mapContainerStyle={{ height: '100%', width: '100%' }}\n                    center={center}\n                    zoom={11}\n                    onClick={handleMapClick}\n                    onLoad={onMapLoad}\n                    options={{\n                      disableDefaultUI: false,\n                      zoomControl: true,\n                      mapTypeControl: false,\n                      streetViewControl: false,\n                      fullscreenControl: true,\n                    }}\n                  >\n                    {/* Marcador en la ubicación seleccionada */}\n                    {markerPosition.lat && markerPosition.lng && (\n                      <Marker \n                        position={markerPosition}\n                        draggable={true}\n                        onDragEnd={(e) => {\n                          if (e.latLng) {\n                            handleMapClick(e as google.maps.MapMouseEvent);\n                          }\n                        }}\n                      />\n                    )}\n                  </GoogleMap>\n                </div>\n                \n                <div className=\"p-4\">\n                  <Button \n                    type=\"button\"\n                    className=\"w-full py-3 bg-primary text-white font-semibold rounded-xl mt-4\"\n                    onClick={validateAndContinue}\n                  >\n                    Continuar\n                  </Button>\n                </div>\n              </div>\n            )}\n            \n            {/* PASO 2: Formulario de detalles del evento */}\n            {step === 2 && (\n              <div className=\"flex-1 overflow-auto\">\n                {/* Mapa pequeño con ubicación seleccionada */}\n                <div className=\"h-60 bg-neutral-100 relative overflow-hidden\">\n                  <GoogleMap\n                    mapContainerStyle={{ height: '100%', width: '100%' }}\n                    center={{\n                      lat: parseFloat(String(form.getValues(\"latitude\"))),\n                      lng: parseFloat(String(form.getValues(\"longitude\")))\n                    }}\n                    zoom={14}\n                    options={{\n                      disableDefaultUI: true,\n                      zoomControl: true,\n                    }}\n                  >\n                    <Marker \n                      position={{\n                        lat: parseFloat(String(form.getValues(\"latitude\"))),\n                        lng: parseFloat(String(form.getValues(\"longitude\")))\n                      }}\n                    />\n                  </GoogleMap>\n                </div>\n                \n                <div className=\"p-4\">\n                  {/* Información de ubicación */}\n                  <div className=\"mb-4 border border-neutral-200 p-3 rounded-xl bg-neutral-50\">\n                    <div className=\"flex items-center gap-2\">\n                      <MapIcon className=\"h-5 w-5 text-primary\" />\n                      <FormLabel className=\"font-medium\">Ubicación</FormLabel>\n                    </div>\n                    <div className=\"mt-2\">\n                      <p className=\"text-sm font-medium\">{form.getValues(\"locationName\") || \"Ubicación seleccionada\"}</p>\n                      <p className=\"text-sm text-gray-600\">{form.getValues(\"locationAddress\") || \"Dirección detectada del mapa\"}</p>\n                    </div>\n                    \n                    {/* Campos ocultos para datos de ubicación */}\n                    <input type=\"hidden\" {...form.register(\"locationAddress\")} />\n                    <input type=\"hidden\" {...form.register(\"locationName\")} />\n                    <input type=\"hidden\" {...form.register(\"latitude\")} />\n                    <input type=\"hidden\" {...form.register(\"longitude\")} />\n                  </div>\n                \n                  {/* Título del evento */}\n                  <FormField\n                    control={form.control}\n                    name=\"title\"\n                    render={({ field }) => (\n                      <FormItem className=\"mb-4\">\n                        <FormLabel>Nombre del Evento</FormLabel>\n                        <FormControl>\n                          <Input\n                            {...field}\n                            placeholder=\"Dale un nombre a tu evento\"\n                            className=\"w-full p-3 border border-neutral-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-primary\"\n                          />\n                        </FormControl>\n                        <FormMessage />\n                      </FormItem>\n                    )}\n                  />\n                  \n                  {/* Categoría del evento */}\n                  <FormField\n                    control={form.control}\n                    name=\"category\"\n                    render={({ field }) => (\n                      <FormItem className=\"mb-4\">\n                        <FormLabel>Categoría</FormLabel>\n                        <Select \n                          onValueChange={field.onChange} \n                          defaultValue={field.value}\n                        >\n                          <FormControl>\n                            <SelectTrigger className=\"w-full p-3 border border-neutral-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-primary\">\n                              <SelectValue placeholder=\"Selecciona una categoría\" />\n                            </SelectTrigger>\n                          </FormControl>\n                          <SelectContent>\n                            {EVENT_CATEGORIES.map(category => (\n                              <SelectItem key={category.value} value={category.value}>\n                                {category.label}\n                              </SelectItem>\n                            ))}\n                          </SelectContent>\n                        </Select>\n                        <FormMessage />\n                      </FormItem>\n                    )}\n                  />\n                  \n                  {/* Fecha y hora */}\n                  <div className=\"mb-4\">\n                    <FormLabel>Fecha y Hora</FormLabel>\n                    <div className=\"flex gap-2\">\n                      <FormField\n                        control={form.control}\n                        name=\"date\"\n                        render={({ field }) => (\n                          <FormItem className=\"flex-1\">\n                            <FormControl>\n                              <Input\n                                {...field}\n                                type=\"date\"\n                                className=\"w-full p-3 border border-neutral-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-primary\"\n                              />\n                            </FormControl>\n                            <FormMessage />\n                          </FormItem>\n                        )}\n                      />\n                      \n                      <FormField\n                        control={form.control}\n                        name=\"time\"\n                        render={({ field }) => (\n                          <FormItem className=\"flex-1\">\n                            <FormControl>\n                              <Input\n                                {...field}\n                                type=\"time\"\n                                className=\"w-full p-3 border border-neutral-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-primary\"\n                              />\n                            </FormControl>\n                            <FormMessage />\n                          </FormItem>\n                        )}\n                      />\n                    </div>\n                  </div>\n                  \n                  {/* Descripción */}\n                  <FormField\n                    control={form.control}\n                    name=\"description\"\n                    render={({ field }) => (\n                      <FormItem className=\"mb-4\">\n                        <FormLabel>Descripción</FormLabel>\n                        <FormControl>\n                          <Textarea\n                            {...field}\n                            placeholder=\"Cuéntale a la gente sobre tu evento...\"\n                            className=\"w-full p-3 border border-neutral-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-primary h-28\"\n                          />\n                        </FormControl>\n                        <FormMessage />\n                      </FormItem>\n                    )}\n                  />\n                  \n                  {/* Tipo de pago - Siempre establecido a \"free\" */}\n                  <input type=\"hidden\" {...form.register(\"paymentType\")} value=\"free\" />\n                  \n                  {/* Capacidad máxima */}\n                  <FormField\n                    control={form.control}\n                    name=\"maxCapacity\"\n                    render={({ field }) => (\n                      <FormItem className=\"mb-4\">\n                        <FormLabel>Capacidad Máxima (Opcional)</FormLabel>\n                        <FormControl>\n                          <Input\n                            {...field}\n                            type=\"number\"\n                            min=\"1\"\n                            placeholder=\"Sin límite\"\n                            className=\"w-full p-3 border border-neutral-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-primary\"\n                          />\n                        </FormControl>\n                        <FormMessage />\n                      </FormItem>\n                    )}\n                  />\n                  \n                  {/* Tipo de privacidad */}\n                  <FormField\n                    control={form.control}\n                    name=\"privacyType\"\n                    render={({ field }) => (\n                      <FormItem className=\"mb-4\">\n                        <FormLabel>🔒 Privacidad del evento</FormLabel>\n                        <div className=\"text-sm text-gray-600 mb-2\">Tipo de evento</div>\n                        <Select \n                          onValueChange={field.onChange} \n                          defaultValue={field.value}\n                        >\n                          <FormControl>\n                            <SelectTrigger className=\"w-full p-3 border border-neutral-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-primary\">\n                              <SelectValue placeholder=\"Selecciona el tipo de evento\" />\n                            </SelectTrigger>\n                          </FormControl>\n                          <SelectContent>\n                            <SelectItem value=\"public\">🌍 Público (visible para todos)</SelectItem>\n                            <SelectItem value=\"private\">🔒 Privado (solo invitados)</SelectItem>\n                          </SelectContent>\n                        </Select>\n                        <FormMessage />\n                      </FormItem>\n                    )}\n                  />\n                  \n                  {/* Preferencia de género */}\n                  <FormField\n                    control={form.control}\n                    name=\"genderPreference\"\n                    render={({ field }) => (\n                      <FormItem className=\"mb-4\">\n                        <FormLabel>👥 Destinado Para</FormLabel>\n                        <div className=\"text-sm text-gray-600 mb-2\">Público destinatario del evento</div>\n                        <Select \n                          onValueChange={field.onChange} \n                          defaultValue={field.value}\n                        >\n                          <FormControl>\n                            <SelectTrigger className=\"w-full p-3 border border-neutral-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-primary\">\n                              <SelectValue placeholder=\"Selecciona para quién es el evento\" />\n                            </SelectTrigger>\n                          </FormControl>\n                          <SelectContent>\n                            {GENDER_PREFERENCE_OPTIONS.map(option => (\n                              <SelectItem key={option.value} value={option.value}>\n                                {option.label}\n                              </SelectItem>\n                            ))}\n                          </SelectContent>\n                        </Select>\n                        <FormMessage />\n                      </FormItem>\n                    )}\n                  />\n                  \n                  {/* Botones de acción */}\n                  <div className=\"flex gap-2 mb-20\">\n                    <Button\n                      type=\"button\"\n                      variant=\"outline\"\n                      className=\"flex-1 py-3\"\n                      onClick={() => setStep(1)}\n                    >\n                      Atrás\n                    </Button>\n                    <Button \n                      type=\"submit\" \n                      className=\"flex-1 py-3 bg-primary text-white\"\n                      disabled={isSubmitting}\n                    >\n                      {isSubmitting ? 'Creando...' : 'Crear Evento'}\n                    </Button>\n                  </div>\n                </div>\n              </div>\n            )}\n          </form>\n        </Form>\n      </div>\n    </div>\n  );\n};\n\nexport default CreateEventFormNew;","size_bytes":26513},"client/src/components/events/create-event-form.tsx":{"content":"import React, { useState, useEffect, useRef, useCallback } from \"react\";\nimport { useForm } from \"react-hook-form\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport { z } from \"zod\";\nimport { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from \"@/components/ui/form\";\nimport { Input } from \"@/components/ui/input\";\nimport { Button } from \"@/components/ui/button\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { apiRequest } from \"@/lib/queryClient\";\nimport { ArrowLeft, MapIcon, Compass, Search } from \"lucide-react\";\nimport { useAuth } from \"@/hooks/use-auth\";\nimport { useLocation } from \"wouter\";\nimport { GoogleMap, Marker, useLoadScript } from '@react-google-maps/api';\nimport { GOOGLE_MAPS_API_KEY, libraries, reverseGeocode, defaultMapConfig } from \"@/lib/google-maps\";\nimport MediaManager, { MediaItem } from \"./media-manager\";\nimport mapboxgl from 'mapbox-gl';\nimport { searchLocations } from \"@/lib/mapbox\";\n\n// Definición centralizada de categorías para reutilización\nconst EVENT_CATEGORIES = [\n  { value: 'social', label: 'Social' },\n  { value: 'music', label: 'Música' },\n  { value: 'spiritual', label: 'Espiritual' },\n  { value: 'education', label: 'Educación' },\n  { value: 'sports', label: 'Deportes' },\n  { value: 'food', label: 'Comida' },\n  { value: 'art', label: 'Arte' },\n  { value: 'technology', label: 'Tecnología' },\n  { value: 'games', label: 'Juegos' },\n  { value: 'outdoor', label: 'Aire Libre' },\n  { value: 'networking', label: 'Networking' },\n  { value: 'workshop', label: 'Talleres' },\n  { value: 'conference', label: 'Conferencias' },\n  { value: 'party', label: 'Fiestas' },\n  { value: 'fair', label: 'Ferias' },\n  { value: 'exhibition', label: 'Exposiciones' }\n];\n\n// Opciones de preferencia de género disponibles\nconst GENDER_PREFERENCE_OPTIONS = [\n  { value: 'all_people', label: 'Todas las Personas' },\n  { value: 'men', label: 'Hombres' },\n  { value: 'women', label: 'Mujeres' }\n];\n\n// Form schema para validación de eventos\nconst createEventSchema = z.object({\n  title: z.string().min(3, \"El título debe tener al menos 3 caracteres\"),\n  description: z.string().min(10, \"La descripción debe tener al menos 10 caracteres\"),\n  category: z.string().min(1, \"Por favor, selecciona una categoría\"),\n  date: z.string().min(1, \"Por favor, selecciona una fecha\"),\n  time: z.string().min(1, \"Por favor, selecciona una hora\"),\n  latitude: z.string().or(z.number()),\n  longitude: z.string().or(z.number()),\n  locationName: z.string().min(3, \"El nombre del lugar debe tener al menos 3 caracteres\"),\n  locationAddress: z.string().min(5, \"La dirección debe tener al menos 5 caracteres\"),\n  paymentType: z.string().min(1, \"Por favor, selecciona un tipo de pago\"),\n  price: z.string().optional(),\n  maxCapacity: z.string().optional(),\n  privacyType: z.string().min(1, \"Por favor, selecciona un tipo de privacidad\"),\n  genderPreference: z.string().min(1, \"Por favor, selecciona para quién es el evento\"),\n  // Nuevo campo para gestión multimedia unificada\n  mediaItems: z.array(z.any()).optional().nullable(),\n  // Mantener por compatibilidad con código existente (deprecated)\n  eventPhoto: z.instanceof(File).optional().nullable(),\n  eventVideo: z.instanceof(File).optional().nullable(),\n});\n\n// Tipos para props y datos\ntype LocationData = {\n  latitude: number;\n  longitude: number;\n  locationName: string;\n  locationAddress: string;\n};\n\ntype CreateEventFormProps = {\n  onClose: () => void;\n  visible: boolean;\n  initialLocation?: LocationData | null;\n};\n\ntype FormValues = z.infer<typeof createEventSchema> & {\n  mediaItems: MediaItem[];\n};\n\n/**\n * Componente CreateEventForm - Formulario para crear nuevos eventos\n */\nconst CreateEventForm = ({ onClose, visible, initialLocation }: CreateEventFormProps) => {\n  // Estados principales\n  const [step, setStep] = useState<1 | 2>(1);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [mapLocation, setMapLocation] = useState<[number, number]>(\n    initialLocation ? [initialLocation.longitude, initialLocation.latitude] : [-122.4194, 37.7749]\n  );\n  \n  // Hooks y referencias\n  const { toast } = useToast();\n  const { user, isLoading } = useAuth();\n  const [_, navigate] = useLocation();\n  const mapContainerRef = useRef<HTMLDivElement>(null);\n  const mapRef = useRef<mapboxgl.Map | null>(null);\n  const markerRef = useRef<mapboxgl.Marker | null>(null);\n\n  // Inicializar formulario con valores iniciales\n  const form = useForm<FormValues>({\n    resolver: zodResolver(createEventSchema),\n    defaultValues: {\n      title: \"\",\n      description: \"\",\n      category: \"\",\n      date: \"\",\n      time: \"\",\n      latitude: initialLocation ? String(initialLocation.latitude) : \"\",\n      longitude: initialLocation ? String(initialLocation.longitude) : \"\",\n      locationName: initialLocation?.locationName || \"\",\n      locationAddress: initialLocation?.locationAddress || \"\",\n      paymentType: \"free\",\n      price: \"\",\n      maxCapacity: \"\",\n      privacyType: \"public\",\n      genderPreference: \"todas_las_personas\",\n      mediaItems: [],\n      eventPhoto: null,\n      eventVideo: null,\n    },\n  });\n\n  // Determinar el paso inicial basado en la ubicación proporcionada\n  useEffect(() => {\n    setStep(initialLocation ? 2 : 1);\n  }, [initialLocation]);\n\n  // Verificar autenticación\n  useEffect(() => {\n    if (!isLoading && !user) {\n      toast({\n        title: \"Autenticación Requerida\",\n        description: \"Por favor, inicia sesión para crear eventos\",\n        variant: \"destructive\",\n      });\n      navigate(\"/login\");\n    }\n  }, [user, isLoading, toast, navigate]);\n\n  // Inicializar y gestionar el mapa\n  useEffect(() => {\n    // Solo inicializar si es visible y el contenedor está disponible\n    if (!visible || !mapContainerRef.current) return;\n    \n    // Inicializar mapa\n    mapRef.current = new mapboxgl.Map({\n      container: mapContainerRef.current,\n      style: 'mapbox://styles/mapbox/streets-v11',\n      center: mapLocation,\n      zoom: 13\n    });\n    \n    // Añadir controles de navegación\n    mapRef.current.addControl(new mapboxgl.NavigationControl(), 'top-right');\n    mapRef.current.addControl(\n      new mapboxgl.GeolocateControl({\n        positionOptions: { enableHighAccuracy: true },\n        trackUserLocation: true,\n        showUserHeading: true\n      }), \n      'top-right'\n    );\n    \n    // Añadir marcador inicial\n    markerRef.current = new mapboxgl.Marker({ \n      draggable: true,\n      color: \"#FF5A5F\"\n    })\n      .setLngLat(mapLocation)\n      .addTo(mapRef.current);\n    \n    // Función para actualizar ubicación cuando se arrastra el marcador\n    const updateLocationFromMarker = async (lng: number, lat: number) => {\n      setMapLocation([lng, lat]);\n      // Guardar como números, no como strings\n      form.setValue(\"latitude\", lat);\n      form.setValue(\"longitude\", lng);\n      \n      try {\n        // Convertimos explícitamente a string los valores para evitar errores de tipo\n        const address = await reverseGeocode(lng, lat);\n        form.setValue(\"locationAddress\", address);\n        \n        // Extraer nombre del lugar de la dirección\n        const locationName = address.split(',')[0] || \"Lugar del evento\";\n        if (!form.getValues(\"locationName\")) {\n          form.setValue(\"locationName\", locationName);\n        }\n      } catch (error) {\n        console.error(\"Error getting address:\", error);\n        // Si falla, mantener al menos las coordenadas\n      }\n    };\n    \n    // Configurar eventos del marcador y mapa\n    if (markerRef.current) {\n      markerRef.current.on('dragend', () => {\n        if (markerRef.current) {\n          const lngLat = markerRef.current.getLngLat();\n          updateLocationFromMarker(lngLat.lng, lngLat.lat);\n        }\n      });\n    }\n    \n    // Click en el mapa para colocar el marcador\n    mapRef.current.on('click', (e) => {\n      if (markerRef.current && mapRef.current) {\n        mapRef.current.panTo(e.lngLat, { duration: 500 });\n        markerRef.current.setLngLat(e.lngLat);\n        \n        updateLocationFromMarker(e.lngLat.lng, e.lngLat.lat);\n        \n        toast({\n          title: \"Ubicación seleccionada\",\n          description: \"Obteniendo detalles de la dirección...\",\n        });\n      }\n    });\n    \n    // Limpiar al desmontar\n    return () => {\n      if (mapRef.current) {\n        mapRef.current.remove();\n        mapRef.current = null;\n      }\n      markerRef.current = null;\n    };\n  }, [visible, mapLocation, form, toast]);\n\n  // Buscar dirección y actualizar mapa\n  const searchAddress = async (address: string) => {\n    if (!mapRef.current || !markerRef.current) return;\n    \n    try {\n      const results = await searchLocations(address, ['address', 'poi', 'poi.landmark', 'place']);\n      \n      if (results.length > 0) {\n        const { center, place_name, properties, text } = results[0];\n        \n        // Actualizar estado y formulario - guardando como números\n        setMapLocation([center[0], center[1]]);\n        form.setValue(\"latitude\", center[1]);\n        form.setValue(\"longitude\", center[0]);\n        form.setValue(\"locationAddress\", place_name);\n        \n        // Nombre de ubicación si es un punto de interés\n        if (properties?.category && !form.getValues(\"locationName\")) {\n          form.setValue(\"locationName\", text || place_name.split(',')[0]);\n        }\n        \n        // Actualizar mapa\n        mapRef.current.flyTo({ \n          center, \n          zoom: 15,\n          essential: true,\n          duration: 1000 \n        });\n        markerRef.current.setLngLat(center);\n        \n        toast({\n          title: \"Ubicación Encontrada\",\n          description: \"Mapa actualizado a la ubicación buscada\",\n        });\n      } else {\n        toast({\n          title: \"Ubicación No Encontrada\",\n          description: \"No se pudo encontrar la dirección especificada\",\n          variant: \"destructive\",\n        });\n      }\n    } catch (error) {\n      console.error(\"Error buscando dirección:\", error);\n      toast({\n        title: \"Error de Búsqueda\",\n        description: \"No se pudo buscar la dirección\",\n        variant: \"destructive\",\n      });\n    }\n  };\n\n  // Validar ubicación antes de continuar al paso 2\n  const validateAndContinue = async () => {\n    // Log para depuración\n    console.log(\"Validando ubicación:\", {\n      latitude: form.getValues(\"latitude\"),\n      longitude: form.getValues(\"longitude\"),\n      tipo_lat: typeof form.getValues(\"latitude\"),\n      tipo_lng: typeof form.getValues(\"longitude\")\n    });\n    \n    if (!form.getValues(\"latitude\") || !form.getValues(\"longitude\")) {\n      toast({\n        title: \"Selecciona una ubicación\",\n        description: \"Haz clic en el mapa para seleccionar dónde se realizará el evento\",\n        variant: \"destructive\"\n      });\n      return;\n    }\n    \n    // Si falta nombre o dirección, intentar obtenerlos\n    if (!form.getValues(\"locationName\") || !form.getValues(\"locationAddress\")) {\n      try {\n        // Siempre convertimos explícitamente a string y luego a número para evitar problemas de tipo\n        const lngValue = form.getValues(\"longitude\");\n        const latValue = form.getValues(\"latitude\");\n        const lng = typeof lngValue === 'string' ? parseFloat(lngValue) : lngValue;\n        const lat = typeof latValue === 'string' ? parseFloat(latValue) : latValue;\n        \n        const address = await reverseGeocode(lng, lat);\n        \n        const locationName = address.split(',')[0] || \"Lugar del evento\";\n        form.setValue(\"locationAddress\", address);\n        form.setValue(\"locationName\", locationName);\n      } catch (error) {\n        // Si falla, usar valores por defecto\n        form.setValue(\"locationAddress\", \"Dirección no disponible\");\n        form.setValue(\"locationName\", \"Lugar del evento\");\n      }\n    }\n    \n    // Avanzar al siguiente paso\n    setStep(2);\n  };\n\n  // Enviar formulario al servidor\n  const onSubmit = async (data: FormValues) => {\n    if (isSubmitting) return;\n    setIsSubmitting(true);\n    \n    try {\n      // Validar que mediaItems sea un array\n      if (!Array.isArray(data.mediaItems)) {\n        console.error(\"Error: mediaItems no es un array válido\", data.mediaItems);\n        data.mediaItems = [];\n      }\n      \n      // Filtrar items inválidos o nulos\n      const safeMediaItems = (data.mediaItems || []).filter(item => item && typeof item === 'object');\n      \n      // Log para depuración\n      console.log(\"Procesando envío - Items multimedia:\", safeMediaItems.length);\n      \n      // Preparar datos para la API\n      const dateTime = new Date(`${data.date}T${data.time}`);\n      \n      // Log valores originales antes de procesamiento\n      console.log(\"Valores originales del formulario:\", {\n        latitude: data.latitude,\n        longitude: data.longitude,\n        tipo_lat: typeof data.latitude,\n        tipo_lng: typeof data.longitude,\n        eventPhoto: data.eventPhoto,\n        eventVideo: data.eventVideo,\n        mediaItemsCount: safeMediaItems.length\n      });\n      \n      // Crear FormData para enviar archivos\n      const formData = new FormData();\n      \n      // Añadir datos básicos del evento\n      formData.append('title', data.title);\n      formData.append('description', data.description);\n      formData.append('category', data.category);\n      formData.append('date', dateTime.toISOString());\n      formData.append('latitude', String(parseFloat(String(data.latitude))));\n      formData.append('longitude', String(parseFloat(String(data.longitude))));\n      formData.append('locationName', data.locationName);\n      formData.append('locationAddress', data.locationAddress);\n      formData.append('paymentType', \"free\"); // Siempre eventos gratuitos\n      formData.append('price', \"0\"); // Sin precio\n      \n      if (data.maxCapacity) {\n        formData.append('maxCapacity', String(parseInt(String(data.maxCapacity))));\n      }\n      \n      formData.append('privacyType', data.privacyType);\n      \n      // Procesar elementos multimedia\n      try {\n        // Asegurar que mediaItems siempre es un array, incluso si está vacío\n        if (!data.mediaItems) {\n          data.mediaItems = [];\n        }\n        \n        // Asegurar que tenemos un array incluso con elementos vacíos\n        const mediaItems = Array.isArray(data.mediaItems) ? data.mediaItems : [];\n        \n        // Añadir todos los archivos nuevos\n        mediaItems.forEach((item, index) => {\n          // Verificación adicional para evitar problemas con elementos undefined\n          if (!item) return;\n          \n          // Asegurarnos de que el tipo siempre esté definido\n          if (!item.type) {\n            console.warn(`Tipo no definido para el elemento multimedia ${index}, asignando 'photo' por defecto`);\n            item.type = 'photo';\n          }\n          \n          if (item.file) {\n            const fieldName = `mediaFile_${index}`;\n            formData.append(fieldName, item.file);\n            \n            // Si es el archivo principal, también enviarlo como el archivo principal\n            if (item.isMain) {\n              formData.append('mainMediaFile', item.file);\n              formData.append('mainMediaType', item.type);\n            }\n          }\n        });\n        \n        // Convertir los metadatos a JSON y enviarlos para todos los elementos (con o sin archivos)\n        const mediaMetadata = mediaItems.map(item => ({\n          type: item.type || 'photo',\n          url: item.url || '',\n          isMain: item.isMain || false,\n          isNew: item.isNew || false,\n          toDelete: item.toDelete || false\n        }));\n        \n        // Asegurarnos de que siempre enviamos un array, aunque sea vacío\n        formData.append('mediaItems', JSON.stringify(mediaMetadata.length > 0 ? mediaMetadata : []));\n      } catch (error) {\n        console.error(\"Error procesando elementos multimedia:\", error);\n        // Enviar un array vacío en caso de error para evitar fallos\n        formData.append('mediaItems', '[]');\n      }\n      \n      // Mantener compatibilidad con código existente\n      if (data.eventPhoto) {\n        formData.append('eventPhoto', data.eventPhoto);\n      }\n      \n      if (data.eventVideo) {\n        formData.append('eventVideo', data.eventVideo);\n      }\n      \n      // Log de datos procesados\n      console.log(\"Datos enviados al servidor (FormData creado)\");\n      \n      // CAMBIO CRÍTICO: En lugar de usar FormData que está causando problemas,\n      // usaremos un objeto JSON estándar para el cuerpo de la solicitud\n      \n      // Extraer datos de mediaItems del FormData y asegurarnos de que sea un JSON válido\n      let mediaItemsJson = '[]';\n      try {\n        if (formData.get('mediaItems')) {\n          mediaItemsJson = formData.get('mediaItems') as string;\n          // Verificar que sea un JSON válido\n          JSON.parse(mediaItemsJson);\n        }\n      } catch (e) {\n        console.error(\"Error analizando mediaItems, usando array vacío:\", e);\n        mediaItemsJson = '[]';\n      }\n      \n      // Crear objeto JSON para enviar al servidor\n      const jsonData = {\n        title: data.title,\n        description: data.description,\n        category: data.category,\n        date: data.date,\n        time: data.time, \n        locationName: data.locationName,\n        locationAddress: data.locationAddress,\n        latitude: data.latitude,\n        longitude: data.longitude,\n        privacyType: data.privacyType,\n        genderPreference: data.genderPreference,\n        paymentType: \"free\",\n        mediaItems: mediaItemsJson\n      };\n      \n      console.log(\"Datos JSON que se enviarán al servidor:\", jsonData);\n      \n      // Enviar al servidor con Content-Type: application/json en lugar de FormData\n      const response = await fetch('/api/events', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(jsonData),\n        credentials: 'include' // Necesario para enviar cookies (sesión)\n      });\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        \n        // Check if this is a user authentication error\n        if (response.status === 401 || (errorData.code && errorData.code === 'USER_NOT_FOUND')) {\n          toast({\n            title: \"Necesitas registrarte primero\",\n            description: \"Debes crear una cuenta y acceder antes de poder crear eventos.\",\n            variant: \"destructive\",\n          });\n          // Redirect to auth page after a short delay\n          setTimeout(() => {\n            navigate(\"/auth\");\n          }, 2000);\n          return;\n        }\n        \n        throw new Error(errorData.message || \"Error al crear el evento\");\n      }\n      \n      const createdEvent = await response.json();\n      console.log(\"Evento creado:\", createdEvent);\n      \n      toast({\n        title: \"¡Éxito!\",\n        description: \"Tu evento ha sido creado correctamente\",\n      });\n      \n      // Resetear el formulario\n      form.reset({\n        title: \"\",\n        description: \"\",\n        category: \"\",\n        date: \"\",\n        time: \"\",\n        latitude: \"\",\n        longitude: \"\",\n        locationName: \"\",\n        locationAddress: \"\",\n        paymentType: \"free\",\n        price: \"\",\n        maxCapacity: \"\",\n        privacyType: \"public\",\n        mediaItems: [],\n        eventPhoto: null,\n        eventVideo: null\n      });\n      \n      // Cerrar formulario\n      onClose();\n      \n      // Actualizar lista de eventos sin recargar la página\n      // Usaremos react-query para invalidar la caché de eventos después de un breve retraso\n      setTimeout(() => {\n        // Importamos queryClient desde queryClient.ts\n        import(\"@/lib/queryClient\").then(({ queryClient }) => {\n          queryClient.invalidateQueries({ queryKey: [\"/api/events\"] });\n        });\n      }, 300);\n    } catch (error: any) {\n      console.error(\"Error creando evento:\", error);\n      toast({\n        title: \"Error al crear evento\",\n        description: error.message || \"No se pudo crear el evento. Por favor, inténtalo de nuevo.\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  // No renderizar nada si no es visible\n  if (!visible) return null;\n\n  // COMPONENTE DE RENDERIZADO\n  return (\n    <div className=\"absolute inset-0 bg-white z-30\">\n      <div className=\"flex flex-col h-full\">\n        {/* Cabecera */}\n        <div className=\"px-4 py-3 border-b border-neutral-200 flex items-center justify-between\">\n          <button className=\"p-2\" onClick={onClose}>\n            <ArrowLeft size={24} />\n          </button>\n          <h2 className=\"font-semibold text-lg\">Crear Evento</h2>\n          <div className=\"w-10\"></div>\n        </div>\n        \n        {/* Formulario */}\n        <Form {...form}>\n          <form onSubmit={form.handleSubmit(onSubmit)} className=\"flex-1 overflow-auto\">\n            {/* PASO 1: Selección de ubicación */}\n            {step === 1 && (\n              <div className=\"flex-1 overflow-auto\">\n                <div className=\"p-4\">\n                  <h3 className=\"font-medium mb-2\">Selecciona la Ubicación del Evento</h3>\n                  <p className=\"text-neutral-500 mb-4\">Toca el mapa para seleccionar dónde se realizará tu evento.</p>\n                </div>\n                \n                {/* Mapa para selección de ubicación */}\n                <div \n                  ref={mapContainerRef} \n                  className=\"h-96 bg-neutral-100 relative overflow-hidden\"\n                ></div>\n                \n                <div className=\"p-4\">\n                  <Button \n                    type=\"button\"\n                    className=\"w-full py-3 bg-primary text-white font-semibold rounded-xl mt-4\"\n                    onClick={validateAndContinue}\n                  >\n                    Continuar\n                  </Button>\n                </div>\n              </div>\n            )}\n            \n            {/* PASO 2: Formulario de detalles del evento */}\n            {step === 2 && (\n              <div className=\"flex-1 overflow-auto\">\n                {/* Mapa pequeño con ubicación seleccionada */}\n                <div \n                  ref={mapContainerRef} \n                  className=\"h-60 bg-neutral-100 relative overflow-hidden\"\n                ></div>\n                \n                <div className=\"p-4\">\n                  {/* Información de ubicación */}\n                  <div className=\"mb-4 border border-neutral-200 p-3 rounded-xl bg-neutral-50\">\n                    <div className=\"flex items-center gap-2\">\n                      <MapIcon className=\"h-5 w-5 text-primary\" />\n                      <FormLabel className=\"font-medium\">Ubicación</FormLabel>\n                    </div>\n                    <div className=\"mt-2\">\n                      <p className=\"text-sm font-medium\">{form.getValues(\"locationName\") || \"Ubicación seleccionada\"}</p>\n                      <p className=\"text-sm text-gray-600\">{form.getValues(\"locationAddress\") || \"Dirección detectada del mapa\"}</p>\n                    </div>\n                    \n                    {/* Campos ocultos para datos de ubicación */}\n                    <input type=\"hidden\" {...form.register(\"locationAddress\")} />\n                    <input type=\"hidden\" {...form.register(\"locationName\")} />\n                    <input type=\"hidden\" {...form.register(\"latitude\")} />\n                    <input type=\"hidden\" {...form.register(\"longitude\")} />\n                  </div>\n                \n                  {/* Título del evento */}\n                  <FormField\n                    control={form.control}\n                    name=\"title\"\n                    render={({ field }) => (\n                      <FormItem className=\"mb-4\">\n                        <FormLabel>Nombre del Evento</FormLabel>\n                        <FormControl>\n                          <Input\n                            {...field}\n                            placeholder=\"Dale un nombre a tu evento\"\n                            className=\"w-full p-3 border border-neutral-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-primary\"\n                          />\n                        </FormControl>\n                        <FormMessage />\n                      </FormItem>\n                    )}\n                  />\n                  \n                  {/* Categoría del evento */}\n                  <FormField\n                    control={form.control}\n                    name=\"category\"\n                    render={({ field }) => (\n                      <FormItem className=\"mb-4\">\n                        <FormLabel>Categoría</FormLabel>\n                        <Select \n                          onValueChange={field.onChange} \n                          defaultValue={field.value}\n                        >\n                          <FormControl>\n                            <SelectTrigger className=\"w-full p-3 border border-neutral-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-primary\">\n                              <SelectValue placeholder=\"Selecciona una categoría\" />\n                            </SelectTrigger>\n                          </FormControl>\n                          <SelectContent>\n                            {EVENT_CATEGORIES.map(category => (\n                              <SelectItem key={category.value} value={category.value}>\n                                {category.label}\n                              </SelectItem>\n                            ))}\n                          </SelectContent>\n                        </Select>\n                        <FormMessage />\n                      </FormItem>\n                    )}\n                  />\n                  \n                  {/* Fecha y hora */}\n                  <div className=\"mb-4\">\n                    <FormLabel>Fecha y Hora</FormLabel>\n                    <div className=\"flex gap-2\">\n                      <FormField\n                        control={form.control}\n                        name=\"date\"\n                        render={({ field }) => (\n                          <FormItem className=\"flex-1\">\n                            <FormControl>\n                              <Input\n                                {...field}\n                                type=\"date\"\n                                className=\"w-full p-3 border border-neutral-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-primary\"\n                              />\n                            </FormControl>\n                            <FormMessage />\n                          </FormItem>\n                        )}\n                      />\n                      \n                      <FormField\n                        control={form.control}\n                        name=\"time\"\n                        render={({ field }) => (\n                          <FormItem className=\"flex-1\">\n                            <FormControl>\n                              <Input\n                                {...field}\n                                type=\"time\"\n                                className=\"w-full p-3 border border-neutral-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-primary\"\n                              />\n                            </FormControl>\n                            <FormMessage />\n                          </FormItem>\n                        )}\n                      />\n                    </div>\n                  </div>\n                  \n                  {/* Descripción */}\n                  <FormField\n                    control={form.control}\n                    name=\"description\"\n                    render={({ field }) => (\n                      <FormItem className=\"mb-4\">\n                        <FormLabel>Descripción</FormLabel>\n                        <FormControl>\n                          <Textarea\n                            {...field}\n                            placeholder=\"Cuéntale a la gente sobre tu evento...\"\n                            className=\"w-full p-3 border border-neutral-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-primary h-28\"\n                          />\n                        </FormControl>\n                        <FormMessage />\n                      </FormItem>\n                    )}\n                  />\n                  \n                  {/* Tipo de pago - Siempre establecido a \"free\" */}\n                  <input type=\"hidden\" {...form.register(\"paymentType\")} value=\"free\" />\n                  \n                  {/* Capacidad máxima */}\n                  <FormField\n                    control={form.control}\n                    name=\"maxCapacity\"\n                    render={({ field }) => (\n                      <FormItem className=\"mb-4\">\n                        <FormLabel>Capacidad Máxima (Opcional)</FormLabel>\n                        <FormControl>\n                          <Input\n                            {...field}\n                            type=\"number\"\n                            min=\"1\"\n                            placeholder=\"Sin límite\"\n                            className=\"w-full p-3 border border-neutral-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-primary\"\n                          />\n                        </FormControl>\n                        <FormMessage />\n                      </FormItem>\n                    )}\n                  />\n                  \n                  {/* Tipo de privacidad */}\n                  <FormField\n                    control={form.control}\n                    name=\"privacyType\"\n                    render={({ field }) => (\n                      <FormItem className=\"mb-4\">\n                        <FormLabel>Privacidad</FormLabel>\n                        <div className=\"flex gap-2\">\n                          <Button\n                            type=\"button\"\n                            className={`flex-1 py-3 ${field.value === 'public' ? 'bg-primary text-white' : 'bg-white border border-neutral-300 text-neutral-700'} font-medium rounded-xl`}\n                            onClick={() => form.setValue(\"privacyType\", \"public\")}\n                          >\n                            Público\n                          </Button>\n                          <Button\n                            type=\"button\"\n                            className={`flex-1 py-3 ${field.value === 'private' ? 'bg-primary text-white' : 'bg-white border border-neutral-300 text-neutral-700'} font-medium rounded-xl`}\n                            onClick={() => form.setValue(\"privacyType\", \"private\")}\n                          >\n                            Privado\n                          </Button>\n                        </div>\n                        <FormMessage />\n                      </FormItem>\n                    )}\n                  />\n                  \n                  {/* Preferencia de género */}\n                  <FormField\n                    control={form.control}\n                    name=\"genderPreference\"\n                    render={({ field }) => (\n                      <FormItem className=\"mb-4\">\n                        <FormLabel>👥 Destinado Para</FormLabel>\n                        <div className=\"text-sm text-gray-600 mb-2\">Público destinatario del evento</div>\n                        <Select \n                          onValueChange={field.onChange} \n                          defaultValue={field.value}\n                        >\n                          <FormControl>\n                            <SelectTrigger className=\"w-full p-3 border border-neutral-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-primary\">\n                              <SelectValue placeholder=\"Selecciona para quién es el evento\" />\n                            </SelectTrigger>\n                          </FormControl>\n                          <SelectContent>\n                            {GENDER_PREFERENCE_OPTIONS.map(option => (\n                              <SelectItem key={option.value} value={option.value}>\n                                {option.label}\n                              </SelectItem>\n                            ))}\n                          </SelectContent>\n                        </Select>\n                        <FormMessage />\n                      </FormItem>\n                    )}\n                  />\n                  \n                  {/* Gestor de multimedia unificado */}\n                  <FormField\n                    control={form.control}\n                    name=\"mediaItems\"\n                    render={({ field }) => (\n                      <FormItem>\n                        <FormControl>\n                          <MediaManager\n                            existingMedia={field.value || []}\n                            onChange={(mediaItems) => {\n                              // CAMBIO CRÍTICO: Asegurarnos que mediaItems es un array válido\n                              if (!Array.isArray(mediaItems)) {\n                                console.error(\"MediaManager devolvió un valor no válido:\", mediaItems);\n                                return;\n                              }\n                              \n                              // SEGURIDAD: Hacer una copia limpia del array para evitar problemas de referencia\n                              const safeMediaItems = [...mediaItems].filter(Boolean);\n                              \n                              // Actualizar campo del formulario\n                              field.onChange(safeMediaItems);\n                              \n                              try {\n                                // Procesar los elementos multimedia para compatibilidad con el código existente\n                                const mainItem = safeMediaItems.find(item => item && item.isMain === true);\n                                \n                                console.log(\"=== PROCESANDO onChange EN MEDIA MANAGER ===\");\n                                console.log(\"¿Hay elemento principal explícito?\", !!mainItem);\n                                \n                                if (mainItem) {\n                                  console.log(\"ELEMENTO PRINCIPAL FINAL:\", {\n                                    tipo: mainItem.type || 'ninguno'\n                                  });\n                                  \n                                  // Comprobación de seguridad para archivo\n                                  const hasValidFile = mainItem.file && typeof mainItem.file === 'object';\n                                  \n                                  // Solo establecer archivo si existe y es válido\n                                  if (hasValidFile) {\n                                    if (mainItem.type === 'photo') {\n                                      form.setValue('eventPhoto', mainItem.file);\n                                  } else if (mainItem.type === 'video') {\n                                    form.setValue('eventVideo', mainItem.file);\n                                  }\n                                }\n                                \n                                // En lugar de intentar cambiar mainMediaType directamente (que no está en el schema),\n                                // actualizar una variable interna para usar más tarde durante el envío\n                                console.log(\"Configurando campos legacy con archivo principal:\", mainItem.type || 'photo', mainItem.file || null);\n                              } else {\n                                console.log(\"No hay elemento principal seleccionado entre\", safeMediaItems.length, \"elementos\");\n                              }\n                              \n                              console.log(\"=== FIN PROCESAMIENTO onChange ===\");\n                              } catch (error) {\n                                console.error(\"Error al procesar los elementos multimedia:\", error);\n                              }\n                            }}\n                          />\n                        </FormControl>\n                        <FormMessage />\n                      </FormItem>\n                    )}\n                  />\n                  \n                  {/* Botón de envío */}\n                  <Button \n                    type=\"submit\"\n                    className=\"w-full py-3 bg-primary text-white font-semibold rounded-xl mt-4\"\n                    disabled={isSubmitting}\n                  >\n                    {isSubmitting ? (\n                      <>\n                        <span className=\"animate-spin mr-2 h-4 w-4 border-b-2 border-white rounded-full inline-block\"></span>\n                        Creando Evento...\n                      </>\n                    ) : (\n                      \"Crear Evento\"\n                    )}\n                  </Button>\n                </div>\n              </div>\n            )}\n          </form>\n        </Form>\n      </div>\n    </div>\n  );\n};\n\nexport default CreateEventForm;","size_bytes":37203},"client/src/components/events/create-event-sheet.tsx":{"content":"import React, { useState, useEffect, useRef } from \"react\";\nimport { useAuth } from \"@/hooks/use-auth\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport CreateEventFormGoogle from \"@/components/events/create-event-form-google\";\nimport { useNavigation } from \"@/contexts/navigation-context\";\nimport { X, ArrowLeft } from \"lucide-react\";\nimport LoadingSpinner from \"@/components/ui/loading-spinner\";\nimport { usePanelGestures } from \"@/hooks/use-panel-gestures\";\n\n// Componente para la creación de eventos en un panel deslizante\n\ninterface LocationData {\n  latitude: number;\n  longitude: number;\n  locationName: string;\n  locationAddress: string;\n}\n\ninterface CreateEventSheetProps {\n  isOpen: boolean;\n  onClose: () => void;\n  initialLocation?: LocationData | null;\n  onEventCreated?: () => void; // Callback para cuando se crea un evento\n}\n\n// Componente para la creación de eventos en un panel deslizante\n\nconst CreateEventSheet = ({ isOpen, onClose, initialLocation, onEventCreated }: CreateEventSheetProps) => {\n  console.log(\"Renderizando CreateEventSheet, isOpen:\", isOpen);\n  const { user, isLoading: authLoading } = useAuth();\n  const { toast } = useToast();\n  const { hideNavigation, showNavigation } = useNavigation();\n  const [formVisible, setFormVisible] = useState(false);\n  const [closing, setClosing] = useState(false);\n  const [selectOpen, setSelectOpen] = useState(false); // Estado para controlar si hay menús desplegables abiertos\n  const sheetRef = useRef<HTMLDivElement>(null);\n  const createEventKey = useRef(0);\n  \n  // Manejar cierre con animación - definido antes del hook que lo usa\n  const handleClose = () => {\n    console.log(\"Iniciando cierre de CreateEventSheet con animación\");\n    setClosing(true);\n    setTimeout(() => {\n      setClosing(false);\n      onClose();\n    }, 300); // Debe coincidir con la duración de la animación CSS\n  };\n  \n  // Advanced gesture system with intelligent scroll detection\n  const { height: panelHeight, isDragging, gestureHandlers } = usePanelGestures({\n    minHeight: 25,\n    maxHeight: 95,\n    snapPositions: [35, 60, 90],\n    velocityThreshold: 0.7,\n    closeThreshold: 40,\n    onClose: handleClose,\n    enableRubberBanding: true,\n    hapticFeedback: true,\n    dragHandleSelector: '.panel-drag-handle', // Solo la barra superior permite arrastre\n    contentScrollSelector: '.panel-content', // El área de contenido permite scroll\n    intelligentScrollDetection: true,\n  });\n  \n  // Control navigation visibility\n  useEffect(() => {\n    if (isOpen) {\n      hideNavigation();\n    } else {\n      showNavigation();\n    }\n    \n    // Cleanup: show navigation when component unmounts\n    return () => {\n      showNavigation();\n    };\n  }, [isOpen, hideNavigation, showNavigation]);\n\n  // Logs para depuración\n  useEffect(() => {\n    console.log(\"Panel de crear evento montado con estado:\", isOpen ? \"abierto\" : \"cerrado\");\n  }, []);\n  \n  // Log para depuración\n  useEffect(() => {\n    console.log(\"Estado de CreateEventSheet:\", { isOpen, closing, formVisible, user: !!user, authLoading });\n  }, [isOpen, closing, formVisible, user, authLoading]);\n\n  // Check authentication\n  useEffect(() => {\n    if (authLoading) return;\n    \n    if (!user) {\n      toast({\n        title: 'Autenticación Requerida',\n        description: 'Por favor inicia sesión para crear eventos',\n        variant: 'destructive',\n      });\n      handleClose();\n      return;\n    }\n    \n    // If authenticated, show the form\n    setFormVisible(true);\n  }, [user, authLoading, toast]);\n\n  // Estado para bloquear el cierre durante los primeros segundos\n  const [lockClosing, setLockClosing] = useState(false);\n\n  // Efecto para bloquear el cierre durante los primeros momentos después de abrir\n  useEffect(() => {\n    if (isOpen) {\n      // Bloquear inmediatamente cuando se abre\n      setLockClosing(true);\n      \n      // Mantener bloqueado durante 5 segundos\n      const timerId = setTimeout(() => {\n        setLockClosing(false);\n        console.log(\"🔓 Bloqueo de cierre liberado después de 5 segundos\");\n      }, 5000);\n      \n      return () => clearTimeout(timerId);\n    }\n  }, [isOpen]);\n  \n  // Efecto para detectar cuando hay menús desplegables abiertos\n  useEffect(() => {\n    const checkDropdownState = () => {\n      // Buscar cualquier menú desplegable abierto en el DOM\n      const openMenus = document.querySelectorAll(\n        '[data-radix-popper-content-wrapper], [role=\"listbox\"], [data-state=\"open\"]'\n      );\n      const isOpen = openMenus.length > 0;\n      \n      if (isOpen !== selectOpen) {\n        console.log(`Estado de menús desplegables actualizado: ${isOpen ? \"ABIERTO\" : \"CERRADO\"}`);\n        setSelectOpen(isOpen);\n      }\n    };\n\n    // Ejecutar la comprobación periódicamente mientras el panel está abierto\n    const intervalId = isOpen ? setInterval(checkDropdownState, 100) : null;\n    \n    return () => {\n      if (intervalId) clearInterval(intervalId);\n    };\n  }, [isOpen, selectOpen]);\n\n  // Efecto para manejar clics fuera del panel - Solución drástica\n  useEffect(() => {\n    // Definir la zona segura del click (donde NO debe cerrarse el panel)\n    function isTargetSafeToClick(target: HTMLElement): boolean {\n      // -1. Si el panel está bloqueado por tiempo, NUNCA cerrar (primeros 5 segundos)\n      if (lockClosing) {\n        console.log(\"🔒 Panel bloqueado temporalmente - NO cerrar\");\n        return true;\n      }\n      \n      // 0. Si hay un menú desplegable abierto, SIEMPRE es seguro (NO cerrar)\n      if (selectOpen) {\n        console.log(\"🛡️ Menú desplegable abierto detectado - NO cerrar\");\n        return true;\n      }\n      \n      // 1. Si el clic está dentro del panel principal, es seguro (NO cerrar)\n      if (sheetRef.current && sheetRef.current.contains(target)) {\n        console.log(\"✅ Clic dentro del panel principal - NO cerrar\");\n        return true;\n      }\n      \n      // 2. Verificar si es parte de algún elemento UI desplegado (dropdown, popup, etc)\n      const uiSelectors = [\n        // Selectores específicos de ShadCN/Radix UI\n        '[data-radix-popper-content-wrapper]',\n        '[class*=\"SelectContent\"]',\n        '[class*=\"PopoverContent\"]',\n        '[class*=\"DropdownMenu\"]',\n        '[class*=\"radix-\"]',\n        '[class*=\"Dialog\"]',\n        '[role=\"listbox\"]',\n        '[role=\"dialog\"]',\n        '[role=\"menu\"]',\n        // Clases genéricas que podrían pertenecer a UI\n        '.select-content',\n        '.popup-menu',\n        '.dropdown-options',\n        '.calendar-popup'\n      ];\n      \n      // Si coincide con alguno de estos selectores, es seguro (NO cerrar)\n      for (const selector of uiSelectors) {\n        if (target.closest(selector)) {\n          console.log(`✅ Clic en elemento UI (${selector}) - NO cerrar`);\n          return true;\n        }\n      }\n      \n      // 3. Si llegamos aquí, no es seguro => CERRAR\n      console.log(\"❌ Clic fuera del panel y elementos UI - CERRAR\");\n      return false;\n    }\n\n    // Función para proteger los contenidos de dropdown específicamente\n    function protectDropdownContents() {\n      // Seleccionar todos los elementos de dropdown y portales\n      const allDropdowns = [\n        ...Array.from(document.querySelectorAll('[data-radix-popper-content-wrapper]')),\n        ...Array.from(document.querySelectorAll('[data-state=\"open\"]')),\n        ...Array.from(document.querySelectorAll('[data-radix-portal]')),\n        ...Array.from(document.querySelectorAll('[role=\"listbox\"]')),\n        ...Array.from(document.querySelectorAll('.select-dropdown-wrapper'))\n      ];\n      \n      allDropdowns.forEach(dropdown => {\n        // Verificar si ya está protegido\n        if (!dropdown.hasAttribute('data-pipol-protected')) {\n          // Marcar como protegido y agregar captura de eventos\n          dropdown.setAttribute('data-pipol-protected', 'true');\n          \n          // Agregar un objeto directo que intercepte clics en TODA el área\n          dropdown.addEventListener('mousedown', (e) => {\n            console.log(\"🔒 Interceptado clic en dropdown (protección especial)\");\n            e.stopPropagation();\n            e.preventDefault();\n          }, true);\n          \n          // Buscar todos los elementos clickeables y protegerlos\n          const clickables = dropdown.querySelectorAll('*');\n          clickables.forEach(el => {\n            el.addEventListener('mousedown', (e) => {\n              e.stopPropagation();\n            }, true);\n          });\n        }\n      });\n    }\n\n    // Ejecutar la protección inmediatamente y en intervalos\n    if (isOpen) {\n      protectDropdownContents();\n      const protectionInterval = setInterval(protectDropdownContents, 50);\n      setTimeout(() => clearInterval(protectionInterval), 5000); // Limpia después de 5 segundos\n    }\n\n    // Función que maneja el clic global\n    function handleGlobalClick(e: MouseEvent) {\n      const clickTarget = e.target as HTMLElement;\n      \n      // VERIFICACIÓN SUPER IMPORTANTE: Si tenemos un menú desplegable abierto con nuestra nueva lógica\n      if (window.__PIPOL_UI_STATE?.preventPanelClose) {\n        console.log(\"🚨 PROTECCIÓN GLOBAL ACTIVADA - NO cerrar bajo ninguna circunstancia\");\n        return;\n      }\n      \n      // VERIFICACIÓN DE DROPDOWN: Clic en un desplegable Radix?\n      if (clickTarget.closest('[data-radix-popper-content-wrapper]') || \n          clickTarget.closest('[role=\"listbox\"]') ||\n          clickTarget.closest('[data-radix-portal]') ||\n          clickTarget.closest('.select-dropdown-wrapper') ||\n          clickTarget.closest('[data-pipol-dropdown]') ||\n          clickTarget.closest('.pipol-dropdown-content')) {\n        console.log(\"🔒 Clic directo en dropdown Radix capturado - NO cerrar\");\n        e.stopPropagation();\n        return;\n      }\n      \n      // VERIFICACIÓN DEL ESTADO GLOBAL\n      if (window.__PIPOL_UI_STATE?.selectMenuOpen) {\n        console.log(\"🚨 Menú Select abierto según estado global - NO cerrar\");\n        return;\n      }\n      \n      // Verificación antigua para compatibilidad\n      const portals = document.querySelectorAll('[data-pipol-select-portal], [data-pipol-protected]');\n      let foundInPortal = false;\n      \n      portals.forEach(portal => {\n        if (portal.contains(clickTarget)) {\n          console.log(\"🛡️ Clic detectado dentro de un portal, ignorando cierre\");\n          foundInPortal = true;\n        }\n      });\n      \n      if (foundInPortal) {\n        return;\n      }\n      \n      // Si es un área segura donde hacer clic, NO cerramos\n      if (isTargetSafeToClick(clickTarget)) {\n        return;\n      }\n      \n      // Si llegamos aquí, cerrar el panel\n      handleClose();\n    }\n    \n    // Solo agregar listener cuando el panel está abierto\n    if (isOpen) {\n      // Usar capture: true para capturar el evento antes que otros handlers\n      document.addEventListener('mousedown', handleGlobalClick, true);\n    }\n    \n    // Limpiar el listener cuando se desmonta\n    return () => {\n      document.removeEventListener('mousedown', handleGlobalClick, true);\n    };\n  }, [isOpen]);\n\n\n  // Agregar estilos CSS para las animaciones\n  useEffect(() => {\n    // Agregar estilos si no existen\n    if (!document.getElementById('slide-sheet-styles')) {\n      const styleSheet = document.createElement('style');\n      styleSheet.id = 'slide-sheet-styles';\n      styleSheet.innerHTML = `\n        .slide-up {\n          animation: slideUp 0.3s ease forwards;\n        }\n        .slide-down {\n          animation: slideDown 0.3s ease forwards;\n        }\n        @keyframes slideUp {\n          from { transform: translateY(100%); }\n          to { transform: translateY(0); }\n        }\n        @keyframes slideDown {\n          from { transform: translateY(0); }\n          to { transform: translateY(100%); }\n        }\n      `;\n      document.head.appendChild(styleSheet);\n    }\n  }, []);\n\n  if (!isOpen) return null;\n\n  return (\n    <div \n      className=\"fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\"\n      onClick={(e) => {\n        // Si se hace clic directamente en el fondo oscuro (no en elementos hijos)\n        if (e.target === e.currentTarget) {\n          console.log(\"⚠️ Clic en fondo oscuro - cerrando panel\");\n          handleClose();\n        }\n      }}\n    >\n      <div \n        ref={sheetRef}\n        className={`absolute bottom-0 left-0 right-0 bg-white rounded-t-3xl shadow-panel z-20 flex flex-col event-panel ${closing ? 'slide-down' : 'slide-up'}`}\n        style={{ \n          height: `${panelHeight}vh`,\n          transition: isDragging ? 'none' : 'height 0.3s ease'\n        }}\n        onClick={(e) => e.stopPropagation()} // Evita que clics en el panel blanco lleguen al fondo\n      >\n        {/* Barra superior con indicador de arrastre y título - fija */}\n        <div className=\"sticky top-0 z-10 bg-white rounded-t-3xl panel-drag-handle\">\n          <div \n            className=\"p-4 flex justify-center cursor-pointer select-none touch-none\"\n            {...gestureHandlers}\n          >\n            <div className={`w-10 h-1 bg-neutral-300 rounded-full transition-all duration-150 ${isDragging ? 'scale-110 bg-neutral-400' : ''}`}></div>\n          </div>\n          \n          <div className=\"border-b border-gray-100\">\n            <div className=\"flex items-center justify-between p-4\">\n              <div className=\"flex items-center\">\n                <button onClick={handleClose} className=\"mr-3\">\n                  <ArrowLeft className=\"h-5 w-5\" />\n                </button>\n                <h2 className=\"text-lg font-medium\">Crear evento</h2>\n              </div>\n              <button onClick={handleClose} className=\"text-gray-500\">\n                <X className=\"h-5 w-5\" />\n              </button>\n            </div>\n          </div>\n        </div>\n        \n        {/* Contenido principal con scroll - permite scroll natural */}\n        <div className=\"flex-1 overflow-y-auto pb-20 panel-content\" style={{ height: `calc(${panelHeight}vh - 70px)`, WebkitOverflowScrolling: 'touch' }}>\n          \n          {/* Loading state */}\n          {authLoading && !formVisible && (\n            <div className=\"flex h-48 items-center justify-center\">\n              <LoadingSpinner size=\"lg\" />\n            </div>\n          )}\n          \n          {/* Render create form when authenticated */}\n          {formVisible && (\n            <div className=\"event-create-container pb-20\">\n              <CreateEventFormGoogle \n                key={`create-event-${createEventKey.current}`}\n                onClose={handleClose} \n                visible={true} \n                initialLocation={initialLocation}\n                onEventCreated={onEventCreated}\n              />\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default CreateEventSheet;","size_bytes":14913},"client/src/components/events/edit-event-form-google.tsx":{"content":"import React, { useState, useEffect, useRef, useCallback } from \"react\";\nimport { useForm, FieldValues } from \"react-hook-form\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport { z } from \"zod\";\nimport { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from \"@/components/ui/form\";\nimport { Input } from \"@/components/ui/input\";\nimport { Button } from \"@/components/ui/button\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { apiRequest } from \"@/lib/queryClient\";\nimport { useQueryClient } from \"@tanstack/react-query\";\nimport { ArrowLeft, MapIcon, Compass, Search, Camera, Video, Clock, Calendar, MapPin, Tag, Users, DollarSign, Lock, Trash2 } from \"lucide-react\";\nimport { useAuth } from \"@/hooks/use-auth\";\nimport { useLocation } from \"wouter\";\nimport LoadingSpinner from \"@/components/ui/loading-spinner\";\nimport { GoogleMap, Marker, useLoadScript, Libraries } from '@react-google-maps/api';\nimport { GOOGLE_MAPS_API_KEY, reverseGeocode, defaultMapConfig } from \"@/lib/google-maps\";\nimport { MediaManager, MediaItem } from \"./media-manager-v2\";\n\n// Definición centralizada de categorías para reutilización\nconst EVENT_CATEGORIES = [\n  { value: 'social', label: 'Social' },\n  { value: 'music', label: 'Música' },\n  { value: 'spiritual', label: 'Espiritual' },\n  { value: 'education', label: 'Educación' },\n  { value: 'sports', label: 'Deportes' },\n  { value: 'food', label: 'Comida' },\n  { value: 'art', label: 'Arte' },\n  { value: 'technology', label: 'Tecnología' },\n  { value: 'games', label: 'Juegos' },\n  { value: 'outdoor', label: 'Aire Libre' },\n  { value: 'networking', label: 'Networking' },\n  { value: 'workshop', label: 'Talleres' },\n  { value: 'conference', label: 'Conferencias' },\n  { value: 'party', label: 'Fiestas' },\n  { value: 'fair', label: 'Ferias' },\n  { value: 'exhibition', label: 'Exposiciones' }\n];\n\n// Form schema para validación de eventos (modo edición más flexible - sin campos obligatorios estrictos)\nconst createEventSchema = z.object({\n  title: z.string().optional().default(\"\"),\n  description: z.string().optional().default(\"\"),\n  category: z.string().optional().default(\"\"),\n  date: z.string().optional().default(\"\"),\n  time: z.string().optional().default(\"\"),\n  endTime: z.string().optional().default(\"\"),\n  latitude: z.union([z.string(), z.number()]).optional(),\n  longitude: z.union([z.string(), z.number()]).optional(),\n  locationName: z.string().optional().default(\"\"),\n  locationAddress: z.string().optional().default(\"\"),\n  paymentType: z.string().optional().default(\"free\"),\n  price: z.string().optional().default(\"\"),\n  maxCapacity: z.string().optional().default(\"\"),\n  privacyType: z.string().optional().default(\"public\"),\n  privateAccessType: z.enum(['solicitud', 'postulacion', 'paga']).optional(),\n  applicationQuestions: z.string().optional().default(\"\"),\n\n  // Campo para gestión multimedia unificada - Para edición, permitir array vacío (archivos existentes se conservan)\n  mediaItems: z.array(\n    z.object({\n      id: z.string().optional(),\n      type: z.enum(['photo', 'video']),\n      url: z.string().optional(),\n      file: z.instanceof(File).optional(),\n      isMain: z.boolean().optional(),\n      isNew: z.boolean().optional(),\n      deleted: z.boolean().optional(),\n      toDelete: z.boolean().optional(),\n      order: z.number().optional(),\n    })\n  ).default([]),\n  \n  // Campos para carga directa de archivos (mantener por compatibilidad)\n  eventPhotos: z.array(z.instanceof(File)).optional().default([]),\n  eventVideos: z.array(z.instanceof(File)).optional().default([]),\n  eventPhoto: z.instanceof(File).optional().nullable(),\n  eventVideo: z.instanceof(File).optional().nullable(),\n  mainMediaFile: z.instanceof(File).optional().nullable(),\n  mainMediaType: z.string().optional(),\n});\n\n// Tipos para props y datos\ntype LocationData = {\n  latitude: number;\n  longitude: number;\n  locationName: string;\n  locationAddress: string;\n};\n\ntype EditEventFormProps = {\n  onClose: () => void;\n  visible: boolean;\n  eventId: number;\n  event: any; // Datos del evento a editar\n  onEventUpdated?: () => void; // Callback para cuando se actualiza el evento con éxito\n};\n\n// Define el tipo extendido para compatibilidad con todo el formulario\ntype FormValues = z.infer<typeof createEventSchema> & {\n  mediaItems: MediaItem[];\n  eventPhoto?: File;\n  eventVideo?: File;\n  eventPhotos?: File[];\n  eventVideos?: File[];\n  mainMediaFile?: File;\n  mainMediaType?: string;\n};\n\n// Librerias de Google Maps\nconst libraries: Libraries = [\"places\"];\n\n/**\n * Componente EditEventFormGoogle - Formulario para editar eventos existentes\n */\n/**\n * EditEventFormGoogle con manejo mejorado de ciclo de vida para evitar problemas\n * al cerrar el formulario. El componente se destruye completamente al cerrarse.\n */\nconst EditEventFormGoogle = ({ onClose, visible, eventId, event, onEventUpdated }: EditEventFormProps) => {\n  console.log(\"Creando instancia de EditEventFormGoogle para evento ID:\", eventId);\n  // Estados principales\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [isDeleting, setIsDeleting] = useState(false);\n  \n  // Cuando el componente va a ser desmontado, limpiar cualquier estado o efecto pendiente\n  useEffect(() => {\n    return () => {\n      console.log(\"Desmontando CreateEventFormGoogle - limpiando recursos\");\n      // La función onClose ya habrá sido llamada desde el botón o desde otro lugar\n      // Este es solo un lugar adicional para asegurar la limpieza completa\n    };\n  }, []);\n  \n  // Inicializar ubicación con los datos del evento\n  const defaultLocation = {\n    lat: 19.4326, // Ciudad de México por defecto\n    lng: -99.1332\n  };\n  \n  // Usar la ubicación del evento\n  const [center, setCenter] = useState(() => {\n    if (event && event.latitude && event.longitude) {\n      const lat = typeof event.latitude === 'string' ? parseFloat(event.latitude) : event.latitude;\n      const lng = typeof event.longitude === 'string' ? parseFloat(event.longitude) : event.longitude;\n      return { lat, lng };\n    }\n    return defaultLocation;\n  });\n  \n  // Configurar el marcador con la misma ubicación del evento\n  const [markerPosition, setMarkerPosition] = useState(() => {\n    if (event && event.latitude && event.longitude) {\n      const lat = typeof event.latitude === 'string' ? parseFloat(event.latitude) : event.latitude;\n      const lng = typeof event.longitude === 'string' ? parseFloat(event.longitude) : event.longitude;\n      return { lat, lng };\n    }\n    return defaultLocation;\n  });\n  \n  // Establecer el paso inicial - Para edición, ir directamente al paso 2 ya que el evento tiene ubicación\n  const [step, setStep] = useState<1 | 2>(2);\n  const [stepAnimation, setStepAnimation] = useState<'none' | 'fade-out' | 'fade-in'>('none');\n  \n  // Cargar Google Maps\n  const { isLoaded, loadError } = useLoadScript({\n    googleMapsApiKey: GOOGLE_MAPS_API_KEY,\n    libraries,\n  });\n  \n  // Hooks y referencias\n  const { toast } = useToast();\n  const { user, isLoading } = useAuth();\n  const [_, navigate] = useLocation();\n  const queryClient = useQueryClient();\n  const mapRef = useRef<google.maps.Map | null>(null);\n  \n  // Extraer fecha y hora del evento\n  const extractDateAndTime = (dateString: string): { date: string, time: string } => {\n    try {\n      if (!dateString) return { date: \"\", time: \"\" };\n      \n      const eventDate = new Date(dateString);\n      \n      // Formatear fecha como YYYY-MM-DD para el input type=\"date\"\n      const date = eventDate.toISOString().split('T')[0];\n      \n      // Formatear hora como HH:MM para el input type=\"time\"\n      const hours = eventDate.getHours().toString().padStart(2, '0');\n      const minutes = eventDate.getMinutes().toString().padStart(2, '0');\n      const time = `${hours}:${minutes}`;\n      \n      return { date, time };\n    } catch (error) {\n      console.error(\"Error al procesar fecha:\", error);\n      return { date: \"\", time: \"\" };\n    }\n  };\n  \n  // Procesar elementos multimedia del evento\n  const processMediaItems = (event: any): MediaItem[] => {\n    console.log(\"Procesando multimedia para evento:\", event?.id, \"mediaItems:\", event?.mediaItems, \"media_items:\", event?.media_items);\n    console.log(\"Tipo de mediaItems:\", typeof event?.mediaItems, \"Contenido:\", event?.mediaItems);\n    console.log(\"Tipo de media_items:\", typeof event?.media_items, \"Contenido:\", event?.media_items);\n    \n    try {\n      if (!event) {\n        console.log(\"No hay evento para procesar multimedia\");\n        return [];\n      }\n      \n      let mediaItemsArray: any[] = [];\n      \n      // Check both camelCase and snake_case field names\n      const mediaItemsField = event.mediaItems || event.media_items;\n      console.log(\"Campo de media items a usar:\", typeof mediaItemsField, mediaItemsField);\n      \n      // Si mediaItems ya es un array, usarlo directamente\n      if (Array.isArray(mediaItemsField) && mediaItemsField.length > 0) {\n        mediaItemsArray = mediaItemsField;\n        console.log(\"MediaItems ya es array válido:\", mediaItemsArray);\n      }\n      // Si mediaItems es una string JSON, parsearlo\n      else if (typeof mediaItemsField === 'string' && mediaItemsField.trim()) {\n        try {\n          mediaItemsArray = JSON.parse(mediaItemsField);\n          console.log(\"MediaItems parseados desde JSON string:\", mediaItemsArray);\n        } catch (e) {\n          console.error(\"Error al parsear JSON de mediaItems:\", e);\n          console.log(\"String original:\", mediaItemsField);\n          return [];\n        }\n      } \n      // Si no hay mediaItems pero hay URLs individuales (compatibilidad)\n      else if (event.mainMediaUrl || event.main_media_url) {\n        const mainUrl = event.mainMediaUrl || event.main_media_url;\n        const mainType = event.mainMediaType || event.main_media_type || 'photo';\n        console.log(\"Usando mainMediaUrl como fallback:\", mainUrl);\n        mediaItemsArray = [{\n          type: mainType,\n          url: mainUrl,\n          order: 0,\n          isMain: true\n        }];\n      }\n      else {\n        console.log(\"No se encontraron elementos multimedia válidos en evento\");\n        console.log(\"Datos del evento disponibles:\", Object.keys(event || {}));\n        return [];\n      }\n      \n      // Validar y mapear los elementos para el formulario\n      const validItems = mediaItemsArray\n        .filter((item: any) => {\n          const isValid = item && \n            typeof item === 'object' && \n            item.type && \n            item.url &&\n            (item.type === 'photo' || item.type === 'video');\n          \n          if (!isValid) {\n            console.warn(\"Item multimedia inválido filtrado:\", item);\n          }\n          \n          return isValid;\n        })\n        .map((item: any, index: number) => ({\n          ...item,\n          id: item.id || `existing-${index}`,\n          order: item.order !== undefined ? item.order : index,\n          isMain: item.isMain || index === 0\n        }));\n      \n      console.log(\"Elementos multimedia procesados y validados:\", validItems.length, validItems);\n      \n      return validItems;\n    } catch (error) {\n      console.error(\"Error al procesar elementos multimedia:\", error);\n      return [];\n    }\n  };\n  \n  // Extraer fecha y hora del evento\n  const { date, time } = extractDateAndTime(event?.date || \"\");\n  \n  // Extraer hora de fin del evento si existe\n  const extractEndTime = (endTimeString: string): string => {\n    try {\n      if (!endTimeString) return \"\";\n      \n      const endDate = new Date(endTimeString);\n      const hours = endDate.getHours().toString().padStart(2, '0');\n      const minutes = endDate.getMinutes().toString().padStart(2, '0');\n      return `${hours}:${minutes}`;\n    } catch (error) {\n      console.error(\"Error al procesar hora de fin:\", error);\n      return \"\";\n    }\n  };\n  \n  const endTime = extractEndTime(event?.endTime || \"\");\n  \n  // Extraer elementos multimedia\n  const mediaItems = processMediaItems(event);\n  console.log(\"Resultado final de processMediaItems:\", mediaItems.length, mediaItems);\n  console.log(\"🔍 FORM DEBUG - Event data received:\", event?.id);\nconsole.log(\"🔍 FORM DEBUG - event.mediaItems:\", typeof event?.mediaItems, event?.mediaItems);\nconsole.log(\"🔍 FORM DEBUG - event.media_items:\", typeof event?.media_items, event?.media_items);\nconsole.log(\"🔍 FORM DEBUG - event.mainMediaUrl:\", typeof event?.mainMediaUrl, event?.mainMediaUrl);\nconsole.log(\"🔍 FORM DEBUG - event.main_media_url:\", typeof event?.main_media_url, event?.main_media_url);\n  \n  // Inicializar formulario con valores del evento\n  const form = useForm<FormValues, any, FormValues>({\n    resolver: zodResolver(createEventSchema),\n    defaultValues: {\n      title: event?.title || \"\",\n      description: event?.description || \"\",\n      category: event?.category || \"\",\n      date: date,\n      time: time,\n      endTime: endTime,\n      // Asegurarnos de que las coordenadas se traten como números\n      latitude: event?.latitude ? parseFloat(String(event.latitude)) : \"\",\n      longitude: event?.longitude ? parseFloat(String(event.longitude)) : \"\",\n      locationName: event?.locationName || \"\",\n      locationAddress: event?.locationAddress || \"\",\n      paymentType: event?.paymentType || \"free\",\n      price: event?.price?.toString() || \"\",\n      maxCapacity: event?.maxCapacity?.toString() || \"\",\n      privacyType: event?.privacyType || \"public\",\n      privateAccessType: event?.privateAccessType || \"solicitud\", // Valor predeterminado cuando privacyType es \"private\"\n      applicationQuestions: event?.applicationQuestions || \"\",\n\n      mediaItems: mediaItems,\n      eventPhotos: [],\n      eventVideos: [],\n      eventPhoto: undefined,\n      eventVideo: undefined,\n      mainMediaFile: undefined,\n      mainMediaType: undefined,\n    },\n  });\n\n  // Verificar autenticación\n  useEffect(() => {\n    if (!isLoading && !user) {\n      toast({\n        title: \"Autenticación Requerida\",\n        description: \"Por favor, inicia sesión para crear eventos\",\n        variant: \"destructive\",\n      });\n      navigate(\"/login\");\n    }\n  }, [user, isLoading, toast, navigate]);\n  \n  // Para edit mode, no necesitamos efecto de ubicación inicial ya que tenemos los datos del evento\n  // Este useEffect se mantiene por compatibilidad pero en modo edición no se usa\n  useEffect(() => {\n    // En modo edición, los datos del evento ya están configurados en defaultValues\n    // Este efecto se mantiene por compatibilidad con el componente original\n    console.log(\"EditEventFormGoogle: Componente inicializado en modo edición\");\n  }, []);\n\n  // Callback para guardar la referencia del mapa\n  const onMapLoad = useCallback((map: google.maps.Map) => {\n    mapRef.current = map;\n  }, []);\n\n  // Manejar click en el mapa\n  const handleMapClick = useCallback((event: google.maps.MapMouseEvent) => {\n    if (event.latLng) {\n      const lat = event.latLng.lat();\n      const lng = event.latLng.lng();\n      \n      setMarkerPosition({ lat, lng });\n      \n      // Guardar como números, no strings\n      form.setValue(\"latitude\", lat);\n      form.setValue(\"longitude\", lng);\n      \n      // Obtener dirección y detalles del lugar\n      reverseGeocode(lng, lat).then(async address => {\n        console.log(\"Dirección geocodificada inversamente:\", address);\n        \n        // Intentar obtener el nombre del lugar usando Places API si está disponible\n        try {\n          // Crear el servicio de Places\n          if (window.google && window.google.maps && window.google.maps.places) {\n            const placesService = new window.google.maps.places.PlacesService(document.createElement('div'));\n            \n            // Buscar lugares cercanos a las coordenadas donde se hizo clic\n            const request = {\n              location: new window.google.maps.LatLng(lat, lng),\n              radius: 100, // Buscar en un radio de 100 metros\n              type: 'establishment' // Priorizar establecimientos - debe ser un string, no un array\n            };\n            \n            // Promisificar la llamada a nearbySearch\n            const nearbyPlaces = await new Promise<google.maps.places.PlaceResult[]>((resolve, reject) => {\n              placesService.nearbySearch(request, (results, status) => {\n                if (status === window.google.maps.places.PlacesServiceStatus.OK && results) {\n                  resolve(results);\n                } else {\n                  reject(new Error(`Places API error: ${status}`));\n                }\n              });\n            });\n            \n            // Si encontramos establecimientos cercanos, usar el nombre del primero\n            if (nearbyPlaces && nearbyPlaces.length > 0) {\n              console.log(\"Lugares encontrados cerca:\", nearbyPlaces);\n              const placeResult = nearbyPlaces[0];\n              const placeName = placeResult.name || address.split(',')[0];\n              \n              form.setValue(\"locationAddress\", address);\n              form.setValue(\"locationName\", placeName);\n              \n              toast({\n                title: \"Ubicación seleccionada\",\n                description: placeName,\n              });\n              return;\n            }\n          }\n        } catch (placesError) {\n          console.error(\"Error al buscar lugares cercanos:\", placesError);\n          // Continuar con el enfoque predeterminado si falla\n        }\n        \n        // Método predeterminado: usar la primera parte de la dirección\n        const locationName = address.split(',')[0] || \"Lugar del evento\";\n        form.setValue(\"locationAddress\", address);\n        form.setValue(\"locationName\", locationName);\n        \n        toast({\n          title: \"Ubicación seleccionada\",\n          description: \"Ubicación guardada correctamente\",\n        });\n      }).catch(error => {\n        console.error(\"Error obteniendo dirección:\", error);\n        form.setValue(\"locationAddress\", \"Dirección no disponible\");\n        form.setValue(\"locationName\", \"Lugar del evento\");\n      });\n    }\n  }, [form, toast]);\n\n  // Función para cambiar de paso con animación (necesaria para compatibilidad)\n  const changeStep = useCallback((newStep: 1 | 2) => {\n    setStepAnimation('fade-out');\n    \n    setTimeout(() => {\n      setStep(newStep);\n      setStepAnimation('fade-in');\n      \n      setTimeout(() => {\n        setStepAnimation('none');\n      }, 300);\n    }, 300);\n  }, []);\n\n  // Validar ubicación antes de continuar al paso 2\n  const validateAndContinue = async () => {\n    // Log para depuración\n    console.log(\"Validando ubicación:\", {\n      latitude: form.getValues(\"latitude\"),\n      longitude: form.getValues(\"longitude\"),\n      tipo_lat: typeof form.getValues(\"latitude\"),\n      tipo_lng: typeof form.getValues(\"longitude\")\n    });\n    \n    if (!form.getValues(\"latitude\") || !form.getValues(\"longitude\")) {\n      toast({\n        title: \"Selecciona una ubicación\",\n        description: \"Haz clic en el mapa para seleccionar dónde se realizará el evento\",\n        variant: \"destructive\"\n      });\n      return;\n    }\n    \n    // Si falta nombre o dirección, intentar obtenerlos\n    if (!form.getValues(\"locationName\") || !form.getValues(\"locationAddress\")) {\n      try {\n        // Siempre convertimos explícitamente a string y luego a número para evitar problemas de tipo\n        const lngValue = form.getValues(\"longitude\");\n        const latValue = form.getValues(\"latitude\");\n        const lng = typeof lngValue === 'string' ? parseFloat(lngValue) : lngValue;\n        const lat = typeof latValue === 'string' ? parseFloat(latValue) : latValue;\n        \n        const address = await reverseGeocode(lng || 0, lat || 0);\n        \n        const locationName = address.split(',')[0] || \"Lugar del evento\";\n        form.setValue(\"locationAddress\", address);\n        form.setValue(\"locationName\", locationName);\n      } catch (error) {\n        // Si falla, usar valores por defecto\n        form.setValue(\"locationAddress\", \"Dirección no disponible\");\n        form.setValue(\"locationName\", \"Lugar del evento\");\n      }\n    }\n    \n    // Avanzar al siguiente paso con animación\n    changeStep(2);\n  };\n\n  // Función para eliminar el evento\n  const handleDeleteEvent = async () => {\n    if (!eventId) return;\n    \n    // Confirmar eliminación\n    const confirmDelete = window.confirm(\n      \"¿Estás seguro de que quieres eliminar este evento? Esta acción no se puede deshacer.\"\n    );\n    \n    if (!confirmDelete) return;\n    \n    setIsDeleting(true);\n    \n    try {\n      console.log(`🗑️ Starting deletion process for event ${eventId}`);\n      \n      // NO hacer optimistic update - esperar confirmación del servidor\n      console.log(\"⏳ Waiting for server confirmation before updating UI\");\n      \n      // Hacer la petición de eliminación primero\n      const response = await fetch(`/api/events/${eventId}`, {\n        method: 'DELETE',\n        credentials: 'include',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n      \n      if (!response.ok) {\n        throw new Error('Failed to delete event');\n      }\n      \n      console.log(`✅ Server confirmed deletion for event ${eventId}`);\n      \n      // Ahora actualizar el cache después de confirmación del servidor\n      queryClient.setQueryData(['/api/events'], (oldData: any[]) => {\n        if (!oldData) return oldData;\n        return oldData.filter((event: any) => event.id !== eventId);\n      });\n      \n      // Invalidar queries para asegurar consistencia\n      queryClient.invalidateQueries({ queryKey: ['events'] });\n      queryClient.invalidateQueries({ queryKey: ['user-events'] });\n      queryClient.invalidateQueries({ queryKey: ['/api/events'] });\n      queryClient.invalidateQueries({ queryKey: ['/api/user/events/created'] });\n      queryClient.invalidateQueries({ queryKey: ['/api/user/events/attending'] });\n      \n      console.log(\"🗑️ Cache updated, waiting for map refresh\");\n      \n      // Esperar a que el mapa se actualice completamente\n      await new Promise(resolve => setTimeout(resolve, 1500));\n      \n      // Verificar que el evento ya no esté en el cache\n      const eventsData = queryClient.getQueryData([\"/api/events\"]) as any[];\n      const eventStillExists = eventsData?.some((e: any) => e.id === eventId);\n      \n      if (eventStillExists) {\n        console.log(\"🔄 Event still in cache, waiting longer\");\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n      \n      console.log(\"🗑️ Deletion process complete, closing panels\");\n      \n      toast({\n        title: \"Evento eliminado\",\n        description: \"El evento ha sido eliminado exitosamente\",\n      });\n      \n      // AHORA cerrar los paneles después de que todo esté completo\n      onClose();\n      \n      if (onEventUpdated) {\n        onEventUpdated();\n      }\n      \n      // Navegar al mapa principal\n      navigate('/');\n    } catch (error) {\n      console.error(\"Error eliminando evento:\", error);\n      \n      // ROLLBACK: Invalidar cache para restaurar el evento\n      queryClient.invalidateQueries({ queryKey: ['/api/events'] });\n      \n      toast({\n        title: \"Error al eliminar\",\n        description: \"No se pudo eliminar el evento. Se restauró en el mapa.\",\n        variant: \"destructive\"\n      });\n    } finally {\n      setIsDeleting(false);\n    }\n  };\n\n  // Enviar formulario al servidor\n  const onSubmit = async (data: FormValues) => {\n    console.log(\"🚀 onSubmit called with data:\", data);\n    console.log(\"🔍 onSubmit - data type:\", typeof data);\n    console.log(\"🔍 onSubmit - data keys:\", Object.keys(data || {}));\n    \n    // SOLUCIÓN AL ERROR UNDEFINED:\n    // El problema ocurre porque los datos no están definidos correctamente\n    // Vamos a asegurarnos que todos los valores críticos estén definidos\n    \n    if (!data || typeof data !== 'object') {\n      console.error(\"❌ Datos del formulario inválidos:\", data);\n      toast({\n        title: \"Error en formulario\",\n        description: \"Los datos del formulario no son válidos. Por favor, inténtalo de nuevo.\",\n        variant: \"destructive\",\n      });\n      return;\n    }\n    \n    if (isSubmitting) return;\n    setIsSubmitting(true);\n    \n    try {\n      // Verificación adicional para mediaItems - Esto es crucial para evitar undefined\n      if (!data.mediaItems || !Array.isArray(data.mediaItems)) {\n        console.warn(\"data.mediaItems no es un array válido. Inicializando como array vacío.\");\n        data.mediaItems = [];\n      }\n      \n      // Preparar datos para la API\n      const dateTime = new Date(`${data.date}T${data.time}`);\n      \n      // Crear FormData para enviar archivos\n      const formData = new FormData();\n      \n      // Añadir campos básicos\n      formData.append('title', data.title);\n      formData.append('description', data.description);\n      formData.append('category', data.category);\n      formData.append('date', dateTime.toISOString());\n      formData.append('latitude', String(data.latitude));\n      formData.append('longitude', String(data.longitude));\n      formData.append('locationName', data.locationName);\n      formData.append('locationAddress', data.locationAddress);\n      formData.append('paymentType', data.paymentType);\n      formData.append('privacyType', data.privacyType);\n      \n      // Añadir campos condicionales\n      if (data.paymentType === 'paid' && data.price) {\n        formData.append('price', data.price);\n      }\n      \n      if (data.privacyType === 'private' && data.privateAccessType) {\n        formData.append('privateAccessType', data.privateAccessType);\n        \n        // Añadir preguntas de aplicación si es relevante\n        if (data.privateAccessType === 'postulacion' && data.applicationQuestions) {\n          formData.append('applicationQuestions', data.applicationQuestions);\n        }\n      }\n      \n      // ===== CORRECCIÓN DEL BUG \"UNDEFINED\" =====\n      // Este es el parche directo para solucionar el problema con los archivos multimedia\n      // 1. Asegurar que formData tenga un valor por defecto para mainMediaType\n      formData.append('mainMediaType', 'photo'); // Valor seguro por defecto\n      \n      // 2. Filtrar y procesar mediaItems\n      const validMediaItems = data.mediaItems.filter(item => \n        item && \n        typeof item === 'object' && \n        !item.deleted && \n        !item.toDelete\n      );\n      \n      // 3. Buscar un elemento principal o usar el primero disponible\n      const mainMediaItem = validMediaItems.find(item => item.isMain) || \n                           (validMediaItems.length > 0 ? validMediaItems[0] : null);\n      \n      // 4. Procesar el elemento principal si existe\n      if (mainMediaItem) {\n        if (mainMediaItem.file instanceof File) {\n          formData.append('mainMediaFile', mainMediaItem.file);\n          formData.append('mainMediaType', mainMediaItem.type || 'photo');\n          console.log(\"Archivo principal agregado:\", mainMediaItem.file.name);\n        } else if (mainMediaItem.url) {\n          formData.append('mainMediaUrl', mainMediaItem.url);\n          formData.append('mainMediaType', mainMediaItem.type || 'photo');\n          console.log(\"URL principal agregada:\", mainMediaItem.url);\n        }\n      }\n      \n      // 5. Procesar archivos multimedia nuevos (solo los que tienen File object)\n      let fileIndex = 0;\n      const filesForUpload: any[] = [];\n      \n      validMediaItems.forEach((item, index) => {\n        console.log(`📎 Processing media item ${index}:`, { \n          hasFile: !!item.file, \n          isNew: !!item.isNew, \n          type: item.type,\n          isFileInstance: item.file instanceof File,\n          fileName: item.file?.name || 'N/A',\n          hasUrl: !!item.url\n        });\n        \n        // Solo procesar archivos nuevos (que tienen File object)\n        if (item.file instanceof File && item.isNew) {\n          const fieldName = `mediaFile_${fileIndex}`;\n          formData.append(fieldName, item.file);\n          console.log(`✅ Added NEW file to FormData: ${fieldName} - ${item.file.name}`);\n          \n          // Guardar info del archivo para metadata\n          filesForUpload.push({\n            fieldName,\n            type: item.type,\n            isMain: item === mainMediaItem,\n            order: item.order || index,\n            id: item.id\n          });\n          \n          fileIndex++;\n        }\n      });\n      \n      // 6. Preparar metadata completa incluyendo archivos existentes y nuevos\n      const mediaItemsMetadata = validMediaItems.map((item, index) => {\n        // Si es un archivo nuevo, encontrar su info de upload\n        const uploadInfo = filesForUpload.find(upload => upload.id === item.id);\n        \n        return {\n          type: item.type || 'photo',\n          isMain: item === mainMediaItem,\n          order: item.order !== undefined ? item.order : index,\n          id: item.id,\n          url: item.url || null, // Preservar URL existente\n          isNew: !!item.isNew, // Marcar si es nuevo\n          hasFile: !!item.file // Marcar si tiene archivo\n        };\n      });\n      \n      // Agregar metadata como JSON\n      formData.append('mediaItems', JSON.stringify(mediaItemsMetadata));\n      \n      // Añadir capacidad máxima si existe\n      if (data.maxCapacity) {\n        formData.append('maxCapacity', String(Number(data.maxCapacity)));\n      }\n      \n      // Usar fetch directamente para FormData - UPDATE para editar evento existente\n      const response = await fetch(`/api/events/${eventId}`, {\n        method: 'PATCH',\n        body: formData,\n        credentials: 'include' // Para enviar cookies de sesión\n      });\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        console.error(\"Error del servidor:\", errorData);\n        \n        // Verificar si es un error de autenticación\n        if (response.status === 401) {\n          toast({\n            title: \"Necesitas iniciar sesión\",\n            description: \"Debes iniciar sesión antes de poder crear eventos.\",\n            variant: \"destructive\",\n          });\n          navigate(\"/login\");\n          return;\n        }\n        \n        // Sanitizar mensaje de error para mostrar al usuario\n        let safeErrorMessage = \"Ocurrió un error al crear el evento. Por favor, inténtalo de nuevo.\";\n        \n        try {\n          if (errorData.message) {\n            if (typeof errorData.message === 'string') {\n              // Detectar error específico de \"undefined\"\n              if (errorData.message.includes('undefined')) {\n                console.warn(\"Detectado mensaje 'undefined' del servidor:\", errorData.message);\n                safeErrorMessage = \"Error en la subida de archivos. Por favor, verifica los archivos e inténtalo nuevamente.\";\n              } else {\n                safeErrorMessage = errorData.message;\n              }\n            } else if (typeof errorData.message === 'object') {\n              // Intentar convertir a string si es posible\n              safeErrorMessage = \"Error del servidor: \" + JSON.stringify(errorData.message);\n            }\n          }\n        } catch (sanitizeError) {\n          console.error(\"Error al sanitizar mensaje de error:\", sanitizeError);\n          // Mantener el mensaje seguro por defecto\n        }\n        \n        toast({\n          title: \"Error al actualizar evento\",\n          description: safeErrorMessage,\n          variant: \"destructive\",\n        });\n        \n        setIsSubmitting(false);\n        return;\n      }\n      \n      const eventData = await response.json();\n      console.log(\"Evento actualizado:\", eventData);\n      \n      toast({\n        title: \"¡Evento actualizado!\",\n        description: \"Los cambios se han guardado correctamente\",\n      });\n      \n      // Invalidar queries para refrescar datos\n      queryClient.invalidateQueries({ queryKey: ['events'] });\n      queryClient.invalidateQueries({ queryKey: ['events', eventId] });\n      \n      // Llamar al callback para actualizar los eventos si existe\n      if (onEventUpdated) {\n        console.log(\"Llamando a onEventUpdated para actualizar eventos...\");\n        onEventUpdated();\n      }\n\n      // Cerrar formulario (esto llamará al método en Home.tsx que limpia el estado)\n      onClose();\n      \n      // No realizamos ninguna navegación adicional, ya que queremos permanecer en el mapa\n      // y ver el evento recién creado en el contexto del mapa\n      \n      // Emitir notificación de éxito adicional para confirmar al usuario\n      setTimeout(() => {\n        toast({\n          title: \"¡Cambios guardados!\",\n          description: \"El evento actualizado ya aparece en el mapa\",\n          variant: \"default\",\n        });\n      }, 500);\n    } catch (error) {\n      console.error(\"Error al actualizar evento:\", error);\n      \n      toast({\n        title: \"Error al actualizar evento\",\n        description: \"Ocurrió un error inesperado. Por favor, inténtalo de nuevo.\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  // Función duplicada eliminada - ya está definida arriba\n  \n  // Función para volver al paso anterior o cerrar formulario\n  const handleBackButtonClick = useCallback(() => {\n    try {\n      console.log(\"Botón de retroceso pulsado, paso actual:\", step);\n      \n      // Cerrar el formulario directamente\n      console.log(\"Cerrando formulario de evento - llamando a onClose directamente\");\n      onClose();\n    } catch (error) {\n      console.error(\"Error al manejar retroceso:\", error);\n      // Si hay un error, intentar cerrar directamente\n      onClose();\n    }\n  }, [step, onClose]);\n  \n  // Renderizado condicional basado en el paso\n  const renderStepContent = () => {\n    if (step === 1) {\n      return (\n        <div className={`step-content ${stepAnimation}`}>\n          <div className=\"space-y-6\">\n            <div className=\"mb-4\">\n              <h2 className=\"text-lg font-semibold mb-1\">Ubicación del Evento</h2>\n              <p className=\"text-sm text-gray-500\">Selecciona dónde se realizará tu evento</p>\n            </div>\n            \n            <div className=\"map-container\" style={{ height: '400px', width: '100%', position: 'relative' }}>\n              {isLoaded ? (\n                <GoogleMap\n                  mapContainerStyle={{ height: '100%', width: '100%' }}\n                  zoom={14}\n                  center={center}\n                  options={defaultMapConfig}\n                  onClick={handleMapClick}\n                  onLoad={onMapLoad}\n                >\n                  <Marker position={markerPosition} />\n                </GoogleMap>\n              ) : loadError ? (\n                <div className=\"error-message p-4 bg-red-50 text-red-700 rounded-md\">\n                  No se pudo cargar el mapa: {loadError.message}\n                </div>\n              ) : (\n                <div className=\"loading-spinner flex justify-center items-center h-full\">\n                  Cargando mapa...\n                </div>\n              )}\n            </div>\n            \n            <div className=\"grid grid-cols-1 gap-4\">\n              <FormField\n                control={form.control}\n                name=\"locationName\"\n                render={({ field }) => (\n                  <FormItem>\n                    <FormLabel>Nombre del lugar</FormLabel>\n                    <FormControl>\n                      <Input placeholder=\"Ej: Centro Cultural, Parque, etc.\" {...field} />\n                    </FormControl>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n              \n              <FormField\n                control={form.control}\n                name=\"locationAddress\"\n                render={({ field }) => (\n                  <FormItem>\n                    <FormLabel>Dirección</FormLabel>\n                    <FormControl>\n                      <Input placeholder=\"Dirección completa\" {...field} />\n                    </FormControl>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n            </div>\n            \n            <div className=\"flex justify-between mt-6\">\n              <Button \n                type=\"button\" \n                variant=\"outline\" \n                onClick={handleBackButtonClick}\n              >\n                <ArrowLeft className=\"h-4 w-4 mr-2\" /> Cancelar\n              </Button>\n              \n              <Button \n                type=\"button\"\n                onClick={validateAndContinue}\n              >\n                Continuar\n              </Button>\n            </div>\n          </div>\n        </div>\n      );\n    } else {\n      // Paso 2 - Detalles del evento\n      return (\n        <div className={`step-content ${stepAnimation}`}>\n          <div className=\"space-y-6\">\n            <div className=\"mb-4\">\n              <h2 className=\"text-lg font-semibold mb-1\">Detalles del Evento</h2>\n              <p className=\"text-sm text-gray-500\">Completa la información de tu evento</p>\n            </div>\n            \n            <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n              <FormField\n                control={form.control}\n                name=\"title\"\n                render={({ field }) => (\n                  <FormItem className=\"space-y-2\">\n                    <FormLabel className=\"flex items-center gap-2\">\n                      <Tag className=\"h-4 w-4 text-primary\" />\n                      <span>Título del evento</span>\n                    </FormLabel>\n                    <FormControl>\n                      <Input \n                        placeholder=\"Ej: Concierto de Jazz, Taller de cerámica...\" \n                        className=\"bg-card\"\n                        {...field} \n                      />\n                    </FormControl>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n              \n              <FormField\n                control={form.control}\n                name=\"category\"\n                render={({ field }) => (\n                  <FormItem className=\"space-y-2\">\n                    <FormLabel className=\"flex items-center gap-2\">\n                      <Tag className=\"h-4 w-4 text-primary\" />\n                      <span>Categoría</span>\n                    </FormLabel>\n                    <Select \n                      onValueChange={field.onChange} \n                      defaultValue={field.value}\n                    >\n                      <FormControl>\n                        <SelectTrigger className=\"bg-card\">\n                          <SelectValue placeholder=\"Selecciona una categoría\" />\n                        </SelectTrigger>\n                      </FormControl>\n                      <SelectContent>\n                        {EVENT_CATEGORIES.map(category => (\n                          <SelectItem key={category.value} value={category.value}>\n                            {category.label}\n                          </SelectItem>\n                        ))}\n                      </SelectContent>\n                    </Select>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n            </div>\n            \n            <FormField\n              control={form.control}\n              name=\"description\"\n              render={({ field }) => (\n                <FormItem className=\"space-y-2\">\n                  <FormLabel className=\"flex items-center gap-2\">\n                    <div className=\"flex items-center gap-2\">\n                      <span className=\"h-4 w-4 flex items-center justify-center text-primary text-xs font-bold border border-primary rounded\">i</span>\n                      <span>Descripción</span>\n                    </div>\n                  </FormLabel>\n                  <FormControl>\n                    <Textarea \n                      placeholder=\"Describe de qué trata el evento, qué pueden esperar los asistentes...\" \n                      className=\"min-h-[150px] bg-card resize-none\"\n                      {...field} \n                    />\n                  </FormControl>\n                  <FormMessage />\n                  <p className=\"text-xs text-muted-foreground\">\n                    Una buena descripción incluye: qué actividades se realizarán, qué deben traer los asistentes, \n                    y cualquier información importante sobre el lugar o los organizadores.\n                  </p>\n                </FormItem>\n              )}\n            />\n            \n            <FormField\n              control={form.control}\n              name=\"maxCapacity\"\n              render={({ field }) => (\n                <FormItem className=\"space-y-2\">\n                  <FormLabel className=\"flex items-center gap-2\">\n                    <Users className=\"h-4 w-4 text-primary\" />\n                    <span>Capacidad máxima (opcional)</span>\n                  </FormLabel>\n                  <FormControl>\n                    <div className=\"relative\">\n                      <Users className=\"absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground\" />\n                      <Input \n                        type=\"number\" \n                        placeholder=\"Deja en blanco si no hay límite\"\n                        className=\"pl-10 bg-card\"\n                        {...field} \n                      />\n                    </div>\n                  </FormControl>\n                  <p className=\"text-xs text-muted-foreground\">\n                    Establece un límite de asistentes para tu evento. \n                    Cuando se alcance este número, no se permitirán más registros.\n                  </p>\n                  <FormMessage />\n                </FormItem>\n              )}\n            />\n            \n            <div className=\"bg-primary/5 rounded-lg p-4 border border-primary/20 mb-4\">\n              <h3 className=\"text-md font-medium mb-3 flex items-center gap-2\">\n                <Calendar className=\"h-4 w-4 text-primary\" />\n                Fecha y hora\n              </h3>\n              <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n                <FormField\n                  control={form.control}\n                  name=\"date\"\n                  render={({ field }) => (\n                    <FormItem className=\"space-y-2\">\n                      <div className=\"flex items-center\">\n                        <FormLabel className=\"text-sm text-muted-foreground flex-grow\">Fecha</FormLabel>\n                        <Calendar \n                          className=\"h-4 w-4 text-primary mr-1\" \n                        />\n                      </div>\n                      <FormControl>\n                        <Input \n                          type=\"date\" \n                          className=\"bg-card\" \n                          {...field} \n                        />\n                      </FormControl>\n                      <FormMessage />\n                    </FormItem>\n                  )}\n                />\n                \n                <FormField\n                  control={form.control}\n                  name=\"time\"\n                  render={({ field }) => (\n                    <FormItem className=\"space-y-2\">\n                      <div className=\"flex items-center\">\n                        <FormLabel className=\"text-sm text-muted-foreground flex-grow\">Hora</FormLabel>\n                        <Clock \n                          className=\"h-4 w-4 text-primary mr-1\" \n                        />\n                      </div>\n                      <FormControl>\n                        <Input \n                          type=\"time\" \n                          className=\"bg-card\" \n                          {...field} \n                        />\n                      </FormControl>\n                      <FormMessage />\n                    </FormItem>\n                  )}\n                />\n              </div>\n            </div>\n            \n            <div className=\"bg-primary/5 rounded-lg p-4 border border-primary/20 mb-4\">\n              <h3 className=\"text-md font-medium mb-3 flex items-center gap-2\">\n                <DollarSign className=\"h-4 w-4 text-primary\" />\n                Tipo de acceso\n              </h3>\n              <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n                <FormField\n                  control={form.control}\n                  name=\"paymentType\"\n                  render={({ field }) => (\n                    <FormItem className=\"space-y-2\">\n                      <FormLabel className=\"text-sm text-muted-foreground\">Acceso</FormLabel>\n                      <Select \n                        onValueChange={field.onChange} \n                        defaultValue={field.value}\n                      >\n                        <FormControl>\n                          <SelectTrigger className=\"bg-card\">\n                            <SelectValue placeholder=\"Selecciona tipo de acceso\" />\n                          </SelectTrigger>\n                        </FormControl>\n                        <SelectContent>\n                          <SelectItem value=\"free\">\n                            <div className=\"flex items-center gap-2\">\n                              <span className=\"h-2 w-2 rounded-full bg-green-500\"></span>\n                              Gratuito\n                            </div>\n                          </SelectItem>\n                          <SelectItem value=\"paid\">\n                            <div className=\"flex items-center gap-2\">\n                              <span className=\"h-2 w-2 rounded-full bg-yellow-500\"></span>\n                              De pago\n                            </div>\n                          </SelectItem>\n                        </SelectContent>\n                      </Select>\n                      <FormMessage />\n                    </FormItem>\n                  )}\n                />\n                \n                {form.watch(\"paymentType\") === \"paid\" && (\n                  <FormField\n                    control={form.control}\n                    name=\"price\"\n                    render={({ field }) => (\n                      <FormItem className=\"space-y-2\">\n                        <FormLabel className=\"text-sm text-muted-foreground\">Precio (MXN)</FormLabel>\n                        <FormControl>\n                          <div className=\"relative\">\n                            <DollarSign className=\"absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground\" />\n                            <Input \n                              type=\"number\" \n                              placeholder=\"Ej: 150\"\n                              className=\"pl-10 bg-card\"\n                              {...field} \n                            />\n                          </div>\n                        </FormControl>\n                        <FormMessage />\n                      </FormItem>\n                    )}\n                  />\n                )}\n              </div>\n            </div>\n            \n            <div className=\"bg-primary/5 rounded-lg p-4 border border-primary/20 mb-4\">\n              <h3 className=\"text-md font-medium mb-3 flex items-center gap-2\">\n                <Lock className=\"h-4 w-4 text-primary\" />\n                Privacidad del evento\n              </h3>\n              <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n                <FormField\n                  control={form.control}\n                  name=\"privacyType\"\n                  render={({ field }) => (\n                    <FormItem className=\"space-y-2\">\n                      <FormLabel className=\"text-sm text-muted-foreground\">Tipo de evento</FormLabel>\n                      <Select \n                        onValueChange={field.onChange} \n                        defaultValue={field.value}\n                      >\n                        <FormControl>\n                          <SelectTrigger className=\"bg-card\">\n                            <SelectValue placeholder=\"Selecciona tipo de privacidad\" />\n                          </SelectTrigger>\n                        </FormControl>\n                        <SelectContent>\n                          <SelectItem value=\"public\">\n                            <div className=\"flex items-center gap-2\">\n                              <span className=\"h-2 w-2 rounded-full bg-green-500\"></span>\n                              Público (visible para todos)\n                            </div>\n                          </SelectItem>\n                          <SelectItem value=\"private\">\n                            <div className=\"flex items-center gap-2\">\n                              <span className=\"h-2 w-2 rounded-full bg-amber-500\"></span>\n                              Privado (acceso restringido)\n                            </div>\n                          </SelectItem>\n                        </SelectContent>\n                      </Select>\n                      <FormMessage />\n                    </FormItem>\n                  )}\n                />\n                \n                {form.watch(\"privacyType\") === \"private\" && (\n                  <FormField\n                    control={form.control}\n                    name=\"privateAccessType\"\n                    render={({ field }) => (\n                      <FormItem className=\"space-y-2\">\n                        <FormLabel className=\"text-sm text-muted-foreground\">Método de acceso</FormLabel>\n                        <Select \n                          onValueChange={field.onChange} \n                          defaultValue={field.value}\n                        >\n                          <FormControl>\n                            <SelectTrigger className=\"bg-card\">\n                              <SelectValue placeholder=\"Tipo de acceso\" />\n                            </SelectTrigger>\n                          </FormControl>\n                          <SelectContent>\n                            <SelectItem value=\"solicitud\">\n                              <div className=\"flex items-center gap-2\">\n                                <Lock className=\"h-3 w-3 text-blue-500\" />\n                                Por solicitud (tú apruebas)\n                              </div>\n                            </SelectItem>\n                            <SelectItem value=\"postulacion\">\n                              <div className=\"flex items-center gap-2\">\n                                <Users className=\"h-3 w-3 text-purple-500\" />\n                                Por postulación (formulario)\n                              </div>\n                            </SelectItem>\n                            <SelectItem value=\"paga\">\n                              <div className=\"flex items-center gap-2\">\n                                <DollarSign className=\"h-3 w-3 text-yellow-500\" />\n                                Solo de pago\n                              </div>\n                            </SelectItem>\n                          </SelectContent>\n                        </Select>\n                        <FormMessage />\n                      </FormItem>\n                    )}\n                  />\n                )}\n              </div>\n            </div>\n            \n            {form.watch(\"privacyType\") === \"private\" && \n             form.watch(\"privateAccessType\") === \"postulacion\" && (\n              <div className=\"bg-blue-50 rounded-lg p-4 border border-blue-200 mb-4\">\n                <div className=\"flex items-center gap-2 mb-2\">\n                  <span className=\"bg-blue-500 text-white rounded-full h-5 w-5 flex items-center justify-center text-xs font-bold\">?</span>\n                  <h3 className=\"text-md font-medium text-blue-700\">Preguntas para postulantes</h3>\n                </div>\n                <p className=\"text-sm text-blue-600 mb-3\">\n                  Estas preguntas deberán ser respondidas por las personas que quieran asistir a tu evento privado.\n                </p>\n                <FormField\n                  control={form.control}\n                  name=\"applicationQuestions\"\n                  render={({ field }) => (\n                    <FormItem className=\"space-y-2\">\n                      <FormControl>\n                        <Textarea \n                          placeholder=\"Escribe las preguntas que quieres que respondan los interesados, separadas por líneas.\nEjemplo:\n¿Por qué quieres participar en este evento?\n¿Cuál es tu experiencia previa en este tema?\n¿Qué esperas obtener de esta actividad?\" \n                          className=\"min-h-[150px] bg-white\"\n                          {...field} \n                        />\n                      </FormControl>\n                      <FormMessage />\n                      <p className=\"text-xs text-blue-600\">\n                        Escribe cada pregunta en una línea separada. Los postulantes deberán responder a todas ellas.\n                      </p>\n                    </FormItem>\n                  )}\n                />\n              </div>\n            )}\n            \n            <div className=\"media-section border rounded-lg p-4 bg-card\">\n              <div className=\"flex items-center gap-2 mb-4\">\n                <Camera className=\"h-5 w-5 text-primary\" />\n                <h3 className=\"text-lg font-medium\">Fotos y videos del evento</h3>\n              </div>\n              <p className=\"text-sm text-muted-foreground mb-4\">\n                Agrega fotos y videos para mostrar lo que los asistentes pueden esperar. \n                El primer elemento será la imagen destacada.\n              </p>\n              <MediaManager \n                existingMedia={(() => {\n                  console.log(\"🔍 DEBUG - Event data en MediaManager:\", event?.id, event?.title);\n                  console.log(\"🔍 DEBUG - Event.mediaItems tipo:\", typeof event?.mediaItems, \"valor:\", event?.mediaItems);\n                  console.log(\"🔍 DEBUG - Event.mediaItems length:\", Array.isArray(event?.mediaItems) ? event?.mediaItems.length : 'not array');\n                  console.log(\"🔍 DEBUG - Processed mediaItems:\", mediaItems.length, mediaItems);\n                  return mediaItems; // Use the processed mediaItems instead of raw event.mediaItems\n                })()}\n                onChange={(newMediaItems) => {\n                  console.log(\"MediaManager onChange en edit:\", newMediaItems.length, \"items\");\n                  form.setValue(\"mediaItems\", newMediaItems);\n                }} \n                maxPhotos={6}\n                maxVideos={3}\n                key={`media-manager-${eventId}-${mediaItems.length}`}\n              />\n            </div>\n            \n            <div className=\"flex justify-between items-center mt-8 pt-4 border-t\">\n              <div className=\"flex gap-3\">\n                <Button \n                  type=\"button\" \n                  variant=\"destructive\"\n                  onClick={handleDeleteEvent}\n                  disabled={isDeleting || isSubmitting}\n                  className=\"bg-red-600 hover:bg-red-700 text-white\"\n                >\n                  {isDeleting ? (\n                    <div className=\"flex items-center gap-2\">\n                      <LoadingSpinner size={16} />\n                      <span>Eliminando...</span>\n                    </div>\n                  ) : (\n                    <div className=\"flex items-center gap-2\">\n                      <Trash2 className=\"h-4 w-4\" />\n                      <span>Eliminar Evento</span>\n                    </div>\n                  )}\n                </Button>\n              </div>\n              \n              <Button \n                type=\"button\"\n                disabled={isSubmitting || isDeleting}\n                onClick={(e) => {\n                  e.preventDefault();\n                  console.log(\"🔲 Guardar Cambios button clicked\");\n                  console.log(\"🔍 Form state:\", form.formState);\n                  console.log(\"🔍 Form values:\", form.getValues());\n                  console.log(\"🔍 Form errors:\", form.formState.errors);\n                  console.log(\"🔍 Is form valid?:\", form.formState.isValid);\n                  console.log(\"🔍 Form isDirty?:\", form.formState.isDirty);\n                  console.log(\"🔍 Form isSubmitting?:\", form.formState.isSubmitting);\n                  console.log(\"🔍 Media items:\", form.getValues().mediaItems);\n                  \n                  // Trigger form submission with enhanced error logging\n                  const submitResult = form.handleSubmit(\n                    (data) => {\n                      console.log(\"✅ Form validation passed, calling onSubmit with data:\", data);\n                      return onSubmit(data);\n                    }, \n                    (errors) => {\n                      console.error(\"❌ Form validation failed with errors:\", errors);\n                      toast({\n                        title: \"Error de validación\",\n                        description: \"Por favor revisa los campos marcados en rojo\",\n                        variant: \"destructive\",\n                      });\n                    }\n                  );\n                  \n                  console.log(\"🔍 Submit result:\", submitResult);\n                  \n                  // Execute the submission\n                  submitResult();\n                }}\n                className=\"bg-primary hover:bg-primary/90 text-white px-8\"\n              >\n                {isSubmitting ? (\n                  <div className=\"flex items-center gap-2\">\n                    <div className=\"h-4 w-4 border-2 border-white border-t-transparent rounded-full animate-spin\"></div>\n                    <span>Guardando...</span>\n                  </div>\n                ) : (\n                  <span>Guardar Cambios</span>\n                )}\n              </Button>\n            </div>\n          </div>\n        </div>\n      );\n    }\n  };\n  \n  // Ocultar completamente el componente cuando no es visible\n  if (!visible) return null;\n  \n  return (\n    <div className=\"w-full\">\n      <Form {...form}>\n        <form className=\"px-4 space-y-6\">\n          {renderStepContent()}\n        </form>\n      </Form>\n    </div>\n  );\n};\n\nexport default EditEventFormGoogle;","size_bytes":58420},"client/src/components/events/edit-event-form.tsx":{"content":"import React, { useState, useEffect, useRef, useCallback } from \"react\";\nimport { useForm } from \"react-hook-form\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport { z } from \"zod\";\nimport { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from \"@/components/ui/form\";\nimport { Input } from \"@/components/ui/input\";\nimport { Button } from \"@/components/ui/button\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { apiRequest } from \"@/lib/queryClient\";\nimport { ArrowLeft, MapIcon, Compass, Search } from \"lucide-react\";\nimport LoadingSpinner from \"@/components/ui/loading-spinner\";\nimport { useAuth } from \"@/hooks/use-auth\";\nimport { useLocation } from \"wouter\";\nimport { GoogleMap, Marker, useLoadScript } from '@react-google-maps/api';\nimport { GOOGLE_MAPS_API_KEY, libraries, reverseGeocode, defaultMapConfig } from \"@/lib/google-maps\";\nimport { MediaManager, type MediaItem } from \"./media-manager-v2\";\nimport mapboxgl from 'mapbox-gl';\nimport { searchLocations } from \"@/lib/mapbox\";\nimport { useQueryClient } from '@tanstack/react-query';\n\n// Definición centralizada de categorías para reutilización (igual que en el formulario de creación)\nconst EVENT_CATEGORIES = [\n  { value: 'social', label: 'Social' },\n  { value: 'music', label: 'Música' },\n  { value: 'spiritual', label: 'Espiritual' },\n  { value: 'education', label: 'Educación' },\n  { value: 'sports', label: 'Deportes' },\n  { value: 'food', label: 'Comida' },\n  { value: 'art', label: 'Arte' },\n  { value: 'technology', label: 'Tecnología' },\n  { value: 'games', label: 'Juegos' },\n  { value: 'outdoor', label: 'Aire Libre' },\n  { value: 'networking', label: 'Networking' },\n  { value: 'workshop', label: 'Talleres' },\n  { value: 'conference', label: 'Conferencias' },\n  { value: 'party', label: 'Fiestas' },\n  { value: 'fair', label: 'Ferias' },\n  { value: 'exhibition', label: 'Exposiciones' }\n];\n\n// Definición del esquema de validación para edición (modo flexible - sin campos obligatorios estrictos)\nconst editEventSchema = z.object({\n  title: z.string().optional().default(\"\"),\n  description: z.string().optional().default(\"\"),\n  category: z.string().optional().default(\"\"),\n  date: z.string().optional().default(\"\"),\n  time: z.string().optional().default(\"\"),\n  endTime: z.string().optional().default(\"\"),\n  latitude: z.number().optional(),\n  longitude: z.number().optional(),\n  locationName: z.string().optional().default(\"\"),\n  locationAddress: z.string().optional().default(\"\"),\n  paymentType: z.string().optional().default(\"free\"),\n  price: z.string().optional().default(\"\"),\n  maxCapacity: z.string().optional().default(\"\"),\n  privacyType: z.string().optional().default(\"public\"),\n  // Campos para gestión multimedia - archivos existentes se conservan\n  mediaItems: z.array(z.any()).optional().nullable(),\n  // Compatibilidad con código existente\n  eventPhoto: z.instanceof(File).optional().nullable(),\n  eventVideo: z.instanceof(File).optional().nullable(),\n  // Campos adicionales para eventos privados\n  privateAccessType: z.string().optional().nullable(),\n  applicationQuestions: z.string().optional().nullable(),\n});\n\n// Tipos para props y datos\ntype LocationData = {\n  latitude: number;\n  longitude: number;\n  locationName: string;\n  locationAddress: string;\n};\n\ntype EditEventFormProps = {\n  eventId: number;\n  onClose: () => void;\n  onEventUpdated?: () => void;\n  visible: boolean;\n  event: {\n    id: number;\n    title: string;\n    description: string;\n    category: string;\n    date: string;\n    locationName: string;\n    locationAddress: string;\n    paymentType: string;\n    price?: string | number;\n    maxCapacity?: number | string;\n    privacyType: string;\n    latitude: string | number;\n    longitude: string | number;\n    organizerId: number;\n    organizer?: {\n      id: number;\n      name: string;\n      avatar?: string;\n    };\n    photoUrl?: string;\n    photo_url?: string;\n    videoUrl?: string;\n    video_url?: string;\n    mainMediaUrl?: string;\n    mainMediaType?: string;\n    mediaItems?: string;\n    privateAccessType?: string | null;\n    applicationQuestions?: string | null;\n    endTime?: string;\n  };\n};\n\ntype FormValues = z.infer<typeof editEventSchema> & {\n  mediaItems: MediaItem[];\n};\n\n/**\n * Componente EditEventForm - Formulario para editar eventos existentes\n * Réplica del formulario de creación adaptado para edición\n */\nconst EditEventForm = ({ eventId, onClose, onEventUpdated, visible, event }: EditEventFormProps) => {\n  // Estados principales\n  const [step, setStep] = useState<1 | 2>(2); // Al editar empezamos en paso 2\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [isDeleting, setIsDeleting] = useState(false);\n  const [isAutoSaving, setIsAutoSaving] = useState(false);\n  const [saveStatus, setSaveStatus] = useState<'idle' | 'saving' | 'saved' | 'error'>('idle');\n  \n  // Convertir coordenadas a números\n  const latitudeNum = typeof event.latitude === 'string' ? parseFloat(event.latitude) : event.latitude;\n  const longitudeNum = typeof event.longitude === 'string' ? parseFloat(event.longitude) : event.longitude;\n  \n  const [mapLocation, setMapLocation] = useState<[number, number]>([\n    longitudeNum, latitudeNum\n  ]);\n  \n  // Debug: Mostrar toda la estructura del evento\n  console.log(\"🔍 DEBUGGING EVENT STRUCTURE:\");\n  console.log(\"Event keys:\", Object.keys(event));\n  console.log(\"Event.mediaItems:\", event.mediaItems);\n  console.log(\"Event.media_items:\", (event as any).media_items);\n  console.log(\"Event.mainMediaUrl:\", event.mainMediaUrl);\n  console.log(\"Event.main_media_url:\", (event as any).main_media_url);\n\n  // Estado para elementos multimedia - procesar desde el evento\n  const processMediaItems = useCallback(() => {\n    console.log(\"📱 processMediaItems ejecutándose...\");\n    console.log(\"📱 event.mediaItems:\", event.mediaItems, typeof event.mediaItems);\n    console.log(\"📱 event.media_items:\", (event as any).media_items, typeof (event as any).media_items);\n    \n    // Intentar tanto mediaItems como media_items (snake_case desde la DB)\n    const mediaData = event.mediaItems || (event as any).media_items || event.mainMediaUrl;\n    \n    if (mediaData) {\n      console.log(\"📱 Datos de media encontrados:\", mediaData, \"tipo:\", typeof mediaData);\n      \n      try {\n        // Si ya es un array, usarlo directamente\n        if (Array.isArray(mediaData)) {\n          console.log(\"📱 Es array, devolviendo:\", mediaData);\n          return mediaData;\n        }\n        \n        // Si es string, parsearlo\n        if (typeof mediaData === 'string' && mediaData.trim()) {\n          console.log(\"📱 Es string, parseando:\", mediaData);\n          \n          // Si es una URL simple (mainMediaUrl), crear un objeto MediaItem\n          if (mediaData.startsWith('/') || mediaData.startsWith('http')) {\n            const mediaItem = {\n              type: mediaData.includes('.mp4') || mediaData.includes('.mov') || mediaData.includes('.webm') ? 'video' : 'photo',\n              url: mediaData,\n              order: 0,\n              isMain: true\n            };\n            console.log(\"📱 Creando MediaItem desde URL:\", mediaItem);\n            return [mediaItem];\n          }\n          \n          // Si no, intentar parsearlo como JSON\n          try {\n            const parsed = JSON.parse(mediaData);\n            const result = Array.isArray(parsed) ? parsed : [];\n            console.log(\"📱 Resultado parseado:\", result);\n            return result;\n          } catch (e) {\n            console.log(\"📱 No es JSON válido, tratando como URL simple\");\n            return [{\n              type: 'photo',\n              url: mediaData,\n              order: 0,\n              isMain: true\n            }];\n          }\n        }\n      } catch (error) {\n        console.error(\"📱 Error procesando mediaItems:\", error);\n      }\n    }\n    \n    // Como último recurso, intentar crear desde mainMediaUrl\n    if (event.mainMediaUrl || (event as any).main_media_url) {\n      const mainUrl = event.mainMediaUrl || (event as any).main_media_url;\n      console.log(\"📱 Usando mainMediaUrl como fallback:\", mainUrl);\n      return [{\n        type: event.mainMediaType === 'video' ? 'video' : 'photo',\n        url: mainUrl,\n        order: 0,\n        isMain: true\n      }];\n    }\n    \n    console.log(\"📱 No se encontraron datos de media, devolviendo array vacío\");\n    return [];\n  }, [event.mediaItems, (event as any).media_items]);\n  \n  const [mediaItems, setMediaItems] = useState<MediaItem[]>(() => processMediaItems());\n  \n  // Hooks y referencias\n  const { toast } = useToast();\n  const { user } = useAuth();\n  const [_, navigate] = useLocation();\n  const queryClient = useQueryClient();\n  const mapContainerRef = useRef<HTMLDivElement>(null);\n  const mapRef = useRef<mapboxgl.Map | null>(null);\n  const markerRef = useRef<mapboxgl.Marker | null>(null);\n\n  // Crear un objeto Date a partir de la fecha almacenada\n  const eventDate = event.date ? new Date(event.date) : new Date();\n  \n  // Formatear la fecha para el input type=\"date\" (YYYY-MM-DD)\n  const formattedDate = eventDate.toISOString().split('T')[0];\n  \n  // Extraer la hora para el input type=\"time\" (HH:MM)\n  const hours = eventDate.getHours().toString().padStart(2, '0');\n  const minutes = eventDate.getMinutes().toString().padStart(2, '0');\n  const formattedTime = `${hours}:${minutes}`;\n\n  // Extraer hora de fin del evento si existe\n  const formatEndTime = (endTimeString: any): string => {\n    try {\n      if (!endTimeString) return \"\";\n      \n      const endDate = new Date(endTimeString);\n      const hours = endDate.getHours().toString().padStart(2, '0');\n      const minutes = endDate.getMinutes().toString().padStart(2, '0');\n      return `${hours}:${minutes}`;\n    } catch (error) {\n      console.error(\"Error al procesar hora de fin:\", error);\n      return \"\";\n    }\n  };\n  \n  const formattedEndTime = formatEndTime(event.endTime || null);\n\n  // Inicializar el formulario con los valores del evento\n  const form = useForm<FormValues>({\n    resolver: zodResolver(editEventSchema),\n    defaultValues: {\n      title: event.title || '',\n      description: event.description || '',\n      category: event.category || '',\n      date: formattedDate,\n      time: formattedTime,\n      endTime: formattedEndTime,\n      latitude: latitudeNum,\n      longitude: longitudeNum,\n      locationName: event.locationName || '',\n      locationAddress: event.locationAddress || '',\n      paymentType: event.paymentType || 'free',\n      price: event.price ? event.price.toString() : '',\n      maxCapacity: event.maxCapacity ? event.maxCapacity.toString() : '',\n      privacyType: event.privacyType || 'public',\n      privateAccessType: event.privateAccessType || null,\n      applicationQuestions: event.applicationQuestions || null,\n      mediaItems: (() => {\n        const processed = processMediaItems();\n        console.log(\"📱 Inicializando form con mediaItems:\", processed);\n        return processed;\n      })(),\n      eventPhoto: null,\n      eventVideo: null,\n    },\n  });\n\n  // Inicializar y gestionar el mapa\n  useEffect(() => {\n    // Solo inicializar si es visible y el contenedor está disponible\n    if (!visible || !mapContainerRef.current) return;\n    \n    // Inicializar mapa\n    mapRef.current = new mapboxgl.Map({\n      container: mapContainerRef.current,\n      style: 'mapbox://styles/mapbox/streets-v11',\n      center: mapLocation,\n      zoom: 13\n    });\n    \n    // Añadir controles de navegación\n    mapRef.current.addControl(new mapboxgl.NavigationControl(), 'top-right');\n    mapRef.current.addControl(\n      new mapboxgl.GeolocateControl({\n        positionOptions: { enableHighAccuracy: true },\n        trackUserLocation: true,\n        showUserHeading: true\n      }), \n      'top-right'\n    );\n    \n    // Añadir marcador inicial\n    markerRef.current = new mapboxgl.Marker({ \n      draggable: true,\n      color: \"#FF5A5F\"\n    })\n      .setLngLat(mapLocation)\n      .addTo(mapRef.current);\n    \n    // Función para actualizar ubicación cuando se arrastra el marcador\n    const updateLocationFromMarker = async (lng: number, lat: number) => {\n      setMapLocation([lng, lat]);\n      // Guardar como números, no como strings\n      form.setValue(\"latitude\", lat);\n      form.setValue(\"longitude\", lng);\n      \n      try {\n        // Convertimos explícitamente a string los valores para evitar errores de tipo\n        const address = await reverseGeocode(lng, lat);\n        form.setValue(\"locationAddress\", address);\n        \n        // Extraer nombre del lugar de la dirección\n        const locationName = address.split(',')[0] || \"Lugar del evento\";\n        if (!form.getValues(\"locationName\")) {\n          form.setValue(\"locationName\", locationName);\n        }\n      } catch (error) {\n        console.error(\"Error getting address:\", error);\n        // Si falla, mantener al menos las coordenadas\n      }\n    };\n    \n    // Configurar eventos del marcador y mapa\n    if (markerRef.current) {\n      markerRef.current.on('dragend', () => {\n        if (markerRef.current) {\n          const lngLat = markerRef.current.getLngLat();\n          updateLocationFromMarker(lngLat.lng, lngLat.lat);\n        }\n      });\n    }\n    \n    // Click en el mapa para colocar el marcador\n    mapRef.current.on('click', (e) => {\n      if (markerRef.current && mapRef.current) {\n        mapRef.current.panTo(e.lngLat, { duration: 500 });\n        markerRef.current.setLngLat(e.lngLat);\n        \n        updateLocationFromMarker(e.lngLat.lng, e.lngLat.lat);\n        \n        toast({\n          title: \"Ubicación seleccionada\",\n          description: \"Obteniendo detalles de la dirección...\",\n        });\n      }\n    });\n    \n    // Limpiar al desmontar\n    return () => {\n      if (mapRef.current) {\n        mapRef.current.remove();\n        mapRef.current = null;\n      }\n      markerRef.current = null;\n    };\n  }, [visible, mapLocation, form, toast]);\n  \n  // Escuchar eventos de cambio de elemento multimedia principal\n  useEffect(() => {\n    const handleMediaMainChanged = (event: CustomEvent) => {\n      console.log(\"🔄 Cambio detectado en elemento principal multimedia:\", event.detail);\n      \n      const { mediaItems, mainItem } = event.detail;\n      \n      if (mainItem && mediaItems) {\n        // Actualizar el estado local\n        setMediaItems(mediaItems);\n        \n        // Si hay un elemento principal, prepararlo para envío automático\n        if (mainItem.url) {\n          console.log(\"📤 Enviando actualización automática para elemento principal:\", mainItem);\n          \n          // Crear FormData para enviar una actualización rápida solo del elemento principal\n          const quickUpdateFormData = new FormData();\n          \n          // Agregar solo la información esencial para actualizar el elemento principal\n          quickUpdateFormData.append('mediaItems', JSON.stringify(mediaItems));\n          quickUpdateFormData.append('mainMediaType', mainItem.type);\n          quickUpdateFormData.append('mainMediaUrl', mainItem.url);\n          \n          // Enviar una actualización rápida al servidor\n          fetch(`/api/events/${eventId}`, {\n            method: 'PUT',\n            body: quickUpdateFormData,\n          })\n            .then(response => {\n              if (response.ok) {\n                console.log(\"✅ Actualización rápida de elemento principal exitosa\");\n                // Invalidar consultas para asegurar que todos los componentes se actualicen\n                queryClient.invalidateQueries({ queryKey: ['events'] });\n                queryClient.invalidateQueries({ queryKey: [`/api/events/${eventId}`] });\n              } else {\n                console.error(\"❌ Error en actualización rápida:\", response.status);\n              }\n            })\n            .catch(error => {\n              console.error(\"❌ Error en actualización rápida:\", error);\n            });\n        }\n      }\n    };\n    \n    // Registrar el event listener\n    window.addEventListener('media-main-changed', handleMediaMainChanged as EventListener);\n    \n    // Limpiar al desmontar\n    return () => {\n      window.removeEventListener('media-main-changed', handleMediaMainChanged as EventListener);\n    };\n  }, [eventId, queryClient]);\n  \n  // Auto-actualización de eventos cuando los campos cambian\n  useEffect(() => {\n    // Crear un timer para auto-guardar\n    let autoSaveTimer: ReturnType<typeof setTimeout> | null = null;\n    \n    // Registrar una función para detectar cambios en el formulario\n    const subscription = form.watch((value, { name, type }) => {\n      // Si es un cambio en un campo importante, programar autoguardado\n      if (name && ['title', 'description', 'category', 'date', 'time', 'paymentType', 'price', 'maxCapacity', 'privacyType'].includes(name)) {\n        console.log(`Campo \"${name}\" modificado, programando auto-guardado...`);\n        \n        // Cancelar timer anterior si existe\n        if (autoSaveTimer) {\n          clearTimeout(autoSaveTimer);\n        }\n        \n        // Programar una nueva actualización después de 1 segundo de inactividad\n        autoSaveTimer = setTimeout(() => {\n          // Solo actualizar si hay cambios importantes\n          if (form.formState.isDirty) {\n            console.log(\"⏱️ Auto-guardando cambios tras inactividad...\");\n            setIsAutoSaving(true);\n            \n            // Obtener los valores actuales\n            const currentData = form.getValues();\n            \n            // Crear FormData\n            const autoSaveFormData = new FormData();\n            \n            // Solo agregar los campos modificados\n            Object.entries(currentData).forEach(([key, value]) => {\n              if (key !== 'mediaItems' && value !== undefined && value !== null) {\n                autoSaveFormData.append(key, value.toString());\n              }\n            });\n            \n            // Construir fecha completa\n            if (currentData.date && currentData.time) {\n              const dateTimeStr = `${currentData.date}T${currentData.time}:00`;\n              autoSaveFormData.append('dateTime', dateTimeStr);\n            }\n            \n            // Agregar mediaItems en formato JSON\n            if (mediaItems.length > 0) {\n              autoSaveFormData.append('mediaItems', JSON.stringify(mediaItems));\n            }\n            \n            // Enviar actualización automática\n            fetch(`/api/events/${eventId}`, {\n              method: 'PUT',\n              body: autoSaveFormData,\n            })\n              .then(response => {\n                if (response.ok) {\n                  console.log(\"✅ Auto-guardado completado\");\n                  // Invalidar consultas relacionadas para mantener todo sincronizado\n                  queryClient.invalidateQueries({ queryKey: ['events'] });\n                  queryClient.invalidateQueries({ queryKey: [`/api/events/${eventId}`] });\n                  \n                  // Mostrar un indicador sutil solo la primera vez\n                  if (name === 'title' || name === 'description') {\n                    toast({\n                      title: \"✓ Cambios guardados automáticamente\",\n                      description: \"Todos los cambios se guardan automáticamente mientras editas\",\n                      duration: 3000,\n                    });\n                  }\n                } else {\n                  console.error(\"❌ Error en auto-guardado:\", response.status);\n                  toast({\n                    title: \"Error al guardar cambios\",\n                    description: \"No se pudieron guardar los cambios automáticamente\",\n                    variant: \"destructive\",\n                  });\n                }\n              })\n              .catch(error => {\n                console.error(\"❌ Error en auto-guardado:\", error);\n                toast({\n                  title: \"Error al guardar cambios\",\n                  description: \"No se pudieron guardar los cambios automáticamente\",\n                  variant: \"destructive\",\n                });\n              })\n              .finally(() => {\n                setIsAutoSaving(false);\n              });\n          }\n        }, 1000); // 1 segundo de retraso\n      }\n    });\n    \n    // Limpiar suscripción y cancelar timer al desmontar\n    return () => {\n      subscription.unsubscribe();\n      if (autoSaveTimer) {\n        clearTimeout(autoSaveTimer);\n      }\n    };\n  }, [form, eventId, mediaItems, queryClient]);\n\n  // Buscar dirección y actualizar mapa\n  const searchAddress = async (address: string) => {\n    if (!mapRef.current || !markerRef.current) return;\n    \n    try {\n      const results = await searchLocations(address, ['address', 'poi', 'poi.landmark', 'place']);\n      \n      if (results.length > 0) {\n        const { center, place_name, properties, text } = results[0];\n        \n        // Actualizar estado y formulario - guardando como números\n        setMapLocation([center[0], center[1]]);\n        form.setValue(\"latitude\", center[1]);\n        form.setValue(\"longitude\", center[0]);\n        form.setValue(\"locationAddress\", place_name);\n        \n        // Nombre de ubicación si es un punto de interés\n        if (properties?.category && !form.getValues(\"locationName\")) {\n          form.setValue(\"locationName\", text || place_name.split(',')[0]);\n        }\n        \n        // Actualizar mapa\n        mapRef.current.flyTo({ \n          center, \n          zoom: 15,\n          essential: true,\n          duration: 1000 \n        });\n        markerRef.current.setLngLat(center);\n        \n        toast({\n          title: \"Ubicación Encontrada\",\n          description: \"Mapa actualizado a la ubicación buscada\",\n        });\n      } else {\n        toast({\n          title: \"Ubicación No Encontrada\",\n          description: \"No se pudo encontrar la dirección especificada\",\n          variant: \"destructive\",\n        });\n      }\n    } catch (error) {\n      console.error(\"Error buscando dirección:\", error);\n      toast({\n        title: \"Error de Búsqueda\",\n        description: \"No se pudo buscar la dirección\",\n        variant: \"destructive\",\n      });\n    }\n  };\n\n  // Parsear los elementos multimedia del evento\n  useEffect(() => {\n    console.log(\"Procesando multimedia para evento:\", event.id);\n    \n    let parsedItems: MediaItem[] = [];\n    \n    // Verificar si tenemos mediaItems como JSON\n    if (event.mediaItems) {\n      try {\n        const parsed = JSON.parse(event.mediaItems);\n        if (Array.isArray(parsed)) {\n          parsedItems = parsed;\n          console.log(`Cargados ${parsedItems.length} elementos multimedia para el evento ${event.id}`);\n        } else {\n          console.warn(\"mediaItems no es un array:\", parsed);\n        }\n      } catch (error) {\n        console.error('Error al parsear elementos multimedia:', error);\n      }\n    }\n    \n    // Si no tenemos items del JSON o el array está vacío, intentamos construir a partir de las propiedades individuales\n    if (parsedItems.length === 0) {\n      console.log(\"Construyendo array de multimedia a partir de propiedades individuales\");\n      \n      // Verificar si tenemos mainMediaUrl (prioridad más alta)\n      if (event.mainMediaUrl) {\n        parsedItems.push({\n          type: event.mainMediaType as 'photo' | 'video' || 'photo',\n          url: event.mainMediaUrl,\n          order: 0,\n          isMain: true\n        });\n      }\n      \n      // Agregar photoUrl si existe y no es igual al mainMediaUrl\n      const photoUrl = event.photoUrl || event.photo_url;\n      if (photoUrl && (!event.mainMediaUrl || photoUrl !== event.mainMediaUrl)) {\n        parsedItems.push({\n          type: 'photo',\n          url: photoUrl,\n          order: parsedItems.length,\n          isMain: parsedItems.length === 0\n        });\n      }\n      \n      // Agregar videoUrl si existe\n      const videoUrl = event.videoUrl || event.video_url;\n      if (videoUrl) {\n        parsedItems.push({\n          type: 'video',\n          url: videoUrl,\n          order: parsedItems.length,\n          isMain: parsedItems.length === 0\n        });\n      }\n    }\n    \n    // Asegurarse de que al menos un elemento está marcado como principal\n    if (parsedItems.length > 0 && !parsedItems.some(item => item.isMain)) {\n      parsedItems[0].isMain = true;\n    }\n    \n    // Actualizar el estado y el formulario\n    setMediaItems(parsedItems);\n    form.setValue(\"mediaItems\", parsedItems);\n  }, [event, form]);\n\n  // Manejar envío del formulario\n  const onSubmit = async (data: FormValues) => {\n    setIsSubmitting(true);\n    \n    try {\n      // Crear un objeto FormData para manejar archivos\n      const formData = new FormData();\n      \n      // Agregar campos de texto del formulario\n      Object.entries(data).forEach(([key, value]) => {\n        if (key !== 'mediaItems' && value !== undefined && value !== null) {\n          formData.append(key, value.toString());\n        }\n      });\n      \n      // Combinar fecha y hora\n      if (data.date && data.time) {\n        const dateTimeStr = `${data.date}T${data.time}:00`;\n        formData.append('dateTime', dateTimeStr);\n      }\n      \n      // Procesar los mediaItems antes de enviarlos\n      const processedMediaItems = [...mediaItems];\n      \n      // Verificar si hay nuevos archivos para determinar el método adecuado (PATCH o PUT)\n      const hasNewFiles = processedMediaItems.some(item => item.file && item.isNew);\n      \n      // Agregar JSON de elementos multimedia (incluidos los marcados para eliminar)\n      formData.append('mediaItems', JSON.stringify(processedMediaItems));\n      formData.append('mediaItemsInfo', JSON.stringify(processedMediaItems));\n      \n      // Agregar archivos nuevos al formData\n      if (hasNewFiles) {\n        processedMediaItems.forEach((item, index) => {\n          if (item.file && item.isNew) {\n            // Usar nombre de campo compatible con el backend (mediaFile_X)\n            formData.append(`mediaFile_${index}`, item.file);\n            console.log(`Agregando archivo nuevo: mediaFile_${index}`, item.file.name);\n          }\n        });\n      }\n      \n      // Seleccionar método apropiado según si hay archivos nuevos\n      const method = hasNewFiles ? 'PATCH' : 'PUT';\n      console.log(`Enviando formulario usando método ${method} con ${hasNewFiles ? 'archivos nuevos' : 'solo datos'}`);\n      \n      // Hacer la solicitud de actualización al servidor\n      const response = await fetch(`/api/events/${eventId}`, {\n        method,\n        body: formData,\n        // No establecer Content-Type, dejar que el navegador lo calcule con el boundary correcto\n      });\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.message || 'Error al actualizar el evento');\n      }\n      \n      // Parsear los datos del evento actualizado para trabajar con ellos\n      const updatedEventData = await response.json();\n      \n      // Actualizar cache de eventos e invalidar consultas relacionadas inmediatamente\n      queryClient.invalidateQueries({ queryKey: ['events'] });\n      queryClient.invalidateQueries({ queryKey: [`/api/events/${eventId}`] });\n      queryClient.invalidateQueries({ queryKey: ['/api/user/events/created'] });\n      queryClient.invalidateQueries({ queryKey: ['/api/user/events/attending'] });\n      \n      // Pre-poblar la caché con los datos actualizados para evitar parpadeos\n      queryClient.setQueryData([`/api/events/${eventId}`], updatedEventData);\n      \n      // Disparar el evento personalizado 'event-updated' para que otros componentes se actualicen\n      if (updatedEventData && typeof window !== 'undefined') {\n        const customEvent = new CustomEvent('event-updated', {\n          detail: {\n            eventId,\n            data: updatedEventData,\n            source: 'edit-form'\n          }\n        });\n        window.dispatchEvent(customEvent);\n        console.log('Enviado evento personalizado de actualización:', eventId);\n      }\n      \n      // Mostrar notificación de éxito\n      toast({\n        title: \"Evento actualizado\",\n        description: \"Los cambios se han guardado correctamente\",\n      });\n      \n      // Cerrar el formulario - con un pequeño retraso para permitir que la caché se actualice\n      setTimeout(() => {\n        onClose();\n      }, 100);\n      \n    } catch (error) {\n      console.error('Error al actualizar evento:', error);\n      toast({\n        title: \"Error\",\n        description: error instanceof Error ? error.message : 'No se pudo actualizar el evento',\n        variant: \"destructive\",\n      });\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n  \n  // Manejar eliminación de evento\n  const handleDeleteEvent = async () => {\n    const confirmed = window.confirm(\"¿Estás seguro de que quieres eliminar este evento? Esta acción no se puede deshacer.\");\n    \n    if (!confirmed) return;\n    \n    setIsDeleting(true);\n    console.log(\"🗑️ Iniciando eliminación del evento:\", eventId);\n    \n    try {\n      // NO hacer optimistic update - esperar a que la API confirme\n      console.log(\"⏳ Esperando confirmación del servidor antes de actualizar UI\");\n      \n      // Hacer la llamada a la API\n      const response = await fetch(`/api/events/${eventId}`, {\n        method: 'DELETE',\n      });\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.message || 'Error al eliminar el evento');\n      }\n      \n      console.log(\"✅ Server confirmed deletion, now updating UI\");\n      \n      // Ahora que el servidor confirmó, eliminar del cache local\n      queryClient.setQueryData([\"/api/events\"], (oldData: any) => {\n        if (!oldData) return [];\n        return oldData.filter((event: any) => event.id !== eventId);\n      });\n      \n      // Eliminar del cache individual también\n      queryClient.removeQueries({ queryKey: [`/api/events/${eventId}`] });\n      \n      // Invalidar queries para asegurar consistencia\n      queryClient.invalidateQueries({ queryKey: ['events'] });\n      queryClient.invalidateQueries({ queryKey: ['user-events'] });\n      queryClient.invalidateQueries({ queryKey: ['/api/events'] });\n      queryClient.invalidateQueries({ queryKey: ['/api/user/events/created'] });\n      queryClient.invalidateQueries({ queryKey: ['/api/user/events/attending'] });\n      \n      console.log(\"🗑️ Cache updated, waiting for map refresh\");\n      \n      // Esperar a que el mapa se actualice completamente\n      await new Promise(resolve => setTimeout(resolve, 1500));\n      \n      // Verificar que el evento ya no esté en el cache\n      const eventsData = queryClient.getQueryData([\"/api/events\"]) as any[];\n      const eventStillExists = eventsData?.some((e: any) => e.id === eventId);\n      \n      if (eventStillExists) {\n        console.log(\"🔄 Event still in cache, waiting longer\");\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n      \n      console.log(\"🗑️ Deletion process complete, closing panels\");\n      \n      // Mostrar notificación de éxito\n      toast({\n        title: \"Evento eliminado\",\n        description: \"El evento ha sido eliminado correctamente\",\n      });\n      \n      // Cerrar panel de edición y llamar onEventUpdated para cerrar el panel de detalles también\n      onClose();\n      if (onEventUpdated) {\n        onEventUpdated();\n      }\n      \n      // Navegar al mapa principal\n      navigate('/');\n      \n    } catch (error) {\n      console.error('Error al eliminar evento:', error);\n      toast({\n        title: \"Error\",\n        description: error instanceof Error ? error.message : 'No se pudo eliminar el evento',\n        variant: \"destructive\",\n      });\n    } finally {\n      setIsDeleting(false);\n    }\n  };\n  \n  // Para verificar la vista actual (estilo de formulario diferente según la vista)\n  const currentPath = typeof window !== 'undefined' ? window.location.pathname : '';\n  const isMapView = currentPath === '/' || currentPath === '';\n  const isMyEventsEditView = currentPath === '/myevents' || currentPath.startsWith('/myevents/');\n  \n  // Formulario común para ambas vistas\n  const formContent = (\n    <Form {...form}>\n      <form onSubmit={form.handleSubmit(onSubmit)} className=\"pb-44 relative\">\n        {step === 1 ? (\n          /* Paso 1: Seleccionar ubicación */\n          <div className=\"px-4 py-3 space-y-4\">\n            <h2 className=\"text-base font-medium text-neutral-800\">Ubicación del evento</h2>\n            \n            {/* Buscador de direcciones */}\n            <div className=\"flex items-center space-x-2 mb-4\">\n              <Input \n                id=\"search-address\"\n                placeholder=\"Buscar dirección o lugar\" \n                className=\"flex-1\"\n                onKeyDown={(e) => {\n                  if (e.key === 'Enter') {\n                    e.preventDefault();\n                    searchAddress((e.target as HTMLInputElement).value);\n                  }\n                }}\n              />\n              <Button \n                type=\"button\" \n                variant=\"outline\"\n                onClick={() => {\n                  const input = document.getElementById('search-address') as HTMLInputElement;\n                  if (input && input.value) {\n                    searchAddress(input.value);\n                  }\n                }}\n              >\n                <Search className=\"h-4 w-4\" />\n              </Button>\n            </div>\n            \n            {/* Mapa para seleccionar ubicación */}\n            <div \n              ref={mapContainerRef} \n              className=\"w-full h-[300px] bg-slate-100 rounded-md mb-4\"\n            ></div>\n            \n            <div className=\"text-sm text-neutral-500 mb-2\">\n              Haz clic en el mapa para seleccionar la ubicación exacta\n            </div>\n            \n            {/* Campos ocultos para guardar las coordenadas */}\n            <FormField\n              control={form.control}\n              name=\"latitude\"\n              render={({ field }) => (\n                <FormItem className=\"hidden\">\n                  <FormControl>\n                    <Input type=\"text\" {...field} />\n                  </FormControl>\n                </FormItem>\n              )}\n            />\n            \n            <FormField\n              control={form.control}\n              name=\"longitude\"\n              render={({ field }) => (\n                <FormItem className=\"hidden\">\n                  <FormControl>\n                    <Input type=\"text\" {...field} />\n                  </FormControl>\n                </FormItem>\n              )}\n            />\n            \n            {/* Botón para continuar */}\n            <Button \n              type=\"button\" \n              onClick={() => setStep(2)}\n              className=\"w-full mt-4\"\n            >\n              Continuar\n            </Button>\n          </div>\n        ) : (\n          /* Paso 2: Información del evento */\n          <>\n            {/* Sección de detalles básicos */}\n            <div className=\"px-4 py-3 space-y-4\">\n              <div className=\"flex items-center justify-between\">\n                <h2 className=\"text-base font-medium text-neutral-800\">Detalles básicos</h2>\n                <Button \n                  type=\"button\" \n                  variant=\"outline\" \n                  size=\"sm\"\n                  onClick={() => setStep(1)}\n                >\n                  <MapIcon className=\"h-4 w-4 mr-1\" />\n                  Cambiar ubicación\n                </Button>\n              </div>\n              \n              <FormField\n                control={form.control}\n                name=\"title\"\n                render={({ field }) => (\n                  <FormItem>\n                    <FormLabel>Título del evento</FormLabel>\n                    <FormControl>\n                      <Input {...field} />\n                    </FormControl>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n              \n              <FormField\n                control={form.control}\n                name=\"description\"\n                render={({ field }) => (\n                  <FormItem>\n                    <FormLabel>Descripción</FormLabel>\n                    <FormControl>\n                      <Textarea \n                        placeholder=\"Describe tu evento...\" \n                        className=\"min-h-[120px]\" \n                        {...field} \n                      />\n                    </FormControl>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n              \n              <FormField\n                control={form.control}\n                name=\"category\"\n                render={({ field }) => (\n                  <FormItem>\n                    <FormLabel>Categoría</FormLabel>\n                    <Select \n                      defaultValue={field.value} \n                      onValueChange={field.onChange}\n                      value={field.value}\n                    >\n                      <FormControl>\n                        <SelectTrigger>\n                          <SelectValue placeholder=\"Selecciona una categoría\" />\n                        </SelectTrigger>\n                      </FormControl>\n                      <SelectContent>\n                        {EVENT_CATEGORIES.map((category) => (\n                          <SelectItem key={category.value} value={category.value}>\n                            {category.label}\n                          </SelectItem>\n                        ))}\n                      </SelectContent>\n                    </Select>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n              \n              <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n                <FormField\n                  control={form.control}\n                  name=\"date\"\n                  render={({ field }) => (\n                    <FormItem>\n                      <FormLabel>Fecha</FormLabel>\n                      <FormControl>\n                        <Input type=\"date\" {...field} />\n                      </FormControl>\n                      <FormMessage />\n                    </FormItem>\n                  )}\n                />\n                \n                <FormField\n                  control={form.control}\n                  name=\"time\"\n                  render={({ field }) => (\n                    <FormItem>\n                      <FormLabel>Hora</FormLabel>\n                      <FormControl>\n                        <Input type=\"time\" {...field} />\n                      </FormControl>\n                      <FormMessage />\n                    </FormItem>\n                  )}\n                />\n              </div>\n              \n              <FormField\n                control={form.control}\n                name=\"locationName\"\n                render={({ field }) => (\n                  <FormItem>\n                    <FormLabel>Nombre del lugar</FormLabel>\n                    <FormControl>\n                      <Input placeholder=\"Ej: Teatro Colón\" {...field} />\n                    </FormControl>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n              \n              <FormField\n                control={form.control}\n                name=\"locationAddress\"\n                render={({ field }) => (\n                  <FormItem>\n                    <FormLabel>Dirección</FormLabel>\n                    <FormControl>\n                      <Input placeholder=\"Ej: Calle Principal 123\" {...field} />\n                    </FormControl>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n            </div>\n            \n            {/* Sección de privacidad */}\n            <div className=\"px-4 py-3 space-y-4 border-t border-gray-100\">\n              <h2 className=\"text-base font-medium text-neutral-800\">Privacidad</h2>\n              \n              <FormField\n                control={form.control}\n                name=\"privacyType\"\n                render={({ field }) => (\n                  <FormItem className=\"mb-4\">\n                    <FormLabel>Tipo de Evento</FormLabel>\n                    <div className=\"flex w-full gap-2\">\n                      <Button\n                        type=\"button\"\n                        className={`flex-1 py-2 ${field.value === 'public' ? 'bg-primary text-white' : 'bg-white text-neutral-700 border border-neutral-300'}`}\n                        onClick={() => {\n                          form.setValue(\"privacyType\", \"public\");\n                          form.setValue(\"privateAccessType\", null);\n                          form.setValue(\"applicationQuestions\", null);\n                        }}\n                      >\n                        Público\n                      </Button>\n                      <Button\n                        type=\"button\" \n                        className={`flex-1 py-2 ${field.value === 'private' ? 'bg-primary text-white' : 'bg-white text-neutral-700 border border-neutral-300'}`}\n                        onClick={() => form.setValue(\"privacyType\", \"private\")}\n                      >\n                        Privado\n                      </Button>\n                    </div>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n              \n              {form.watch(\"privacyType\") === \"private\" && (\n                <FormField\n                  control={form.control}\n                  name=\"privateAccessType\"\n                  render={({ field }) => (\n                    <FormItem className=\"mb-4\">\n                      <FormLabel>Modo de Acceso</FormLabel>\n                      <div className=\"flex flex-col space-y-2\">\n                        <div className=\"flex items-center space-x-2\">\n                          <input\n                            type=\"radio\"\n                            id=\"solicitud\"\n                            value=\"solicitud\"\n                            checked={field.value === \"solicitud\"}\n                            onChange={() => form.setValue(\"privateAccessType\", \"solicitud\")}\n                            className=\"h-4 w-4 text-primary\"\n                          />\n                          <label htmlFor=\"solicitud\" className=\"text-neutral-700 text-sm\">\n                            Por solicitud (aprobar o rechazar)\n                          </label>\n                        </div>\n                        <div className=\"flex items-center space-x-2\">\n                          <input\n                            type=\"radio\"\n                            id=\"postulacion\"\n                            value=\"postulacion\"\n                            checked={field.value === \"postulacion\"}\n                            onChange={() => form.setValue(\"privateAccessType\", \"postulacion\")}\n                            className=\"h-4 w-4 text-primary\"\n                          />\n                          <label htmlFor=\"postulacion\" className=\"text-neutral-700 text-sm\">\n                            Por postulación (con preguntas)\n                          </label>\n                        </div>\n                        <div className=\"flex items-center space-x-2 opacity-50\">\n                          <input\n                            type=\"radio\"\n                            id=\"paga\"\n                            value=\"paga\"\n                            disabled\n                            checked={field.value === \"paga\"}\n                            onChange={() => {}}\n                            className=\"h-4 w-4 text-primary\"\n                          />\n                          <label htmlFor=\"paga\" className=\"text-neutral-700 text-sm\">\n                            Por pago (próximamente)\n                          </label>\n                        </div>\n                      </div>\n                      <FormMessage />\n                    </FormItem>\n                  )}\n                />\n              )}\n              \n              {/* Mostrar campo de preguntas solo si el tipo de acceso es por postulación */}\n              {form.watch(\"privateAccessType\") === \"postulacion\" && (\n                <FormField\n                  control={form.control}\n                  name=\"applicationQuestions\"\n                  render={({ field }) => (\n                    <FormItem>\n                      <FormLabel>Preguntas para postulantes</FormLabel>\n                      <FormControl>\n                        <Textarea \n                          placeholder=\"Escribe aquí las preguntas que los usuarios deben responder...\" \n                          className=\"min-h-[80px]\" \n                          value={field.value || ''}\n                          onChange={field.onChange}\n                          onBlur={field.onBlur}\n                          name={field.name}\n                          ref={field.ref}\n                        />\n                      </FormControl>\n                      <FormMessage />\n                    </FormItem>\n                  )}\n                />\n              )}\n              \n              <FormField\n                control={form.control}\n                name=\"paymentType\"\n                render={({ field }) => (\n                  <FormItem className=\"mb-4\">\n                    <FormLabel>Tipo de Pago</FormLabel>\n                    <div className=\"flex w-full gap-2\">\n                      <Button\n                        type=\"button\"\n                        className={`flex-1 py-2 ${field.value === 'free' ? 'bg-primary text-white' : 'bg-white text-neutral-700 border border-neutral-300'}`}\n                        onClick={() => {\n                          form.setValue(\"paymentType\", \"free\");\n                          form.setValue(\"price\", \"\");\n                        }}\n                      >\n                        Gratuito\n                      </Button>\n                      <Button\n                        type=\"button\" \n                        className={`flex-1 py-2 ${field.value === 'paid' ? 'bg-primary text-white' : 'bg-white text-neutral-700 border border-neutral-300'}`}\n                        onClick={() => form.setValue(\"paymentType\", \"paid\")}\n                        disabled\n                      >\n                        De pago (Próximamente)\n                      </Button>\n                    </div>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n              \n              {form.watch(\"paymentType\") === \"paid\" && (\n                <FormField\n                  control={form.control}\n                  name=\"price\"\n                  render={({ field }) => (\n                    <FormItem>\n                      <FormLabel>Precio (ARS $)</FormLabel>\n                      <FormControl>\n                        <Input \n                          type=\"number\" \n                          placeholder=\"Ej: 500\" \n                          {...field} \n                        />\n                      </FormControl>\n                      <FormMessage />\n                    </FormItem>\n                  )}\n                />\n              )}\n              \n              <FormField\n                control={form.control}\n                name=\"maxCapacity\"\n                render={({ field }) => (\n                  <FormItem>\n                    <FormLabel>Capacidad máxima (opcional)</FormLabel>\n                    <FormControl>\n                      <Input \n                        type=\"number\" \n                        placeholder=\"Deja en blanco si no hay límite\" \n                        {...field} \n                      />\n                    </FormControl>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n            </div>\n            \n            {/* Sección de multimedia */}\n            <div className=\"px-4 py-3 space-y-4 border-t border-gray-100\">\n              <h2 className=\"text-base font-medium text-neutral-800\">Multimedia</h2>\n              \n              <div className=\"relative mb-4\">\n                {/* Indicadores visuales de estado de guardado */}\n                {saveStatus === 'saving' && (\n                  <div className=\"absolute top-2 right-2 bg-blue-500/80 text-white text-xs px-3 py-1 rounded-full animate-pulse z-10 flex items-center gap-1\">\n                    <div className=\"w-2 h-2 bg-white rounded-full animate-spin\"></div>\n                    Guardando...\n                  </div>\n                )}\n                {saveStatus === 'saved' && (\n                  <div className=\"absolute top-2 right-2 bg-green-500/90 text-white text-xs px-3 py-1 rounded-full z-10 flex items-center gap-1\">\n                    <div className=\"w-2 h-2 bg-white rounded-full\"></div>\n                    ¡Guardado!\n                  </div>\n                )}\n                {saveStatus === 'error' && (\n                  <div className=\"absolute top-2 right-2 bg-red-500/90 text-white text-xs px-3 py-1 rounded-full z-10 flex items-center gap-1\">\n                    <div className=\"w-2 h-2 bg-white rounded-full\"></div>\n                    Error\n                  </div>\n                )}\n                {isAutoSaving && (\n                  <div className=\"absolute top-2 right-2 bg-primary/80 text-white text-xs px-2 py-1 rounded-md animate-pulse z-10\">\n                    Guardando cambios...\n                  </div>\n                )}\n                <FormField\n                  control={form.control}\n                  name=\"mediaItems\"\n                  render={({ field }) => (\n                    <FormItem>\n                      <FormControl>\n                        <MediaManager\n                          existingMedia={(() => {\n                            const processed = processMediaItems();\n                            console.log(\"📱 MediaManager recibiendo existingMedia:\", processed);\n                            return processed;\n                          })()}\n                          onChange={(newMediaItems) => {\n                            console.log(\"📱 MediaManager onChange en edit:\", newMediaItems.length, \"items\", newMediaItems);\n                            \n                            // Actualizar el estado local primero para la UI\n                            setMediaItems(newMediaItems);\n                            \n                            // Guardar el valor en el formulario también \n                            field.onChange(newMediaItems);\n                            \n                            // Mostrar indicador de cambio\n                            setSaveStatus('saving');\n                            setTimeout(() => setSaveStatus('saved'), 800);\n                            setTimeout(() => setSaveStatus('idle'), 2500);\n                          }}\n                        />\n                      </FormControl>\n                      <FormMessage />\n                    </FormItem>\n                  )}\n                />\n              </div>\n            </div>\n            \n            {/* Botones de acción */}\n            <div className=\"px-4 py-3 space-y-4 border-t border-gray-100 sticky bottom-0 bg-white z-10\">\n              <div className=\"flex justify-between items-center\">\n                <Button \n                  type=\"button\" \n                  variant=\"destructive\"\n                  onClick={handleDeleteEvent}\n                  disabled={isDeleting}\n                >\n                  {isDeleting ? (\n                    <><LoadingSpinner size={16} className=\"mr-2\" /> Eliminando</>\n                  ) : (\n                    \"Eliminar evento\"\n                  )}\n                </Button>\n                \n                <div className=\"flex space-x-2\">\n                  <Button \n                    type=\"button\" \n                    variant=\"outline\" \n                    onClick={onClose}\n                  >\n                    Cancelar\n                  </Button>\n                  <Button \n                    type=\"submit\" \n                    disabled={isSubmitting || isAutoSaving}\n                    className=\"relative\"\n                  >\n                    {isSubmitting ? (\n                      <><LoadingSpinner size={16} className=\"mr-2\" /> Guardando</>\n                    ) : isAutoSaving ? (\n                      <>\n                        <LoadingSpinner size={16} className=\"mr-2\" /> \n                        Auto-guardando...\n                      </>\n                    ) : (\n                      <>\n                        ✓ Guardar cambios\n                        <span className=\"text-xs ml-2 opacity-70\">(Auto-guardado activado)</span>\n                      </>\n                    )}\n                  </Button>\n                </div>\n              </div>\n            </div>\n          </>\n        )}\n      </form>\n    </Form>\n  );\n  \n  // Si estamos en la vista de mapa, solo mostramos el formulario como contenido simple\n  if (isMapView) {\n    return <div className=\"w-full\">{formContent}</div>;\n  }\n  \n  // En la vista de \"Mis eventos\", mostramos el formulario con un layout y título de página\n  return (\n    <div className=\"w-full rounded-xl bg-white overflow-hidden\">\n      <div className=\"sticky top-0 z-10 bg-white border-b border-gray-100\">\n        <div className=\"flex justify-between items-center p-4\">\n          <h3 className=\"text-lg font-medium\">Editar evento</h3>\n          <button \n            onClick={onClose}\n            className=\"rounded-full p-2 hover:bg-gray-100 transition-colors\"\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\" strokeLinecap=\"round\" strokeLinejoin=\"round\" className=\"lucide lucide-x\">\n              <path d=\"M18 6 6 18\"></path>\n              <path d=\"m6 6 12 12\"></path>\n            </svg>\n          </button>\n        </div>\n      </div>\n      {formContent}\n    </div>\n  );\n};\n\nexport default EditEventForm;","size_bytes":54248},"client/src/components/events/edit-event-sheet.tsx":{"content":"import React, { useState, useEffect, useRef } from \"react\";\nimport { useAuth } from \"@/hooks/use-auth\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useNavigation } from \"@/contexts/navigation-context\";\nimport EditEventFormGoogle from \"@/components/events/edit-event-form-google\";\nimport { Loader2, X, ArrowLeft } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\n\n// Componente para la edición de eventos en un panel deslizante\n\ninterface EditEventSheetProps {\n  eventId: number;\n  isOpen: boolean;\n  onClose: () => void;\n  onEventUpdated?: () => void; // Callback para cuando se actualiza un evento\n}\n\n// Componente para la edición de eventos en un panel deslizante\n\nconst EditEventSheet = ({ eventId, isOpen, onClose, onEventUpdated }: EditEventSheetProps) => {\n  console.log(\"Renderizando EditEventSheet, isOpen:\", isOpen);\n  const { user, isLoading: authLoading } = useAuth();\n  const { toast } = useToast();\n  const { hideNavigation, showNavigation } = useNavigation();\n  const [formVisible, setFormVisible] = useState(false);\n  const [closing, setClosing] = useState(false);\n  const [selectOpen, setSelectOpen] = useState(false); // Estado para controlar si hay menús desplegables abiertos\n  const [error500, setError500] = useState(false);\n  const sheetRef = useRef<HTMLDivElement>(null);\n  const editEventKey = useRef(0);\n  \n  // Control navigation visibility\n  useEffect(() => {\n    if (isOpen) {\n      hideNavigation();\n    } else {\n      showNavigation();\n    }\n    \n    // Cleanup: show navigation when component unmounts\n    return () => {\n      showNavigation();\n    };\n  }, [isOpen, hideNavigation, showNavigation]);\n\n  // Logs para depuración\n  useEffect(() => {\n    console.log(\"Panel de editar evento montado con estado:\", isOpen ? \"abierto\" : \"cerrado\");\n  }, []);\n  \n  // Log para depuración\n  useEffect(() => {\n    console.log(\"Estado de EditEventSheet:\", { isOpen, closing, formVisible, user: !!user, authLoading, eventId });\n  }, [isOpen, closing, formVisible, user, authLoading, eventId]);\n  \n  // Manejar cierre con animación\n  const handleClose = () => {\n    console.log(\"Iniciando cierre de EditEventSheet con animación\");\n    setClosing(true);\n    setTimeout(() => {\n      setClosing(false);\n      onClose();\n    }, 300); // Debe coincidir con la duración de la animación CSS\n  };\n\n  // Fetch event details\n  const { data: event, isLoading, error } = useQuery({\n    queryKey: [`/api/events/${eventId}`],\n    queryFn: async () => {\n      try {\n        console.log(\"Fetching event data for sheet, ID:\", eventId);\n        const response = await fetch(`/api/events/${eventId}`, {\n          credentials: 'include',\n        });\n        if (!response.ok) {\n          console.error(\"Error fetching event data:\", response.status, response.statusText);\n          if (response.status === 500) {\n            setError500(true);\n          }\n          throw new Error(`Failed to fetch event details: ${response.status}`);\n        }\n        const data = await response.json();\n        console.log(\"Event data fetched successfully:\", data);\n        console.log(\"🔍 SHEET DEBUG - media_items field:\", data.media_items);\n        console.log(\"🔍 SHEET DEBUG - mediaItems field:\", data.mediaItems);\n        console.log(\"🔍 SHEET DEBUG - main_media_url field:\", data.main_media_url);\n        console.log(\"🔍 SHEET DEBUG - mainMediaUrl field:\", data.mainMediaUrl);\n        return data;\n      } catch (err) {\n        console.error(\"Error in queryFn:\", err);\n        throw err;\n      }\n    },\n    enabled: isOpen && !!eventId && !isNaN(eventId),\n    retry: 1,\n  });\n\n  // Check authentication\n  useEffect(() => {\n    if (authLoading) return;\n    \n    if (!user) {\n      toast({\n        title: 'Autenticación Requerida',\n        description: 'Por favor inicia sesión para editar eventos',\n        variant: 'destructive',\n      });\n      handleClose();\n      return;\n    }\n  }, [user, authLoading, toast]);\n\n  // Check authorization when event is loaded\n  useEffect(() => {\n    if (!event || !user) return;\n    \n    // Check if event has organizer_id or organizerId (backend uses snake_case, frontend might use camelCase)\n    const eventOrganizerId = event.organizer_id || event.organizerId;\n    \n    if (!eventOrganizerId) {\n      // Log error and close\n      console.error('Error: El evento no tiene ID de organizador válido', event);\n      toast({\n        title: 'Error de Datos',\n        description: 'No se pudo verificar el organizador del evento',\n        variant: 'destructive',\n      });\n      handleClose();\n      return;\n    }\n    \n    // En caso de que event.organizer no esté presente pero sí tengamos organizer_id\n    if (!event.organizer) {\n      console.log('Advertencia: event.organizer no existe, pero sí existe organizer_id:', eventOrganizerId);\n    }\n    \n    // Check if user is the organizer (usando prioritariamente organizer_id del backend)\n    const organizerId = eventOrganizerId || (event.organizer && event.organizer.id);\n    \n    if (organizerId !== parseInt(String(user.id))) {\n      console.log(`Usuario ${user.id} intentó editar evento del organizador ${organizerId}`);\n      toast({\n        title: 'No Autorizado',\n        description: 'Solo el organizador puede editar este evento',\n        variant: 'destructive',\n      });\n      handleClose();\n      return;\n    }\n    \n    // If authenticated and authorized, show the form\n    setFormVisible(true);\n  }, [event, user, toast]);\n\n  // Estado para bloquear el cierre durante los primeros segundos\n  const [lockClosing, setLockClosing] = useState(false);\n\n  // Efecto para bloquear el cierre durante los primeros momentos después de abrir\n  useEffect(() => {\n    if (isOpen) {\n      // Bloquear inmediatamente cuando se abre\n      setLockClosing(true);\n      \n      // Mantener bloqueado durante 5 segundos\n      const timerId = setTimeout(() => {\n        setLockClosing(false);\n        console.log(\"🔓 Bloqueo de cierre liberado después de 5 segundos\");\n      }, 5000);\n      \n      return () => clearTimeout(timerId);\n    }\n  }, [isOpen]);\n\n  // Efecto para detectar cuando hay menús desplegables abiertos\n  useEffect(() => {\n    const checkDropdownState = () => {\n      // Buscar cualquier menú desplegable abierto en el DOM\n      const openMenus = document.querySelectorAll(\n        '[data-radix-popper-content-wrapper], [role=\"listbox\"], [data-state=\"open\"]'\n      );\n      const isOpen = openMenus.length > 0;\n      \n      if (isOpen !== selectOpen) {\n        console.log(`Estado global de menú select: ${isOpen ? \"ABIERTO\" : \"CERRADO\"}`);\n        setSelectOpen(isOpen);\n      }\n    };\n\n    // Ejecutar la comprobación periódicamente mientras el panel está abierto\n    const intervalId = isOpen ? setInterval(checkDropdownState, 100) : null;\n    \n    return () => {\n      if (intervalId) clearInterval(intervalId);\n    };\n  }, [isOpen, selectOpen]);\n\n  // Efecto para manejar clics fuera del panel - Solución drástica\n  useEffect(() => {\n    // Define global UI state if it doesn't exist\n    if (typeof window !== 'undefined' && !window.__PIPOL_UI_STATE) {\n      window.__PIPOL_UI_STATE = {\n        selectMenuOpen: false,\n        setSelectMenuOpen: (isOpen: boolean) => {\n          if (window.__PIPOL_UI_STATE) {\n            window.__PIPOL_UI_STATE.selectMenuOpen = isOpen;\n          }\n        },\n        preventPanelClose: false\n      };\n    }\n    \n    // Definir la zona segura del click (donde NO debe cerrarse el panel)\n    function isTargetSafeToClick(target: HTMLElement): boolean {\n      // -1. Si el panel está bloqueado por tiempo, NUNCA cerrar (primeros 5 segundos)\n      if (lockClosing) {\n        console.log(\"🔒 Panel bloqueado temporalmente - NO cerrar\");\n        return true;\n      }\n      \n      // 0. Si hay un menú desplegable abierto, SIEMPRE es seguro (NO cerrar)\n      if (selectOpen) {\n        console.log(\"🛡️ Menú desplegable abierto detectado - NO cerrar\");\n        return true;\n      }\n      \n      // 1. Si el clic está dentro del panel principal, es seguro (NO cerrar)\n      if (sheetRef.current && sheetRef.current.contains(target)) {\n        console.log(\"✅ Clic dentro del panel principal - NO cerrar\");\n        return true;\n      }\n      \n      // 2. Verificar si es parte de algún elemento UI desplegado (dropdown, popup, etc)\n      const uiSelectors = [\n        // Selectores específicos de ShadCN/Radix UI\n        '[data-radix-popper-content-wrapper]',\n        '[class*=\"SelectContent\"]',\n        '[class*=\"PopoverContent\"]',\n        '[class*=\"DropdownMenu\"]',\n        '[class*=\"radix-\"]',\n        '[class*=\"Dialog\"]',\n        '[role=\"listbox\"]',\n        '[role=\"dialog\"]',\n        '[role=\"menu\"]',\n        // Clases genéricas que podrían pertenecer a UI\n        '.select-content',\n        '.popup-menu',\n        '.dropdown-options',\n        '.calendar-popup'\n      ];\n      \n      // Si coincide con alguno de estos selectores, es seguro (NO cerrar)\n      for (const selector of uiSelectors) {\n        if (target.closest(selector)) {\n          console.log(`✅ Clic en elemento UI (${selector}) - NO cerrar`);\n          return true;\n        }\n      }\n      \n      // 3. Si llegamos aquí, no es seguro => CERRAR\n      console.log(\"❌ Clic fuera del panel y elementos UI - CERRAR\");\n      return false;\n    }\n\n    // Función para proteger los contenidos de dropdown específicamente\n    function protectDropdownContents() {\n      // Seleccionar todos los elementos de dropdown y portales\n      const allDropdowns = [\n        ...Array.from(document.querySelectorAll('[data-radix-popper-content-wrapper]')),\n        ...Array.from(document.querySelectorAll('[data-state=\"open\"]')),\n        ...Array.from(document.querySelectorAll('[data-radix-portal]')),\n        ...Array.from(document.querySelectorAll('[role=\"listbox\"]')),\n        ...Array.from(document.querySelectorAll('.select-dropdown-wrapper'))\n      ];\n      \n      allDropdowns.forEach(dropdown => {\n        // Verificar si ya está protegido\n        if (!dropdown.hasAttribute('data-pipol-protected')) {\n          // Marcar como protegido y agregar captura de eventos\n          dropdown.setAttribute('data-pipol-protected', 'true');\n          \n          // Agregar un objeto directo que intercepte clics en TODA el área\n          dropdown.addEventListener('mousedown', (e) => {\n            console.log(\"🔒 Interceptado clic en dropdown (protección especial)\");\n            e.stopPropagation();\n            e.preventDefault();\n          }, true);\n          \n          // Buscar todos los elementos clickeables y protegerlos\n          const clickables = dropdown.querySelectorAll('*');\n          clickables.forEach(el => {\n            el.addEventListener('mousedown', (e) => {\n              e.stopPropagation();\n            }, true);\n          });\n        }\n      });\n    }\n\n    // Ejecutar la protección inmediatamente y en intervalos\n    if (isOpen) {\n      protectDropdownContents();\n      const protectionInterval = setInterval(protectDropdownContents, 50);\n      setTimeout(() => clearInterval(protectionInterval), 5000); // Limpia después de 5 segundos\n    }\n\n    // Función que maneja el clic global\n    function handleGlobalClick(e: MouseEvent) {\n      const clickTarget = e.target as HTMLElement;\n      \n      // VERIFICACIÓN SUPER IMPORTANTE: Si tenemos un menú desplegable abierto con nuestra nueva lógica\n      if (window.__PIPOL_UI_STATE?.preventPanelClose) {\n        console.log(\"🚨 PROTECCIÓN GLOBAL ACTIVADA - NO cerrar bajo ninguna circunstancia\");\n        return;\n      }\n      \n      // VERIFICACIÓN DE DROPDOWN: Clic en un desplegable Radix?\n      if (clickTarget.closest('[data-radix-popper-content-wrapper]') || \n          clickTarget.closest('[role=\"listbox\"]') ||\n          clickTarget.closest('[data-radix-portal]') ||\n          clickTarget.closest('.select-dropdown-wrapper') ||\n          clickTarget.closest('[data-pipol-dropdown]') ||\n          clickTarget.closest('.pipol-dropdown-content')) {\n        console.log(\"🔒 Clic directo en dropdown Radix capturado - NO cerrar\");\n        e.stopPropagation();\n        return;\n      }\n      \n      // VERIFICACIÓN DEL ESTADO GLOBAL\n      if (window.__PIPOL_UI_STATE?.selectMenuOpen) {\n        console.log(\"🚨 Menú Select abierto según estado global - NO cerrar\");\n        return;\n      }\n      \n      // Verificación antigua para compatibilidad\n      const portals = document.querySelectorAll('[data-pipol-select-portal], [data-pipol-protected]');\n      let foundInPortal = false;\n      \n      portals.forEach(portal => {\n        if (portal.contains(clickTarget)) {\n          console.log(\"🛡️ Clic detectado dentro de un portal, ignorando cierre\");\n          foundInPortal = true;\n        }\n      });\n      \n      if (foundInPortal) {\n        return;\n      }\n      \n      // Si es un área segura donde hacer clic, NO cerramos\n      if (isTargetSafeToClick(clickTarget)) {\n        return;\n      }\n      \n      // Si llegamos aquí, cerrar el panel\n      handleClose();\n    }\n    \n    // Solo agregar listener cuando el panel está abierto\n    if (isOpen) {\n      // Usar capture: true para capturar el evento antes que otros handlers\n      document.addEventListener('mousedown', handleGlobalClick, true);\n    }\n    \n    // Limpiar el listener cuando se desmonta\n    return () => {\n      document.removeEventListener('mousedown', handleGlobalClick, true);\n    };\n  }, [isOpen, lockClosing, selectOpen]);\n\n  if (!isOpen) return null;\n\n  return (\n    <div \n      className=\"fixed inset-0 z-[999999] bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\"\n      onClick={(e) => {\n        // Si se hace clic directamente en el fondo oscuro (no en elementos hijos)\n        if (e.target === e.currentTarget) {\n          console.log(\"⚠️ Clic en fondo oscuro - cerrando panel\");\n          handleClose();\n        }\n      }}\n    >\n      <div \n        ref={sheetRef}\n        className={`absolute bottom-0 left-0 right-0 bg-white rounded-t-3xl shadow-panel z-[999999] flex flex-col event-panel ${closing ? 'slide-down' : 'slide-up'}`}\n        style={{ height: '90vh' }}\n        onClick={(e) => e.stopPropagation()} // Evita que clics en el panel blanco lleguen al fondo\n      >\n        {/* Barra superior con indicador de arrastre y título - fija */}\n        <div className=\"sticky top-0 z-10 bg-white rounded-t-3xl\">\n          <div className=\"p-2 flex justify-center\">\n            <div \n              className=\"w-10 h-1 bg-neutral-300 rounded-full cursor-pointer\"\n              onClick={handleClose}  \n            ></div>\n          </div>\n          \n          <div className=\"border-b border-gray-100\">\n            <div className=\"flex items-center justify-between p-4\">\n              <div className=\"flex items-center\">\n                <button onClick={handleClose} className=\"mr-3\">\n                  <ArrowLeft className=\"h-5 w-5\" />\n                </button>\n                <h2 className=\"text-lg font-medium\">Editar evento</h2>\n              </div>\n              <button onClick={handleClose} className=\"text-gray-500\">\n                <X className=\"h-5 w-5\" />\n              </button>\n            </div>\n          </div>\n        </div>\n        \n        {/* Contenido principal con scroll */}\n        <div className=\"flex-1 overflow-y-auto pb-20\" style={{ height: 'calc(90vh - 70px)', WebkitOverflowScrolling: 'touch' }}>\n          \n          {/* Loading state */}\n          {(isLoading || authLoading) && !formVisible && (\n            <div className=\"flex h-48 items-center justify-center\">\n              <Loader2 className=\"h-8 w-8 animate-spin text-primary\" />\n            </div>\n          )}\n          \n          {/* Error state */}\n          {error && !formVisible && !error500 && (\n            <div className=\"flex h-48 items-center justify-center\">\n              <div className=\"text-center p-4\">\n                <h2 className=\"text-lg font-semibold mb-2\">Error al cargar el evento</h2>\n                <p className=\"text-neutral-500\">No se pudo cargar la información del evento</p>\n                <Button \n                  className=\"mt-4\" \n                  onClick={handleClose}\n                >\n                  Volver\n                </Button>\n              </div>\n            </div>\n          )}\n          \n          {/* Handle errors from the server */}\n          {error500 && (\n            <div className=\"flex h-48 items-center justify-center\">\n              <div className=\"text-center p-4\">\n                <h2 className=\"text-lg font-semibold mb-2\">Error del servidor</h2>\n                <p className=\"text-neutral-500\">Hubo un problema procesando tu solicitud</p>\n                <Button \n                  className=\"mt-4\" \n                  onClick={handleClose}\n                >\n                  Volver\n                </Button>\n              </div>\n            </div>\n          )}\n          \n          {/* Event not found */}\n          {!event && !isLoading && !error && (\n            <div className=\"flex h-48 items-center justify-center\">\n              <div className=\"text-center p-4\">\n                <h2 className=\"text-lg font-semibold mb-2\">No se encontró el evento</h2>\n                <p className=\"text-neutral-500\">El evento que buscas no existe o no tienes acceso</p>\n                <Button \n                  className=\"mt-4\" \n                  onClick={handleClose}\n                >\n                  Volver\n                </Button>\n              </div>\n            </div>\n          )}\n          \n          {/* Render edit form when event loaded successfully */}\n          {event && formVisible && (\n            <div className=\"event-edit-container\">\n              <EditEventFormGoogle \n                eventId={event.id}\n                event={event}\n                visible={true}\n                onEventUpdated={() => {\n                  // Llamar al callback si existe\n                  if (onEventUpdated) {\n                    onEventUpdated();\n                  }\n                  \n                  // Emitir evento personalizado para asegurar que todas las vistas se actualicen\n                  // incluso si el WebSocket no funciona correctamente\n                  const eventUpdateEvent = new CustomEvent('event-updated', { \n                    detail: { eventId: event.id, data: event }\n                  });\n                  window.dispatchEvent(eventUpdateEvent);\n                  console.log('Evento personalizado emitido desde EditEventSheet para:', event.id);\n                }}\n                onClose={handleClose}\n              />\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n};\n\n// La interfaz Window.__PIPOL_UI_STATE ya está declarada en select.tsx\n\nexport default EditEventSheet;","size_bytes":18875},"client/src/components/events/event-detail-sheet.tsx":{"content":"import React, { useState, useEffect, useRef } from \"react\";\nimport { createPortal } from \"react-dom\";\nimport { motion, useAnimation } from \"framer-motion\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { apiRequest } from \"@/lib/queryClient\";\nimport { useLocation } from \"wouter\";\nimport {\n  CalendarIcon,\n  MapPin,\n  Users,\n  X,\n  MessageSquare,\n  Share2,\n  UserPlus,\n  Edit,\n  Trash2,\n  ChevronLeft,\n  ChevronRight,\n} from \"lucide-react\";\nimport { useAuth } from \"@/hooks/use-auth\";\nimport { Avatar } from \"@/components/ui/avatar\";\nimport { Button } from \"@/components/ui/button\";\nimport { useNavigation } from \"@/contexts/navigation-context\";\nimport { useUserProfile } from \"@/contexts/user-profile-context\";\nimport { useZIndex } from \"@/contexts/z-index-context\";\nimport { useMap } from \"@/contexts/MapContext\";\nimport { format } from \"date-fns\";\nimport { es } from \"date-fns/locale\";\nimport Chat from \"@/components/chat/chat\";\nimport EventRequests from \"@/components/events/event-requests\";\nimport EditEventForm from \"@/components/events/edit-event-form\";\nimport EditEventSheet from \"@/components/events/edit-event-sheet\";\nimport { formatPrice, formatAccessType } from \"@/lib/stripe\";\nimport mapboxgl from \"mapbox-gl\";\nimport useEmblaCarousel from \"embla-carousel-react\";\n\n// Declare Google Maps types for TypeScript\ndeclare global {\n  interface Window {\n    google: any;\n  }\n}\n\ntype EventDetailSheetProps = {\n  event: {\n    id: number;\n    title: string;\n    description: string;\n    category: string;\n    date: string;\n    locationName: string;\n    locationAddress: string;\n    paymentType: string;\n    price?: string | number;\n    maxCapacity?: number;\n    privacyType: string;\n    genderPreference?: string;\n    longitude?: number | string;\n    latitude?: number | string;\n    photoUrl?: string;\n    photo_url?: string;\n    videoUrl?: string;\n    video_url?: string;\n    // Campos multimedia nuevos\n    mediaItems?: string; // JSON string de items multimedia\n    mainMediaType?: string; // Tipo del medio principal ('photo' o 'video')\n    mainMediaUrl?: string; // URL del medio principal\n    // Campos de la base de datos (formato snake_case)\n    main_media_type?: string;\n    main_media_url?: string;\n    organizerId: number; // ID del organizador\n    organizer: {\n      id: number;\n      name: string;\n      avatar?: string;\n    };\n    attendees: Array<{\n      id: number;\n      user: {\n        id: number;\n        name: string;\n        avatar?: string;\n      };\n    }>;\n  } | null;\n  onClose: () => void;\n  visible: boolean;\n  onEventUpdated?: () => void;\n  openedFromChat?: boolean; // Indica si se abrió desde el chat\n};\n\nconst EventDetailSheet = ({\n  event: initialEvent,\n  onClose,\n  visible,\n  onEventUpdated,\n  openedFromChat = false,\n}: EventDetailSheetProps) => {\n  console.log(\n    \"🎯 EventDetailSheet: Component rendered with visible =\",\n    visible,\n    \"event =\",\n    initialEvent ? \"present\" : \"null\",\n  );\n\n  // Early return MUST be before any hooks - only check visible state for immediate closure\n  if (!visible) {\n    console.log(\n      \"🎯 EventDetailSheet: Early return - visible =\",\n      visible,\n      \"event =\",\n      initialEvent ? \"present\" : \"null\",\n    );\n    return null;\n  }\n\n  // Additional check for missing event after visible check\n  if (!initialEvent) {\n    console.log(\"🎯 EventDetailSheet: Early return - missing event\");\n    return null;\n  }\n\n  // Use initialEvent for the rest of the component (non-null after early return)\n  const currentEvent = initialEvent;\n\n  const { user } = useAuth();\n  const { toast } = useToast();\n  const [_, navigate] = useLocation();\n  const { hideNavigation, showNavigation } = useNavigation();\n  const { showUserProfile } = useUserProfile();\n  const { getNextZIndex } = useZIndex();\n  const { restoreCameraState } = useMap();\n  const [chatVisible, setChatVisible] = useState(false);\n  const [mapLoaded, setMapLoaded] = useState(false);\n  const [showRequests, setShowRequests] = useState(false);\n  const [editFormVisible, setEditFormVisible] = useState(false);\n  const [editSheetVisible, setEditSheetVisible] = useState(false);\n  const [isDeleting, setIsDeleting] = useState(false);\n  const [event, setEvent] = useState(initialEvent);\n  const [locationName, setLocationName] = useState<string>(\"\");\n  const [showAllAttendees, setShowAllAttendees] = useState(false);\n  const [currentZIndex, setCurrentZIndex] = useState(100);\n  const [hasAnimated, setHasAnimated] = useState(false);\n  const [isComingFromChat, setIsComingFromChat] = useState(false);\n  const [panelHeight, setPanelHeight] = useState(78); // Percentage height - Fixed at 78%\n  const [isDragging, setIsDragging] = useState(false);\n  const [dragStartY, setDragStartY] = useState(0);\n  const [dragStartHeight, setDragStartHeight] = useState(78);\n  const mapContainerRef = useRef<HTMLDivElement>(null);\n  const mapRef = useRef<mapboxgl.Map | null>(null);\n  const panelRef = useRef<HTMLDivElement>(null);\n  const detailPanelControls = useAnimation();\n\n  // Validar asistentes y estado de asistencia\n  const safeAttendees = currentEvent?.attendees || [];\n  const [isAttending, setIsAttending] = useState(false);\n\n  // Debug logs para verificar los asistentes\n  console.log(\"🎯 EventDetailSheet - Debug de asistentes:\");\n  console.log(\"currentEvent:\", currentEvent);\n  console.log(\"currentEvent.attendees:\", currentEvent?.attendees);\n  console.log(\"safeAttendees:\", safeAttendees);\n  console.log(\"safeAttendees.length:\", safeAttendees.length);\n\n  // Enhanced close handler that restores camera state before closing\n  const handleClose = () => {\n    console.log(\"🔄 EventDetailSheet: ANTES de restaurar estado de cámara\");\n    restoreCameraState();\n    console.log(\"🔄 EventDetailSheet: DESPUÉS de restaurar estado de cámara\");\n    onClose();\n  };\n\n  // Control navigation visibility and z-index with premium animations\n  useEffect(() => {\n    console.log(\"🎯 EventDetailSheet: Component effect, visible =\", visible);\n    if (visible && !hasAnimated && !isComingFromChat) {\n      console.log(\"🎯 EventDetailSheet: Hiding navigation\");\n      hideNavigation();\n      setHasAnimated(true);\n      \n      // Get new z-index when becoming visible\n      const newZIndex = getNextZIndex();\n      setCurrentZIndex(newZIndex);\n      console.log(`🎯 EventDetailSheet opened with z-index: ${newZIndex}`);\n    } else if (!visible && hasAnimated) {\n      setHasAnimated(false);\n      showNavigation();\n    }\n\n    // Cleanup to restore navigation when component unmounts or becomes invisible\n    return () => {\n      if (hasAnimated && !isComingFromChat) {\n        console.log(\"🎯 EventDetailSheet: Cleanup - Showing navigation\");\n        showNavigation();\n      }\n    };\n  }, [visible, hasAnimated, isComingFromChat, hideNavigation, showNavigation, getNextZIndex]);\n\n  // Actualizar el evento cuando cambia initialEvent\n  useEffect(() => {\n    setEvent(initialEvent);\n  }, [initialEvent]);\n\n  // Asegurarse de que la fecha sea válida\n  const eventDate = currentEvent.date\n    ? new Date(currentEvent.date)\n    : new Date();\n\n  // Escuchar el evento personalizado 'event-updated'\n  useEffect(() => {\n    const handleEventUpdate = (e: CustomEvent) => {\n      const { eventId, data } = e.detail;\n\n      // Verificar si este es nuestro evento\n      if (eventId === currentEvent.id && data) {\n        console.log(\n          \"Actualizando datos del evento en el panel de detalles mediante evento personalizado:\",\n          data,\n        );\n        setEvent(data);\n\n        // Adicionalmente, podríamos invalidar consultas de react-query si estamos usando esa librería\n        import(\"@/lib/queryClient\").then(({ queryClient }) => {\n          queryClient.invalidateQueries({ queryKey: [\"/api/events\"] });\n          queryClient.invalidateQueries({\n            queryKey: [`/api/events/${eventId}`],\n          });\n        });\n      }\n    };\n\n    // Agregar el listener\n    window.addEventListener(\n      \"event-updated\",\n      handleEventUpdate as EventListener,\n    );\n\n    // Limpiar al desmontar\n    return () => {\n      window.removeEventListener(\n        \"event-updated\",\n        handleEventUpdate as EventListener,\n      );\n    };\n  }, [currentEvent.id]);\n\n  // Verificar si el usuario está asistiendo al evento usando la API\n  useEffect(() => {\n    if (user && currentEvent.id) {\n      // Si el usuario es el organizador, automáticamente está \"asistiendo\"\n      const userIsOrganizer =\n        currentEvent.organizerId === parseInt(String(user.id)) ||\n        currentEvent.organizer?.id === parseInt(String(user.id));\n\n      if (userIsOrganizer) {\n        setIsAttending(true);\n        console.log(\"Usuario es organizador, automáticamente asistiendo\");\n        return;\n      }\n\n      const checkAttendanceStatus = async () => {\n        try {\n          const res = await fetch(`/api/events/${currentEvent.id}/status`, {\n            method: \"GET\",\n            credentials: \"include\",\n            headers: {\n              \"Content-Type\": \"application/json\",\n            },\n          });\n\n          if (res.ok) {\n            const data = await res.json();\n            // Si el usuario es organizador según la API, también está asistiendo\n            if (data.isOrganizer) {\n              setIsAttending(true);\n              console.log(\n                \"Usuario es organizador según la API, automáticamente asistiendo\",\n              );\n            } else if (data.isAttending) {\n              setIsAttending(true);\n              console.log(\"Usuario está asistiendo al evento según la API\");\n            } else {\n              setIsAttending(false);\n              console.log(\"Usuario no está asistiendo al evento según la API\");\n            }\n          } else if (res.status === 404) {\n            // Si la API responde con 404, el usuario no está asistiendo\n            setIsAttending(false);\n            console.log(\"Usuario no está asistiendo al evento según la API\");\n          }\n        } catch (error) {\n          console.error(\"Error verificando asistencia:\", error);\n          setIsAttending(false);\n        }\n      };\n\n      checkAttendanceStatus();\n    }\n  }, [\n    user,\n    currentEvent.id,\n    currentEvent.organizerId,\n    currentEvent.organizer?.id,\n  ]);\n\n  // Validar organizador - usar organizerId como fuente primaria\n  const isOrganizer =\n    user &&\n    (currentEvent.organizerId === parseInt(String(user.id)) ||\n      currentEvent.organizer?.id === parseInt(String(user.id)));\n\n  // Calcular capacidad y conteo\n  const spotsLeft = currentEvent.maxCapacity\n    ? currentEvent.maxCapacity - (safeAttendees.length || 0)\n    : null;\n  const attendeeCount = safeAttendees.length || 0;\n\n  // Fetch location name from Google Maps geocoding\n  useEffect(() => {\n    const fetchLocationName = async () => {\n      if (!currentEvent.latitude || !currentEvent.longitude) return;\n\n      try {\n        const lat =\n          typeof currentEvent.latitude === \"string\"\n            ? parseFloat(currentEvent.latitude)\n            : currentEvent.latitude;\n        const lng =\n          typeof currentEvent.longitude === \"string\"\n            ? parseFloat(currentEvent.longitude)\n            : currentEvent.longitude;\n\n        const response = await fetch(\n          `/api/google-proxy/geocode/json?latlng=${lat},${lng}`,\n        );\n        const data = await response.json();\n\n        if (data.results && data.results.length > 0) {\n          // Get the formatted address from the first result\n          const formattedAddress = data.results[0].formatted_address;\n          setLocationName(formattedAddress);\n        } else {\n          console.log(\"No geocoding results found for coordinates:\", {\n            lat,\n            lng,\n          });\n          setLocationName(\"Ubicación del evento\");\n        }\n      } catch (error) {\n        console.error(\"Error fetching location name:\", error);\n        setLocationName(\"Ubicación del evento\");\n      }\n    };\n\n    if (visible) {\n      fetchLocationName();\n    }\n  }, [visible, currentEvent.latitude, currentEvent.longitude]);\n\n  // Reset map loaded state when event changes\n  useEffect(() => {\n    setMapLoaded(false);\n    if (mapRef.current) {\n      mapRef.current.remove();\n      mapRef.current = null;\n    }\n  }, [currentEvent.id]);\n\n  // Inicializar el mapa cuando el componente sea visible\n  useEffect(() => {\n    if (\n      !visible ||\n      !mapContainerRef.current ||\n      mapLoaded ||\n      !currentEvent.latitude ||\n      !currentEvent.longitude\n    )\n      return;\n\n    const initializeMap = async () => {\n      // Try to get Mapbox token from server\n      let mapboxToken: string | null = null;\n      try {\n        const tokenResponse = await fetch(\"/api/mapbox-token\");\n        if (tokenResponse.ok) {\n          const tokenData = await tokenResponse.json();\n          mapboxToken = tokenData.token;\n        }\n      } catch (error) {\n        console.log(\"Could not fetch Mapbox token:\", error);\n      }\n\n      // Extraer las coordenadas desde los datos del evento y garantizar que son números\n      const location = {\n        longitude:\n          typeof currentEvent.longitude === \"string\"\n            ? parseFloat(currentEvent.longitude)\n            : currentEvent.longitude,\n        latitude:\n          typeof currentEvent.latitude === \"string\"\n            ? parseFloat(currentEvent.latitude)\n            : currentEvent.latitude,\n      };\n\n      try {\n        const lng = Number(location.longitude);\n        const lat = Number(location.latitude);\n\n        if (isNaN(lng) || isNaN(lat)) {\n          console.error(\"Invalid coordinates:\", { lat, lng });\n          return;\n        }\n\n        console.log(\"Initializing map with coordinates:\", { lat, lng });\n\n        // Use Google Maps instead of Mapbox for better integration\n        if (mapContainerRef.current) {\n          const initGoogleMap = () => {\n            if (mapContainerRef.current && window.google) {\n              const map = new window.google.maps.Map(mapContainerRef.current, {\n                center: { lat, lng },\n                zoom: 15,\n                mapTypeControl: false,\n                streetViewControl: false,\n                fullscreenControl: false,\n              });\n\n              // Add marker identical to Google's default blue but in yellow\n              new window.google.maps.Marker({\n                position: { lat, lng },\n                map: map,\n                icon: {\n                  url:\n                    \"data:image/svg+xml;charset=UTF-8,\" +\n                    encodeURIComponent(`\n                  <svg width=\"25\" height=\"41\" viewBox=\"0 0 25 41\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n                    <path d=\"M12.5 0C5.596 0 0 5.596 0 12.5C0 21.563 12.5 41 12.5 41S25 21.563 25 12.5C25 5.596 19.404 0 12.5 0Z\" fill=\"#FFEB3B\"/>\n                    <path d=\"M12.5 0C5.596 0 0 5.596 0 12.5C0 21.563 12.5 41 12.5 41S25 21.563 25 12.5C25 5.596 19.404 0 12.5 0Z\" stroke=\"#000000\" stroke-width=\"1\"/>\n                    <circle cx=\"12.5\" cy=\"12.5\" r=\"4\" fill=\"white\" stroke=\"#000000\" stroke-width=\"1\"/>\n                  </svg>\n                `),\n                  scaledSize: new window.google.maps.Size(25, 41),\n                  anchor: new window.google.maps.Point(12.5, 41),\n                },\n              });\n\n              setMapLoaded(true);\n            }\n          };\n\n          // Load Google Maps script dynamically\n          if (!window.google) {\n            fetch(\"/api/google-maps-key\")\n              .then((response) => response.json())\n              .then((apiKey) => {\n                const script = document.createElement(\"script\");\n                script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&libraries=places`;\n                script.onload = initGoogleMap;\n                document.head.appendChild(script);\n              })\n              .catch((error) => {\n                console.error(\"Error loading Google Maps:\", error);\n                // Fallback to simple display\n                if (mapContainerRef.current) {\n                  mapContainerRef.current.innerHTML = `\n                  <div style=\"width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: #f5f5f5; border-radius: 8px;\">\n                    <div style=\"text-align: center;\">\n                      <div style=\"font-size: 16px; color: #666; margin-bottom: 8px;\">📍 Ubicación del evento</div>\n                      <button onclick=\"window.open('https://www.google.com/maps?q=${lat},${lng}', '_blank')\" \n                              style=\"padding: 8px 16px; background: #4285f4; color: white; border: none; border-radius: 4px; cursor: pointer;\">\n                        Ver en Google Maps\n                      </button>\n                    </div>\n                  </div>\n                `;\n                }\n                setMapLoaded(true);\n              });\n          } else {\n            initGoogleMap();\n          }\n        }\n      } catch (error) {\n        console.error(\"Error initializing map:\", error);\n      }\n    };\n\n    initializeMap();\n  }, [\n    visible,\n    currentEvent.id,\n    currentEvent.latitude,\n    currentEvent.longitude,\n    mapLoaded,\n  ]);\n\n  const [joinRequestStatus, setJoinRequestStatus] = useState<string | null>(\n    null,\n  );\n\n  // Check if user has a pending request for this event\n  useEffect(() => {\n    if (user && event && !isAttending && !isOrganizer) {\n      const checkPendingRequest = async () => {\n        try {\n          const res = await apiRequest(\n            \"GET\",\n            `/api/events/${currentEvent.id}/status`,\n          );\n          if (res.ok) {\n            const data = await res.json();\n            if (data.status === \"pending\") {\n              setJoinRequestStatus(\"pending\");\n            }\n          }\n        } catch (error) {\n          console.error(\"Error checking request status:\", error);\n        }\n      };\n\n      checkPendingRequest();\n    }\n  }, [user, event, isAttending, isOrganizer]);\n\n  const [showApplicationForm, setShowApplicationForm] = useState(false);\n  const [applicationAnswers, setApplicationAnswers] = useState<string[]>([]);\n\n  const handleJoinEvent = async (answers?: string[]) => {\n    if (!user) {\n      toast({\n        title: \"Autenticación Requerida\",\n        description: \"Por favor inicia sesión para unirte a este evento\",\n        variant: \"destructive\",\n      });\n      navigate(\"/auth\");\n      return;\n    }\n\n    // Check if this is a private event with special access requirements\n    if (currentEvent.privacyType === 'private') {\n      const privateAccessType = (currentEvent as any).privateAccessType || (currentEvent as any).private_access_type;\n      \n      if (privateAccessType === 'postulacion' && !answers) {\n        // Show application form for \"postulación\" events\n        setShowApplicationForm(true);\n        return;\n      }\n      \n      if (privateAccessType === 'paga') {\n        // Handle payment for \"solo de pago\" events\n        try {\n          const res = await apiRequest(\n            \"POST\",\n            `/api/events/${currentEvent.id}/pay`,\n          );\n\n          if (!res.ok) {\n            const errorData = await res.json();\n            throw new Error(errorData.message || \"Error al procesar el pago\");\n          }\n\n          const data = await res.json();\n          \n          if (data.paymentSuccess) {\n            toast({\n              title: \"¡Pago Exitoso!\",\n              description: \"Te has unido al evento después del pago.\",\n            });\n\n            // Update attendance status\n            import(\"@/lib/queryClient\").then(({ queryClient }) => {\n              queryClient.invalidateQueries({ queryKey: [\"/api/events\"] });\n              setIsAttending(true);\n            });\n            return;\n          }\n        } catch (error) {\n          console.error(\"Error processing payment:\", error);\n          toast({\n            title: \"Error de Pago\",\n            description: error instanceof Error ? error.message : \"No se pudo procesar el pago.\",\n            variant: \"destructive\",\n          });\n          return;\n        }\n      }\n    }\n\n    try {\n      const requestBody = answers ? { answers } : {};\n      \n      const res = await apiRequest(\n        \"POST\",\n        `/api/events/${currentEvent.id}/join`,\n        requestBody\n      );\n\n      if (!res.ok) {\n        const errorData = await res.json();\n        \n        if (res.status === 402 && errorData.requiresPayment) {\n          // This shouldn't happen now since we handle payment above, but keep as fallback\n          toast({\n            title: \"Pago Requerido\",\n            description: \"Este evento requiere pago para acceder.\",\n            variant: \"destructive\",\n          });\n          return;\n        }\n        \n        throw new Error(errorData.message || \"Error al unirse al evento\");\n      }\n\n      const data = await res.json();\n\n      if (data.isPendingApproval) {\n        setJoinRequestStatus(\"pending\");\n        setShowApplicationForm(false); // Close application form\n        toast({\n          title: \"Solicitud Enviada\",\n          description: currentEvent.privacyType === 'private' && \n            ((currentEvent as any).privateAccessType === 'postulacion' || (currentEvent as any).private_access_type === 'postulacion')\n            ? \"Tu postulación ha sido enviada y está pendiente de revisión.\"\n            : \"Tu solicitud para unirte al evento ha sido enviada y está pendiente de aprobación.\",\n        });\n        return;\n      }\n\n      toast({\n        title: \"¡Éxito!\",\n        description: \"¡Te has unido al evento!\",\n      });\n\n      // Actualizar datos sin recargar\n      import(\"@/lib/queryClient\").then(({ queryClient }) => {\n        queryClient.invalidateQueries({ queryKey: [\"/api/events\"] });\n        // Verificar de nuevo el estado de asistencia\n        setIsAttending(true);\n      });\n    } catch (error) {\n      console.error(\"Error joining event:\", error);\n      toast({\n        title: \"Error\",\n        description:\n          error instanceof Error\n            ? error.message\n            : \"No se pudo unir al evento. Por favor intenta de nuevo.\",\n        variant: \"destructive\",\n      });\n    }\n  };\n\n  // Función para mostrar el perfil de un usuario\n  const handleShowUserProfile = (attendee: any) => {\n    if (attendee.user) {\n      showUserProfile({\n        id: attendee.user.id,\n        name: attendee.user.name,\n        email: attendee.user.email || `${attendee.user.name}@example.com`,\n        avatar: attendee.user.avatar,\n        username: attendee.user.username,\n        bio: attendee.user.bio\n      });\n    }\n  };\n\n  const handleLeaveEvent = async () => {\n    if (!user) {\n      toast({\n        title: \"Autenticación Requerida\",\n        description: \"Por favor inicia sesión para dejar este evento\",\n        variant: \"destructive\",\n      });\n      navigate(\"/login\");\n      return;\n    }\n\n    // Mostrar confirmación antes de dejar el evento\n    if (!window.confirm(\"¿Estás seguro que deseas dejar este evento?\")) {\n      return;\n    }\n\n    try {\n      const res = await apiRequest(\n        \"DELETE\",\n        `/api/events/${currentEvent.id}/leave`,\n      );\n\n      if (res.ok) {\n        toast({\n          title: \"¡Éxito!\",\n          description: \"Has dejado el evento exitosamente\",\n        });\n\n        // Actualizar datos sin recargar\n        import(\"@/lib/queryClient\").then(({ queryClient }) => {\n          queryClient.invalidateQueries({ queryKey: [\"/api/events\"] });\n          // Actualizar estado de asistencia\n          setIsAttending(false);\n          // Opcionalmente, cerrar el panel de detalles\n          handleClose();\n        });\n      } else {\n        const errorData = await res.json();\n        throw new Error(errorData.message || \"Error al dejar el evento\");\n      }\n    } catch (error) {\n      console.error(\"Error leaving event:\", error);\n      toast({\n        title: \"Error\",\n        description:\n          error instanceof Error\n            ? error.message\n            : \"No se pudo dejar el evento. Por favor intenta de nuevo.\",\n        variant: \"destructive\",\n      });\n    }\n  };\n\n  // Touch gesture handlers for panel manipulation\n  const handleTouchStart = (e: React.TouchEvent) => {\n    if (!panelRef.current) return;\n    const touch = e.touches[0];\n    setIsDragging(true);\n    setDragStartY(touch.clientY);\n    setDragStartHeight(panelHeight);\n    \n    // Prevent scrolling while dragging\n    document.body.style.overflow = 'hidden';\n  };\n\n  const handleTouchMove = (e: React.TouchEvent) => {\n    if (!isDragging || !panelRef.current) return;\n    \n    const touch = e.touches[0];\n    const deltaY = dragStartY - touch.clientY;\n    const viewportHeight = window.innerHeight;\n    const heightChange = (deltaY / viewportHeight) * 100;\n    \n    let newHeight = dragStartHeight + heightChange;\n    \n    // Constrain between 25% and 90%\n    newHeight = Math.max(25, Math.min(90, newHeight));\n    \n    setPanelHeight(newHeight);\n    \n    // Prevent default to stop page scrolling\n    e.preventDefault();\n  };\n\n  const handleTouchEnd = () => {\n    if (!isDragging) return;\n    \n    setIsDragging(false);\n    document.body.style.overflow = '';\n    \n    // Keep fixed height at 68% unless closing\n    let targetHeight: number;\n    \n    if (panelHeight < 40) {\n      // Close panel\n      targetHeight = 25;\n      setTimeout(() => handleClose(), 200);\n    } else {\n      // Always snap back to 78%\n      targetHeight = 78;\n    }\n    \n    setPanelHeight(targetHeight);\n  };\n\n  const handleMouseDown = (e: React.MouseEvent) => {\n    // Convert mouse events to touch-like events for desktop compatibility\n    const touch = { clientY: e.clientY };\n    setIsDragging(true);\n    setDragStartY(touch.clientY);\n    setDragStartHeight(panelHeight);\n    document.body.style.overflow = 'hidden';\n  };\n\n  const handleMouseMove = (e: MouseEvent) => {\n    if (!isDragging || !panelRef.current) return;\n    \n    const deltaY = dragStartY - e.clientY;\n    const viewportHeight = window.innerHeight;\n    const heightChange = (deltaY / viewportHeight) * 100;\n    \n    let newHeight = dragStartHeight + heightChange;\n    newHeight = Math.max(25, Math.min(90, newHeight));\n    \n    setPanelHeight(newHeight);\n  };\n\n  const handleMouseUp = () => {\n    if (!isDragging) return;\n    \n    setIsDragging(false);\n    document.body.style.overflow = '';\n    \n    let targetHeight: number;\n    \n    if (panelHeight < 40) {\n      targetHeight = 25;\n      setTimeout(() => handleClose(), 200);\n    } else {\n      // Always snap back to 78%\n      targetHeight = 78;\n    }\n    \n    setPanelHeight(targetHeight);\n  };\n\n  // Add mouse event listeners for desktop support\n  useEffect(() => {\n    if (isDragging) {\n      document.addEventListener('mousemove', handleMouseMove);\n      document.addEventListener('mouseup', handleMouseUp);\n      \n      return () => {\n        document.removeEventListener('mousemove', handleMouseMove);\n        document.removeEventListener('mouseup', handleMouseUp);\n      };\n    }\n  }, [isDragging, dragStartY, dragStartHeight, panelHeight]);\n\n  // Función para eliminar un evento\n\n  if (!visible) return null;\n\n  return (\n    <>\n      {/* Overlay to close when clicking outside - sin blur para mejor experiencia visual */}\n      <div\n        className=\"fixed inset-0\"\n        style={{ zIndex: currentZIndex - 1 }}\n        onClick={handleClose}\n      />\n\n      {/* Chat component */}\n      {chatVisible && (\n        <Chat\n          eventId={currentEvent.id}\n          eventTitle={currentEvent.title}\n          visible={chatVisible}\n          onClose={() => setChatVisible(false)}\n          eventImage={\n            (event as any).main_media_url || currentEvent.mainMediaUrl\n          }\n          parentZIndex={currentZIndex}\n          onHeaderClick={() => {\n            // Al hacer click en el header del chat, cerrar chat y abrir detalles del evento\n            setChatVisible(false);\n            // Dar tiempo para que se cierre el chat antes de abrir el panel de detalles\n            // Instead of timeout, immediately update z-index and trigger smooth transition\n            const newZIndex = getNextZIndex();\n            setCurrentZIndex(newZIndex);\n            setIsComingFromChat(true);\n            console.log(`🎯 EventDetailSheet reopened from chat with z-index: ${newZIndex}`);\n            \n            // Smooth forward slide animation like chat panel\n            detailPanelControls.start({\n              y: [\"10px\", \"-5px\", \"0px\"],\n              opacity: [0.8, 0.95, 1],\n              scale: [0.98, 1.02, 1],\n              transition: {\n                duration: 0.6,\n                times: [0, 0.6, 1],\n                ease: [0.23, 1, 0.32, 1]\n              }\n            });\n            \n            // Reset the flag after animation\n            setTimeout(() => setIsComingFromChat(false), 600);\n          }}\n        />\n      )}\n\n      {/* Formulario de edición (legacy) */}\n      {editFormVisible && (\n        <EditEventForm\n          eventId={currentEvent.id}\n          event={{\n            ...event,\n            latitude: currentEvent.latitude || \"\",\n            longitude: currentEvent.longitude || \"\",\n          }}\n          visible={editFormVisible}\n          onClose={() => {\n            setEditFormVisible(false);\n\n            // Hacer una petición para actualizar los datos del evento\n            const fetchUpdatedEvent = async () => {\n              try {\n                const response = await fetch(`/api/events/${currentEvent.id}`, {\n                  credentials: \"include\",\n                });\n\n                if (response.ok) {\n                  const updatedEventData = await response.json();\n                  console.log(\n                    \"Datos actualizados del evento obtenidos después de editar (legacy):\",\n                    updatedEventData,\n                  );\n\n                  // Actualizar el estado local con los datos actualizados\n                  setEvent(updatedEventData);\n                }\n              } catch (error) {\n                console.error(\n                  \"Error al obtener los datos actualizados del evento:\",\n                  error,\n                );\n              }\n            };\n\n            // Ejecutar la actualización\n            fetchUpdatedEvent();\n          }}\n        />\n      )}\n\n      {/* Panel de edición (nueva versión) */}\n      {editSheetVisible && (\n        <EditEventSheet\n          eventId={currentEvent.id}\n          isOpen={editSheetVisible}\n          onClose={() => {\n            // Cuando se cierra el panel de edición, forzamos una actualización de los datos\n            setEditSheetVisible(false);\n\n            // Hacer una petición para actualizar los datos del evento\n            const fetchUpdatedEvent = async () => {\n              try {\n                const response = await fetch(`/api/events/${currentEvent.id}`, {\n                  credentials: \"include\",\n                });\n\n                if (response.ok) {\n                  const updatedEventData = await response.json();\n                  console.log(\n                    \"Datos actualizados del evento obtenidos después de editar:\",\n                    updatedEventData,\n                  );\n\n                  // Actualizar el estado local con los datos actualizados\n                  setEvent(updatedEventData);\n                } else if (response.status === 404) {\n                  // El evento fue eliminado, cerrar el panel de detalles también\n                  console.log(\"🔒 Event not found (404), closing detail panel\");\n                  handleClose();\n                }\n              } catch (error) {\n                console.error(\n                  \"Error al obtener los datos actualizados del evento:\",\n                  error,\n                );\n                // Si hay un error de red u otro problema, también cerrar el panel\n                handleClose();\n              }\n            };\n\n            // Ejecutar la actualización\n            fetchUpdatedEvent();\n          }}\n          onEventUpdated={() => {\n            // Llamar al callback si existe\n            if (onEventUpdated) {\n              onEventUpdated();\n            }\n\n            // Emitir evento personalizado para asegurar que todas las vistas se actualicen\n            // incluso si el WebSocket no funciona correctamente\n            const eventUpdateEvent = new CustomEvent(\"event-updated\", {\n              detail: { eventId: currentEvent.id, data: event },\n            });\n            window.dispatchEvent(eventUpdateEvent);\n            console.log(\n              \"Evento personalizado emitido desde EventDetailSheet para:\",\n              currentEvent.id,\n            );\n\n            // Verificar si el evento aún existe después de la actualización\n            const verifyEventExists = async () => {\n              try {\n                const response = await fetch(`/api/events/${currentEvent.id}`, {\n                  credentials: \"include\",\n                });\n\n                if (response.status === 404) {\n                  // El evento fue eliminado durante la edición, cerrar este panel también\n                  console.log(\n                    \"🔒 Event deleted during editing, closing detail panel\",\n                  );\n                  handleClose();\n                }\n              } catch (error) {\n                console.error(\n                  \"Error verificando existencia del evento:\",\n                  error,\n                );\n              }\n            };\n\n            verifyEventExists();\n          }}\n        />\n      )}\n\n      <motion.div\n        animate={isComingFromChat ? detailPanelControls : { \n          y: [\"-8px\", \"0px\"],\n          opacity: 1,\n          scale: 1,\n          rotateX: 0,\n          transition: {\n            duration: 0.75,\n            times: [0, 1],\n            ease: [0.16, 1, 0.3, 1]\n          }\n        }}\n        initial={{ y: \"100%\", opacity: 0, scale: 0.93, rotateX: 5 }}\n        exit={{ \n          y: \"100%\", \n          opacity: 0, \n          scale: 0.95,\n          rotateX: 3,\n          transition: {\n            duration: 0.45,\n            ease: [0.4, 0, 0.6, 1]\n          }\n        }}\n        ref={panelRef}\n        className=\"fixed bottom-0 left-0 right-0 bg-white rounded-t-3xl shadow-panel flex flex-col transition-all duration-200 ease-out\"\n        style={{ \n          zIndex: currentZIndex,\n          transformStyle: \"preserve-3d\",\n          perspective: \"1000px\",\n          height: `${panelHeight}vh`,\n          maxHeight: '90vh'\n        }}\n        onClick={(e) => e.stopPropagation()}\n        onTouchStart={handleTouchStart}\n        onTouchMove={handleTouchMove}\n        onTouchEnd={handleTouchEnd}\n        onAnimationComplete={() => {\n          if (isComingFromChat) {\n            console.log(`🎬 EventDetailSheet special animation from chat completed`);\n          }\n        }}\n      >\n        <div \n          className=\"p-2 flex justify-center cursor-grab active:cursor-grabbing\"\n          onMouseDown={handleMouseDown}\n        >\n          <div className=\"w-12 h-1 bg-neutral-300 rounded-full\"></div>\n        </div>\n\n        <div\n          className=\"flex-1 overflow-y-auto p-5\"\n          style={{ \n            scrollBehavior: \"smooth\",\n            touchAction: isDragging ? 'none' : 'pan-y'\n          }}\n        >\n          <div className=\"flex items-start justify-between mb-4\">\n            <div>\n              <span\n                className={`inline-block px-2 py-1 text-xs font-medium category-${currentEvent.category}-light rounded-full mb-2`}\n              >\n                {currentEvent.category.charAt(0).toUpperCase() +\n                  currentEvent.category.slice(1)}\n              </span>\n              <h2 className=\"text-xl font-bold text-neutral-900\">\n                {currentEvent.title}\n              </h2>\n              <p className=\"text-neutral-500 flex items-center gap-1 mt-1\">\n                <CalendarIcon size={16} />\n                <span>\n                  {format(eventDate, \"EEE, d MMM • HH:mm\", { locale: es })}\n                </span>\n              </p>\n            </div>\n\n            <div className=\"flex items-center gap-2\">\n              {(isAttending || isOrganizer) && (\n                <button\n                  className=\"p-2 text-primary bg-primary/10 rounded-full\"\n                  onClick={() => setChatVisible(true)}\n                  aria-label=\"Abrir chat\"\n                >\n                  <MessageSquare size={20} />\n                </button>\n              )}\n              <button\n                className=\"p-2 text-neutral-400 hover:text-neutral-600 transition-colors\"\n                onClick={handleClose}\n                aria-label=\"Cerrar detalles\"\n              >\n                <X size={20} />\n              </button>\n            </div>\n          </div>\n\n          {/* Event multimedia */}\n          {(() => {\n            // Parse mediaItems to get all media items\n            let mediaItemsArray: MediaItem[] = [];\n            let hasValidMedia = false;\n\n            if (currentEvent.mediaItems) {\n              try {\n                if (typeof currentEvent.mediaItems === \"string\") {\n                  mediaItemsArray = JSON.parse(currentEvent.mediaItems);\n                } else if (Array.isArray(currentEvent.mediaItems)) {\n                  mediaItemsArray = currentEvent.mediaItems;\n                } else {\n                  mediaItemsArray = [];\n                }\n\n                // Filter out invalid items and ensure proper structure\n                mediaItemsArray = mediaItemsArray\n                  .filter((item: any) => {\n                    return (\n                      item &&\n                      item.url &&\n                      item.type &&\n                      (item.type === \"photo\" || item.type === \"video\")\n                    );\n                  })\n                  .map((item: any) => ({\n                    type: item.type,\n                    url: item.url,\n                    isMain: item.isMain === true,\n                    order: item.order || 0,\n                  }));\n\n                hasValidMedia = mediaItemsArray.length > 0;\n              } catch (error) {\n                console.error(\"Error parsing mediaItems in detail:\", error);\n                mediaItemsArray = [];\n              }\n            }\n\n            // Fallback to legacy media fields\n            const mainMediaUrl =\n              (event as any).main_media_url || currentEvent.mainMediaUrl;\n            const mainMediaType =\n              (event as any).main_media_type || currentEvent.mainMediaType;\n\n            if (!hasValidMedia && mainMediaUrl) {\n              const mediaType = mainMediaType === \"video\" ? \"video\" : \"photo\";\n              mediaItemsArray = [\n                {\n                  type: mediaType,\n                  url: mainMediaUrl,\n                  isMain: true,\n                },\n              ];\n              hasValidMedia = true;\n            }\n\n            if (!hasValidMedia || mediaItemsArray.length === 0) {\n              return null; // Don't render empty multimedia section\n            }\n\n            const allMediaItems = mediaItemsArray;\n\n            return (\n              <SimpleMediaCarousel\n                items={allMediaItems}\n                eventTitle={currentEvent.title}\n              />\n            );\n          })()}\n\n          {/* Organizer info */}\n          <div className=\"flex items-center justify-between mb-5\">\n            <div className=\"flex items-center gap-3\">\n              <Avatar className=\"w-12 h-12\">\n                <img\n                  src={\n                    currentEvent.organizer?.avatar ||\n                    `https://ui-avatars.com/api/?name=${encodeURIComponent(currentEvent.organizer?.name || \"Organizador\")}`\n                  }\n                  alt={currentEvent.organizer?.name || \"Organizador\"}\n                  className=\"w-full h-full object-cover\"\n                />\n              </Avatar>\n              <div>\n                <p className=\"text-sm text-neutral-500\">Organizado por</p>\n                <p className=\"font-medium\">\n                  {currentEvent.organizer?.name || \"Usuario\"}\n                </p>\n              </div>\n            </div>\n\n\n          </div>\n\n          {/* Event description - Enhanced version */}\n          <div className=\"mb-6\">\n            <div className=\"bg-gradient-to-r from-neutral-50 to-neutral-100 p-5 rounded-2xl border border-neutral-200/60\">\n              <div className=\"flex items-center gap-3 mb-3\">\n                <div className=\"bg-white p-2 rounded-lg\">\n                  <span className=\"text-xl\">👋</span>\n                </div>\n                <div>\n                  <p className=\"font-semibold text-neutral-800\">Acerca de este evento</p>\n                </div>\n              </div>\n              <div className=\"relative\">\n                <p className=\"text-neutral-700 leading-relaxed text-base whitespace-pre-wrap\">\n                  {currentEvent.description || \"El organizador no ha proporcionado una descripción para este evento.\"}\n                </p>\n                {currentEvent.description && currentEvent.description.length > 150 && (\n                  <div className=\"absolute bottom-0 right-0 bg-gradient-to-l from-neutral-100 to-transparent w-12 h-6 pointer-events-none rounded-bl-lg\"></div>\n                )}\n              </div>\n              {currentEvent.description && currentEvent.description.length > 300 && (\n                <div className=\"mt-3 pt-3 border-t border-neutral-200/60\">\n                  <p className=\"text-xs text-neutral-500 flex items-center gap-1\">\n                    <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\">\n                      <circle cx=\"12\" cy=\"12\" r=\"10\"/>\n                      <path d=\"M12 6v6l4 2\"/>\n                    </svg>\n                    Descripción detallada por el organizador\n                  </p>\n                </div>\n              )}\n            </div>\n          </div>\n\n\n          {/* Event details - Meetup style cards (without Host card) */}\n          <div className=\"space-y-3 mb-5\">\n            {/* Location card - show if we have any location data */}\n            {(currentEvent.locationName ||\n              currentEvent.locationAddress ||\n              currentEvent.latitude ||\n              currentEvent.longitude ||\n              (currentEvent as any).latitude ||\n              (currentEvent as any).longitude) && (\n              <div className=\"bg-neutral-100 p-4 rounded-xl\">\n                <div className=\"flex items-start gap-3 mb-3\">\n                  <div className=\"bg-white p-2 rounded-lg\">\n                    <svg\n                      xmlns=\"http://www.w3.org/2000/svg\"\n                      width=\"20\"\n                      height=\"20\"\n                      viewBox=\"0 0 24 24\"\n                      fill=\"none\"\n                      stroke=\"currentColor\"\n                      strokeWidth=\"2\"\n                      strokeLinecap=\"round\"\n                      strokeLinejoin=\"round\"\n                      className=\"text-neutral-600\"\n                    >\n                      <path d=\"M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z\" />\n                      <circle cx=\"12\" cy=\"10\" r=\"3\" />\n                    </svg>\n                  </div>\n                  <div>\n                    <p className=\"font-semibold text-neutral-800\">\n                      Ubicación del evento\n                    </p>\n                    <p className=\"text-sm text-neutral-600\">\n                      {currentEvent.locationAddress ||\n                        locationName ||\n                        currentEvent.locationName ||\n                        (currentEvent.latitude || (currentEvent as any).latitude\n                          ? `${(currentEvent.latitude || (currentEvent as any).latitude)?.toString().substring(0, 9)}, ${(currentEvent.longitude || (currentEvent as any).longitude)?.toString().substring(0, 10)}`\n                          : \"Ver ubicación en el mapa\")}\n                    </p>\n                  </div>\n                </div>\n                {/* Map display within the location card */}\n                {(currentEvent.latitude || (currentEvent as any).latitude) && \n                 (currentEvent.longitude || (currentEvent as any).longitude) && (\n                  <div\n                    ref={mapContainerRef}\n                    className=\"w-full h-48 rounded-lg overflow-hidden bg-gray-100\"\n                    style={{ border: \"1px solid #e5e5e5\", minHeight: \"192px\" }}\n                  ></div>\n                )}\n              </div>\n            )}\n\n            {/* Date and time card */}\n            <div className=\"bg-neutral-100 p-4 rounded-xl\">\n              <div className=\"flex items-start gap-3\">\n                <div className=\"bg-white p-2 rounded-lg\">\n                  <svg\n                    xmlns=\"http://www.w3.org/2000/svg\"\n                    width=\"20\"\n                    height=\"20\"\n                    viewBox=\"0 0 24 24\"\n                    fill=\"none\"\n                    stroke=\"currentColor\"\n                    strokeWidth=\"2\"\n                    strokeLinecap=\"round\"\n                    strokeLinejoin=\"round\"\n                    className=\"text-neutral-600\"\n                  >\n                    <rect x=\"3\" y=\"4\" width=\"18\" height=\"18\" rx=\"2\" ry=\"2\" />\n                    <line x1=\"16\" y1=\"2\" x2=\"16\" y2=\"6\" />\n                    <line x1=\"8\" y1=\"2\" x2=\"8\" y2=\"6\" />\n                    <line x1=\"3\" y1=\"10\" x2=\"21\" y2=\"10\" />\n                  </svg>\n                </div>\n                <div>\n                  <p className=\"font-semibold text-neutral-800\">\n                    {new Date(currentEvent.date).toLocaleDateString(\"en-US\", {\n                      month: \"short\",\n                      day: \"numeric\",\n                      year: \"numeric\",\n                    })}\n                  </p>\n                  <p className=\"text-sm text-neutral-600\">\n                    {new Date(currentEvent.date).toLocaleTimeString(\"en-US\", {\n                      hour: \"2-digit\",\n                      minute: \"2-digit\",\n                      hour12: true,\n                    })}\n                    {(currentEvent as any).endTime && (\n                      <span>\n                        {\" \"}\n                        -{\" \"}\n                        {new Date(\n                          (currentEvent as any).endTime,\n                        ).toLocaleTimeString(\"en-US\", {\n                          hour: \"2-digit\",\n                          minute: \"2-digit\",\n                          hour12: true,\n                        })}\n                      </span>\n                    )}\n                  </p>\n                </div>\n              </div>\n            </div>\n\n            {/* Gender preference card */}\n            {(currentEvent as any).gender_preference && (\n              <div className=\"bg-neutral-100 p-4 rounded-xl\">\n                <div className=\"flex items-start gap-3\">\n                  <div className=\"bg-white p-2 rounded-lg\">\n                    <svg\n                      xmlns=\"http://www.w3.org/2000/svg\"\n                      width=\"20\"\n                      height=\"20\"\n                      viewBox=\"0 0 24 24\"\n                      fill=\"none\"\n                      stroke=\"currentColor\"\n                      strokeWidth=\"2\"\n                      strokeLinecap=\"round\"\n                      strokeLinejoin=\"round\"\n                      className=\"text-neutral-600\"\n                    >\n                      <path d=\"M16 4a4 4 0 0 1 0 8 4 4 0 0 1 0-8z\" />\n                      <path d=\"M16 12v6\" />\n                      <path d=\"M8 20a4 4 0 0 1 0-8 4 4 0 0 1 0 8z\" />\n                      <path d=\"M8 12V6\" />\n                    </svg>\n                  </div>\n                  <div>\n                    <p className=\"font-semibold text-neutral-800\">Destinado Para</p>\n                    <p className=\"text-sm text-neutral-600\">\n                      {((currentEvent as any).gender_preference === 'all_people' || (currentEvent as any).gender_preference === 'mixto') && 'Todas Las Personas'}\n                      {(currentEvent as any).gender_preference === 'men' && 'Hombres'}\n                      {(currentEvent as any).gender_preference === 'women' && 'Mujeres'}\n                    </p>\n                  </div>\n                </div>\n              </div>\n            )}\n\n            {/* Going section */}\n            <div \n              className=\"bg-neutral-100 p-4 rounded-xl cursor-pointer hover:bg-neutral-200 transition-colors\"\n              onClick={() => attendeeCount > 0 && setShowAllAttendees(true)}\n            >\n              <div className=\"flex items-start justify-between\">\n                <div className=\"flex items-start gap-3\">\n                  {/* Person icon with same style as other icons */}\n                  <div className=\"bg-white p-2 rounded-lg\">\n                    <Users className=\"w-5 h-5 text-neutral-600\" />\n                  </div>\n                  <div>\n                    <p className=\"font-semibold text-neutral-800\">Yendo</p>\n                    <p className=\"text-sm text-neutral-600\">\n                      {attendeeCount > 0 ? `${attendeeCount} asistente${attendeeCount > 1 ? 's' : ''}` : 'aun nadie se unio al evento'}\n                    </p>\n                  </div>\n                </div>\n\n                {/* Attendee avatars - show if there are attendees */}\n                {attendeeCount > 0 && (\n                  <div className=\"flex -space-x-1\">\n                    {safeAttendees.slice(0, 8).map((attendee, index) => (\n                      <Avatar\n                        key={attendee.id}\n                        className=\"w-7 h-7 border-2 border-white cursor-pointer hover:scale-110 transition-transform\"\n                        onClick={(e) => {\n                          e.stopPropagation();\n                          handleShowUserProfile(attendee);\n                        }}\n                      >\n                        <img\n                          src={\n                            attendee.user?.avatar ||\n                            `https://ui-avatars.com/api/?name=${encodeURIComponent(attendee.user?.name || \"Usuario\")}&background=random`\n                          }\n                          alt={attendee.user?.name || \"Usuario\"}\n                          className=\"w-full h-full object-cover\"\n                        />\n                      </Avatar>\n                    ))}\n                    {attendeeCount > 8 && (\n                      <div className=\"w-7 h-7 rounded-full bg-gray-500 border-2 border-white flex items-center justify-center\">\n                        <span className=\"text-xs font-bold text-white\">\n                          +{attendeeCount - 8}\n                        </span>\n                      </div>\n                    )}\n                  </div>\n                )}\n              </div>\n            </div>\n          </div>\n\n          {/* Join event button */}\n          <div className=\"mb-5\">\n            {!isOrganizer &&\n              !isAttending &&\n              joinRequestStatus !== \"pending\" && \n              !showApplicationForm && (\n                <Button\n                  className=\"w-full py-4 bg-yellow-400 text-black font-semibold rounded-full text-lg hover:bg-yellow-500\"\n                  onClick={() => handleJoinEvent()}\n                >\n                  {currentEvent.privacyType === 'private' \n                    ? (() => {\n                        const accessType = (currentEvent as any).privateAccessType || (currentEvent as any).private_access_type;\n                        if (accessType === 'solicitud') return 'Quiero unirme (con solicitud)';\n                        if (accessType === 'postulacion') return 'Quiero unirme (con postulación)';\n                        if (accessType === 'paga') return 'Quiero unirme (con pago)';\n                        return 'Quiero unirme (con solicitud)';\n                      })()\n                    : 'Quiero unirme'\n                  }\n                </Button>\n              )}\n\n            {/* Application Form for \"postulación\" events */}\n            {showApplicationForm && (\n              <div className=\"bg-white border rounded-xl p-4 space-y-4\">\n                <div className=\"flex items-center justify-between\">\n                  <h3 className=\"font-semibold text-lg\">Postulación al Evento</h3>\n                  <Button\n                    variant=\"ghost\"\n                    size=\"sm\"\n                    onClick={() => setShowApplicationForm(false)}\n                  >\n                    ✕\n                  </Button>\n                </div>\n                \n                <div className=\"space-y-3\">\n                  {(() => {\n                    try {\n                      const questionsData = (currentEvent as any).applicationQuestions || (currentEvent as any).application_questions;\n                      const questions = questionsData ? JSON.parse(questionsData) : ['¿Por qué te interesa este evento?', '¿Qué esperas obtener de esta experiencia?'];\n                      \n                      return questions.map((question: string, index: number) => (\n                        <div key={index}>\n                          <label className=\"block text-sm font-medium text-gray-700 mb-1\">\n                            {question}\n                          </label>\n                          <textarea\n                            className=\"w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-yellow-400 focus:border-transparent\"\n                            rows={3}\n                            value={applicationAnswers[index] || ''}\n                            onChange={(e) => {\n                              const newAnswers = [...applicationAnswers];\n                              newAnswers[index] = e.target.value;\n                              setApplicationAnswers(newAnswers);\n                            }}\n                            placeholder=\"Tu respuesta...\"\n                          />\n                        </div>\n                      ));\n                    } catch (e) {\n                      console.error('Error parsing application questions:', e);\n                      return (\n                        <div>\n                          <label className=\"block text-sm font-medium text-gray-700 mb-1\">\n                            ¿Por qué te interesa este evento?\n                          </label>\n                          <textarea\n                            className=\"w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-yellow-400 focus:border-transparent\"\n                            rows={3}\n                            value={applicationAnswers[0] || ''}\n                            onChange={(e) => {\n                              const newAnswers = [...applicationAnswers];\n                              newAnswers[0] = e.target.value;\n                              setApplicationAnswers(newAnswers);\n                            }}\n                            placeholder=\"Tu respuesta...\"\n                          />\n                        </div>\n                      );\n                    }\n                  })()}\n                </div>\n                \n                <div className=\"flex gap-2\">\n                  <Button\n                    variant=\"outline\"\n                    className=\"flex-1\"\n                    onClick={() => setShowApplicationForm(false)}\n                  >\n                    Cancelar\n                  </Button>\n                  <Button\n                    className=\"flex-1 bg-yellow-400 text-black hover:bg-yellow-500\"\n                    onClick={() => handleJoinEvent(applicationAnswers)}\n                    disabled={applicationAnswers.every(answer => !answer?.trim())}\n                  >\n                    Enviar Postulación\n                  </Button>\n                </div>\n              </div>\n            )}\n\n            {joinRequestStatus === \"pending\" && (\n              <div className=\"flex flex-col space-y-2\">\n                <div className=\"bg-amber-100 text-amber-800 px-4 py-3 rounded-xl flex items-center gap-2\">\n                  <svg\n                    xmlns=\"http://www.w3.org/2000/svg\"\n                    width=\"20\"\n                    height=\"20\"\n                    viewBox=\"0 0 24 24\"\n                    fill=\"none\"\n                    stroke=\"currentColor\"\n                    strokeWidth=\"2\"\n                    strokeLinecap=\"round\"\n                    strokeLinejoin=\"round\"\n                  >\n                    <path d=\"M10.42 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v10.42\"></path>\n                    <path d=\"M18 18m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0\"></path>\n                    <path d=\"M18 14.5V21\"></path>\n                  </svg>\n                  <span>\n                    {currentEvent.privacyType === 'private' && \n                     ((currentEvent as any).privateAccessType === 'postulacion' || (currentEvent as any).private_access_type === 'postulacion')\n                      ? 'Postulación pendiente de revisión'\n                      : 'Solicitud pendiente de aprobación'\n                    }\n                  </span>\n                </div>\n                <Button\n                  variant=\"destructive\"\n                  className=\"px-6 py-2 text-sm rounded-xl\"\n                  onClick={handleLeaveEvent}\n                >\n                  Cancelar {currentEvent.privacyType === 'private' && \n                           ((currentEvent as any).privateAccessType === 'postulacion' || (currentEvent as any).private_access_type === 'postulacion')\n                           ? 'Postulación' : 'Solicitud'}\n                </Button>\n              </div>\n            )}\n\n            {isAttending && joinRequestStatus !== \"pending\" && !isOrganizer && (\n              <div className=\"space-y-3\">\n                <Button\n                  className=\"w-full py-4 bg-primary text-white font-semibold rounded-xl text-lg hover:bg-primary/90 flex items-center justify-center gap-2\"\n                  onClick={() => setChatVisible(true)}\n                >\n                  <MessageSquare size={20} />\n                  Chat del evento\n                </Button>\n                <Button\n                  variant=\"destructive\"\n                  className=\"w-full py-4 font-semibold rounded-xl text-lg\"\n                  onClick={handleLeaveEvent}\n                >\n                  Abandonar Evento\n                </Button>\n              </div>\n            )}\n\n            {isOrganizer && (\n              <div className=\"space-y-4\">\n                <div className=\"flex items-center justify-center gap-2\">\n                  <Button\n                    variant=\"outline\"\n                    className=\"border-primary text-primary px-6 py-3 font-semibold rounded-xl\"\n                    onClick={() => setEditSheetVisible(true)}\n                  >\n                    Administrar\n                  </Button>\n\n                  {currentEvent.privacyType === \"private\" && (\n                    <Button\n                      variant=\"outline\"\n                      className=\"flex items-center gap-1\"\n                      onClick={() => setShowRequests(!showRequests)}\n                    >\n                      <UserPlus size={18} />\n                      <span>Solicitudes</span>\n                    </Button>\n                  )}\n                </div>\n\n                {/* Event requests management section */}\n                {showRequests && currentEvent.privacyType === \"private\" && (\n                  <div className=\"mt-6 border rounded-lg p-4 bg-neutral-50\">\n                    <EventRequests\n                      eventId={currentEvent.id}\n                      onStatusChange={() => {\n                        // Refrescar los datos al cambiar el estado de una solicitud\n                        toast({\n                          title: \"Actualizado\",\n                          description:\n                            \"La solicitud ha sido procesada exitosamente\",\n                        });\n                      }}\n                    />\n                  </div>\n                )}\n              </div>\n            )}\n          </div>\n        </div>\n      </motion.div>\n\n      {/* Modal para mostrar todos los asistentes */}\n      {showAllAttendees && (\n        <div\n          className=\"fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center p-4\"\n          style={{ zIndex: currentZIndex + 10 }}\n          onClick={() => setShowAllAttendees(false)}\n        >\n          <div\n            className=\"bg-white rounded-2xl max-w-md w-full max-h-[70vh] overflow-hidden shadow-2xl\"\n            onClick={(e) => e.stopPropagation()}\n          >\n            <div className=\"flex items-center justify-between p-4 border-b border-gray-200\">\n              <h3 className=\"text-lg font-semibold text-gray-900\">\n                Asistentes ({attendeeCount})\n              </h3>\n              <button\n                onClick={() => setShowAllAttendees(false)}\n                className=\"p-2 hover:bg-gray-100 rounded-full transition-colors\"\n              >\n                <X className=\"w-5 h-5 text-gray-500\" />\n              </button>\n            </div>\n            <div className=\"p-4 overflow-y-auto max-h-[calc(70vh-80px)]\">\n              <div className=\"space-y-3\">\n                {safeAttendees.map((attendee, index) => (\n                  <div\n                    key={attendee.id}\n                    className=\"flex items-center gap-3 p-2 hover:bg-gray-50 rounded-lg cursor-pointer transition-colors\"\n                    onClick={() => {\n                      handleShowUserProfile(attendee);\n                      setShowAllAttendees(false);\n                    }}\n                  >\n                    <Avatar className=\"w-10 h-10\">\n                      <img\n                        src={\n                          attendee.user?.avatar ||\n                          `https://ui-avatars.com/api/?name=${encodeURIComponent(attendee.user?.name || \"Usuario\")}&background=random`\n                        }\n                        alt={attendee.user?.name || \"Usuario\"}\n                        className=\"w-full h-full object-cover\"\n                      />\n                    </Avatar>\n                    <div>\n                      <p className=\"font-medium text-gray-900\">\n                        {attendee.user?.name || \"Usuario\"}\n                      </p>\n                      {(attendee.user as any)?.username && (\n                        <p className=\"text-sm text-gray-500\">\n                          @{(attendee.user as any).username}\n                        </p>\n                      )}\n                    </div>\n                  </div>\n                ))}\n              </div>\n            </div>\n          </div>\n        </div>\n      )}\n    </>\n  );\n};\n\n// Componente de carrusel estilo Instagram para elementos multimedia\ntype MediaItem = {\n  type: \"photo\" | \"video\";\n  url: string;\n  isMain?: boolean;\n  order?: number;\n};\n\ntype MediaCarouselProps = {\n  items: MediaItem[];\n  eventTitle: string;\n};\n\nconst SimpleMediaCarousel = ({ items, eventTitle }: MediaCarouselProps) => {\n  const [currentIndex, setCurrentIndex] = useState(0);\n  const [isLightboxOpen, setIsLightboxOpen] = useState(false);\n  const [lightboxIndex, setLightboxIndex] = useState(0);\n\n  // Prevenir scroll del body cuando el lightbox esté abierto\n  useEffect(() => {\n    if (isLightboxOpen) {\n      document.body.style.overflow = 'hidden';\n      return () => {\n        document.body.style.overflow = 'unset';\n      };\n    }\n  }, [isLightboxOpen]);\n\n  if (!items || items.length === 0) return null;\n\n  const nextSlide = () => {\n    setCurrentIndex((prev) => (prev + 1) % items.length);\n  };\n\n  const prevSlide = () => {\n    setCurrentIndex((prev) => (prev - 1 + items.length) % items.length);\n  };\n\n  const openLightbox = (index: number) => {\n    setLightboxIndex(index);\n    setIsLightboxOpen(true);\n    document.body.style.overflow = 'hidden'; // Prevent scrolling\n  };\n\n  const closeLightbox = () => {\n    setIsLightboxOpen(false);\n    document.body.style.overflow = ''; // Re-enable scrolling\n  };\n\n  const nextLightboxSlide = () => {\n    setLightboxIndex((prev) => (prev + 1) % items.length);\n  };\n\n  const prevLightboxSlide = () => {\n    setLightboxIndex((prev) => (prev - 1 + items.length) % items.length);\n  };\n\n  const currentItem = items[currentIndex];\n\n  // Safety check for currentItem\n  if (!currentItem || !currentItem.type || !currentItem.url) {\n    return null;\n  }\n\n  return (\n    <>\n      <div className=\"mb-5\">\n        <h3 className=\"font-semibold mb-3\">Contenido multimedia</h3>\n        <div className=\"relative aspect-[4/5] rounded-lg overflow-hidden bg-black\">\n          {/* Current media item */}\n          {currentItem.type === \"video\" ? (\n            <video\n              key={currentIndex}\n              src={currentItem.url}\n              className=\"w-full h-full object-cover\"\n              preload=\"metadata\"\n              controls\n            />\n          ) : (\n            <img\n              src={currentItem.url}\n              alt={`${eventTitle} - imagen ${currentIndex + 1}`}\n              className=\"w-full h-full object-cover cursor-pointer\"\n              onClick={() => openLightbox(currentIndex)}\n            />\n          )}\n\n          {/* Navigation arrows */}\n          {items.length > 1 && (\n            <>\n              <button\n                onClick={prevSlide}\n                className=\"absolute left-2 top-1/2 transform -translate-y-1/2 bg-white/80 text-gray-800 rounded-full p-2 hover:bg-white transition-colors shadow-md z-10\"\n              >\n                <ChevronLeft size={16} />\n              </button>\n              <button\n                onClick={nextSlide}\n                className=\"absolute right-2 top-1/2 transform -translate-y-1/2 bg-white/80 text-gray-800 rounded-full p-2 hover:bg-white transition-colors shadow-md z-10\"\n              >\n                <ChevronRight size={16} />\n              </button>\n            </>\n          )}\n\n          {/* Pagination indicator */}\n          {items.length > 1 && (\n            <div className=\"absolute top-2 right-2 bg-black/70 text-white text-sm px-2 py-1 rounded z-10\">\n              {currentIndex + 1} / {items.length}\n            </div>\n          )}\n\n          {/* Main indicator badge */}\n          {currentItem.isMain && (\n            <div className=\"absolute top-2 left-2 bg-yellow-500 text-white text-xs px-2 py-1 rounded z-10\">\n              Principal\n            </div>\n          )}\n        </div>\n\n        {/* Dot navigation */}\n        {items.length > 1 && (\n          <div className=\"flex gap-1 mt-2 justify-center\">\n            {items.map((_, index) => (\n              <button\n                key={index}\n                onClick={() => setCurrentIndex(index)}\n                className={`w-2 h-2 rounded-full transition-colors ${\n                  index === currentIndex ? \"bg-blue-500\" : \"bg-gray-300\"\n                }`}\n              />\n            ))}\n          </div>\n        )}\n      </div>\n\n      {/* Full-Screen Lightbox Modal using Portal */}\n      {typeof window !== \"undefined\" &&\n        isLightboxOpen &&\n        createPortal(\n          <div\n            className=\"fixed inset-0 bg-black flex items-center justify-center\"\n            style={{\n              zIndex: 2147483647,\n              position: \"fixed\",\n              top: 0,\n              left: 0,\n              right: 0,\n              bottom: 0,\n              width: \"100vw\",\n              height: \"100vh\",\n            }}\n            onClick={closeLightbox}\n          >\n            {/* Close button */}\n            <button\n              onClick={closeLightbox}\n              className=\"absolute top-4 left-4 text-white bg-black/50 rounded-full p-2 hover:bg-black/70 transition-colors\"\n              style={{ zIndex: 2147483647 }}\n            >\n              <X size={24} />\n            </button>\n\n            {/* Image counter */}\n            <div\n              className=\"absolute top-4 right-4 text-white bg-black/50 px-3 py-1 rounded-full text-sm\"\n              style={{ zIndex: 2147483647 }}\n            >\n              {lightboxIndex + 1} of {items.length}\n            </div>\n\n            {/* Current image */}\n            <div\n              className=\"relative w-full h-full flex items-center justify-center p-4\"\n              onClick={(e) => e.stopPropagation()}\n            >\n              {items[lightboxIndex]?.type === \"video\" ? (\n                <video\n                  src={items[lightboxIndex].url}\n                  className=\"max-w-full max-h-full object-contain\"\n                  controls\n                  autoPlay\n                />\n              ) : (\n                <img\n                  src={items[lightboxIndex]?.url}\n                  alt={`${eventTitle} - imagen ${lightboxIndex + 1}`}\n                  className=\"max-w-full max-h-full object-contain\"\n                />\n              )}\n\n              {/* Navigation arrows in lightbox */}\n              {items.length > 1 && (\n                <>\n                  <button\n                    onClick={(e) => {\n                      e.stopPropagation();\n                      prevLightboxSlide();\n                    }}\n                    className=\"absolute left-4 top-1/2 transform -translate-y-1/2 text-white bg-black/50 rounded-full p-3 hover:bg-black/70 transition-colors\"\n                    style={{ zIndex: 2147483647 }}\n                  >\n                    <ChevronLeft size={24} />\n                  </button>\n                  <button\n                    onClick={(e) => {\n                      e.stopPropagation();\n                      nextLightboxSlide();\n                    }}\n                    className=\"absolute right-4 top-1/2 transform -translate-y-1/2 text-white bg-black/50 rounded-full p-3 hover:bg-black/70 transition-colors\"\n                    style={{ zIndex: 2147483647 }}\n                  >\n                    <ChevronRight size={24} />\n                  </button>\n                </>\n              )}\n            </div>\n          </div>,\n          document.body\n        )}\n    </>\n  );\n};\n\nexport default EventDetailSheet;\n","size_bytes":70302},"client/src/components/events/event-filters.tsx":{"content":"import React, { useState } from \"react\";\nimport { motion, AnimatePresence } from \"framer-motion\";\nimport { Button } from \"@/components/ui/button\";\nimport { Slider } from \"@/components/ui/slider\";\nimport { X } from \"lucide-react\";\n\ntype EventFiltersProps = {\n  onClose: () => void;\n  onApply?: (filters: {\n    categories: string[];\n    paymentTypes: string[];\n    dateFilter: string;\n    distance: number;\n    genderFilter: string;\n  }) => void;\n};\n\nconst EventFilters = ({ onClose, onApply }: EventFiltersProps) => {\n  // State for selected filters\n  const [selectedCategories, setSelectedCategories] = useState<string[]>([]);\n  const [selectedPaymentTypes, setSelectedPaymentTypes] = useState<string[]>([]);\n  const [selectedDateFilter, setSelectedDateFilter] = useState<string>(\"all\");\n  const [selectedDistance, setSelectedDistance] = useState<number>(100);\n  const [selectedGenderFilter, setSelectedGenderFilter] = useState<string>(\"todos\");\n  \n  // Distance options: 1km → 5km → 10km → 20km → +50km → +80km → +100km\n  const distanceOptions = [1, 5, 10, 20, 50, 80, 100];\n  \n  // Convert slider value to distance option\n  const getDistanceFromSliderValue = (value: number) => {\n    return distanceOptions[value] || 1;\n  };\n  \n  // Convert distance option to slider value\n  const getSliderValueFromDistance = (distance: number) => {\n    const index = distanceOptions.indexOf(distance);\n    return index !== -1 ? index : 0;\n  };\n  \n  // Get distance label según la lógica exacta especificada\n  const getDistanceLabel = (distance: number) => {\n    if (distance >= 100) return '+100km';\n    if (distance >= 80) return '+80km';\n    if (distance >= 50) return '+50km';\n    return `${distance}km`;\n  };\n  \n  // Reset all filters\n  const resetFilters = () => {\n    setSelectedCategories([]);\n    setSelectedPaymentTypes([]);\n    setSelectedDateFilter(\"all\");\n    setSelectedDistance(100);\n    setSelectedGenderFilter(\"todos\");\n  };\n\n  // Category options with icons\n  const categories = [\n    { id: \"social\", label: \"Social\", icon: \"👥\" },\n    { id: \"music\", label: \"Música\", icon: \"🎵\" },\n    { id: \"spiritual\", label: \"Espiritual\", icon: \"✨\" },\n    { id: \"education\", label: \"Educación\", icon: \"📚\" },\n    { id: \"sports\", label: \"Deportes\", icon: \"🏆\" },\n    { id: \"food\", label: \"Comida\", icon: \"🍽️\" },\n    { id: \"art\", label: \"Arte\", icon: \"🎨\" },\n    { id: \"technology\", label: \"Tecnología\", icon: \"💻\" },\n    { id: \"games\", label: \"Juegos\", icon: \"🎮\" },\n    { id: \"outdoor\", label: \"Aire Libre\", icon: \"🏕️\" },\n    { id: \"networking\", label: \"Networking\", icon: \"🤝\" },\n    { id: \"workshop\", label: \"Talleres\", icon: \"🔧\" },\n    { id: \"conference\", label: \"Conferencias\", icon: \"🎤\" },\n    { id: \"party\", label: \"Fiestas\", icon: \"🎉\" },\n    { id: \"fair\", label: \"Ferias\", icon: \"🎪\" },\n    { id: \"exhibition\", label: \"Exposiciones\", icon: \"🖼️\" },\n  ];\n\n  // Payment type options\n  const paymentTypes = [\n    { id: \"free\", label: \"Publico\" },\n    { id: \"paid\", label: \"De pago\" },\n  ];\n\n  // Date filter options\n  const dateFilters = [\n    { id: \"all\", label: \"Todas las fechas\" },\n    { id: \"today\", label: \"Hoy\" },\n    { id: \"tomorrow\", label: \"Mañana\" },\n    { id: \"this_week\", label: \"Esta Semana\" },\n    { id: \"next_week\", label: \"Próxima Semana\" },\n    { id: \"weekend\", label: \"Fin de Semana\" },\n  ];\n\n  // Gender filter options  \n  const genderFilters = [\n    { id: \"todos\", label: \"Todos\" },\n    { id: \"men\", label: \"Hombres\" },\n    { id: \"women\", label: \"Mujeres\" },\n  ];\n\n  // Toggle category selection\n  const toggleCategory = (categoryId: string) => {\n    if (selectedCategories.includes(categoryId)) {\n      setSelectedCategories(selectedCategories.filter(id => id !== categoryId));\n    } else {\n      setSelectedCategories([...selectedCategories, categoryId]);\n    }\n  };\n\n  // Toggle payment type selection\n  const togglePaymentType = (typeId: string) => {\n    if (selectedPaymentTypes.includes(typeId)) {\n      setSelectedPaymentTypes(selectedPaymentTypes.filter(id => id !== typeId));\n    } else {\n      setSelectedPaymentTypes([...selectedPaymentTypes, typeId]);\n    }\n  };\n\n  // Set date filter\n  const setDateFilter = (filterId: string) => {\n    setSelectedDateFilter(filterId);\n  };\n\n  // Apply filters\n  const handleApplyFilters = () => {\n    if (onApply) {\n      onApply({\n        categories: selectedCategories,\n        paymentTypes: selectedPaymentTypes,\n        dateFilter: selectedDateFilter,\n        distance: selectedDistance,\n        genderFilter: selectedGenderFilter,\n      });\n    }\n    onClose();\n  };\n\n  return (\n    <AnimatePresence>\n      <motion.div\n        initial={{ opacity: 0, y: -50, scale: 0.9 }}\n        animate={{ opacity: 1, y: 0, scale: 1 }}\n        exit={{ opacity: 0, y: -50, scale: 0.9 }}\n        transition={{\n          type: \"spring\",\n          damping: 25,\n          stiffness: 300,\n          duration: 0.4\n        }}\n        className=\"absolute top-16 left-4 right-4 z-10 bg-white/10 backdrop-blur-lg rounded-xl shadow-2xl border border-white/20 p-3 max-h-[80vh] overflow-y-auto\"\n      >\n        <div className=\"flex justify-between items-center mb-2\">\n          <h3 className=\"font-semibold text-white\">Descubrir eventos</h3>\n          <button onClick={onClose} className=\"p-1 hover:bg-white/20 rounded-full transition-all duration-200 text-white/80 hover:text-white\">\n            <X size={20} />\n          </button>\n        </div>\n\n        {/* Gender Filter */}\n        <div className=\"mb-4\">\n          <h4 className=\"text-sm font-medium text-white/80 mb-2\">Para:</h4>\n          <select\n            value={selectedGenderFilter}\n            onChange={(e) => setSelectedGenderFilter(e.target.value)}\n            className=\"w-full px-3 py-2 text-sm bg-white/10 text-white/80 border border-white/20 rounded-lg\"\n          >\n            {genderFilters.map(filter => (\n              <option key={filter.id} value={filter.id} className=\"bg-gray-800 text-white\">\n                {filter.label}\n              </option>\n            ))}\n          </select>\n        </div>\n      \n        {/* Category Filter */}\n        <div className=\"mb-4\">\n          <h4 className=\"text-sm font-medium text-white/80 mb-2\">Tema:</h4>\n          <select\n            value={selectedCategories.length > 0 ? selectedCategories[0] : \"all\"}\n            onChange={(e) => {\n              if (e.target.value === \"all\") {\n                setSelectedCategories([]);\n              } else {\n                setSelectedCategories([e.target.value]);\n              }\n            }}\n            className=\"w-full px-3 py-2 text-sm bg-white/10 text-white/80 border border-white/20 rounded-lg\"\n          >\n            <option value=\"all\" className=\"bg-gray-800 text-white\">Todos</option>\n            {categories.map(category => (\n              <option key={category.id} value={category.id} className=\"bg-gray-800 text-white\">\n                {category.icon} {category.label}\n              </option>\n            ))}\n          </select>\n        </div>\n        \n        {/* Distance Filter */}\n        <div className=\"mb-1\">\n          <h4 className=\"text-sm font-medium text-white/80 mb-1\">Distancia:</h4>\n          <div className=\"px-2 py-1\">\n            <Slider\n              value={[getSliderValueFromDistance(selectedDistance)]}\n              defaultValue={[6]}\n              onValueChange={(values) => setSelectedDistance(getDistanceFromSliderValue(values[0]))}\n              max={6}\n              min={0}\n              step={1}\n              className=\"slider-distance w-full\"\n            />\n            <div className=\"text-center mt-1 text-white/60 text-xs\">\n              {getDistanceLabel(selectedDistance)}\n            </div>\n          </div>\n        </div>\n        \n        {/* Date Filter */}\n        <div className=\"mb-2\">\n          <h4 className=\"text-sm font-medium text-white/80 mb-2\">Fecha:</h4>\n          <select\n            value={selectedDateFilter}\n            onChange={(e) => setDateFilter(e.target.value)}\n            className=\"w-full px-3 py-2 text-sm bg-white/10 text-white/80 border border-white/20 rounded-lg\"\n          >\n            {dateFilters.map(filter => (\n              <option key={filter.id} value={filter.id} className=\"bg-gray-800 text-white\">\n                {filter.label}\n              </option>\n            ))}\n          </select>\n        </div>\n        \n        {/* Clear Filters */}\n        <div className=\"mb-2\">\n          <Button\n            variant=\"outline\"\n            className=\"w-full py-2 bg-white/10 text-white/80 rounded-lg font-medium border border-white/20 hover:bg-white/20 transition-all duration-200\"\n            onClick={resetFilters}\n          >\n            Limpiar Filtros\n          </Button>\n        </div>\n      \n      <div className=\"mb-4\">\n        <Button\n          className=\"w-full py-3 bg-white/20 text-white rounded-xl font-medium border border-white/30 hover:bg-white/30 transition-all duration-200\"\n          onClick={handleApplyFilters}\n        >\n          Aplicar Filtros\n        </Button>\n      </div>\n      </motion.div>\n    </AnimatePresence>\n  );\n};\n\nexport default EventFilters;\n","size_bytes":9128},"client/src/components/events/event-requests.tsx":{"content":"import React, { useState, useEffect } from 'react';\nimport { useToast } from '../../hooks/use-toast';\nimport { apiRequest } from '../../lib/queryClient';\nimport { Button } from '../ui/button';\nimport { useAuth } from '../../hooks/use-auth';\n\ntype JoinRequest = {\n  id: number;\n  eventId: number;\n  userId: number;\n  status: string;\n  createdAt: string;\n  user: {\n    id: number;\n    name: string;\n    username: string;\n    avatar?: string;\n  };\n};\n\ntype EventRequestsProps = {\n  eventId: number;\n  onStatusChange: () => void;\n};\n\nexport function EventRequests({ eventId, onStatusChange }: EventRequestsProps) {\n  const [requests, setRequests] = useState<JoinRequest[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [processingId, setProcessingId] = useState<number | null>(null);\n  const { toast } = useToast();\n  const { user } = useAuth();\n\n  useEffect(() => {\n    if (!user) return;\n    \n    fetchRequests();\n  }, [eventId, user]);\n\n  const fetchRequests = async () => {\n    try {\n      setLoading(true);\n      const res = await apiRequest('GET', `/api/events/${eventId}/requests`);\n      if (!res.ok) {\n        throw new Error('No se pudieron cargar las solicitudes');\n      }\n      const data = await res.json();\n      setRequests(data);\n    } catch (error) {\n      console.error('Error fetching requests:', error);\n      toast({\n        title: 'Error',\n        description: 'No se pudieron cargar las solicitudes para este evento',\n        variant: 'destructive',\n      });\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleApprove = async (attendeeId: number) => {\n    try {\n      setProcessingId(attendeeId);\n      const res = await apiRequest(\n        'POST', \n        `/api/events/${eventId}/requests/${attendeeId}/approve`\n      );\n      \n      if (!res.ok) {\n        throw new Error('No se pudo aprobar la solicitud');\n      }\n      \n      // Remove approved request from the list\n      setRequests(requests.filter(r => r.userId !== attendeeId));\n      \n      toast({\n        title: 'Solicitud aprobada',\n        description: 'El usuario ha sido añadido al evento',\n      });\n      \n      // Notify parent component about the status change\n      onStatusChange();\n    } catch (error) {\n      console.error('Error approving request:', error);\n      toast({\n        title: 'Error',\n        description: 'No se pudo aprobar la solicitud',\n        variant: 'destructive',\n      });\n    } finally {\n      setProcessingId(null);\n    }\n  };\n\n  const handleReject = async (attendeeId: number) => {\n    try {\n      setProcessingId(attendeeId);\n      const res = await apiRequest(\n        'POST', \n        `/api/events/${eventId}/requests/${attendeeId}/reject`\n      );\n      \n      if (!res.ok) {\n        throw new Error('No se pudo rechazar la solicitud');\n      }\n      \n      // Remove rejected request from the list\n      setRequests(requests.filter(r => r.userId !== attendeeId));\n      \n      toast({\n        title: 'Solicitud rechazada',\n        description: 'La solicitud ha sido rechazada',\n      });\n      \n      // Notify parent component about the status change\n      onStatusChange();\n    } catch (error) {\n      console.error('Error rejecting request:', error);\n      toast({\n        title: 'Error',\n        description: 'No se pudo rechazar la solicitud',\n        variant: 'destructive',\n      });\n    } finally {\n      setProcessingId(null);\n    }\n  };\n\n  if (loading) {\n    return <div className=\"text-center py-4\">Cargando solicitudes...</div>;\n  }\n\n  if (requests.length === 0) {\n    return (\n      <div className=\"text-center py-4 text-neutral-500\">\n        No hay solicitudes pendientes para este evento\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-4\">\n      <h3 className=\"font-semibold text-lg\">Solicitudes pendientes ({requests.length})</h3>\n      \n      <div className=\"space-y-3\">\n        {requests.map((request) => (\n          <div \n            key={request.id} \n            className=\"bg-white rounded-lg p-4 shadow-sm border border-neutral-100 flex items-center justify-between\"\n          >\n            <div className=\"flex items-center gap-3\">\n              <div className=\"w-10 h-10 rounded-full bg-neutral-200 overflow-hidden flex-shrink-0\">\n                <img \n                  src={request.user.avatar || `https://ui-avatars.com/api/?name=${encodeURIComponent(request.user.name)}`}\n                  alt={request.user.name}\n                  className=\"w-full h-full object-cover\"\n                />\n              </div>\n              <div>\n                <p className=\"font-medium\">{request.user.name}</p>\n                <p className=\"text-sm text-neutral-500\">@{request.user.username}</p>\n              </div>\n            </div>\n            \n            <div className=\"flex gap-2\">\n              <Button \n                variant=\"destructive\" \n                size=\"sm\"\n                onClick={() => handleReject(request.user.id)}\n                disabled={processingId === request.user.id}\n              >\n                Rechazar\n              </Button>\n              <Button \n                variant=\"default\" \n                size=\"sm\"\n                onClick={() => handleApprove(request.user.id)}\n                disabled={processingId === request.user.id}\n              >\n                Aprobar\n              </Button>\n            </div>\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n\nexport default EventRequests;","size_bytes":5434},"client/src/components/events/media-debug.tsx":{"content":"import React, { useEffect } from 'react';\n\ninterface MediaDebugProps {\n  event: any;\n}\n\nexport const MediaDebug: React.FC<MediaDebugProps> = ({ event }) => {\n  useEffect(() => {\n    // Solo ejecutar en desarrollo\n    if (process.env.NODE_ENV !== 'production') {\n      console.group('🔍 DEBUG MULTIMEDIA - Evento #' + event.id);\n      console.log('🎥 mainMediaUrl:', event.mainMediaUrl);\n      console.log('📊 mainMediaType:', event.mainMediaType);\n      \n      try {\n        let mediaItems = [];\n        if (typeof event.mediaItems === 'string') {\n          try {\n            mediaItems = JSON.parse(event.mediaItems);\n            console.log('📋 mediaItems parseados:', mediaItems);\n          } catch (e) {\n            console.error('❌ Error parseando mediaItems:', e);\n          }\n        } else if (Array.isArray(event.mediaItems)) {\n          mediaItems = event.mediaItems;\n          console.log('📋 mediaItems (ya es array):', mediaItems);\n        } else {\n          console.log('❓ mediaItems formato desconocido:', typeof event.mediaItems, event.mediaItems);\n        }\n        \n        // Verificar la validez de cada elemento\n        if (Array.isArray(mediaItems) && mediaItems.length > 0) {\n          mediaItems.forEach((item, index) => {\n            console.log(`Item #${index}:`, item);\n            console.log(`  - ¿Tiene URL? ${!!item.url}`);\n            console.log(`  - ¿Tipo válido? ${item.type === 'photo' || item.type === 'video'}`);\n            console.log(`  - ¿Es principal? ${!!item.isMain}`);\n          });\n          \n          const validItems = mediaItems.filter(item => \n            item && \n            typeof item === 'object' && \n            typeof item.url === 'string' && \n            (item.type === 'photo' || item.type === 'video')\n          );\n          \n          console.log(`✅ Items válidos: ${validItems.length} de ${mediaItems.length}`);\n          validItems.forEach((item, index) => {\n            console.log(`Item válido #${index}:`, item);\n          });\n        } else {\n          console.log('⚠️ No hay elementos multimedia');\n        }\n      } catch (error) {\n        console.error('❌ Error general:', error);\n      }\n      \n      console.groupEnd();\n    }\n  }, [event]);\n  \n  // No renderiza nada visualmente\n  return null;\n};\n\nexport default MediaDebug;","size_bytes":2326},"client/src/components/events/media-manager-fixed.tsx":{"content":"import React, { useState, useEffect, useRef } from 'react';\nimport { Button } from '@/components/ui/button';\nimport { Badge } from '@/components/ui/badge';\nimport { Trash, Video, Image, Star, StarOff, GripVertical, AlertCircle, Loader2 } from 'lucide-react';\nimport { cn } from '@/lib/utils';\nimport { useToast } from '@/hooks/use-toast';\nimport MediaPreview from './media-preview';\n\nexport type MediaItem = {\n  id?: string;\n  type: 'photo' | 'video';\n  url?: string; // URL para medios existentes\n  file?: File; // File para nuevos medios\n  previewUrl?: string; // URL temporal para vista previa (solo para UI)\n  isMain?: boolean;\n  isNew?: boolean;\n  deleted?: boolean; // Marca para vista (ocultar de la UI)\n  toDelete?: boolean; // Marca para enviar al servidor (eliminación permanente)\n  order?: number; // Para ordenamiento\n  uploading?: boolean; // Estado de carga\n  uploadProgress?: number; // Progreso de carga (0-100)\n  errorMessage?: string; // Mensaje de error si falla la carga\n  fileIndex?: number; // Índice del archivo para seguimiento en el servidor\n};\n\ntype MediaManagerProps = {\n  existingMedia?: MediaItem[] | string; // Puede ser string para JSON o MediaItem[]\n  onChange: (media: MediaItem[]) => void;\n  maxPhotos?: number;\n  maxVideos?: number;\n  disabled?: boolean;\n};\n\nexport const MediaManager: React.FC<MediaManagerProps> = ({\n  existingMedia = [],\n  onChange,\n  maxPhotos = 6,\n  maxVideos = 3,\n  disabled = false,\n}) => {\n  const { toast } = useToast();\n  // Inicialización segura de mediaItems\n  const [mediaItems, setMediaItems] = useState<MediaItem[]>(() => {\n    // Manejar caso donde existingMedia es undefined o null\n    if (existingMedia === undefined || existingMedia === null) {\n      console.log(\"existingMedia es undefined/null, inicializando como array vacío\");\n      return [];\n    }\n    \n    // Manejar caso donde existingMedia es string\n    if (typeof existingMedia === 'string') {\n      try {\n        // Si es string vacío, devolver array vacío\n        if (!existingMedia.trim()) {\n          return [];\n        }\n        \n        const parsed = JSON.parse(existingMedia);\n        \n        // Verificar que el resultado sea un array\n        if (!Array.isArray(parsed)) {\n          console.warn(\"existingMedia parseado no es un array:\", parsed);\n          return [];\n        }\n        \n        // Filtrar elementos inválidos\n        return parsed.filter(item => item !== null && item !== undefined);\n      } catch (e) {\n        console.error('Error parsing media JSON:', e);\n        return [];\n      }\n    }\n    \n    // Si es array, asegurarse de que todos los elementos son válidos\n    if (Array.isArray(existingMedia)) {\n      return existingMedia.filter(item => item !== null && item !== undefined);\n    }\n    \n    // Caso por defecto\n    console.warn(\"existingMedia no es un tipo reconocido:\", typeof existingMedia);\n    return [];\n  });\n  \n  const [photoCount, setPhotoCount] = useState(0);\n  const [videoCount, setVideoCount] = useState(0);\n  const [draggedItem, setDraggedItem] = useState<number | null>(null);\n  const [dragOverItem, setDragOverItem] = useState<number | null>(null);\n  const fileInputRef = useRef<HTMLInputElement>(null);\n  \n  // Actualizar los contadores cuando cambia la lista de medios\n  useEffect(() => {\n    if (!Array.isArray(mediaItems)) {\n      console.error(\"mediaItems no es un array en useEffect\");\n      return;\n    }\n    \n    // Contar fotos y videos válidos (no eliminados o marcados para eliminar)\n    const photos = mediaItems.filter(\n      item => item && item.type === 'photo' && !item.deleted && !item.toDelete\n    );\n    const videos = mediaItems.filter(\n      item => item && item.type === 'video' && !item.deleted && !item.toDelete\n    );\n    \n    setPhotoCount(photos.length);\n    setVideoCount(videos.length);\n  }, [mediaItems]);\n  \n  // Abrir el selector de archivos\n  const handleAddMedia = (isPhoto: boolean) => {\n    if (disabled) return;\n    \n    // Verificar si hay espacio disponible\n    if (isPhoto && photoCount >= maxPhotos) {\n      toast({\n        title: \"Límite alcanzado\",\n        description: `No puedes agregar más de ${maxPhotos} fotos`,\n        variant: \"destructive\"\n      });\n      return;\n    }\n    \n    if (!isPhoto && videoCount >= maxVideos) {\n      toast({\n        title: \"Límite alcanzado\",\n        description: `No puedes agregar más de ${maxVideos} videos`,\n        variant: \"destructive\"\n      });\n      return;\n    }\n    \n    // Verificar y crear el input de archivos si es necesario\n    if (!fileInputRef.current) {\n      console.error(\"Input de archivos no encontrado\");\n      return;\n    }\n    \n    // Establecer los tipos de archivos aceptados\n    fileInputRef.current.accept = isPhoto ? 'image/*' : 'video/*';\n    fileInputRef.current.dataset.type = isPhoto ? 'photo' : 'video';\n    \n    // Abrir el selector de archivos\n    fileInputRef.current.click();\n  };\n  \n  // Manejar la selección de archivos\n  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    if (disabled) return;\n    \n    const files = Array.from(e.target.files || []);\n    if (files.length === 0) return;\n    \n    const isPhoto = e.target.dataset.type === 'photo';\n    console.log(`Agregando ${files.length} ${isPhoto ? 'fotos' : 'videos'}`);\n    \n    // Calcular espacio disponible\n    const currentCount = isPhoto ? photoCount : videoCount;\n    const maxAllowed = isPhoto ? maxPhotos : maxVideos;\n    const availableSlots = Math.max(0, maxAllowed - currentCount);\n    \n    if (availableSlots === 0) {\n      toast({\n        title: \"Límite alcanzado\",\n        description: `No puedes agregar más ${isPhoto ? 'fotos' : 'videos'}`,\n        variant: \"destructive\"\n      });\n      return;\n    }\n    \n    if (files.length > availableSlots) {\n      toast({\n        title: \"Demasiados archivos\",\n        description: `Solo se agregarán los primeros ${availableSlots} archivos`,\n      });\n    }\n    \n    // Limitar la cantidad de archivos que se pueden agregar\n    const filesToAdd = files.slice(0, availableSlots);\n    \n    // Asegurarnos de que mediaItems es un array válido\n    const safeMediaItems = Array.isArray(mediaItems) ? mediaItems : [];\n    \n    // Verificar si hay algún elemento principal existente (con protección adicional contra null/undefined)\n    const hasMainItem = safeMediaItems.some(item => \n      item && item.isMain === true && item.deleted !== true && item.toDelete !== true\n    );\n    \n    // Crear nuevos elementos de medios\n    const newMediaItems = filesToAdd.map((file, idx): MediaItem => {\n      // Para evitar archivos no soportados\n      const isValidType = isPhoto \n        ? file.type.startsWith('image/') \n        : file.type.startsWith('video/');\n      \n      // Verificar el tamaño (límite de 5MB para imágenes, 10MB para videos)\n      const maxSize = isPhoto ? 5 * 1024 * 1024 : 10 * 1024 * 1024;\n      const isSizeValid = file.size <= maxSize;\n      \n      // Determinar si este elemento debe ser principal\n      // Prioridad para fotos como elemento principal\n      const shouldBeMain = !hasMainItem && \n                          ((isPhoto && idx === 0) || \n                           (safeMediaItems.length === 0 && idx === 0));\n      \n      let errorMsg;\n      if (!isValidType) {\n        errorMsg = `Formato no soportado: ${file.type}`;\n      } else if (!isSizeValid) {\n        errorMsg = `Archivo demasiado grande: ${(file.size / (1024 * 1024)).toFixed(1)}MB (máx. ${isPhoto ? '5MB' : '10MB'})`;\n      }\n        \n      // Generar un ID único para este elemento\n      const uniqueId = `new-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n      \n      // Crear una URL de vista previa para el archivo (con manejo seguro)\n      let previewUrl = '';\n      try {\n        previewUrl = URL.createObjectURL(file);\n      } catch (error) {\n        console.error(\"Error creando URL para vista previa:\", error);\n        errorMsg = errorMsg || \"Error procesando archivo\";\n      }\n      \n      console.log(`Agregando nuevo elemento: ${uniqueId}, tipo: ${isPhoto ? 'photo' : 'video'}, archivo: ${file.name}`);\n      \n      // Crear objeto MediaItem con valores seguros\n      return {\n        id: uniqueId,\n        type: isPhoto ? 'photo' : 'video',\n        file,\n        previewUrl, // URL temporal para vista previa\n        isNew: true,\n        order: safeMediaItems.length + idx,\n        fileIndex: idx, // Agregar índice para seguimiento\n        errorMessage: errorMsg,\n        isMain: shouldBeMain && isValidType && isSizeValid\n      };\n    });\n    \n    // Filtrar archivos con errores que no se van a usar\n    const validMediaItems = newMediaItems.filter(item => !item.errorMessage);\n    const invalidMediaItems = newMediaItems.filter(item => !!item.errorMessage);\n    \n    // No mostramos alerta para archivos inválidos\n    // Simplemente los incluimos en la lista con su mensaje de error\n    // para que el usuario pueda eliminarlos manualmente\n    \n    // Actualizar el estado con los archivos nuevos\n    // IMPORTANTE: Usar la versión segura de mediaItems (safeMediaItems)\n    const updatedMedia = [...safeMediaItems, ...newMediaItems];\n    console.log(\"Media antes de ordenar:\", updatedMedia.length, \"elementos\");\n    \n    // Asegurarse de que no haya null/undefined en el array\n    const cleanMedia = updatedMedia.filter(item => item !== null && item !== undefined);\n    \n    // Asegurarse de que no haya duplicados (basados en el ID único)\n    // Manejo adicional para casos donde los atributos puedan ser undefined\n    const uniqueMedia = Array.from(new Map(\n      cleanMedia.map(item => {\n        const key = item.id || `${item.url || (item.file ? item.file.name : '') || Date.now()}`;\n        return [key, item];\n      })\n    ).values());\n    \n    console.log(\"Media después de eliminar duplicados:\", uniqueMedia);\n    \n    // Ordenar los elementos asegurando que cada uno tiene un orden válido\n    const sortedMedia = [...uniqueMedia].sort((a, b) => \n      (a.order || 0) - (b.order || 0)\n    );\n    \n    // Asegurarse de que haya exactamente un elemento principal\n    const mainItems = sortedMedia.filter(item => \n      item && item.isMain && !item.deleted && !item.toDelete && !item.errorMessage\n    );\n    \n    let finalMedia = sortedMedia;\n    \n    // Si hay más de un elemento principal, dejar solo uno (priorizar fotos)\n    if (mainItems.length > 1) {\n      console.log(\"Hay más de un elemento principal, corrigiendo...\");\n      const mainPhoto = mainItems.find(item => item.type === 'photo');\n      const itemToSetMain = mainPhoto || mainItems[0];\n      console.log(\"Elemento principal seleccionado:\", \n                 itemToSetMain.type, \n                 itemToSetMain.id || \"sin ID\");\n      \n      // Marcar solo uno como principal\n      finalMedia = sortedMedia.map(item => ({\n        ...item,\n        isMain: item === itemToSetMain\n      }));\n    }\n    // Si no hay ningún elemento principal y hay elementos válidos, marcar el primero como principal\n    else if (mainItems.length === 0 && validMediaItems.length > 0) {\n      console.log(\"No hay elemento principal, estableciendo uno automáticamente\");\n      // Buscar primero una foto para establecer como principal\n      const firstPhoto = sortedMedia.find(\n        item => item.type === 'photo' && !item.deleted && !item.toDelete && !item.errorMessage\n      );\n      const firstValid = firstPhoto || sortedMedia.find(\n        item => !item.deleted && !item.toDelete && !item.errorMessage\n      );\n      \n      if (firstValid) {\n        finalMedia = sortedMedia.map(item => ({\n          ...item,\n          isMain: item === firstValid\n        }));\n        console.log(\"Elemento principal establecido automáticamente:\", \n                   firstValid.type, \n                   firstValid.id || \"sin ID\");\n      }\n    }\n    \n    // Verificar cuántos elementos principales tenemos ahora\n    const finalMainItems = finalMedia.filter(item => \n      item.isMain && !item.deleted && !item.toDelete\n    );\n    console.log(\"Elementos principales después de procesar:\", finalMainItems.length);\n    \n    // Actualizar el estado con los elementos procesados\n    setMediaItems(finalMedia);\n    \n    // Actualizar los contadores\n    if (isPhoto) {\n      setPhotoCount(prev => prev + validMediaItems.length);\n    } else {\n      setVideoCount(prev => prev + validMediaItems.length);\n    }\n    \n    // Notificar al componente padre\n    onChange(finalMedia);\n    \n    // Limpiar el input de archivos para permitir seleccionar el mismo archivo nuevamente\n    if (fileInputRef.current) {\n      fileInputRef.current.value = '';\n    }\n  };\n  \n  // Manejar arrastrar y soltar (drag & drop)\n  const handleDragStart = (index: number) => {\n    if (disabled) return;\n    setDraggedItem(index);\n  };\n  \n  const handleDragOver = (index: number) => {\n    if (disabled) return;\n    setDragOverItem(index);\n  };\n  \n  const handleDragEnd = () => {\n    if (disabled || draggedItem === null || dragOverItem === null) return;\n    \n    // Los índices deben ser distintos y válidos\n    if (draggedItem === dragOverItem || \n        draggedItem < 0 || dragOverItem < 0 || \n        draggedItem >= mediaItems.length || dragOverItem >= mediaItems.length) {\n      setDraggedItem(null);\n      setDragOverItem(null);\n      return;\n    }\n    \n    // Crear una copia del array para no mutar el estado directamente\n    const items = [...mediaItems];\n    const draggedItemContent = items[draggedItem];\n    \n    // Protección contra elementos null/undefined\n    if (!draggedItemContent) {\n      console.error(\"El elemento arrastrado es null o undefined\");\n      setDraggedItem(null);\n      setDragOverItem(null);\n      return;\n    }\n    \n    // Eliminar elemento arrastrado\n    items.splice(draggedItem, 1);\n    \n    // Insertar en nueva posición\n    items.splice(dragOverItem, 0, draggedItemContent);\n    \n    // Actualizar índices/orden\n    const reorderedItems = items.map((item, idx) => ({\n      ...item,\n      order: idx\n    }));\n    \n    // Actualizar estado local\n    setMediaItems(reorderedItems);\n    \n    // Notificar al componente padre\n    onChange(reorderedItems);\n    \n    // Limpiar estados de arrastre\n    setDraggedItem(null);\n    setDragOverItem(null);\n  };\n\n  // Eliminar un medio\n  const handleRemoveMedia = (indexToRemove: number) => {\n    if (disabled) return;\n    \n    // Verificar que el índice es válido y mediaItems existe\n    if (!mediaItems || indexToRemove < 0 || indexToRemove >= mediaItems.length) {\n      console.error(\"Índice de eliminación inválido o no hay elementos multimedia\");\n      return;\n    }\n    \n    const itemToRemove = mediaItems[indexToRemove];\n    \n    // Verificar que itemToRemove existe\n    if (!itemToRemove) {\n      console.error(\"No se pudo encontrar el elemento a eliminar\");\n      return;\n    }\n    \n    console.log(\"Eliminando elemento multimedia:\", itemToRemove);\n    \n    // Si es un elemento nuevo, simplemente lo eliminamos del array\n    if (itemToRemove.isNew) {\n      console.log(\"Eliminando elemento nuevo:\", itemToRemove);\n      \n      // Filtrar el elemento a eliminar\n      const updatedMedia = mediaItems.filter((item, index) => index !== indexToRemove);\n      \n      // Verificar si necesitamos asignar un nuevo elemento principal\n      if (itemToRemove.isMain && updatedMedia.length > 0) {\n        console.log(\"El elemento eliminado era principal, buscando nuevo elemento principal\");\n        \n        // Buscar primero una foto para establecer como principal\n        const firstPhoto = updatedMedia.find(\n          item => item.type === 'photo' && !item.deleted && !item.toDelete\n        );\n        \n        const firstValid = firstPhoto || updatedMedia.find(\n          item => !item.deleted && !item.toDelete\n        );\n        \n        if (firstValid) {\n          console.log(\"Nuevo elemento principal:\", firstValid);\n          \n          // Marcar el nuevo elemento como principal\n          const finalMedia = updatedMedia.map(item => ({\n            ...item,\n            isMain: item === firstValid\n          }));\n          \n          // Actualizar estado\n          setMediaItems(finalMedia);\n          \n          // Actualizar contadores\n          const newPhotoCount = finalMedia.filter(\n            item => item.type === 'photo' && !item.deleted && !item.toDelete\n          ).length;\n          \n          const newVideoCount = finalMedia.filter(\n            item => item.type === 'video' && !item.deleted && !item.toDelete\n          ).length;\n          \n          setPhotoCount(newPhotoCount);\n          setVideoCount(newVideoCount);\n          \n          // Notificar al componente padre\n          onChange(finalMedia);\n          return;\n        }\n      }\n      \n      // Actualizar estado\n      setMediaItems(updatedMedia);\n      \n      // Actualizar contadores\n      const newPhotoCount = updatedMedia.filter(\n        item => item.type === 'photo' && !item.deleted && !item.toDelete\n      ).length;\n      \n      const newVideoCount = updatedMedia.filter(\n        item => item.type === 'video' && !item.deleted && !item.toDelete\n      ).length;\n      \n      setPhotoCount(newPhotoCount);\n      setVideoCount(newVideoCount);\n      \n      // Notificar al componente padre\n      onChange(updatedMedia);\n    } \n    // Si es un elemento existente, lo marcamos para eliminación\n    else {\n      console.log(\"Marcando elemento existente para eliminación:\", itemToRemove);\n      \n      // Crear una copia para no mutar el estado directamente\n      const updatedMedia = mediaItems.map((item, index) => {\n        if (index === indexToRemove) {\n          return {\n            ...item,\n            deleted: true, // Para la UI (ocultar)\n            toDelete: true, // Para el backend (eliminar de la DB)\n            isMain: false // Nunca mostrar como principal un elemento eliminado\n          };\n        }\n        return item;\n      });\n      \n      // Verificar si necesitamos asignar un nuevo elemento principal\n      if (itemToRemove.isMain) {\n        console.log(\"El elemento marcado para eliminación era principal, buscando reemplazo\");\n        \n        // Elementos no eliminados\n        const visibleItems = updatedMedia.filter(\n          item => !item.deleted && !item.toDelete\n        );\n        \n        if (visibleItems.length > 0) {\n          // Buscar primero una foto para establecer como principal\n          const firstPhoto = visibleItems.find(item => item.type === 'photo');\n          const firstValid = firstPhoto || visibleItems[0];\n          \n          if (firstValid) {\n            console.log(\"Nuevo elemento principal después de eliminación:\", firstValid);\n            \n            // Crear array final con el nuevo elemento principal\n            const finalMedia = updatedMedia.map(item => {\n              if (item === firstValid) {\n                return {\n                  ...item,\n                  isMain: true\n                };\n              }\n              return item;\n            });\n            \n            // Actualizar estado\n            setMediaItems(finalMedia);\n            \n            // Notificar al componente padre\n            onChange(finalMedia);\n            \n            // Actualizar contadores\n            const newPhotoCount = finalMedia.filter(\n              item => item.type === 'photo' && !item.deleted && !item.toDelete\n            ).length;\n            \n            const newVideoCount = finalMedia.filter(\n              item => item.type === 'video' && !item.deleted && !item.toDelete\n            ).length;\n            \n            setPhotoCount(newPhotoCount);\n            setVideoCount(newVideoCount);\n            \n            return;\n          }\n        }\n      }\n      \n      // Actualizar estado\n      setMediaItems(updatedMedia);\n      \n      // Notificar al componente padre\n      onChange(updatedMedia);\n      \n      // Actualizar contadores\n      const newPhotoCount = updatedMedia.filter(\n        item => item.type === 'photo' && !item.deleted && !item.toDelete\n      ).length;\n      \n      const newVideoCount = updatedMedia.filter(\n        item => item.type === 'video' && !item.deleted && !item.toDelete\n      ).length;\n      \n      setPhotoCount(newPhotoCount);\n      setVideoCount(newVideoCount);\n      \n      // Buscar elementos marcados para eliminación para debugging\n      const itemsToDelete = updatedMedia.filter(item => item.toDelete === true);\n      if (itemsToDelete.length > 0) {\n        console.log(\"Elementos marcados para eliminación:\", \n          itemsToDelete.map(item => ({ url: item.url, type: item.type })));\n      }\n      \n      // Mostrar mensaje de confirmación\n      toast({\n        title: \"Elemento marcado para eliminación\",\n        description: \"El cambio se aplicará al guardar el formulario\",\n      });\n    }\n  };\n  \n  // Establecer un medio como principal\n  const handleSetMainMedia = (indexToSetMain: number) => {\n    // CONTROL 1: Si está deshabilitado, no hacer nada\n    if (disabled) return;\n    \n    console.log(\"===== MARCANDO COMO PRINCIPAL =====\");\n    console.log(\"Índice seleccionado:\", indexToSetMain);\n    \n    // CONTROL 2: Verificar que mediaItems es un array válido\n    if (!Array.isArray(mediaItems)) {\n      console.error(\"Error crítico: mediaItems no es un array\");\n      toast({\n        title: \"Error interno\",\n        description: \"Ocurrió un problema con la gestión de medios\",\n        variant: \"destructive\"\n      });\n      return;\n    }\n    \n    // CONTROL 3: Verificar que el índice es válido\n    if (indexToSetMain < 0 || indexToSetMain >= mediaItems.length) {\n      console.error(\"Índice para establecer como principal fuera de rango:\", indexToSetMain);\n      return;\n    }\n    \n    try {\n      // PASO 1: Crear una copia profunda de todos los elementos para evitar mutaciones\n      const clonedItems: MediaItem[] = mediaItems.map(item => {\n        if (!item) {\n          console.warn(\"Elemento null/undefined detectado en mediaItems\");\n          return null as unknown as MediaItem;\n        }\n        \n        // Crear objeto base con tipo seguro\n        const safeType = (item.type === 'photo' || item.type === 'video') ? item.type : 'photo';\n        \n        const newItem: MediaItem = {\n          id: item.id || `id-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n          type: safeType,\n          isMain: false, // Por defecto, ninguno es principal (se establecerá después)\n          order: typeof item.order === 'number' ? item.order : 0,\n        };\n        \n        // Copiar propiedades opcionales solo si existen\n        if (item.url) newItem.url = item.url;\n        if (item.file) newItem.file = item.file;\n        if (item.previewUrl) newItem.previewUrl = item.previewUrl;\n        if (item.isNew) newItem.isNew = true;\n        if (item.deleted) newItem.deleted = true;\n        if (item.toDelete) newItem.toDelete = true;\n        if (item.errorMessage) newItem.errorMessage = item.errorMessage;\n        \n        return newItem;\n      }).filter(Boolean) as MediaItem[]; // Eliminar posibles null/undefined\n      \n      // PASO 2: Obtener una referencia segura al elemento a marcar como principal\n      const itemToSetMain = clonedItems[indexToSetMain];\n      \n      // Verificación adicional\n      if (!itemToSetMain) {\n        throw new Error(\"El elemento seleccionado no existe después de la clonación\");\n      }\n      \n      // PASO 3: Verificar que el elemento cumple criterios para ser principal\n      if (itemToSetMain.errorMessage) {\n        console.warn(\"No se puede establecer como principal un elemento con errores\");\n        return;\n      }\n      \n      if (itemToSetMain.deleted || itemToSetMain.toDelete) {\n        console.warn(\"No se puede establecer como principal un elemento marcado para eliminación\");\n        return;\n      }\n      \n      // PASO 4: Marcar solo el elemento seleccionado como principal\n      clonedItems.forEach((item, idx) => {\n        item.isMain = (idx === indexToSetMain);\n      });\n      \n      console.log(\"Estado actualizado - Elemento principal:\", clonedItems[indexToSetMain].id);\n      \n      // Verificar elemento principal para debugging\n      const mainItems = clonedItems.filter(item => item.isMain === true);\n      console.log(\"¿Hay elemento principal explícito?\", mainItems.length > 0);\n      \n      if (mainItems.length > 0) {\n        console.log(\"ELEMENTO PRINCIPAL FINAL:\", {\n          tipo: mainItems[0].type || \"desconocido\",\n          id: mainItems[0].id || \"sin-id\"\n        });\n      } else {\n        console.error(\"¡No se encontró un elemento principal después de la actualización!\");\n      }\n      \n      // PASO 5: Actualizar el estado y notificar al formulario padre\n      setMediaItems(clonedItems);\n      \n      // IMPORTANTE: Usar una copia fresca para evitar mutaciones accidentales\n      onChange([...clonedItems]);\n      \n      // PASO 6: Notificación visual al usuario\n      const mainItem = clonedItems[indexToSetMain];\n      const itemName = mainItem && mainItem.file ? mainItem.file.name : \n                     (mainItem && mainItem.url ? 'Archivo seleccionado' : 'Elemento');\n      \n      toast({\n        title: \"Elemento principal actualizado\",\n        description: `${itemName} será la imagen destacada`,\n        duration: 3000\n      });\n      \n      console.log(\"=== PROCESANDO onChange EN MEDIA MANAGER ===\");\n      console.log(\"¿Hay elemento principal explícito?\", mainItems.length > 0);\n      console.log(\"ELEMENTO PRINCIPAL FINAL:\", {tipo: mainItems.length > 0 ? mainItems[0].type : 'ninguno'});\n      console.log(\"=== FIN PROCESAMIENTO onChange ===\");\n      \n    } catch (error) {\n      // MANEJO DE ERRORES\n      console.error(\"Error crítico al establecer elemento principal:\", error);\n      \n      toast({\n        title: \"Error al establecer elemento principal\",\n        description: \"Ha ocurrido un problema técnico. Por favor, inténtalo de nuevo.\",\n        variant: \"destructive\",\n        duration: 5000\n      });\n    }\n  };\n  \n  // Renderizar miniatura para medio (foto o video)\n  const renderMediaItem = (item: MediaItem, index: number) => {\n    // Verificar si el item es válido\n    if (!item) {\n      console.error(`Intentando renderizar un item undefined o null en el índice ${index}`);\n      return null;\n    }\n    \n    // No mostrar elementos eliminados\n    if (item.deleted || item.toDelete) {\n      return null;\n    }\n    \n    return (\n      <div \n        key={item.id || index}\n        className={cn(\n          \"relative group border rounded-md overflow-hidden hover:shadow-md transition-all\",\n          \"flex flex-col items-center justify-center\",\n          \"min-w-[120px] w-[120px] h-[120px]\",\n          \"bg-background\",\n          draggedItem === index ? \"opacity-50 border-dashed\" : \"\",\n          dragOverItem === index ? \"bg-accent\" : \"\",\n          item.errorMessage ? \"border-destructive\" : (item.isMain ? \"border-primary border-2\" : \"border-border\")\n        )}\n        draggable={!disabled}\n        onDragStart={() => handleDragStart(index)}\n        onDragOver={() => handleDragOver(index)}\n        onDragEnd={handleDragEnd}\n      >\n        {/* Previsualizacion del medio */}\n        <MediaPreview \n          file={item.file}\n          url={item.url}\n          previewUrl={item.previewUrl}\n          type={item.type}\n          className=\"w-full h-full object-cover\"\n        />\n        \n        {/* Acciones */}\n        <div className=\"absolute inset-0 flex items-center justify-center opacity-0 group-hover:opacity-100 bg-black/50 transition-opacity\">\n          {/* Botón para establecer como principal */}\n          <Button\n            type=\"button\"\n            onClick={() => handleSetMainMedia(index)}\n            disabled={item.isMain || disabled}\n            className={cn(\n              \"absolute top-1 left-1 h-7 w-7 p-0 rounded-full\",\n              item.isMain ? \"bg-primary text-primary-foreground hover:bg-primary/90\" : \"bg-black/50 hover:bg-black/70\"\n            )}\n            title=\"Establecer como principal\"\n          >\n            {item.isMain ? <Star size={14} /> : <StarOff size={14} />}\n          </Button>\n          \n          {/* Botón para eliminar */}\n          <Button\n            type=\"button\"\n            onClick={() => handleRemoveMedia(index)}\n            disabled={disabled}\n            className=\"absolute top-1 right-1 h-7 w-7 p-0 rounded-full bg-black/50 hover:bg-destructive/90\"\n            title=\"Eliminar\"\n          >\n            <Trash size={14} />\n          </Button>\n        </div>\n        \n        {/* Icono de tipo */}\n        <div className=\"absolute bottom-1 left-1 bg-black/50 text-white p-1 rounded-sm text-xs\">\n          {item.type === 'photo' ? <Image size={14} /> : <Video size={14} />}\n        </div>\n        \n        {/* Indicador de elemento principal */}\n        {item.isMain && (\n          <Badge className=\"absolute bottom-1 right-1 text-xs bg-primary\" variant=\"default\">\n            Principal\n          </Badge>\n        )}\n        \n        {/* Mensaje de error si lo hay */}\n        {item.errorMessage && (\n          <div className=\"absolute inset-0 flex items-center justify-center bg-black/70 text-white p-2 text-xs text-center\">\n            <div className=\"flex flex-col items-center space-y-1\">\n              <AlertCircle size={16} className=\"text-destructive\" />\n              <span>{item.errorMessage}</span>\n            </div>\n          </div>\n        )}\n        \n        {/* Indicador de carga */}\n        {item.uploading && (\n          <div className=\"absolute inset-0 flex flex-col items-center justify-center bg-black/70 text-white\">\n            <Loader2 size={24} className=\"animate-spin mb-2\" />\n            <div className=\"text-xs\">{item.uploadProgress || 0}%</div>\n          </div>\n        )}\n      </div>\n    );\n  };\n  \n  // Conteo de elementos válidos (no eliminados)\n  const visibleItems = mediaItems.filter(item => !item.deleted && !item.toDelete);\n  \n  return (\n    <div className=\"space-y-4\">\n      {/* Input oculto para seleccionar archivos */}\n      <input \n        type=\"file\" \n        ref={fileInputRef}\n        className=\"hidden\"\n        onChange={handleFileChange}\n        multiple\n      />\n      \n      {/* Área de visualización de medios */}\n      <div className=\"flex flex-wrap gap-3 min-h-[120px] border border-dashed rounded-md p-3\">\n        {visibleItems.length > 0 ? (\n          visibleItems.map((item, index) => renderMediaItem(item, index))\n        ) : (\n          <div className=\"w-full h-full flex items-center justify-center text-muted-foreground text-sm py-8\">\n            No hay medios añadidos\n          </div>\n        )}\n      </div>\n      \n      {/* Botones para agregar medios */}\n      <div className=\"flex flex-wrap gap-2\">\n        <Button\n          type=\"button\"\n          onClick={() => handleAddMedia(true)}\n          disabled={disabled || photoCount >= maxPhotos}\n          variant=\"outline\"\n          className=\"text-xs\"\n        >\n          <Image className=\"mr-2\" size={14} />\n          Añadir Foto ({photoCount}/{maxPhotos})\n        </Button>\n        \n        <Button\n          type=\"button\"\n          onClick={() => handleAddMedia(false)}\n          disabled={disabled || videoCount >= maxVideos}\n          variant=\"outline\"\n          className=\"text-xs\"\n        >\n          <Video className=\"mr-2\" size={14} />\n          Añadir Video ({videoCount}/{maxVideos})\n        </Button>\n      </div>\n    </div>\n  );\n};\n\nexport default MediaManager;","size_bytes":31338},"client/src/components/events/media-manager-v2.tsx":{"content":"import { useRef, useState, useEffect } from 'react';\nimport { cn } from '@/lib/utils';\nimport { useToast } from '@/hooks/use-toast';\nimport { Button } from '@/components/ui/button';\nimport { Progress } from '@/components/ui/progress';\nimport { Image, Video, Trash, Star, StarOff, X } from 'lucide-react';\n\nexport type MediaItem = {\n  id?: string;\n  type: 'photo' | 'video';\n  url?: string; // URL para medios existentes\n  file?: File; // File para nuevos medios\n  previewUrl?: string; // URL temporal para vista previa (solo para UI)\n  isMain?: boolean;\n  isNew?: boolean;\n  deleted?: boolean; // Marca para vista (ocultar de la UI)\n  toDelete?: boolean; // Marca para enviar al servidor (eliminación permanente)\n  order?: number; // Para ordenamiento\n  uploading?: boolean; // Estado de carga\n  uploadProgress?: number; // Progreso de carga (0-100)\n  errorMessage?: string; // Mensaje de error si falla la carga\n  fileIndex?: number; // Índice del archivo para seguimiento en el servidor\n};\n\ntype MediaManagerProps = {\n  existingMedia?: MediaItem[] | string; // Puede ser string para JSON o MediaItem[]\n  onChange: (media: MediaItem[]) => void;\n  maxPhotos?: number;\n  maxVideos?: number;\n  disabled?: boolean;\n};\n\nexport const MediaManager = ({\n  existingMedia = [],\n  onChange,\n  maxPhotos = 6,\n  maxVideos = 3,\n  disabled = false,\n}: MediaManagerProps) => {\n  console.log(\"🎬 MediaManager RENDER START - Component is rendering\");\n  console.log(\"🎬 MediaManager props:\", { existingMedia: Array.isArray(existingMedia) ? existingMedia.length : typeof existingMedia, disabled, maxPhotos, maxVideos });\n  \n  const { toast } = useToast();\n  const [mediaItems, setMediaItems] = useState<MediaItem[]>([]);\n  const fileInputRef = useRef<HTMLInputElement>(null);\n  \n  // Al inicializar, procesar existingMedia\n  useEffect(() => {\n    console.log(\"🔄 MediaManager useEffect TRIGGERED - existingMedia changed\");\n    console.log(\"🔄 Current mediaItems.length before update:\", mediaItems.length);\n    console.log(\"🔄 New existingMedia:\", typeof existingMedia, existingMedia);\n    \n    // CRITICAL: Don't reset mediaItems if we already have new items that haven't been saved\n    const hasUnsavedItems = mediaItems.some(item => item.isNew && item.file);\n    if (hasUnsavedItems) {\n      console.log(\"⚠️ PREVENTING RESET: MediaManager has unsaved new items, skipping existingMedia update\");\n      console.log(\"⚠️ Unsaved items:\", mediaItems.filter(item => item.isNew && item.file).map(item => ({ id: item.id, fileName: item.file?.name })));\n      return;\n    }\n    \n    let initialItems: MediaItem[] = [];\n    \n    // Si es un array y tiene elementos, usarlo directamente\n    if (Array.isArray(existingMedia) && existingMedia.length > 0) {\n      initialItems = existingMedia.map(item => ({ ...item }));\n      console.log(\"MediaManager: Media recibido como array:\", initialItems.length, initialItems);\n    }\n    // Si es un string, intentar parsearlo como JSON\n    else if (typeof existingMedia === 'string' && existingMedia.trim()) {\n      try {\n        initialItems = JSON.parse(existingMedia);\n        console.log(\"MediaManager: Media parseado de JSON string:\", initialItems.length, initialItems);\n      } catch (e) {\n        console.error('MediaManager: Error al parsear JSON:', e);\n        console.log('MediaManager: String original:', existingMedia);\n        setMediaItems([]);\n        onChange([]);\n        return;\n      }\n    }\n    // Si no hay datos válidos\n    else {\n      console.log(\"MediaManager: No hay media existente válido\");\n      setMediaItems([]);\n      onChange([]);\n      return;\n    }\n    \n    // Filtrar elementos nulos y undefined para evitar errores\n    initialItems = initialItems.filter(item => item !== null && item !== undefined);\n    \n    // Asegurarse de que cada elemento tenga un orden\n    const itemsWithOrder = initialItems.map((item, index) => ({\n      ...item,\n      order: item.order !== undefined ? item.order : index\n    }));\n    \n    // Ordenar: primero el elemento principal, luego por order\n    const sortedItems = [...itemsWithOrder].sort((a, b) => {\n      // Si uno es principal y el otro no, el principal va primero\n      if (a.isMain && !b.isMain) return -1;\n      if (!a.isMain && b.isMain) return 1;\n      // Si ambos son principales o ninguno es principal, ordenar por order\n      return (a.order || 0) - (b.order || 0);\n    });\n    \n    console.log(\"Media inicial ordenado:\", sortedItems);\n    \n    // Asegurarse de que solo hay un elemento principal\n    let hasMain = false;\n    const finalItems = sortedItems.map(item => {\n      if (item.isMain && !hasMain) {\n        hasMain = true;\n        return { ...item, isMain: true };\n      }\n      return { ...item, isMain: false };\n    });\n    \n    // Si no hay un elemento principal, establecer el primero como principal\n    if (!hasMain && finalItems.length > 0) {\n      finalItems[0].isMain = true;\n      console.log(\"Estableciendo el primer elemento como principal por defecto\");\n    }\n    \n    console.log(\"🔄 SETTING INITIAL MEDIA from existingMedia:\", finalItems.length);\n    console.log(\"🔄 EXISTING MEDIA DETAILS:\", finalItems.map(item => ({ \n      id: item.id, \n      type: item.type, \n      isNew: !!item.isNew,\n      hasUrl: !!item.url,\n      hasFile: !!item.file\n    })));\n    \n    setMediaItems(finalItems);\n    \n    // Importante: Asegurarnos de que el componente padre tenga el estado inicial correcto\n    // Esta línea soluciona el problema del \"undefined\" al enviar el formulario\n    onChange(finalItems);\n  }, [existingMedia]);\n  \n  // Contar elementos visibles actuales\n  const validItems = mediaItems.filter(item => item && typeof item === 'object');\n  const visibleItems = validItems.filter(item => !item.deleted && !item.toDelete);\n  const photoCount = visibleItems.filter(item => item.type === 'photo').length;\n  const videoCount = visibleItems.filter(item => item.type === 'video').length;\n  \n  // Verificar si se pueden agregar más elementos\n  const canAddMorePhotos = photoCount < maxPhotos;\n  const canAddMoreVideos = videoCount < maxVideos;\n  \n  console.log(\"MediaManager render counts:\", {\n    totalItems: mediaItems.length,\n    validItems: validItems.length,\n    visibleItems: visibleItems.length,\n    photoCount,\n    videoCount,\n    canAddMorePhotos,\n    canAddMoreVideos,\n    disabled\n  });\n  \n  // Función para seleccionar archivos\n  const handleSelectFiles = (acceptType: 'image/*' | 'video/*') => {\n    console.log(\"=== FILE SELECTION STARTED ===\");\n    console.log(\"Accept type:\", acceptType);\n    console.log(\"Current media items before selection:\", mediaItems.length);\n    console.log(\"Disabled state:\", disabled);\n    \n    if (disabled) {\n      console.log(\"File selection disabled, returning\");\n      return;\n    }\n    \n    if (fileInputRef.current) {\n      console.log(\"File input ref found, setting accept and clicking\");\n      fileInputRef.current.accept = acceptType;\n      fileInputRef.current.click();\n    } else {\n      console.error(\"File input ref not found!\");\n    }\n  };\n\n  // Procesar archivos seleccionados con validación mejorada\n  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    if (!e.target.files || e.target.files.length === 0) return;\n    \n    try {\n      const files = Array.from(e.target.files);\n      const isImage = e.target.accept === 'image/*';\n      const mediaType = isImage ? 'photo' : 'video';\n      \n      // Verificar si hay espacio para más archivos\n      const currentCount = mediaType === 'photo' ? photoCount : videoCount;\n      const maxCount = mediaType === 'photo' ? maxPhotos : maxVideos;\n      \n      if (currentCount + files.length > maxCount) {\n        toast({\n          title: `Demasiados ${mediaType === 'photo' ? 'fotos' : 'videos'}`,\n          description: `Solo puedes agregar hasta ${maxCount} ${mediaType === 'photo' ? 'fotos' : 'videos'}`,\n          variant: \"destructive\"\n        });\n        \n        // Limpiar input para que pueda seleccionar los mismos archivos de nuevo\n        e.target.value = '';\n        return;\n      }\n      \n      // Procesar cada archivo\n      const newItems: MediaItem[] = [];\n      \n      files.forEach(file => {\n        // Validar tamaño (10MB máximo)\n        if (file.size > 10 * 1024 * 1024) {\n          toast({\n            title: \"Archivo demasiado grande\",\n            description: `${file.name} excede el límite de 10MB`,\n            variant: \"destructive\"\n          });\n          return;\n        }\n        \n        // Crear URL temporal para vista previa\n        const previewUrl = URL.createObjectURL(file);\n        \n        // Crear nuevo item con verificación de tipo\n        const newItem: MediaItem = {\n          id: `new-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n          type: mediaType,\n          file,\n          previewUrl,\n          isNew: true,\n          isMain: false, // Por defecto no es principal\n          order: mediaItems.length + newItems.length\n        };\n        \n        newItems.push(newItem);\n      });\n      \n      // Si no hay elementos nuevos, no hacemos nada\n      if (newItems.length === 0) {\n        console.log(\"No se agregaron nuevos elementos\");\n        // Limpiar input para que pueda seleccionar los mismos archivos de nuevo\n        e.target.value = '';\n        return;\n      }\n      \n      // Asegurarse de que mediaItems existe y es un array\n      const currentItems = Array.isArray(mediaItems) ? [...mediaItems] : [];\n      \n      // Si no hay elementos en mediaItems o no hay ningún elemento principal marcado, hacer el primero principal\n      const hasMainItem = currentItems.some(item => item && item.isMain === true && !item.deleted && !item.toDelete);\n      \n      if (!hasMainItem && newItems.length > 0) {\n        newItems[0].isMain = true;\n        console.log(\"Marcando el primer elemento nuevo como principal\");\n      }\n      \n      // Combinar elementos actuales y nuevos con validación adicional\n      const updatedItems = [...currentItems, ...newItems].filter(item => item !== null && item !== undefined);\n      \n      console.log(\"=== MEDIA PROCESSING DEBUG ===\");\n      console.log(\"Current items count:\", currentItems.length);\n      console.log(\"New items count:\", newItems.length);\n      console.log(\"Updated items count:\", updatedItems.length);\n      console.log(\"New items details:\", newItems.map(item => ({\n        id: item.id,\n        type: item.type,\n        fileName: item.file?.name,\n        isNew: item.isNew,\n        hasPreviewUrl: !!item.previewUrl\n      })));\n      console.log(\"Updated items details:\", updatedItems.map(item => ({\n        id: item.id,\n        type: item.type,\n        isNew: item.isNew,\n        hasUrl: !!item.url,\n        hasPreviewUrl: !!item.previewUrl\n      })));\n      \n      // Si el array está vacío después de los filtros, proporcionar un array vacío válido\n      const safeItems = updatedItems.length > 0 ? updatedItems : [];\n      \n      console.log(\"🔥 ADDING NEW FILES - Setting media items to:\", safeItems.length);\n      console.log(\"🔥 ADDING NEW FILES - Details:\", safeItems.map(item => ({ \n        id: item.id, \n        type: item.type, \n        isNew: item.isNew, \n        fileName: item.file?.name || 'no file',\n        hasUrl: !!item.url \n      })));\n      \n      setMediaItems(safeItems);\n      // Garantizar que siempre se pase un array válido al llamar a onChange\n      onChange(safeItems);\n      \n      console.log(\"🔥 ADDING NEW FILES - onChange called with\", safeItems.length, \"items\");\n      \n      // Limpiar input para que pueda seleccionar los mismos archivos de nuevo\n      e.target.value = '';\n      \n      // Mostrar mensaje de éxito\n      toast({\n        title: \"Archivos agregados\",\n        description: `Se han agregado ${newItems.length} ${mediaType === 'photo' ? 'fotos' : 'videos'}`,\n      });\n    } catch (error) {\n      console.error(\"Error al procesar archivos:\", error);\n      toast({\n        title: \"Error al procesar archivos\",\n        description: \"No se pudieron procesar algunos archivos. Intenta nuevamente.\",\n        variant: \"destructive\"\n      });\n      \n      // Limpiar input para que pueda seleccionar los mismos archivos de nuevo\n      if (e.target) e.target.value = '';\n      \n      // En caso de error, asegurémonos de que onChange reciba un array válido (el estado actual)\n      onChange(Array.isArray(mediaItems) ? mediaItems : []);\n    }\n  };\n  \n  // Función mejorada para establecer un elemento como principal\n  const handleSetMain = (index: number) => {\n    console.log(\"===== MARCANDO COMO PRINCIPAL =====\");\n    console.log(\"Índice seleccionado:\", index);\n    \n    if (disabled) return;\n    \n    // Validación inicial robusta\n    if (!Array.isArray(mediaItems)) {\n      console.error(\"mediaItems no es un array válido\");\n      onChange([]);\n      return;\n    }\n    \n    if (index < 0 || index >= mediaItems.length) {\n      console.error(\"Índice inválido:\", index);\n      onChange([...mediaItems]);\n      return;\n    }\n    \n    const targetItem = mediaItems[index];\n    \n    // Verificaciones de validez del elemento objetivo\n    if (!targetItem || typeof targetItem !== 'object') {\n      console.error(\"Elemento no válido en el índice:\", index);\n      onChange([...mediaItems]);\n      return;\n    }\n    \n    // No se puede marcar como principal un elemento eliminado\n    if (targetItem.deleted || targetItem.toDelete) {\n      toast({\n        title: \"Elemento no válido\",\n        description: \"No se puede establecer como principal un elemento eliminado\",\n        variant: \"destructive\"\n      });\n      return;\n    }\n    \n    // No se puede marcar como principal un elemento con errores\n    if (targetItem.errorMessage) {\n      toast({\n        title: \"Elemento con errores\",\n        description: \"No se puede establecer como principal un elemento que tiene errores\",\n        variant: \"destructive\"\n      });\n      return;\n    }\n    \n    // Debe tener contenido válido (URL, file o previewUrl)\n    if (!targetItem.url && !targetItem.file && !targetItem.previewUrl) {\n      toast({\n        title: \"Elemento sin contenido\",\n        description: \"Este elemento no tiene imagen o video válido\",\n        variant: \"destructive\"\n      });\n      return;\n    }\n    \n    try {\n      // Filtrar elementos válidos y actualizar estado\n      const validItems = mediaItems.filter(item => \n        item !== null && \n        item !== undefined && \n        typeof item === 'object'\n      );\n      \n      // Asegurar que solo el elemento target sea principal\n      const updatedItems = validItems.map((item, i) => ({\n        ...item,\n        isMain: i === index\n      }));\n      \n      // Reorganizar: mover el elemento principal al inicio\n      const reorderedItems = [...updatedItems].sort((a, b) => {\n        // Si uno es principal y el otro no, el principal va primero\n        if (a.isMain && !b.isMain) return -1;\n        if (!a.isMain && b.isMain) return 1;\n        // Si ambos son principales o ninguno es principal, mantener orden actual\n        return 0;\n      });\n      \n      console.log(\"Estado actualizado - Elemento principal:\", \n        reorderedItems.find(item => item.isMain)?.id || \"ninguno\");\n      console.log(\"Elemento principal movido a posición 0\");\n      \n      // Actualizar estado y notificar cambios\n      setMediaItems(reorderedItems);\n      onChange(reorderedItems);\n      \n      // Mostrar confirmación al usuario\n      toast({\n        title: \"Elemento principal actualizado\",\n        description: \"Este elemento será la imagen destacada del evento\",\n      });\n      \n    } catch (error) {\n      console.error(\"Error al establecer elemento principal:\", error);\n      toast({\n        title: \"Error al actualizar\",\n        description: \"No se pudo establecer el elemento principal\",\n        variant: \"destructive\"\n      });\n      \n      // Mantener estado actual en caso de error\n      onChange(Array.isArray(mediaItems) ? [...mediaItems] : []);\n    }\n  };\n  \n  // Función para eliminar un elemento\n  const handleRemove = (index: number) => {\n    if (disabled) return;\n    \n    // Verificar que mediaItems es un array válido\n    if (!Array.isArray(mediaItems)) {\n      console.error(\"mediaItems no es un array válido al intentar eliminar\");\n      onChange([]);\n      return;\n    }\n    \n    // Verificar que el índice es válido\n    if (index < 0 || index >= mediaItems.length) {\n      console.error(\"Índice inválido para eliminar:\", index);\n      onChange([...mediaItems]);\n      return;\n    }\n    \n    try {\n      const itemToRemove = mediaItems[index];\n      \n      // Verificar que el elemento existe\n      if (!itemToRemove) {\n        console.error(\"Elemento no encontrado para eliminar\");\n        onChange([...mediaItems]);\n        return;\n      }\n      \n      // Si es un elemento nuevo, eliminarlo completamente\n      if (itemToRemove.isNew) {\n        // Liberar URL de vista previa\n        if (itemToRemove.previewUrl) {\n          try {\n            URL.revokeObjectURL(itemToRemove.previewUrl);\n          } catch (e) {\n            console.error(\"Error al liberar URL de vista previa:\", e);\n          }\n        }\n        \n        // Filtrar el elemento con validación adicional\n        const updatedItems = mediaItems.filter((item, i) => i !== index && item !== null && item !== undefined);\n        \n        // Si el elemento eliminado era el principal, establecer otro como principal\n        if (itemToRemove.isMain && updatedItems.length > 0) {\n          updatedItems[0].isMain = true;\n        }\n        \n        // Actualizar estado\n        setMediaItems(updatedItems);\n        onChange(updatedItems);\n      } \n      // Si es un elemento existente, marcarlo para eliminación\n      else {\n        const updatedItems = mediaItems.map((item, i) => {\n          if (item === null || item === undefined) {\n            return null; // Será filtrado después\n          }\n          \n          if (i === index) {\n            return {\n              ...item,\n              deleted: true,\n              toDelete: true,\n              isMain: false // Ya no puede ser principal\n            };\n          }\n          return item;\n        }).filter(item => item !== null && item !== undefined); // Filtrar elementos inválidos\n        \n        // Si el elemento eliminado era el principal, establecer otro como principal\n        if (itemToRemove.isMain) {\n          const visibleItems = updatedItems.filter(item => !item.deleted && !item.toDelete);\n          if (visibleItems.length > 0) {\n            // Buscar el primer elemento visible y establecerlo como principal\n            const firstVisibleIndex = updatedItems.findIndex(\n              item => !item.deleted && !item.toDelete\n            );\n            \n            if (firstVisibleIndex >= 0) {\n              updatedItems[firstVisibleIndex].isMain = true;\n            }\n          }\n        }\n        \n        // Actualizar estado\n        setMediaItems(updatedItems);\n        onChange(updatedItems);\n      }\n      \n      // Mostrar notificación\n      toast({\n        title: \"Elemento eliminado\",\n        description: \"El archivo ha sido eliminado\"\n      });\n    } catch (error) {\n      console.error(\"Error al eliminar elemento:\", error);\n      toast({\n        title: \"Error al eliminar\",\n        description: \"No se pudo eliminar el elemento\",\n        variant: \"destructive\"\n      });\n      \n      // En caso de error, asegurar que devolvemos un array válido\n      onChange(Array.isArray(mediaItems) ? [...mediaItems] : []);\n    }\n  };\n\n  // Verificación mejorada: asegurar que siempre hay un elemento principal válido\n  useEffect(() => {\n    if (!Array.isArray(mediaItems) || mediaItems.length === 0) return;\n    \n    const visibleItems = mediaItems.filter(item => \n      item && !item.deleted && !item.toDelete && (item.url || item.file || item.previewUrl)\n    );\n    \n    if (visibleItems.length === 0) return;\n    \n    const hasValidMainItem = visibleItems.some(item => item.isMain === true);\n    \n    // Solo intervenir si NO hay elemento principal válido\n    if (!hasValidMainItem) {\n      console.log(\"Auto-asignando elemento principal - no hay uno válido\");\n      \n      const firstValidIndex = mediaItems.findIndex(item => \n        item && !item.deleted && !item.toDelete && (item.url || item.file || item.previewUrl)\n      );\n      \n      if (firstValidIndex >= 0) {\n        const updatedItems = mediaItems.map((item, i) => ({\n          ...item,\n          isMain: i === firstValidIndex\n        }));\n        \n        setMediaItems(updatedItems);\n        onChange(updatedItems);\n        \n        console.log(\"Elemento principal auto-asignado:\", {\n          índice: firstValidIndex,\n          tipo: updatedItems[firstValidIndex].type\n        });\n      }\n    }\n  }, [mediaItems, onChange]);\n\n  return (\n    <div className=\"w-full\">\n      {/* Contador de archivos */}\n      <div className=\"flex justify-between mb-2 text-sm text-gray-600\">\n        <div>Fotos: {photoCount}/{maxPhotos}</div>\n        <div>Videos: {videoCount}/{maxVideos}</div>\n      </div>\n      \n      {/* Contenedor de miniaturas */}\n      <div className=\"grid grid-cols-2 gap-2 mb-4 max-w-full\">\n        {mediaItems.map((item, index) => {\n          // Validar elemento antes de procesarlo\n          if (!item || typeof item !== 'object') {\n            console.warn(`Invalid item at index ${index}:`, item);\n            return null;\n          }\n          \n          // No mostrar elementos eliminados\n          if (item.deleted || item.toDelete) return null;\n          \n          console.log(`Rendering media item ${index}:`, {\n            id: item.id,\n            type: item.type,\n            hasUrl: !!item.url,\n            hasPreviewUrl: !!item.previewUrl,\n            isMain: item.isMain,\n            isNew: item.isNew\n          });\n          \n          return (\n            <div \n              key={item.id || index}\n              className={cn(\n                \"relative group aspect-square rounded-md overflow-hidden shadow-sm\",\n                item.isMain ? \"ring-2 ring-yellow-500\" : \"\",\n                disabled ? \"opacity-70 pointer-events-none\" : \"\"\n              )}\n            >\n              {/* Contenido del medio */}\n              {item && item.type ? (\n                item.type === 'photo' ? (\n                  // Foto\n                  <img \n                    src={item.previewUrl || item.url}\n                    alt={`Foto ${index + 1}`}\n                    className=\"w-full h-full object-cover\"\n                    onError={(e) => {\n                      e.currentTarget.src = 'data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><line x1=\"15\" y1=\"9\" x2=\"9\" y2=\"15\"/><line x1=\"9\" y1=\"9\" x2=\"15\" y2=\"15\"/></svg>';\n                    }}\n                  />\n                ) : (\n                  // Video\n                  <video \n                    src={item.previewUrl || item.url}\n                    className=\"w-full h-full object-cover\"\n                    muted\n                  />\n                )\n              ) : (\n                // Fallback por si item o item.type no existe\n                <div className=\"w-full h-full flex items-center justify-center bg-gray-200\">\n                  <span className=\"text-gray-500 text-xs\">Archivo no disponible</span>\n                </div>\n              )}\n              \n              {/* Indicador de tipo */}\n              {item && item.type && (\n                <div className=\"absolute bottom-1 right-1 bg-black/50 rounded-full p-1\">\n                  {item.type === 'photo' ? (\n                    <Image size={14} className=\"text-white\" />\n                  ) : (\n                    <Video size={14} className=\"text-white\" />\n                  )}\n                </div>\n              )}\n              \n              {/* Controles superpuestos */}\n              {item && (\n                <div className=\"absolute top-0 left-0 right-0 flex justify-between p-1\">\n                  {/* Botón para eliminar */}\n                  <button\n                    type=\"button\"\n                    className=\"bg-red-500 text-white rounded-full p-1 opacity-0 group-hover:opacity-100 transition-opacity\"\n                    onClick={() => handleRemove(index)}\n                  >\n                    <Trash size={14} />\n                  </button>\n                  \n                  {/* Botón para establecer como principal */}\n                  <button\n                    type=\"button\"\n                    className={cn(\n                      \"rounded-full p-1 transition-opacity\",\n                      item.isMain \n                        ? \"bg-yellow-500 text-white opacity-100\" \n                        : \"bg-black/50 text-white opacity-0 group-hover:opacity-100\"\n                    )}\n                    onClick={() => handleSetMain(index)}\n                  >\n                    {item.isMain ? <Star size={14} /> : <StarOff size={14} />}\n                  </button>\n                </div>\n              )}\n              \n              {/* Etiqueta de principal */}\n              {item && item.isMain && (\n                <div className=\"absolute top-1 left-1/2 -translate-x-1/2 bg-yellow-500 text-white px-2 py-0.5 rounded text-xs font-medium shadow\">\n                  Imagen principal\n                </div>\n              )}\n              \n              {/* Estado de carga */}\n              {item && item.uploading && (\n                <div className=\"absolute inset-0 bg-black/70 flex flex-col items-center justify-center\">\n                  <div className=\"text-white text-xs mb-2\">Subiendo...</div>\n                  <Progress value={item.uploadProgress || 0} className=\"w-4/5 h-1\" />\n                </div>\n              )}\n              \n              {/* Mensaje de error */}\n              {item && item.errorMessage && (\n                <div className=\"absolute inset-0 bg-red-500/80 flex items-center justify-center p-2\">\n                  <div className=\"text-white text-xs text-center\">{item.errorMessage}</div>\n                </div>\n              )}\n            </div>\n          );\n        })}\n      </div>\n      \n      {/* Botones para agregar - Uno debajo del otro */}\n      <div className=\"flex flex-col gap-2\">\n        <Button\n          type=\"button\"\n          variant=\"outline\"\n          onClick={(e) => {\n            console.log(\"=== BUTTON CLICK EVENT ===\");\n            console.log(\"Button clicked, event:\", e.type);\n            console.log(\"Can add more photos:\", canAddMorePhotos);\n            console.log(\"Disabled state:\", disabled);\n            console.log(\"Photo count:\", photoCount, \"max:\", maxPhotos);\n\n            e.preventDefault();\n            e.stopPropagation();\n            handleSelectFiles('image/*');\n          }}\n          disabled={!canAddMorePhotos || disabled}\n          className=\"w-full\"\n        >\n          <Image className=\"mr-2 h-4 w-4\" />\n          Agregar fotos\n          <span className=\"ml-1 opacity-60\">{photoCount}/{maxPhotos}</span>\n        </Button>\n        \n        <Button\n          type=\"button\"\n          variant=\"outline\"\n          onClick={() => handleSelectFiles('video/*')}\n          disabled={!canAddMoreVideos || disabled}\n          className=\"w-full\"\n        >\n          <Video className=\"mr-2 h-4 w-4\" />\n          Agregar videos\n          <span className=\"ml-1 opacity-60\">{videoCount}/{maxVideos}</span>\n        </Button>\n      </div>\n      \n      {/* Límites y consejos */}\n      <div className=\"mt-2 text-xs text-gray-500\">\n        <ul className=\"list-disc list-inside space-y-1\">\n          <li>Límites: hasta {maxPhotos} fotos (máx. 10MB c/u) y {maxVideos} videos (máx. 10MB c/u)</li>\n          <li>Para destacar una imagen como principal, haz clic en el botón de estrella</li>\n        </ul>\n      </div>\n      \n      {/* Input oculto para seleccionar archivos */}\n      <input\n        type=\"file\"\n        ref={fileInputRef}\n        className=\"hidden\"\n        onChange={(e) => {\n          console.log(\"=== FILE INPUT CHANGE EVENT ===\");\n          console.log(\"Files selected:\", e.target.files?.length || 0);\n          if (e.target.files) {\n            const files = Array.from(e.target.files);\n            console.log(\"Files details:\", files.map(f => ({ name: f.name, type: f.type, size: f.size })));\n          }\n          handleFileChange(e);\n        }}\n        multiple\n      />\n    </div>\n  );\n};\n\n// Exportación predeterminada para compatibilidad con las importaciones existentes\nexport default MediaManager;\n","size_bytes":28592},"client/src/components/events/media-manager.tsx":{"content":"import React, { useState, useEffect, useRef } from 'react';\nimport { Button } from '@/components/ui/button';\nimport { Badge } from '@/components/ui/badge';\nimport { Trash, Video, Image, Star, StarOff, GripVertical, AlertCircle, Loader2 } from 'lucide-react';\nimport { cn } from '@/lib/utils';\nimport { useToast } from '@/hooks/use-toast';\nimport MediaPreview from './media-preview';\n\nexport type MediaItem = {\n  id?: string;\n  type: 'photo' | 'video';\n  url?: string; // URL para medios existentes\n  file?: File; // File para nuevos medios\n  previewUrl?: string; // URL temporal para vista previa (solo para UI)\n  isMain?: boolean;\n  isNew?: boolean;\n  deleted?: boolean; // Marca para vista (ocultar de la UI)\n  toDelete?: boolean; // Marca para enviar al servidor (eliminación permanente)\n  order?: number; // Para ordenamiento\n  uploading?: boolean; // Estado de carga\n  uploadProgress?: number; // Progreso de carga (0-100)\n  errorMessage?: string; // Mensaje de error si falla la carga\n  fileIndex?: number; // Índice del archivo para seguimiento en el servidor\n};\n\ntype MediaManagerProps = {\n  existingMedia?: MediaItem[] | string; // Puede ser string para JSON o MediaItem[]\n  onChange: (media: MediaItem[]) => void;\n  maxPhotos?: number;\n  maxVideos?: number;\n  disabled?: boolean;\n};\n\nexport const MediaManager: React.FC<MediaManagerProps> = ({\n  existingMedia = [],\n  onChange,\n  maxPhotos = 6,\n  maxVideos = 3,\n  disabled = false,\n}) => {\n  const { toast } = useToast();\n  // Inicialización segura de mediaItems\n  const [mediaItems, setMediaItems] = useState<MediaItem[]>(() => {\n    // Manejar caso donde existingMedia es undefined o null\n    if (existingMedia === undefined || existingMedia === null) {\n      console.log(\"existingMedia es undefined/null, inicializando como array vacío\");\n      return [];\n    }\n    \n    // Manejar caso donde existingMedia es string\n    if (typeof existingMedia === 'string') {\n      try {\n        // Si es string vacío, devolver array vacío\n        if (!existingMedia.trim()) {\n          return [];\n        }\n        \n        const parsed = JSON.parse(existingMedia);\n        \n        // Verificar que el resultado sea un array\n        if (!Array.isArray(parsed)) {\n          console.warn(\"existingMedia parseado no es un array:\", parsed);\n          return [];\n        }\n        \n        // Filtrar elementos inválidos\n        return parsed.filter(item => item !== null && item !== undefined);\n      } catch (e) {\n        console.error('Error parsing media JSON:', e);\n        return [];\n      }\n    }\n    \n    // Si es array, asegurarse de que todos los elementos son válidos\n    if (Array.isArray(existingMedia)) {\n      return existingMedia.filter(item => item !== null && item !== undefined);\n    }\n    \n    // Caso por defecto\n    console.warn(\"existingMedia no es un tipo reconocido:\", typeof existingMedia);\n    return [];\n  });\n  \n  const [photoCount, setPhotoCount] = useState(0);\n  const [videoCount, setVideoCount] = useState(0);\n  const [draggedItem, setDraggedItem] = useState<number | null>(null);\n  const [dragOverItem, setDragOverItem] = useState<number | null>(null);\n  const fileInputRef = useRef<HTMLInputElement>(null);\n  \n  // Actualizar los contadores cuando cambia la lista de medios\n  useEffect(() => {\n    if (!Array.isArray(mediaItems)) {\n      console.error(\"mediaItems no es un array en useEffect\");\n      return;\n    }\n    \n    // Contar fotos y videos válidos (no eliminados o marcados para eliminar)\n    const photos = mediaItems.filter(\n      item => item && item.type === 'photo' && !item.deleted && !item.toDelete\n    );\n    const videos = mediaItems.filter(\n      item => item && item.type === 'video' && !item.deleted && !item.toDelete\n    );\n    \n    setPhotoCount(photos.length);\n    setVideoCount(videos.length);\n  }, [mediaItems]);\n  \n  // Abrir el selector de archivos\n  const handleAddMedia = (isPhoto: boolean) => {\n    if (disabled) return;\n    \n    // Verificar si hay espacio disponible\n    if (isPhoto && photoCount >= maxPhotos) {\n      toast({\n        title: \"Límite alcanzado\",\n        description: `No puedes agregar más de ${maxPhotos} fotos`,\n        variant: \"destructive\"\n      });\n      return;\n    }\n    \n    if (!isPhoto && videoCount >= maxVideos) {\n      toast({\n        title: \"Límite alcanzado\",\n        description: `No puedes agregar más de ${maxVideos} videos`,\n        variant: \"destructive\"\n      });\n      return;\n    }\n    \n    // Verificar y crear el input de archivos si es necesario\n    if (!fileInputRef.current) {\n      console.error(\"Input de archivos no encontrado\");\n      return;\n    }\n    \n    // Establecer los tipos de archivos aceptados\n    fileInputRef.current.accept = isPhoto ? 'image/*' : 'video/*';\n    fileInputRef.current.dataset.type = isPhoto ? 'photo' : 'video';\n    \n    // Abrir el selector de archivos\n    fileInputRef.current.click();\n  };\n  \n  // Manejar la selección de archivos\n  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    if (disabled) return;\n    \n    const files = Array.from(e.target.files || []);\n    if (files.length === 0) return;\n    \n    const isPhoto = e.target.dataset.type === 'photo';\n    console.log(`Agregando ${files.length} ${isPhoto ? 'fotos' : 'videos'}`);\n    \n    // Calcular espacio disponible\n    const currentCount = isPhoto ? photoCount : videoCount;\n    const maxAllowed = isPhoto ? maxPhotos : maxVideos;\n    const availableSlots = Math.max(0, maxAllowed - currentCount);\n    \n    if (availableSlots === 0) {\n      toast({\n        title: \"Límite alcanzado\",\n        description: `No puedes agregar más ${isPhoto ? 'fotos' : 'videos'}`,\n        variant: \"destructive\"\n      });\n      return;\n    }\n    \n    if (files.length > availableSlots) {\n      toast({\n        title: \"Demasiados archivos\",\n        description: `Solo se agregarán los primeros ${availableSlots} archivos`,\n      });\n    }\n    \n    // Limitar la cantidad de archivos que se pueden agregar\n    const filesToAdd = files.slice(0, availableSlots);\n    \n    // Asegurarnos de que mediaItems es un array válido\n    const safeMediaItems = Array.isArray(mediaItems) ? mediaItems : [];\n    \n    // Verificar si hay algún elemento principal existente (con protección adicional contra null/undefined)\n    const hasMainItem = safeMediaItems.some(item => \n      item && item.isMain === true && item.deleted !== true && item.toDelete !== true\n    );\n    \n    // Crear nuevos elementos de medios\n    const newMediaItems = filesToAdd.map((file, idx): MediaItem => {\n      // Para evitar archivos no soportados\n      const isValidType = isPhoto \n        ? file.type.startsWith('image/') \n        : file.type.startsWith('video/');\n      \n      // Verificar el tamaño (límite de 5MB para imágenes, 10MB para videos)\n      const maxSize = isPhoto ? 5 * 1024 * 1024 : 10 * 1024 * 1024;\n      const isSizeValid = file.size <= maxSize;\n      \n      // Determinar si este elemento debe ser principal\n      // Prioridad para fotos como elemento principal\n      const shouldBeMain = !hasMainItem && \n                          ((isPhoto && idx === 0) || \n                           (safeMediaItems.length === 0 && idx === 0));\n      \n      let errorMsg;\n      if (!isValidType) {\n        errorMsg = `Formato no soportado: ${file.type}`;\n      } else if (!isSizeValid) {\n        errorMsg = `Archivo demasiado grande: ${(file.size / (1024 * 1024)).toFixed(1)}MB (máx. ${isPhoto ? '5MB' : '10MB'})`;\n      }\n        \n      // Generar un ID único para este elemento\n      const uniqueId = `new-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n      \n      // Crear una URL de vista previa para el archivo (con manejo seguro)\n      let previewUrl = '';\n      try {\n        previewUrl = URL.createObjectURL(file);\n      } catch (error) {\n        console.error(\"Error creando URL para vista previa:\", error);\n        errorMsg = errorMsg || \"Error procesando archivo\";\n      }\n      \n      console.log(`Agregando nuevo elemento: ${uniqueId}, tipo: ${isPhoto ? 'photo' : 'video'}, archivo: ${file.name}`);\n      \n      // Crear objeto MediaItem con valores seguros\n      return {\n        id: uniqueId,\n        type: isPhoto ? 'photo' : 'video',\n        file,\n        previewUrl, // URL temporal para vista previa\n        isNew: true,\n        order: safeMediaItems.length + idx,\n        fileIndex: idx, // Agregar índice para seguimiento\n        errorMessage: errorMsg,\n        isMain: shouldBeMain && isValidType && isSizeValid\n      };\n    });\n    \n    // Filtrar archivos con errores que no se van a usar\n    const validMediaItems = newMediaItems.filter(item => !item.errorMessage);\n    const invalidMediaItems = newMediaItems.filter(item => !!item.errorMessage);\n    \n    // No mostramos alerta para archivos inválidos\n    // Simplemente los incluimos en la lista con su mensaje de error\n    // para que el usuario pueda eliminarlos manualmente\n    \n    // Actualizar el estado con los archivos nuevos\n    // IMPORTANTE: Usar la versión segura de mediaItems (safeMediaItems)\n    const updatedMedia = [...safeMediaItems, ...newMediaItems];\n    console.log(\"Media antes de ordenar:\", updatedMedia.length, \"elementos\");\n    \n    // Asegurarse de que no haya null/undefined en el array\n    const cleanMedia = updatedMedia.filter(item => item !== null && item !== undefined);\n    \n    // Asegurarse de que no haya duplicados (basados en el ID único)\n    // Manejo adicional para casos donde los atributos puedan ser undefined\n    const uniqueMedia = Array.from(new Map(\n      cleanMedia.map(item => {\n        const key = item.id || `${item.url || (item.file ? item.file.name : '') || Date.now()}`;\n        return [key, item];\n      })\n    ).values());\n    \n    console.log(\"Media después de eliminar duplicados:\", uniqueMedia);\n    \n    // Ordenar los elementos asegurando que cada uno tiene un orden válido\n    const sortedMedia = [...uniqueMedia].sort((a, b) => \n      (a.order || 0) - (b.order || 0)\n    );\n    \n    // Asegurarse de que haya exactamente un elemento principal\n    const mainItems = sortedMedia.filter(item => \n      item && item.isMain && !item.deleted && !item.toDelete && !item.errorMessage\n    );\n    \n    let finalMedia = sortedMedia;\n    \n    // Si hay más de un elemento principal, dejar solo uno (priorizar fotos)\n    if (mainItems.length > 1) {\n      console.log(\"Hay más de un elemento principal, corrigiendo...\");\n      const mainPhoto = mainItems.find(item => item.type === 'photo');\n      const itemToSetMain = mainPhoto || mainItems[0];\n      console.log(\"Elemento principal seleccionado:\", \n                 itemToSetMain.type, \n                 itemToSetMain.id || \"sin ID\");\n      \n      // Marcar solo uno como principal\n      finalMedia = sortedMedia.map(item => ({\n        ...item,\n        isMain: item === itemToSetMain\n      }));\n    }\n    // Si no hay ningún elemento principal y hay elementos válidos, marcar el primero como principal\n    else if (mainItems.length === 0 && validMediaItems.length > 0) {\n      console.log(\"No hay elemento principal, estableciendo uno automáticamente\");\n      // Buscar primero una foto para establecer como principal\n      const firstPhoto = sortedMedia.find(\n        item => item.type === 'photo' && !item.deleted && !item.toDelete && !item.errorMessage\n      );\n      const firstValid = firstPhoto || sortedMedia.find(\n        item => !item.deleted && !item.toDelete && !item.errorMessage\n      );\n      \n      if (firstValid) {\n        finalMedia = sortedMedia.map(item => ({\n          ...item,\n          isMain: item === firstValid\n        }));\n        console.log(\"Elemento principal establecido automáticamente:\", \n                   firstValid.type, \n                   firstValid.id || \"sin ID\");\n      }\n    }\n    \n    // Verificar cuántos elementos principales tenemos ahora\n    const finalMainItems = finalMedia.filter(item => \n      item.isMain && !item.deleted && !item.toDelete\n    );\n    console.log(\"Elementos principales después de procesar:\", finalMainItems.length);\n    \n    // Actualizar el estado con los elementos procesados\n    setMediaItems(finalMedia);\n    \n    // Actualizar los contadores\n    if (isPhoto) {\n      setPhotoCount(prev => prev + validMediaItems.length);\n    } else {\n      setVideoCount(prev => prev + validMediaItems.length);\n    }\n    \n    // Notificar al componente padre\n    onChange(finalMedia);\n    \n    // Limpiar el input de archivos para permitir seleccionar el mismo archivo nuevamente\n    if (fileInputRef.current) {\n      fileInputRef.current.value = '';\n    }\n  };\n  \n  // Manejar arrastrar y soltar (drag & drop)\n  const handleDragStart = (index: number) => {\n    if (disabled) return;\n    setDraggedItem(index);\n  };\n  \n  const handleDragOver = (index: number) => {\n    if (disabled) return;\n    setDragOverItem(index);\n  };\n  \n  const handleDragEnd = () => {\n    if (disabled || draggedItem === null || dragOverItem === null) return;\n    \n    // Los índices deben ser distintos y válidos\n    if (draggedItem === dragOverItem || \n        draggedItem < 0 || dragOverItem < 0 || \n        draggedItem >= mediaItems.length || dragOverItem >= mediaItems.length) {\n      setDraggedItem(null);\n      setDragOverItem(null);\n      return;\n    }\n    \n    // Crear una copia del array para no mutar el estado directamente\n    const items = [...mediaItems];\n    const draggedItemContent = items[draggedItem];\n    \n    // Protección contra elementos null/undefined\n    if (!draggedItemContent) {\n      console.error(\"El elemento arrastrado es null o undefined\");\n      setDraggedItem(null);\n      setDragOverItem(null);\n      return;\n    }\n    \n    // Eliminar elemento arrastrado\n    items.splice(draggedItem, 1);\n    \n    // Insertar en nueva posición\n    items.splice(dragOverItem, 0, draggedItemContent);\n    \n    // Actualizar índices/orden\n    const reorderedItems = items.map((item, idx) => ({\n      ...item,\n      order: idx\n    }));\n    \n    // Actualizar estado local\n    setMediaItems(reorderedItems);\n    \n    // Notificar al componente padre\n    onChange(reorderedItems);\n    \n    // Limpiar estados de arrastre\n    setDraggedItem(null);\n    setDragOverItem(null);\n  };\n\n  // Eliminar un medio\n  const handleRemoveMedia = (indexToRemove: number) => {\n    if (disabled) return;\n    \n    // Verificar que el índice es válido y mediaItems existe\n    if (!mediaItems || indexToRemove < 0 || indexToRemove >= mediaItems.length) {\n      console.error(\"Índice de eliminación inválido o no hay elementos multimedia\");\n      return;\n    }\n    \n    const itemToRemove = mediaItems[indexToRemove];\n    \n    // Verificar que itemToRemove existe\n    if (!itemToRemove) {\n      console.error(\"No se pudo encontrar el elemento a eliminar\");\n      return;\n    }\n    \n    console.log(\"Eliminando elemento multimedia:\", itemToRemove);\n    \n    // Si es un elemento nuevo, simplemente lo eliminamos del array\n    if (itemToRemove.isNew) {\n      console.log(\"Eliminando elemento nuevo:\", itemToRemove);\n      \n      // Filtrar el elemento a eliminar\n      const updatedMedia = mediaItems.filter((item, index) => index !== indexToRemove);\n      \n      // Verificar si necesitamos asignar un nuevo elemento principal\n      if (itemToRemove.isMain && updatedMedia.length > 0) {\n        console.log(\"El elemento eliminado era principal, buscando nuevo elemento principal\");\n        \n        // Buscar primero una foto para establecer como principal\n        const firstPhoto = updatedMedia.find(\n          item => item.type === 'photo' && !item.deleted && !item.toDelete\n        );\n        \n        const firstValid = firstPhoto || updatedMedia.find(\n          item => !item.deleted && !item.toDelete\n        );\n        \n        if (firstValid) {\n          console.log(\"Nuevo elemento principal:\", firstValid);\n          \n          // Marcar el nuevo elemento como principal\n          const finalMedia = updatedMedia.map(item => ({\n            ...item,\n            isMain: item === firstValid\n          }));\n          \n          // Actualizar estado\n          setMediaItems(finalMedia);\n          \n          // Actualizar contadores\n          const newPhotoCount = finalMedia.filter(\n            item => item.type === 'photo' && !item.deleted && !item.toDelete\n          ).length;\n          \n          const newVideoCount = finalMedia.filter(\n            item => item.type === 'video' && !item.deleted && !item.toDelete\n          ).length;\n          \n          setPhotoCount(newPhotoCount);\n          setVideoCount(newVideoCount);\n          \n          // Notificar al componente padre\n          onChange(finalMedia);\n          return;\n        }\n      }\n      \n      // Actualizar estado\n      setMediaItems(updatedMedia);\n      \n      // Actualizar contadores\n      const newPhotoCount = updatedMedia.filter(\n        item => item.type === 'photo' && !item.deleted && !item.toDelete\n      ).length;\n      \n      const newVideoCount = updatedMedia.filter(\n        item => item.type === 'video' && !item.deleted && !item.toDelete\n      ).length;\n      \n      setPhotoCount(newPhotoCount);\n      setVideoCount(newVideoCount);\n      \n      // Notificar al componente padre\n      onChange(updatedMedia);\n    } \n    // Si es un elemento existente, lo marcamos para eliminación\n    else {\n      console.log(\"Marcando elemento existente para eliminación:\", itemToRemove);\n      \n      // Crear una copia para no mutar el estado directamente\n      const updatedMedia = mediaItems.map((item, index) => {\n        if (index === indexToRemove) {\n          return {\n            ...item,\n            deleted: true, // Para la UI (ocultar)\n            toDelete: true, // Para el backend (eliminar de la DB)\n            isMain: false // Nunca mostrar como principal un elemento eliminado\n          };\n        }\n        return item;\n      });\n      \n      // Verificar si necesitamos asignar un nuevo elemento principal\n      if (itemToRemove.isMain) {\n        console.log(\"El elemento marcado para eliminación era principal, buscando reemplazo\");\n        \n        // Elementos no eliminados\n        const visibleItems = updatedMedia.filter(\n          item => !item.deleted && !item.toDelete\n        );\n        \n        if (visibleItems.length > 0) {\n          // Buscar primero una foto para establecer como principal\n          const firstPhoto = visibleItems.find(item => item.type === 'photo');\n          const firstValid = firstPhoto || visibleItems[0];\n          \n          if (firstValid) {\n            console.log(\"Nuevo elemento principal después de eliminación:\", firstValid);\n            \n            // Crear array final con el nuevo elemento principal\n            const finalMedia = updatedMedia.map(item => {\n              if (item === firstValid) {\n                return {\n                  ...item,\n                  isMain: true\n                };\n              }\n              return item;\n            });\n            \n            // Actualizar estado\n            setMediaItems(finalMedia);\n            \n            // Notificar al componente padre\n            onChange(finalMedia);\n            \n            // Actualizar contadores\n            const newPhotoCount = finalMedia.filter(\n              item => item.type === 'photo' && !item.deleted && !item.toDelete\n            ).length;\n            \n            const newVideoCount = finalMedia.filter(\n              item => item.type === 'video' && !item.deleted && !item.toDelete\n            ).length;\n            \n            setPhotoCount(newPhotoCount);\n            setVideoCount(newVideoCount);\n            \n            return;\n          }\n        }\n      }\n      \n      // Actualizar estado\n      setMediaItems(updatedMedia);\n      \n      // Notificar al componente padre\n      onChange(updatedMedia);\n      \n      // Actualizar contadores\n      const newPhotoCount = updatedMedia.filter(\n        item => item.type === 'photo' && !item.deleted && !item.toDelete\n      ).length;\n      \n      const newVideoCount = updatedMedia.filter(\n        item => item.type === 'video' && !item.deleted && !item.toDelete\n      ).length;\n      \n      setPhotoCount(newPhotoCount);\n      setVideoCount(newVideoCount);\n      \n      // Buscar elementos marcados para eliminación para debugging\n      const itemsToDelete = updatedMedia.filter(item => item.toDelete === true);\n      if (itemsToDelete.length > 0) {\n        console.log(\"Elementos marcados para eliminación:\", \n          itemsToDelete.map(item => ({ url: item.url, type: item.type })));\n      }\n      \n      // Mostrar mensaje de confirmación\n      toast({\n        title: \"Elemento marcado para eliminación\",\n        description: \"El cambio se aplicará al guardar el formulario\",\n      });\n    }\n  };\n  \n  // Establecer un medio como principal\n  const handleSetMainMedia = (indexToSetMain: number) => {\n    // CONTROL 1: Si está deshabilitado, no hacer nada\n    if (disabled) return;\n    \n    console.log(\"===== MARCANDO COMO PRINCIPAL =====\");\n    console.log(\"Índice seleccionado:\", indexToSetMain);\n    \n    // CONTROL 2: Verificar que mediaItems es un array válido\n    if (!Array.isArray(mediaItems)) {\n      console.error(\"Error crítico: mediaItems no es un array\");\n      toast({\n        title: \"Error interno\",\n        description: \"Ocurrió un problema con la gestión de medios\",\n        variant: \"destructive\"\n      });\n      return;\n    }\n    \n    // CONTROL 3: Verificar que el índice es válido\n    if (indexToSetMain < 0 || indexToSetMain >= mediaItems.length) {\n      console.error(\"Índice para establecer como principal fuera de rango:\", indexToSetMain);\n      return;\n    }\n    \n    try {\n      // PASO 1: Crear una copia shallow de los elementos preservando IDs originales\n      const clonedItems: MediaItem[] = mediaItems.map(item => {\n        if (!item) {\n          console.warn(\"Elemento null/undefined detectado en mediaItems\");\n          return null as unknown as MediaItem;\n        }\n        \n        // Preservar el objeto completo sin crear nuevos IDs\n        return {\n          ...item,\n          isMain: false // Por defecto, ninguno es principal (se establecerá después)\n        };\n      }).filter(Boolean) as MediaItem[]; // Eliminar posibles null/undefined\n      \n      // PASO 2: Obtener una referencia segura al elemento a marcar como principal\n      const itemToSetMain = clonedItems[indexToSetMain];\n      \n      // Verificación adicional\n      if (!itemToSetMain) {\n        throw new Error(\"El elemento seleccionado no existe después de la clonación\");\n      }\n      \n      // PASO 3: Verificar que el elemento cumple criterios para ser principal\n      if (itemToSetMain.errorMessage) {\n        console.warn(\"No se puede establecer como principal un elemento con errores\");\n        return;\n      }\n      \n      if (itemToSetMain.deleted || itemToSetMain.toDelete) {\n        console.warn(\"No se puede establecer como principal un elemento marcado para eliminación\");\n        return;\n      }\n      \n      // PASO 4: Marcar solo el elemento seleccionado como principal\n      clonedItems.forEach((item, idx) => {\n        item.isMain = (idx === indexToSetMain);\n      });\n      \n      console.log(\"Estado actualizado - Elemento principal:\", clonedItems[indexToSetMain].id);\n      \n      // Verificar elemento principal para debugging\n      const mainItems = clonedItems.filter(item => item.isMain === true);\n      console.log(\"¿Hay elemento principal explícito?\", mainItems.length > 0);\n      \n      if (mainItems.length > 0) {\n        console.log(\"ELEMENTO PRINCIPAL FINAL:\", {\n          tipo: mainItems[0].type || \"desconocido\",\n          id: mainItems[0].id || \"sin-id\"\n        });\n      } else {\n        console.error(\"¡No se encontró un elemento principal después de la actualización!\");\n      }\n      \n      // PASO 5: Actualizar el estado y notificar al formulario padre de forma inmediata\n      setMediaItems(clonedItems);\n      \n      // IMPORTANTE: Usar una copia fresca para evitar mutaciones accidentales\n      onChange([...clonedItems]);\n      \n      // PASO 6: Aplicar la actualización de forma inmediata (envío instantáneo)\n      // Construimos un objeto FormData y enviamos automáticamente la actualización\n      if (typeof window !== 'undefined' && itemToSetMain && itemToSetMain.url) {\n        // Disparar un evento personalizado para notificar el cambio de elemento principal\n        const customEvent = new CustomEvent('media-main-changed', {\n          detail: {\n            mediaItems: clonedItems,\n            mainItem: itemToSetMain\n          }\n        });\n        window.dispatchEvent(customEvent);\n        \n        console.log('Enviado evento de actualización principal:', customEvent);\n      }\n      \n      // PASO 7: Notificación visual al usuario\n      const mainItem = clonedItems[indexToSetMain];\n      const itemName = mainItem && mainItem.file ? mainItem.file.name : \n                     (mainItem && mainItem.url ? 'Archivo destacado' : 'Elemento');\n      \n      toast({\n        title: \"✓ Elemento principal actualizado\",\n        description: `${itemName} ahora es la imagen destacada. Los cambios se guardan automáticamente.`,\n        duration: 2000\n      });\n      console.log(\"ELEMENTO PRINCIPAL FINAL:\", {tipo: mainItems.length > 0 ? mainItems[0].type : 'ninguno'});\n      console.log(\"=== FIN PROCESAMIENTO onChange ===\");\n      \n    } catch (error) {\n      // MANEJO DE ERRORES\n      console.error(\"Error crítico al establecer elemento principal:\", error);\n      \n      toast({\n        title: \"Error al establecer elemento principal\",\n        description: \"Ha ocurrido un problema técnico. Por favor, inténtalo de nuevo.\",\n        variant: \"destructive\",\n        duration: 5000\n      });\n    }\n  };\n  \n  // Renderizar miniatura para medio (foto o video)\n  const renderMediaItem = (item: MediaItem, index: number) => {\n    // Verificar si el item es válido\n    if (!item) {\n      console.error(`Intentando renderizar un item undefined o null en el índice ${index}`);\n      return null;\n    }\n    \n    // No mostrar elementos eliminados\n    if (item.deleted || item.toDelete) {\n      return null;\n    }\n    \n    return (\n      <div \n        key={item.id || index}\n        className={cn(\n          \"relative group border rounded-md overflow-hidden hover:shadow-md transition-all\",\n          \"flex flex-col items-center justify-center\",\n          \"min-w-[120px] w-[120px] h-[120px]\",\n          \"bg-background\",\n          draggedItem === index ? \"opacity-50 border-dashed\" : \"\",\n          dragOverItem === index ? \"bg-accent\" : \"\",\n          item.errorMessage ? \"border-destructive\" : (item.isMain ? \"border-primary border-2\" : \"border-border\")\n        )}\n        draggable={!disabled}\n        onDragStart={() => handleDragStart(index)}\n        onDragOver={() => handleDragOver(index)}\n        onDragEnd={handleDragEnd}\n      >\n        {/* Previsualizacion del medio */}\n        <MediaPreview \n          file={item.file}\n          url={item.url}\n          previewUrl={item.previewUrl}\n          type={item.type}\n          className=\"w-full h-full object-cover\"\n        />\n        \n        {/* Acciones */}\n        <div className=\"absolute inset-0 flex items-center justify-center opacity-0 group-hover:opacity-100 bg-black/50 transition-opacity\">\n          {/* Botón para establecer como principal */}\n          <Button\n            type=\"button\"\n            onClick={() => handleSetMainMedia(index)}\n            disabled={item.isMain || disabled}\n            className={cn(\n              \"absolute top-1 left-1 h-7 w-7 p-0 rounded-full\",\n              item.isMain ? \"bg-primary text-primary-foreground hover:bg-primary/90\" : \"bg-black/50 hover:bg-black/70\"\n            )}\n            title=\"Establecer como principal\"\n          >\n            {item.isMain ? <Star size={14} /> : <StarOff size={14} />}\n          </Button>\n          \n          {/* Botón para eliminar */}\n          <Button\n            type=\"button\"\n            onClick={() => handleRemoveMedia(index)}\n            disabled={disabled}\n            className=\"absolute top-1 right-1 h-7 w-7 p-0 rounded-full bg-black/50 hover:bg-destructive/90\"\n            title=\"Eliminar\"\n          >\n            <Trash size={14} />\n          </Button>\n        </div>\n        \n        {/* Icono de tipo */}\n        <div className=\"absolute bottom-1 left-1 bg-black/50 text-white p-1 rounded-sm text-xs\">\n          {item.type === 'photo' ? <Image size={14} /> : <Video size={14} />}\n        </div>\n        \n        {/* Indicador de elemento principal */}\n        {item.isMain && (\n          <Badge className=\"absolute bottom-1 right-1 text-xs bg-primary\" variant=\"default\">\n            Principal\n          </Badge>\n        )}\n        \n        {/* Mensaje de error si lo hay */}\n        {item.errorMessage && (\n          <div className=\"absolute inset-0 flex items-center justify-center bg-black/70 text-white p-2 text-xs text-center\">\n            <div className=\"flex flex-col items-center space-y-1\">\n              <AlertCircle size={16} className=\"text-destructive\" />\n              <span>{item.errorMessage}</span>\n            </div>\n          </div>\n        )}\n        \n        {/* Indicador de carga */}\n        {item.uploading && (\n          <div className=\"absolute inset-0 flex flex-col items-center justify-center bg-black/70 text-white\">\n            <Loader2 size={24} className=\"animate-spin mb-2\" />\n            <div className=\"text-xs\">{item.uploadProgress || 0}%</div>\n          </div>\n        )}\n      </div>\n    );\n  };\n  \n  // Conteo de elementos válidos (no eliminados)\n  const visibleItems = mediaItems.filter(item => !item.deleted && !item.toDelete);\n  \n  return (\n    <div className=\"space-y-4\">\n      {/* Input oculto para seleccionar archivos */}\n      <input \n        type=\"file\" \n        ref={fileInputRef}\n        className=\"hidden\"\n        onChange={handleFileChange}\n        multiple\n      />\n      \n      {/* Área de visualización de medios */}\n      <div className=\"flex flex-wrap gap-3 min-h-[120px] border border-dashed rounded-md p-3\">\n        {visibleItems.length > 0 ? (\n          visibleItems.map((item, index) => renderMediaItem(item, index))\n        ) : (\n          <div className=\"w-full h-full flex items-center justify-center text-muted-foreground text-sm py-8\">\n            No hay medios añadidos\n          </div>\n        )}\n      </div>\n      \n      {/* Botones para agregar medios */}\n      <div className=\"flex flex-wrap gap-2\">\n        <Button\n          type=\"button\"\n          onClick={() => handleAddMedia(true)}\n          disabled={disabled || photoCount >= maxPhotos}\n          variant=\"outline\"\n          className=\"text-xs\"\n        >\n          <Image className=\"mr-2\" size={14} />\n          Añadir Foto ({photoCount}/{maxPhotos})\n        </Button>\n        \n        <Button\n          type=\"button\"\n          onClick={() => handleAddMedia(false)}\n          disabled={disabled || videoCount >= maxVideos}\n          variant=\"outline\"\n          className=\"text-xs\"\n        >\n          <Video className=\"mr-2\" size={14} />\n          Añadir Video ({videoCount}/{maxVideos})\n        </Button>\n      </div>\n    </div>\n  );\n};\n\nexport default MediaManager;","size_bytes":31166},"client/src/components/events/media-preview.tsx":{"content":"import React, { useState, useEffect } from 'react';\nimport LoadingSpinner from '@/components/ui/loading-spinner';\n\ntype MediaPreviewProps = {\n  file?: File;\n  url?: string;\n  previewUrl?: string;\n  type: 'photo' | 'video';\n  onLoad?: () => void;\n  onError?: () => void;\n  className?: string;\n};\n\nconst MediaPreview: React.FC<MediaPreviewProps> = ({ \n  file, \n  url,\n  previewUrl,\n  type,\n  onLoad,\n  onError,\n  className = ''\n}) => {\n  const [preview, setPreview] = useState<string | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(false);\n  \n  useEffect(() => {\n    // Si hay una URL de vista previa existente, usarla\n    if (previewUrl) {\n      setPreview(previewUrl);\n      return;\n    }\n    \n    // Si hay una URL para un archivo remoto, usarla\n    if (url) {\n      setPreview(url);\n      return;\n    }\n    \n    // Si hay un archivo local, generar URL de vista previa\n    if (file) {\n      const objectUrl = URL.createObjectURL(file);\n      setPreview(objectUrl);\n      \n      // Cleanup al desmontar\n      return () => {\n        URL.revokeObjectURL(objectUrl);\n      };\n    }\n  }, [file, url, previewUrl]);\n  \n  const handleLoad = () => {\n    setLoading(false);\n    if (onLoad) onLoad();\n  };\n  \n  const handleError = () => {\n    setLoading(false);\n    setError(true);\n    if (onError) onError();\n  };\n  \n  if (!preview) {\n    return (\n      <div className={`flex items-center justify-center bg-gray-100 ${className}`}>\n        <LoadingSpinner size=\"md\" />\n      </div>\n    );\n  }\n  \n  if (type === 'video') {\n    return (\n      <div className={`relative ${className}`}>\n        {loading && (\n          <div className=\"absolute inset-0 flex items-center justify-center bg-black/10\">\n            <LoadingSpinner size=\"md\" />\n          </div>\n        )}\n        <video \n          src={preview}\n          className={`w-full h-full object-cover ${error ? 'hidden' : ''}`}\n          onLoadedData={handleLoad}\n          onError={handleError}\n          muted\n          preload=\"metadata\"\n        />\n        {error && (\n          <div className=\"flex flex-col items-center justify-center w-full h-full bg-red-50 text-red-500\">\n            <span className=\"text-xs\">Error al cargar video</span>\n          </div>\n        )}\n      </div>\n    );\n  }\n  \n  return (\n    <div className={`relative ${className}`}>\n      {loading && (\n        <div className=\"absolute inset-0 flex items-center justify-center bg-black/10\">\n          <LoadingSpinner size=\"md\" />\n        </div>\n      )}\n      <img \n        src={preview}\n        className={`w-full h-full object-cover ${error ? 'hidden' : ''}`}\n        onLoad={handleLoad}\n        onError={handleError}\n        alt=\"Media preview\"\n      />\n      {error && (\n        <div className=\"flex flex-col items-center justify-center w-full h-full bg-red-50 text-red-500\">\n          <span className=\"text-xs\">Error al cargar imagen</span>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default MediaPreview;","size_bytes":2988},"client/src/components/events/simple-media-manager.tsx":{"content":"import React, { useState, useRef, useEffect } from 'react';\nimport { Button } from \"@/components/ui/button\";\nimport { AlertCircle, Image as ImageIcon, Video, Star, StarOff, Trash, Plus } from \"lucide-react\";\nimport { useToast } from \"@/hooks/use-toast\";\n\n// Definición del tipo de elemento multimedia\nexport type MediaItem = {\n  id?: string;\n  type: 'photo' | 'video';\n  url?: string;     // URL para medios existentes\n  file?: File;      // File para nuevos medios\n  previewUrl?: string; // URL temporal para vista previa\n  isMain?: boolean;\n  isNew?: boolean;\n  order?: number;\n  toDelete?: boolean;\n};\n\n// Props para el componente\ninterface SimpleMediaManagerProps {\n  existingMedia?: MediaItem[];\n  onChange: (media: MediaItem[]) => void;\n  maxItems?: number;\n  disabled?: boolean;\n}\n\nconst SimpleMediaManager: React.FC<SimpleMediaManagerProps> = ({\n  existingMedia = [],\n  onChange,\n  maxItems = 10,\n  disabled = false\n}) => {\n  const { toast } = useToast();\n  const [mediaItems, setMediaItems] = useState<MediaItem[]>(existingMedia);\n  const fileInputRef = useRef<HTMLInputElement>(null);\n\n  // Inicializar con medios existentes\n  useEffect(() => {\n    if (existingMedia && existingMedia.length > 0) {\n      setMediaItems(existingMedia);\n    }\n  }, [existingMedia]);\n\n  // Función para cargar un nuevo archivo\n  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    try {\n      const files = e.target.files;\n      if (!files || files.length === 0) return;\n\n      const newItems: MediaItem[] = [];\n      \n      // Comprobar si estamos excediendo el límite\n      if (mediaItems.length + files.length > maxItems) {\n        toast({\n          title: \"Demasiados archivos\",\n          description: `Solo puedes subir hasta ${maxItems} archivos en total.`,\n          variant: \"destructive\",\n        });\n        return;\n      }\n      \n      // Procesar cada archivo\n      Array.from(files).forEach(file => {\n        const isImage = file.type.startsWith('image/');\n        const isVideo = file.type.startsWith('video/');\n        \n        if (!isImage && !isVideo) {\n          toast({\n            title: \"Tipo de archivo no soportado\",\n            description: \"Solo se permiten imágenes y videos.\",\n            variant: \"destructive\",\n          });\n          return;\n        }\n        \n        // Comprobar tamaño máximo (10MB)\n        if (file.size > 10 * 1024 * 1024) {\n          toast({\n            title: \"Archivo demasiado grande\",\n            description: \"El tamaño máximo permitido es 10MB.\",\n            variant: \"destructive\",\n          });\n          return;\n        }\n        \n        // Crear la URL de vista previa\n        const previewUrl = URL.createObjectURL(file);\n        \n        newItems.push({\n          id: `new-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,\n          type: isImage ? 'photo' : 'video',\n          file: file,\n          previewUrl: previewUrl,\n          isNew: true,\n          isMain: mediaItems.length === 0 && newItems.length === 0, // El primer elemento es el principal por defecto\n          order: mediaItems.length + newItems.length\n        });\n      });\n      \n      // Actualizar estado y notificar cambio\n      const updatedItems = [...mediaItems, ...newItems];\n      setMediaItems(updatedItems);\n      onChange(updatedItems);\n      \n      // Limpiar input para permitir seleccionar el mismo archivo nuevamente\n      if (fileInputRef.current) {\n        fileInputRef.current.value = '';\n      }\n    } catch (error) {\n      console.error(\"Error al procesar archivos:\", error);\n      toast({\n        title: \"Error al procesar archivos\",\n        description: \"No se pudieron procesar los archivos seleccionados.\",\n        variant: \"destructive\",\n      });\n    }\n  };\n\n  // Función para eliminar un elemento\n  const handleRemoveMedia = (index: number) => {\n    try {\n      const updatedItems = [...mediaItems];\n      \n      // Si el elemento a eliminar es el principal, debemos establecer otro como principal\n      const isRemovingMain = updatedItems[index]?.isMain === true;\n      \n      // Marcar para eliminar si es un elemento existente, o eliminarlo si es nuevo\n      if (updatedItems[index]?.id && !updatedItems[index]?.isNew) {\n        updatedItems[index] = { \n          ...updatedItems[index], \n          toDelete: true \n        };\n      } else {\n        // Liberar URL de objeto si existe\n        if (updatedItems[index]?.previewUrl) {\n          URL.revokeObjectURL(updatedItems[index].previewUrl!);\n        }\n        updatedItems.splice(index, 1);\n      }\n      \n      // Si eliminamos el elemento principal, establecer el primer elemento visible como principal\n      if (isRemovingMain) {\n        const firstVisibleIndex = updatedItems.findIndex(item => !item.toDelete);\n        if (firstVisibleIndex >= 0) {\n          updatedItems[firstVisibleIndex] = { \n            ...updatedItems[firstVisibleIndex], \n            isMain: true \n          };\n        }\n      }\n      \n      // Actualizar estado\n      setMediaItems(updatedItems);\n      onChange(updatedItems);\n    } catch (error) {\n      console.error(\"Error al eliminar medio:\", error);\n    }\n  };\n\n  // Función para establecer un elemento como principal\n  const handleSetMainMedia = (index: number) => {\n    try {\n      if (index < 0 || index >= mediaItems.length) {\n        console.error(\"Índice fuera de rango:\", index, \"de\", mediaItems.length);\n        return;\n      }\n      \n      console.log(\"Marcando el elemento\", index, \"como principal\");\n      \n      // Crear una copia profunda del array para evitar problemas de referencia\n      const updatedItems = mediaItems.map((item, i) => ({\n        ...item,\n        isMain: i === index // Solo el índice seleccionado será principal\n      }));\n      \n      console.log(\"Items actualizados:\", updatedItems.length);\n      setMediaItems(updatedItems);\n      onChange(updatedItems);\n    } catch (error) {\n      console.error(\"Error al establecer medio principal:\", error);\n    }\n  };\n\n  // Filtrar elementos que no están marcados para eliminar\n  const visibleMediaItems = mediaItems.filter(item => !item.toDelete);\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"flex flex-wrap gap-4\">\n        {visibleMediaItems.map((item, index) => (\n          <div \n            key={item.id || `media-${index}`}\n            className=\"relative border rounded-lg overflow-hidden w-[150px] h-[150px]\"\n          >\n            {/* Vista previa del medio */}\n            <div className=\"w-full h-full flex items-center justify-center bg-gray-100\">\n              {item.type === 'photo' ? (\n                <img \n                  src={item.previewUrl || item.url} \n                  alt=\"Media preview\" \n                  className=\"w-full h-full object-cover\"\n                  onError={(e) => {\n                    (e.target as HTMLImageElement).src = 'https://placehold.co/150x150?text=Error';\n                  }}\n                />\n              ) : (\n                <div className=\"w-full h-full flex items-center justify-center bg-gray-800\">\n                  <Video className=\"w-12 h-12 text-white\" />\n                </div>\n              )}\n            </div>\n            \n            {/* Botones de acción */}\n            <div className=\"absolute top-2 right-2 flex flex-col gap-2\">\n              {/* Botón eliminar */}\n              <Button\n                type=\"button\"\n                variant=\"destructive\"\n                size=\"icon\"\n                className=\"w-8 h-8 rounded-full\"\n                onClick={() => handleRemoveMedia(index)}\n                disabled={disabled}\n              >\n                <Trash className=\"w-4 h-4\" />\n              </Button>\n              \n              {/* Botón marcar como principal */}\n              <Button\n                type=\"button\"\n                variant={item.isMain ? \"default\" : \"outline\"}\n                size=\"icon\"\n                className=\"w-8 h-8 rounded-full\"\n                onClick={() => handleSetMainMedia(index)}\n                disabled={disabled || item.isMain}\n              >\n                {item.isMain ? (\n                  <Star className=\"w-4 h-4\" />\n                ) : (\n                  <StarOff className=\"w-4 h-4\" />\n                )}\n              </Button>\n            </div>\n            \n            {/* Indicador de elemento principal */}\n            {item.isMain && (\n              <div className=\"absolute bottom-2 left-2 bg-primary text-white text-xs px-2 py-1 rounded\">\n                Principal\n              </div>\n            )}\n          </div>\n        ))}\n        \n        {/* Botón para añadir más medios */}\n        {visibleMediaItems.length < maxItems && (\n          <div \n            className=\"border-2 border-dashed rounded-lg overflow-hidden w-[150px] h-[150px] flex flex-col items-center justify-center cursor-pointer hover:bg-gray-50\"\n            onClick={() => fileInputRef.current?.click()}\n          >\n            <Plus className=\"w-8 h-8 text-gray-400\" />\n            <p className=\"text-sm text-gray-500 mt-2\">Añadir</p>\n          </div>\n        )}\n      </div>\n      \n      {/* Input oculto para seleccionar archivos */}\n      <input\n        ref={fileInputRef}\n        type=\"file\"\n        accept=\"image/*,video/*\"\n        multiple\n        onChange={handleFileChange}\n        className=\"hidden\"\n        disabled={disabled}\n      />\n      \n      {/* Mensaje informativo */}\n      <p className=\"text-sm text-gray-500\">\n        {visibleMediaItems.length === 0 \n          ? \"Añade fotos o videos para tu evento\" \n          : `${visibleMediaItems.length} de ${maxItems} elementos seleccionados. Marca uno como principal.`}\n      </p>\n    </div>\n  );\n};\n\nexport default SimpleMediaManager;","size_bytes":9706},"client/src/components/layout/bottom-nav.tsx":{"content":"import { useState, useEffect } from \"react\";\nimport { Link, useLocation } from \"wouter\";\nimport { motion, AnimatePresence } from \"framer-motion\";\nimport {\n  Compass,\n  Calendar,\n  MessageSquare,\n  User,\n  Home,\n  Ticket,\n  Bell,\n} from \"lucide-react\";\nimport { useNavigation } from \"@/contexts/navigation-context\";\nimport { useAuth } from \"@/hooks/use-auth\";\nimport { apiRequest } from \"@/lib/queryClient\";\nimport NotificationsPanel from \"@/components/notifications/notifications-panel\";\n\nexport function BottomNav() {\n  const [location] = useLocation();\n  const { isNavigationVisible } = useNavigation();\n  const { user } = useAuth();\n  const [showNotifications, setShowNotifications] = useState(false);\n  const [notificationCount, setNotificationCount] = useState(0);\n\n  // Debug: log navigation visibility state\n  console.log(\"🎯 BottomNav: isNavigationVisible =\", isNavigationVisible);\n\n  // Map routes to determine which tab is active\n  const isTicketsActive = location.startsWith(\"/tickets\");\n  const isEventsActive = location.startsWith(\"/my-events\");\n  const isHomeActive = location === \"/\" || location.startsWith(\"/explore\"); // Centro - Inicio\n  const isChatsActive = location.startsWith(\"/messages\");\n  const isProfileActive = location.startsWith(\"/profile\");\n\n  // Fetch notification count periodically\n  useEffect(() => {\n    if (user) {\n      const fetchNotificationCount = async () => {\n        try {\n          const response = await apiRequest(\"GET\", \"/api/notifications/count\");\n          if (response.ok) {\n            const data = await response.json();\n            setNotificationCount(data.count || 0);\n          }\n        } catch (error) {\n          console.error(\"Error fetching notification count:\", error);\n        }\n      };\n\n      fetchNotificationCount();\n      \n      // Poll for new notifications every 30 seconds\n      const interval = setInterval(fetchNotificationCount, 30000);\n      return () => clearInterval(interval);\n    }\n  }, [user]);\n\n  return (\n    <>\n      <div \n        className={`fixed bottom-0 left-0 right-0 z-50 px-5 pb-[45px] transition-transform duration-200 ease-out ${!isNavigationVisible ? 'translate-y-full opacity-0' : 'translate-y-0 opacity-100'}`}\n      >\n        <div className=\"bg-white/2 backdrop-blur-lg rounded-[25px] shadow-lg shadow-black/15 mx-auto border border-gray-200/30\">\n          <div className=\"flex justify-around items-center px-2 py-1 h-[58px]\">\n          {/* Tickets */}\n          <motion.div\n            whileHover={{ scale: 1.1 }}\n            whileTap={{ scale: 0.95 }}\n            transition={{ duration: 0.2 }}\n          >\n            <Link\n              href=\"/tickets\"\n              className=\"flex flex-col items-center py-2 px-3 min-w-0\"\n            >\n              <motion.div\n                animate={{ \n                  color: isTicketsActive ? \"#eab308\" : \"#4b5563\",\n                  scale: isTicketsActive ? 1.1 : 1\n                }}\n                transition={{ duration: 0.3, ease: \"easeOut\" }}\n                className=\"p-1\"\n              >\n                <Ticket size={20} />\n              </motion.div>\n              <motion.span\n                animate={{ \n                  color: isTicketsActive ? \"#eab308\" : \"#4b5563\",\n                  fontWeight: isTicketsActive ? 600 : 500\n                }}\n                transition={{ duration: 0.3 }}\n                className=\"text-xs mt-1\"\n              >\n                Tickets\n              </motion.span>\n            </Link>\n          </motion.div>\n\n          {/* Events */}\n          <motion.div\n            whileHover={{ scale: 1.1 }}\n            whileTap={{ scale: 0.95 }}\n            transition={{ duration: 0.2 }}\n          >\n            <Link\n              href=\"/my-events\"\n              className=\"flex flex-col items-center py-2 px-3 min-w-0\"\n            >\n              <motion.div\n                animate={{ \n                  color: isEventsActive ? \"#eab308\" : \"#4b5563\",\n                  scale: isEventsActive ? 1.1 : 1\n                }}\n                transition={{ duration: 0.3, ease: \"easeOut\" }}\n                className=\"p-1\"\n              >\n                <Calendar size={20} />\n              </motion.div>\n              <motion.span\n                animate={{ \n                  color: isEventsActive ? \"#eab308\" : \"#4b5563\",\n                  fontWeight: isEventsActive ? 600 : 500\n                }}\n                transition={{ duration: 0.3 }}\n                className=\"text-xs mt-1\"\n              >\n                Eventos\n              </motion.span>\n            </Link>\n          </motion.div>\n\n          {/* Home - Centro (Inicio) - Always Yellow/Active like in the image */}\n          <motion.div\n            whileHover={{ scale: 1.15, rotate: 5 }}\n            whileTap={{ scale: 0.9 }}\n            transition={{ duration: 0.2, ease: \"easeOut\" }}\n          >\n            <Link\n              href=\"/\"\n              className=\"flex flex-col items-center py-2 px-3 min-w-0\"\n            >\n              <motion.div \n                whileHover={{ \n                  boxShadow: \"0 0 20px rgba(234, 179, 8, 0.6)\",\n                  scale: 1.05 \n                }}\n                transition={{ duration: 0.2 }}\n                className=\"bg-yellow-500 rounded-full p-2\"\n              >\n                <motion.div\n                  animate={{ rotate: isHomeActive ? 0 : 0 }}\n                  whileHover={{ rotate: 360 }}\n                  transition={{ duration: 0.6, ease: \"easeInOut\" }}\n                >\n                  <Compass size={20} className=\"text-black\" />\n                </motion.div>\n              </motion.div>\n              <motion.span \n                animate={{ scale: isHomeActive ? 1.05 : 1 }}\n                className=\"text-xs mt-1 text-yellow-500 font-semibold\"\n              >\n                Inicio\n              </motion.span>\n            </Link>\n          </motion.div>\n\n          {/* Chats */}\n          <motion.div\n            whileHover={{ scale: 1.1 }}\n            whileTap={{ scale: 0.95 }}\n            transition={{ duration: 0.2 }}\n          >\n            <Link\n              href=\"/messages\"\n              className=\"flex flex-col items-center py-2 px-3 min-w-0\"\n            >\n              <motion.div\n                animate={{ \n                  color: isChatsActive ? \"#eab308\" : \"#4b5563\",\n                  scale: isChatsActive ? 1.1 : 1\n                }}\n                transition={{ duration: 0.3, ease: \"easeOut\" }}\n                className=\"p-1\"\n              >\n                <MessageSquare size={20} />\n              </motion.div>\n              <motion.span\n                animate={{ \n                  color: isChatsActive ? \"#eab308\" : \"#4b5563\",\n                  fontWeight: isChatsActive ? 600 : 500\n                }}\n                transition={{ duration: 0.3 }}\n                className=\"text-xs mt-1\"\n              >\n                Chats\n              </motion.span>\n            </Link>\n          </motion.div>\n\n          {/* Profile */}\n          <motion.div\n            whileHover={{ scale: 1.1 }}\n            whileTap={{ scale: 0.95 }}\n            transition={{ duration: 0.2 }}\n          >\n            <Link\n              href=\"/profile\"\n              className=\"flex flex-col items-center py-2 px-3 min-w-0\"\n            >\n              <motion.div\n                animate={{ \n                  color: isProfileActive ? \"#eab308\" : \"#4b5563\",\n                  scale: isProfileActive ? 1.1 : 1\n                }}\n                transition={{ duration: 0.3, ease: \"easeOut\" }}\n                className=\"p-1\"\n              >\n                <User size={20} />\n              </motion.div>\n              <motion.span\n                animate={{ \n                  color: isProfileActive ? \"#eab308\" : \"#4b5563\",\n                  fontWeight: isProfileActive ? 600 : 500\n                }}\n                transition={{ duration: 0.3 }}\n                className=\"text-xs mt-1\"\n              >\n                Perfil\n              </motion.span>\n            </Link>\n          </motion.div>\n          </div>\n        </div>\n      </div>\n      \n      {/* Notifications Panel */}\n      <NotificationsPanel \n        isOpen={showNotifications} \n        onClose={() => setShowNotifications(false)} \n      />\n    </>\n  );\n}\n\nexport default BottomNav;\n","size_bytes":8299},"client/src/components/maps/Map3DToggle.tsx":{"content":"import React from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport { Layers3, Map } from \"lucide-react\";\n\ninterface Map3DToggleProps {\n  is3D: boolean;\n  onToggle: (is3D: boolean) => void;\n}\n\nexport default function Map3DToggle({ is3D, onToggle }: Map3DToggleProps) {\n  return (\n    <div className=\"absolute top-4 right-4 z-10\">\n      <Button\n        variant={is3D ? \"default\" : \"outline\"}\n        size=\"sm\"\n        onClick={() => onToggle(!is3D)}\n        className=\"bg-white/90 backdrop-blur-sm border border-white/20 hover:bg-white shadow-lg\"\n      >\n        {is3D ? (\n          <>\n            <Map className=\"w-4 h-4 mr-2\" />\n            2D\n          </>\n        ) : (\n          <>\n            <Layers3 className=\"w-4 h-4 mr-2\" />\n            3D\n          </>\n        )}\n      </Button>\n    </div>\n  );\n}","size_bytes":823},"client/src/components/maps/PipolMap.tsx":{"content":"import React, { useEffect, useRef, useState } from \"react\";\nimport mapboxgl, { Map as MapboxMap, GeoJSONSource } from \"mapbox-gl\";\nimport { useMap } from '@/contexts/MapContext';\n\n// Configurar token de Mapbox\nmapboxgl.accessToken = import.meta.env.VITE_MAPBOX_ACCESS_TOKEN || process.env.MAPBOX_ACCESS_TOKEN || \"\";\n\ntype EventPoint = {\n  id: string;\n  title: string;\n  lat: number;\n  lng: number;\n  emoji?: string;\n  creatorAvatar?: string;\n  category?: string;\n  organizerId?: number;\n  organizerName?: string;\n  organizerEmail?: string;\n};\n\ntype Props = {\n  events: EventPoint[];\n  styleUrl?: string;\n  center?: [number, number];\n  onEventClick?: (eventId: string, coordinates?: [number, number]) => void;\n};\n\nexport default function PipolMap({ \n  events, \n  styleUrl, \n  center = [-64.1888, -31.4201], // Córdoba Centro\n  onEventClick \n}: Props) {\n  const { setMapInstance, saveCameraState, clearMapInstance } = useMap();\n  const mapRef = useRef<MapboxMap | null>(null);\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const markersRef = useRef<mapboxgl.Marker[]>([]);\n  const [isLoaded, setIsLoaded] = useState(false);\n\n  // Limpiar marcadores existentes\n  const clearMarkers = () => {\n    markersRef.current.forEach(marker => marker.remove());\n    markersRef.current = [];\n  };\n\n  useEffect(() => {\n    if (!containerRef.current || mapRef.current) return;\n\n    const map = new mapboxgl.Map({\n      container: containerRef.current,\n      style: styleUrl || \"mapbox://styles/mapbox/light-v11\",\n      center: center,\n      zoom: 15,\n      pitch: 60,   // INCLINACIÓN \"Snap\"\n      bearing: -20, // ROTACIÓN \"Snap\"\n      attributionControl: false // Eliminar controles de atribución\n    });\n\n    // Controles básicos - ELIMINADOS COMPLETAMENTE\n    // No agregar ningún control para mantener la interfaz limpia\n\n    map.on(\"load\", async () => {\n      // --- (1) Terreno (DEM) + Cielo ---\n      // Fuente DEM de Mapbox (igual approach que Snap)\n      if (!map.getSource(\"mapbox-dem\")) {\n        map.addSource(\"mapbox-dem\", {\n          type: \"raster-dem\",\n          url: \"mapbox://mapbox.mapbox-terrain-dem-v1\",\n          tileSize: 512,\n          maxzoom: 14\n        });\n      }\n      // Activa terreno (exageración leve para \"pop\" 3D)\n      // @ts-ignore\n      map.setTerrain({ source: \"mapbox-dem\", exaggeration: 1.1 });\n\n      // Capa de cielo (profundidad 3D)\n      if (!map.getLayer(\"sky\")) {\n        map.addLayer({\n          id: \"sky\",\n          type: \"sky\",\n          paint: {\n            \"sky-type\": \"atmosphere\",\n            \"sky-atmosphere-sun\": [0.0, 0.0],\n            \"sky-atmosphere-sun-intensity\": 15\n          }\n        });\n      }\n\n      // --- (2) Edificios extruidos 3D (idéntico a Snap) ---\n      // Busca la capa de labels para insertar edificios por debajo\n      const layers = map.getStyle().layers || [];\n      const labelLayerId = layers.find((l) => l.type === \"symbol\" && (l.layout as any)?.[\"text-field\"])?.id;\n\n      map.addLayer(\n        {\n          id: \"3d-buildings\",\n          source: \"composite\",\n          \"source-layer\": \"building\",\n          filter: [\"==\", \"extrude\", \"true\"],\n          type: \"fill-extrusion\",\n          minzoom: 15,\n          paint: {\n            \"fill-extrusion-color\": \"#e6e6e6\",\n            \"fill-extrusion-height\": [\"coalesce\", [\"get\", \"height\"], 12],\n            \"fill-extrusion-base\": [\"coalesce\", [\"get\", \"min_height\"], 0],\n            \"fill-extrusion-opacity\": 0.9\n          }\n        },\n        labelLayerId // inserta debajo de labels\n      );\n\n      // --- (3) Clúster de eventos (performance al estilo Snap) ---\n      // Creamos un GeoJSON dinámico con tus eventos\n      const geojson = {\n        type: \"FeatureCollection\" as const,\n        features: events.map((ev) => ({\n          type: \"Feature\" as const,\n          properties: { \n            id: ev.id, \n            title: ev.title,\n            category: ev.category,\n            emoji: ev.emoji,\n            creatorAvatar: ev.creatorAvatar\n          },\n          geometry: { type: \"Point\" as const, coordinates: [ev.lng, ev.lat] }\n        }))\n      };\n\n      if (!map.getSource(\"events\")) {\n        map.addSource(\"events\", {\n          type: \"geojson\",\n          data: geojson,\n          cluster: true,\n          clusterMaxZoom: 14,\n          clusterRadius: 50\n        });\n\n        // Capa de clusters (burbujas)\n        map.addLayer({\n          id: \"clusters\",\n          type: \"circle\",\n          source: \"events\",\n          filter: [\"has\", \"point_count\"],\n          paint: {\n            \"circle-color\": \"#ffffff\",\n            \"circle-stroke-color\": \"#00000022\",\n            \"circle-stroke-width\": 2,\n            \"circle-radius\": [\n              \"step\",\n              [\"get\", \"point_count\"],\n              16, 10,\n              20, 25,\n              28\n            ]\n          }\n        });\n\n        // Números dentro del cluster\n        map.addLayer({\n          id: \"cluster-count\",\n          type: \"symbol\",\n          source: \"events\",\n          filter: [\"has\", \"point_count\"],\n          layout: {\n            \"text-field\": [\"to-string\", [\"get\", \"point_count_abbreviated\"]],\n            \"text-font\": [\"DIN Offc Pro Medium\", \"Arial Unicode MS Bold\"],\n            \"text-size\": 12\n          },\n          paint: { \"text-color\": \"#444\" }\n        });\n\n        // Puntos individuales (no cluster) - círculos simples en zoom bajo\n        map.addLayer({\n          id: \"unclustered-point\",\n          type: \"circle\",\n          source: \"events\",\n          filter: [\"!\", [\"has\", \"point_count\"]],\n          maxzoom: 15, // Solo visible hasta zoom 15\n          paint: {\n            \"circle-color\": \"#ffffff\",\n            \"circle-radius\": 10,\n            \"circle-stroke-color\": \"#00000022\",\n            \"circle-stroke-width\": 2\n          }\n        });\n      }\n\n      // Zoom al hacer click en cluster\n      map.on(\"click\", \"clusters\", (e) => {\n        const features = map.queryRenderedFeatures(e.point, { layers: [\"clusters\"] });\n        const clusterId = features[0].properties?.cluster_id;\n        // @ts-ignore\n        map.getSource(\"events\").getClusterExpansionZoom(clusterId, (err: any, zoom: number) => {\n          if (err) return;\n          map.easeTo({ center: (features[0].geometry as any).coordinates, zoom });\n        });\n      });\n\n      // Click en punto individual con zoom\n      map.on(\"click\", \"unclustered-point\", (e) => {\n        const feature = e.features?.[0];\n        if (feature && onEventClick) {\n          const coordinates = (feature.geometry as any).coordinates as [number, number];\n          \n          // Guardar posición actual de la cámara ANTES de hacer zoom usando el contexto\n          console.log(\"🚨 PipolMap: ANTES de llamar saveCameraState\");\n          saveCameraState();\n          console.log(\"🚨 PipolMap: DESPUÉS de llamar saveCameraState\");\n          \n          // Hacer zoom al marker con animación suave\n          map.flyTo({\n            center: coordinates,\n            zoom: 18, // Zoom más cercano para efecto focal\n            duration: 1200, // Animación más larga y suave\n            essential: true,\n            pitch: 60, // Mantener vista 3D\n            bearing: map.getBearing() // Mantener rotación actual\n          });\n          \n          // Llamar callback con coordenadas para informar al padre\n          onEventClick(feature.properties?.id, coordinates);\n        }\n      });\n\n      // Cursor \"pointer\"\n      [\"clusters\", \"unclustered-point\"].forEach((id) => {\n        map.on(\"mouseenter\", id, () => {\n          map.getCanvas().style.cursor = \"pointer\";\n        });\n        map.on(\"mouseleave\", id, () => {\n          map.getCanvas().style.cursor = \"\";\n        });\n      });\n\n      setIsLoaded(true);\n    });\n\n    // Manejar cambios de zoom para mostrar/ocultar marcadores DOM\n    map.on(\"zoom\", () => {\n      const zoom = map.getZoom();\n      if (zoom >= 15) {\n        // Mostrar marcadores DOM estilo Snap\n        addDomMarkers();\n      } else {\n        // Ocultar marcadores DOM, mostrar círculos\n        clearMarkers();\n      }\n    });\n\n    mapRef.current = map;\n    \n    // Configurar la instancia del mapa en el contexto\n    console.log(\"🗺️ PipolMap: Configurando mapa en contexto...\");\n    setMapInstance(map);\n    console.log(\"🗺️ PipolMap: Mapa configurado en contexto\");\n    return () => { \n      clearMarkers();\n      map.remove(); \n      mapRef.current = null; \n    };\n  }, [styleUrl, center]);\n\n  // Actualizar datos cuando cambien los eventos\n  useEffect(() => {\n    if (!mapRef.current || !isLoaded) return;\n\n    const geojson = {\n      type: \"FeatureCollection\" as const,\n      features: events.map((ev) => ({\n        type: \"Feature\" as const,\n        properties: { \n          id: ev.id, \n          title: ev.title,\n          category: ev.category,\n          emoji: ev.emoji,\n          creatorAvatar: ev.creatorAvatar\n        },\n        geometry: { type: \"Point\" as const, coordinates: [ev.lng, ev.lat] }\n      }))\n    };\n\n    const source = mapRef.current.getSource(\"events\") as GeoJSONSource;\n    if (source) {\n      source.setData(geojson);\n      \n      // Si estamos en zoom alto, actualizar marcadores DOM\n      if (mapRef.current.getZoom() >= 15) {\n        addDomMarkers();\n      }\n    }\n  }, [events, isLoaded]);\n\n  // Función para agregar marcadores DOM estilo Snap\n  const addDomMarkers = () => {\n    if (!mapRef.current) return;\n    \n    clearMarkers();\n    \n    const bounds = mapRef.current?.getBounds();\n    const visibleEvents = events.filter(event => \n      bounds && bounds.contains([event.lng, event.lat])\n    );\n\n    visibleEvents.forEach(event => {\n      const el = document.createElement(\"div\");\n      el.className = \"snap-marker\";\n      el.innerHTML = `\n        <div class=\"relative flex items-center justify-center w-12 h-12 bg-white rounded-full shadow-xl border-2 border-white cursor-pointer hover:scale-110 transition-transform\">\n          ${event.creatorAvatar ? \n            `<img src=\"${event.creatorAvatar}\" alt=\"creator\" class=\"w-10 h-10 rounded-full object-cover avatar-clickeable\" data-creator-id=\"${event.organizerId}\" />` :\n            `<div class=\"w-10 h-10 rounded-full bg-gradient-to-br from-blue-400 to-purple-500 avatar-clickeable\" data-creator-id=\"${event.organizerId}\"></div>`\n          }\n          ${event.emoji ? \n            `<span class=\"absolute -bottom-1 -right-1 text-lg leading-none\">${event.emoji}</span>` : \n            ''\n          }\n        </div>\n      `;\n\n      el.addEventListener(\"click\", (e) => {\n        e.stopPropagation();\n        const target = e.target as HTMLElement;\n        \n        // Si se clickea en el avatar, mostrar perfil del creador\n        if (target.classList.contains('avatar-clickeable') && event.organizerId) {\n          // Trigger user profile display (implementation will be added globally)\n          console.log('Avatar clicked for user:', event.organizerId);\n          // For now just show event details with zoom\n          if (onEventClick && mapRef.current) {\n            // Guardar estado de la cámara ANTES del zoom (DOM markers - avatar click)\n            saveCameraState();\n            // Hacer zoom al marker de la misma forma\n            mapRef.current.flyTo({\n              center: [event.lng, event.lat],\n              zoom: 18,\n              duration: 1200,\n              essential: true,\n              pitch: 60,\n              bearing: mapRef.current.getBearing()\n            });\n            onEventClick(event.id, [event.lng, event.lat]);\n          }\n        } else {\n          // Si se clickea en otra parte, mostrar detalles del evento con zoom\n          if (onEventClick && mapRef.current) {\n            // Guardar estado de la cámara ANTES del zoom (DOM markers - general click)\n            saveCameraState();\n            // Hacer zoom al marker de la misma forma\n            mapRef.current.flyTo({\n              center: [event.lng, event.lat],\n              zoom: 18,\n              duration: 1200,\n              essential: true,\n              pitch: 60,\n              bearing: mapRef.current.getBearing()\n            });\n            onEventClick(event.id, [event.lng, event.lat]);\n          }\n        }\n      });\n\n      const marker = new mapboxgl.Marker(el, { anchor: \"center\" })\n        .setLngLat([event.lng, event.lat])\n        .addTo(mapRef.current!);\n      \n      markersRef.current.push(marker);\n    });\n  };\n\n  return <div ref={containerRef} className=\"w-full h-full\" />;\n}","size_bytes":12411},"client/src/components/maps/SnapMarker.tsx":{"content":"import React from \"react\";\n\nexport function SnapBubble({ \n  avatar, \n  emoji, \n  onClick,\n  size = \"w-12 h-12\"\n}: { \n  avatar?: string; \n  emoji?: string; \n  onClick?: () => void;\n  size?: string;\n}) {\n  return (\n    <div \n      className={`relative flex items-center justify-center ${size} bg-white rounded-full shadow-xl border-2 border-white cursor-pointer hover:scale-110 transition-transform`}\n      onClick={onClick}\n    >\n      {avatar ? (\n        <img \n          src={avatar} \n          alt=\"creator\" \n          className={`${size === \"w-12 h-12\" ? \"w-10 h-10\" : \"w-8 h-8\"} rounded-full object-cover`} \n        />\n      ) : (\n        <div className={`${size === \"w-12 h-12\" ? \"w-10 h-10\" : \"w-8 h-8\"} rounded-full bg-gradient-to-br from-blue-400 to-purple-500`} />\n      )}\n      {emoji && (\n        <span className=\"absolute -bottom-1 -right-1 text-lg leading-none\">\n          {emoji}\n        </span>\n      )}\n    </div>\n  );\n}\n\n// Función helper para crear marcadores DOM en Mapbox\nexport function createSnapMarkerElement(\n  avatar?: string, \n  emoji?: string, \n  onClick?: () => void\n): HTMLDivElement {\n  const el = document.createElement(\"div\");\n  el.className = \"snap-marker\";\n  \n  el.innerHTML = `\n    <div class=\"relative flex items-center justify-center w-12 h-12 bg-white rounded-full shadow-xl border-2 border-white cursor-pointer hover:scale-110 transition-transform\">\n      ${avatar ? \n        `<img src=\"${avatar}\" alt=\"creator\" class=\"w-10 h-10 rounded-full object-cover\" />` :\n        `<div class=\"w-10 h-10 rounded-full bg-gradient-to-br from-blue-400 to-purple-500\"></div>`\n      }\n      ${emoji ? \n        `<span class=\"absolute -bottom-1 -right-1 text-lg leading-none\">${emoji}</span>` : \n        ''\n      }\n    </div>\n  `;\n\n  if (onClick) {\n    el.addEventListener(\"click\", onClick);\n  }\n\n  return el;\n}","size_bytes":1833},"client/src/components/maps/event-pin.tsx":{"content":"import React from \"react\";\n\ntype EventPinProps = {\n  category: string;\n  mainMediaUrl?: string;\n  mainMediaType?: \"photo\" | \"video\";\n  eventTitle?: string;\n  showLabel?: boolean;\n};\n\n// Helper function for category emojis\nconst getCategoryEmoji = (category: string): string => {\n  const categoryEmojis: Record<string, string> = {\n    social: \"🥂\", // brindis: más cercano a reuniones sociales\n    music: \"🎶\", // notas musicales para más dinamismo\n    spiritual: \"🧘\", // flor de loto: más moderno y espiritual\n    education: \"🎓\", // birrete: representa cursos o clases\n    sports: \"⛹️‍♂️\", // medalla: más genérico que solo fútbol\n    food: \"🍷\", // copa de vino: más lifestyle y foodie\n    art: \"🗿\", // pincel: más artístico y creativo\n    technology: \"🤖\", // robot: más tech y moderno\n    games: \"🕹️\", // joystick retro: más visual\n    outdoor: \"🌳\", // paisaje: transmite naturaleza y aire libre\n    networking: \"💼\", // maletín: networking profesional\n    workshop: \"🛠️\", // herramientas cruzadas\n    conference: \"🎤\", // micrófono: charlas y conferencias\n    party: \"🎉\", // bola de discoteca: más festivo y actual\n    fair: \"🎡\", // rueda gigante: ferias y festivales\n    exhibition: \"🏛️\", // edificio clásico: museos, expos\n  };\n  return categoryEmojis[category] || \"📅\";\n};\n\n// Componente EventPin MEJORADO - con sistema de etiquetas perfecto\nconst EventPin = ({ category, mainMediaUrl, mainMediaType, eventTitle, showLabel }: EventPinProps) => {\n  const markerSize = 48; // Tamaño total del marker\n  const mediaCircleSize = 32; // Tamaño del círculo de media\n  \n  // Debug logging MEJORADO para verificar prop changes\n  React.useEffect(() => {\n    console.log(`🏷️ EventPin \"${eventTitle}\" - showLabel: ${showLabel} (${showLabel ? 'SHOULD BE VISIBLE' : 'SHOULD BE HIDDEN'})`);\n  }, [showLabel, eventTitle]);\n\n  return (\n    <div className=\"relative group cursor-pointer\">\n      {/* Contenedor principal del pin con estilo Nomadtable */}\n      <div className=\"transform transition-transform group-hover:scale-110\">\n        {/* Círculo principal del marker - SIEMPRE MUESTRA LA IMAGEN PRINCIPAL */}\n        <div\n          className=\"rounded-full border-2 border-gray-200 shadow-lg flex items-center justify-center relative z-10 overflow-hidden\"\n          style={{\n            width: markerSize,\n            height: markerSize,\n            backgroundColor: \"white\",\n            boxShadow: \"0 4px 12px rgba(0, 0, 0, 0.15)\",\n          }}\n        >\n          {/* Media principal o fondo gris si no hay imagen */}\n          {mainMediaUrl ? (\n            mainMediaType === \"video\" ? (\n              <div className=\"relative w-full h-full\">\n                <video\n                  className=\"w-full h-full object-cover\"\n                  src={mainMediaUrl}\n                  muted\n                  loop\n                  playsInline\n                  preload=\"metadata\"\n                />\n                {/* Play icon overlay para videos */}\n                <div className=\"absolute inset-0 flex items-center justify-center bg-black bg-opacity-30\">\n                  <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"white\">\n                    <path d=\"M8 5v14l11-7z\" />\n                  </svg>\n                </div>\n              </div>\n            ) : (\n              <img\n                src={mainMediaUrl}\n                alt=\"Event media\"\n                className=\"w-full h-full object-cover\"\n                onError={(e) => {\n                  // Si falla la imagen, mostrar fondo gris para que siempre haya dos círculos\n                  const parent = (e.target as HTMLElement).parentElement!;\n                  parent.style.backgroundColor = \"#f3f4f6\";\n                  parent.innerHTML = `<div class=\"flex items-center justify-center text-2xl text-gray-400\">📷</div>`;\n                }}\n              />\n            )\n          ) : (\n            // Si no hay imagen, mostrar fondo gris con icono de cámara\n            <div \n              className=\"flex items-center justify-center text-2xl text-gray-400 w-full h-full\"\n              style={{ backgroundColor: \"#f3f4f6\" }}\n            >\n              📷\n            </div>\n          )}\n        </div>\n\n        {/* Círculo pequeño con emoji de categoría - SIEMPRE VISIBLE */}\n        <div\n          className=\"absolute rounded-full border-2 border-white shadow-lg flex items-center justify-center z-20\"\n          style={{\n            width: mediaCircleSize,\n            height: mediaCircleSize,\n            bottom: -10,\n            right: -11,\n            backgroundColor: \"white\",\n            boxShadow: \"0 2px 8px rgba(0, 0, 0, 0.2)\",\n          }}\n        >\n          {/* Emoji de la categoría en el círculo secundario */}\n          <div className=\"flex items-center justify-center text-lg\">\n            {getCategoryEmoji(category)}\n          </div>\n        </div>\n\n        {/* Puntero/cola del pin */}\n        <div\n          className=\"absolute left-1/2 transform -translate-x-1/2\"\n          style={{\n            top: markerSize - 4,\n            width: 0,\n            height: 0,\n            borderLeft: \"8px solid transparent\",\n            borderRight: \"8px solid transparent\",\n            borderTop: \"12px solid white\",\n            filter: \"drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1))\",\n            zIndex: 5,\n          }}\n        />\n\n        {/* Borde de la cola */}\n        <div\n          className=\"absolute left-1/2 transform -translate-x-1/2\"\n          style={{\n            top: markerSize - 5,\n            width: 0,\n            height: 0,\n            borderLeft: \"9px solid transparent\",\n            borderRight: \"9px solid transparent\",\n            borderTop: \"13px solid #e5e7eb\",\n            zIndex: 4,\n          }}\n        />\n\n        {/* Sistema de etiquetas PERFECTO - siempre renderizado para animaciones fluidas */}\n        {eventTitle && (\n          <div\n            key={`label-${eventTitle}`}\n            className={`\n              absolute left-1/2 pointer-events-none\n              transition-all duration-300 ease-in-out\n              ${showLabel \n                ? 'opacity-100 visible scale-100 translate-y-0' \n                : 'opacity-0 invisible scale-90 translate-y-2'\n              }\n            `}\n            data-label-state={showLabel ? 'visible' : 'hidden'}\n            style={{\n              top: -50,\n              maxWidth: \"200px\",\n              zIndex: 50,\n              transform: 'translateX(-50%)',\n              transformOrigin: 'center bottom',\n              willChange: 'transform, opacity',\n            }}\n          >\n            <div \n              className={`\n                bg-white/95 backdrop-blur-sm px-3 py-1.5 rounded-lg border \n                text-xs font-semibold text-gray-900 whitespace-nowrap text-center\n                transition-all duration-300 ease-in-out shadow-lg\n                ${showLabel \n                  ? 'border-gray-300 shadow-xl' \n                  : 'border-gray-200 shadow-md'\n                }\n              `}\n              style={{\n                minWidth: '60px',\n                backdropFilter: 'blur(12px)',\n                boxShadow: showLabel \n                  ? '0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(0, 0, 0, 0.08)' \n                  : '0 4px 12px rgba(0, 0, 0, 0.08)',\n              }}\n            >\n              {eventTitle}\n              {/* Flecha perfecta */}\n              <div\n                className=\"absolute left-1/2 -bottom-1.5 transform -translate-x-1/2\"\n                style={{\n                  width: 0,\n                  height: 0,\n                  borderLeft: \"6px solid transparent\",\n                  borderRight: \"6px solid transparent\",\n                  borderTop: \"6px solid rgba(255, 255, 255, 0.95)\",\n                  filter: \"drop-shadow(0 1px 2px rgba(0, 0, 0, 0.1))\",\n                }}\n              />\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default EventPin;\n","size_bytes":8009},"client/src/components/maps/map-config-panel.tsx":{"content":"import React, { useState, useEffect } from 'react';\nimport { motion, AnimatePresence } from \"framer-motion\";\nimport { Button } from \"@/components/ui/button\";\nimport { Switch } from \"@/components/ui/switch\";\nimport { Label } from \"@/components/ui/label\";\nimport { RadioGroup, RadioGroupItem } from \"@/components/ui/radio-group\";\nimport { Card } from \"@/components/ui/card\";\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"@/components/ui/tabs\";\nimport { Separator } from \"@/components/ui/separator\";\nimport { Settings, X, SunMoon, MapIcon, Layers, Globe, Building2, Mountain, Eye, Image } from 'lucide-react';\nimport { MapConfigOptions, LightPreset, MapTheme, MapFont, applyMapConfig, MapStyle, getLightPresetByTime } from '@/lib/mapbox';\nimport mapboxgl from 'mapbox-gl';\n\ninterface MapConfigPanelProps {\n  map: mapboxgl.Map | null;\n  isOpen: boolean;\n  onClose: () => void;\n  onConfigChange: (config: Partial<MapConfigOptions>) => void;\n  config: MapConfigOptions;\n  is3DMode?: boolean;\n}\n\nexport default function MapConfigPanel({ \n  map, \n  isOpen, \n  onClose, \n  onConfigChange, \n  config,\n  is3DMode = true\n}: MapConfigPanelProps) {\n  const [localConfig, setLocalConfig] = useState<MapConfigOptions>(config);\n  \n  // Update local config when props change\n  useEffect(() => {\n    setLocalConfig(config);\n  }, [config]);\n\n  // Apply changes when a setting is modified\n  const handleSettingChange = (key: keyof MapConfigOptions, value: any) => {\n    const newConfig = { ...localConfig, [key]: value };\n    setLocalConfig(newConfig);\n    onConfigChange({ [key]: value });\n    \n    // Apply immediately if map is available\n    if (map) {\n      applyMapConfig(map, { [key]: value });\n    }\n  };\n\n  // Helper function to toggle boolean settings\n  const toggleSetting = (key: keyof MapConfigOptions) => {\n    const newValue = !localConfig[key];\n    \n    // Caso especial para useAutoLightPreset\n    if (key === 'useAutoLightPreset' && newValue === true && map) {\n      try {\n        // Si estamos activando la iluminación automática, obtener y aplicar preset según hora actual\n        // Determinar el preset según la hora actual\n        const currentHour = new Date().getHours();\n        let currentTimePreset: LightPreset;\n        \n        if (currentHour >= 6 && currentHour < 8) {\n          // Early morning (6:00 AM - 8:00 AM)\n          currentTimePreset = LightPreset.DAWN;\n        } else if (currentHour >= 8 && currentHour < 18) {\n          // Daytime (8:00 AM - 6:00 PM)\n          currentTimePreset = LightPreset.DAWN;\n        } else if (currentHour >= 18 && currentHour < 20) {\n          // Evening (6:00 PM - 8:00 PM)\n          currentTimePreset = LightPreset.DUSK;\n        } else {\n          // Night (8:00 PM - 6:00 AM)\n          currentTimePreset = LightPreset.NIGHT;\n        }\n        \n        console.log(`Activando iluminación automática, aplicando preset: ${currentTimePreset}`);\n        \n        // Actualizar configuración local\n        const updatedConfig = { \n          ...localConfig, \n          useAutoLightPreset: true,\n          lightPreset: currentTimePreset \n        };\n        setLocalConfig(updatedConfig);\n        \n        // Notificar al componente padre\n        onConfigChange({ \n          useAutoLightPreset: true,\n          lightPreset: currentTimePreset \n        });\n        \n        // Aplicar directamente al mapa\n        map.setConfigProperty('basemap', 'lightPreset', currentTimePreset);\n        map.setConfigProperty('basemap', 'useAutoLightPreset', true);\n        \n        return; // Salir, ya que manejamos todo aquí\n      } catch (err) {\n        console.error(\"Error al aplicar iluminación automática:\", err);\n        // Si falla, seguir con el comportamiento normal\n      }\n    }\n    \n    // Comportamiento normal para otros casos\n    handleSettingChange(key, newValue);\n  };\n\n  // Set the light preset and disable auto time of day\n  const setLightPreset = (preset: LightPreset) => {\n    // Update local state\n    setLocalConfig(prev => ({\n      ...prev,\n      lightPreset: preset,\n      useAutoLightPreset: false\n    }));\n    \n    // Notify parent component\n    onConfigChange({ \n      lightPreset: preset,\n      useAutoLightPreset: false \n    });\n    \n    // Apply directly to map if available\n    if (map) {\n      try {\n        map.setConfigProperty('basemap', 'lightPreset', preset);\n        map.setConfigProperty('basemap', 'useAutoLightPreset', false);\n      } catch (err) {\n        console.error(\"Error applying lightPreset:\", err);\n      }\n    }\n  };\n\n  if (!isOpen) return null;\n\n  return (\n    <AnimatePresence>\n      <motion.div\n        initial={{ opacity: 0, x: \"100%\", scale: 0.9 }}\n        animate={{ opacity: 1, x: 0, scale: 1 }}\n        exit={{ opacity: 0, x: \"100%\", scale: 0.9 }}\n        transition={{\n          type: \"spring\",\n          damping: 25,\n          stiffness: 300,\n          duration: 0.4\n        }}\n        className=\"absolute top-20 right-4 z-10 w-72 bg-white/10 backdrop-blur-lg rounded-lg shadow-2xl border border-white/20 overflow-hidden\"\n      >\n        <div className=\"flex items-center justify-between p-3 bg-white/10 text-white\">\n          <div className=\"flex items-center gap-2\">\n            <Settings size={18} />\n            <h3 className=\"font-medium\">\n              {is3DMode ? \"Configuración del Mapa 3D\" : \"Configuración del Mapa\"}\n            </h3>\n          </div>\n          <button onClick={onClose} className=\"text-white hover:text-white/80 transition-all duration-200\">\n            <X size={18} />\n          </button>\n        </div>\n\n      <Tabs defaultValue={is3DMode ? \"visual\" : \"style\"} className=\"w-full\">\n        <TabsList className={`w-full grid ${is3DMode ? 'grid-cols-3' : 'grid-cols-1'} bg-white/10`}>\n          {is3DMode && (\n            <TabsTrigger value=\"visual\" className=\"text-xs\">\n              <div className=\"flex flex-col items-center gap-1\">\n                <Eye size={16} />\n                <span>Visual</span>\n              </div>\n            </TabsTrigger>\n          )}\n          \n          {is3DMode && (\n            <TabsTrigger value=\"lighting\" className=\"text-xs\">\n              <div className=\"flex flex-col items-center gap-1\">\n                <SunMoon size={16} />\n                <span>Iluminación</span>\n              </div>\n            </TabsTrigger>\n          )}\n          \n          <TabsTrigger value=\"style\" className=\"text-xs\">\n            <div className=\"flex flex-col items-center gap-1\">\n              <Layers size={16} />\n              <span>Estilo</span>\n            </div>\n          </TabsTrigger>\n        </TabsList>\n        \n        {/* Visual Settings Tab */}\n        <TabsContent value=\"visual\" className=\"p-3 space-y-4\">\n          <div className=\"space-y-2\">\n            <div className=\"flex items-center justify-between\">\n              <Label htmlFor=\"show3dObjects\" className=\"text-sm flex items-center gap-1\">\n                <Building2 size={16} />\n                Mostrar edificios 3D\n              </Label>\n              <Switch \n                id=\"show3dObjects\" \n                checked={localConfig.show3dObjects}\n                onCheckedChange={() => toggleSetting('show3dObjects')}\n              />\n            </div>\n            \n            <div className=\"flex items-center justify-between\">\n              <Label htmlFor=\"showPlaceLabels\" className=\"text-sm flex items-center gap-1\">\n                <MapIcon size={16} />\n                Mostrar etiquetas de lugares\n              </Label>\n              <Switch \n                id=\"showPlaceLabels\" \n                checked={localConfig.showPlaceLabels}\n                onCheckedChange={() => toggleSetting('showPlaceLabels')}\n              />\n            </div>\n            \n            <div className=\"flex items-center justify-between\">\n              <Label htmlFor=\"showRoadLabels\" className=\"text-sm flex items-center gap-1\">\n                <MapIcon size={16} />\n                Mostrar nombres de calles\n              </Label>\n              <Switch \n                id=\"showRoadLabels\" \n                checked={localConfig.showRoadLabels}\n                onCheckedChange={() => toggleSetting('showRoadLabels')}\n              />\n            </div>\n            \n            <div className=\"flex items-center justify-between\">\n              <Label htmlFor=\"showPointOfInterestLabels\" className=\"text-sm flex items-center gap-1\">\n                <MapIcon size={16} />\n                Puntos de interés\n              </Label>\n              <Switch \n                id=\"showPointOfInterestLabels\" \n                checked={localConfig.showPointOfInterestLabels}\n                onCheckedChange={() => toggleSetting('showPointOfInterestLabels')}\n              />\n            </div>\n            \n            <div className=\"flex items-center justify-between\">\n              <Label htmlFor=\"showTransitLabels\" className=\"text-sm flex items-center gap-1\">\n                <MapIcon size={16} />\n                Transporte público\n              </Label>\n              <Switch \n                id=\"showTransitLabels\" \n                checked={localConfig.showTransitLabels}\n                onCheckedChange={() => toggleSetting('showTransitLabels')}\n              />\n            </div>\n          </div>\n        </TabsContent>\n        \n        {/* Lighting Settings Tab */}\n        <TabsContent value=\"lighting\" className=\"p-3 space-y-4\">\n          <div className=\"space-y-2\">\n            <div className=\"flex items-center justify-between\">\n              <Label htmlFor=\"useAutoLightPreset\" className=\"text-sm flex items-center gap-1\">\n                <SunMoon size={16} />\n                Iluminación automática\n              </Label>\n              <Switch \n                id=\"useAutoLightPreset\" \n                checked={localConfig.useAutoLightPreset}\n                onCheckedChange={() => toggleSetting('useAutoLightPreset')}\n              />\n            </div>\n            \n            <Separator className=\"my-2\" />\n            \n            <div className=\"space-y-2\">\n              <Label className=\"text-sm\">Hora del día</Label>\n              <RadioGroup \n                value={localConfig.lightPreset} \n                onValueChange={(value) => setLightPreset(value as LightPreset)}\n                className=\"grid grid-cols-2 gap-2\"\n                disabled={localConfig.useAutoLightPreset}\n              >\n                <div className=\"flex items-center space-x-2 bg-gray-50 p-2 rounded-md\">\n                  <RadioGroupItem value=\"night\" id=\"night\" />\n                  <Label htmlFor=\"night\" className=\"flex items-center gap-1 cursor-pointer\">\n                    <span>Noche</span>\n                  </Label>\n                </div>\n                \n                <div className=\"flex items-center space-x-2 bg-gray-50 p-2 rounded-md\">\n                  <RadioGroupItem value=\"dawn\" id=\"dawn\" />\n                  <Label htmlFor=\"dawn\" className=\"flex items-center gap-1 cursor-pointer\">\n                    <span>Amanecer</span>\n                  </Label>\n                </div>\n                \n                <div className=\"flex items-center space-x-2 bg-gray-50 p-2 rounded-md\">\n                  <RadioGroupItem value=\"dusk\" id=\"dusk\" />\n                  <Label htmlFor=\"dusk\" className=\"flex items-center gap-1 cursor-pointer\">\n                    <span>Atardecer</span>\n                  </Label>\n                </div>\n              </RadioGroup>\n            </div>\n          </div>\n        </TabsContent>\n        \n        {/* Style Settings Tab */}\n        <TabsContent value=\"style\" className=\"p-3 space-y-4\">\n          <div className=\"space-y-2\">\n            <Label className=\"text-sm\">Tipo de mapa</Label>\n            <div className=\"grid grid-cols-1 gap-2\">\n              <Button \n                variant=\"outline\"\n                className=\"justify-start\" \n                onClick={() => {\n                  if (map) {\n                    map.setStyle(is3DMode ? MapStyle.STANDARD_3D : MapStyle.STREETS_2D);\n                  }\n                }}\n              >\n                <Globe className=\"mr-2 h-4 w-4\" />\n                Mapa estándar\n              </Button>\n              \n              <Button \n                variant=\"outline\" \n                className=\"justify-start\"\n                onClick={() => {\n                  if (map) {\n                    map.setStyle(is3DMode ? MapStyle.STANDARD_SATELLITE : MapStyle.SATELLITE_2D);\n                  }\n                }}\n              >\n                <Image className=\"mr-2 h-4 w-4\" />\n                Mapa satélite\n              </Button>\n            </div>\n          </div>\n        </TabsContent>\n      </Tabs>\n      </motion.div>\n    </AnimatePresence>\n  );\n}","size_bytes":12697},"client/src/components/maps/map-view-fixed.tsx":{"content":"","size_bytes":0},"client/src/components/maps/map-view-original.tsx":{"content":"import React, { useState, useEffect, useRef } from \"react\";\nimport SearchBar from \"@/components/search/search-bar\";\nimport GooglePlacesSearch from \"@/components/search/google-places-search\";\nimport EventFilters from \"@/components/events/event-filters\";\nimport { Circle, MapPin, MapIcon, PinIcon, Plus, Pin, MapPinned, Check, X, Compass, Filter } from \"lucide-react\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { Card } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport EventPin from \"./event-pin\";\n// CategoryPin se define inline - no necesitamos un archivo separado\nimport mapboxgl, { LngLat } from 'mapbox-gl';\nimport { initializeMap, getUserLocation, defaultMapConfig, searchLocations, reverseGeocode } from \"@/lib/mapbox\";\n// Para debugging - importar también funciones de google\nimport { reverseGeocode as googleReverseGeocode, findNearbyPlaces } from \"@/lib/google-maps\";\nimport { createRoot } from 'react-dom/client';\n\n// Import required types\ntype Event = {\n  id: number;\n  title: string;\n  description: string;\n  category: string;\n  date: string;\n  latitude: string | number;\n  longitude: string | number;\n  locationName: string;\n  locationAddress: string;\n  paymentType: string;\n  price?: string | number;\n  maxCapacity?: number;\n  privacyType: string;\n  organizerId: number;\n  organizer: {\n    id: number;\n    name: string;\n    avatar?: string;\n  };\n  attendees: Array<{\n    id: number;\n    user: {\n      id: number;\n      name: string;\n      avatar?: string;\n    };\n  }>;\n};\n\ntype MapViewProps = {\n  onEventSelect: (event: Event) => void;\n  onCreateEventClick: (locationData?: { \n    latitude: number, \n    longitude: number, \n    locationAddress: string, \n    locationName: string \n  }) => void;\n  filters?: {\n    category?: string[];\n    paymentType?: string[];\n    date?: string;\n  };\n  resetLocationOnFormClose?: boolean;\n};\n\n\n\nconst MapView = ({ onEventSelect, onCreateEventClick, filters, resetLocationOnFormClose }: MapViewProps) => {\n  const [filtersVisible, setFiltersVisible] = useState(false);\n  const [searchTerm, setSearchTerm] = useState(\"\");\n  const [locationMode, setLocationMode] = useState(false);\n  const [eventsPanelVisible, setEventsPanelVisible] = useState(false);\n  const [tempLocationMarker, setTempLocationMarker] = useState<mapboxgl.Marker | null>(null);\n  const [tempLocationData, setTempLocationData] = useState<{\n    latitude: number;\n    longitude: number;\n    locationAddress: string;\n    locationName: string;\n  } | null>(null);\n  \n  // Estado para mostrar botones de acción en ubicación actual\n  const [showActionsForLocation, setShowActionsForLocation] = useState(false);\n  \n  // Estado para guardar las coordenadas y datos de la ubicación actual del mapa\n  const [currentLocation, setCurrentLocation] = useState<{\n    lng: number;\n    lat: number;\n    locationName?: string;\n    locationAddress?: string;\n  } | null>(null);\n  \n  // Estado para guardar eventos filtrados por una ubicación específica\n  const [locationFilteredEvents, setLocationFilteredEvents] = useState<Event[]>([]);\n  \n  const { toast } = useToast();\n  const mapContainerRef = useRef<HTMLDivElement>(null);\n  const mapRef = useRef<mapboxgl.Map | null>(null);\n  const markersRef = useRef<mapboxgl.Marker[]>([]);\n  const popupsRef = useRef<mapboxgl.Popup[]>([]);\n  \n  // Fetch events from API\n  const { data: eventsData, isLoading, error } = useQuery({\n    queryKey: ['/api/events'],\n    refetchOnWindowFocus: true,\n  });\n\n  // Use fetched events or empty array if no data yet\n  const events: Event[] = Array.isArray(eventsData) ? eventsData : [];\n\n  // Filter events based on search and filters\n  const filteredEvents = events.filter((event: Event) => {\n    // Search filter\n    if (searchTerm && !event.title.toLowerCase().includes(searchTerm.toLowerCase())) {\n      return false;\n    }\n    \n    // Category filter\n    if (filters?.category?.length && !filters.category.includes(event.category)) {\n      return false;\n    }\n    \n    // Payment type filter\n    if (filters?.paymentType?.length && !filters.paymentType.includes(event.paymentType)) {\n      return false;\n    }\n    \n    // Date filter handling\n    if (filters?.date && filters.date !== 'all') {\n      const eventDate = new Date(event.date);\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n      \n      const tomorrow = new Date(today);\n      tomorrow.setDate(tomorrow.getDate() + 1);\n      \n      const nextWeekStart = new Date(today);\n      nextWeekStart.setDate(nextWeekStart.getDate() + 7);\n      \n      const nextWeekEnd = new Date(nextWeekStart);\n      nextWeekEnd.setDate(nextWeekEnd.getDate() + 7);\n      \n      // Get the current day of the week (0 = Sunday, 6 = Saturday)\n      const currentDay = today.getDay();\n      \n      // Calculate days until next weekend (Friday and Saturday)\n      const daysUntilFriday = (5 - currentDay + 7) % 7;\n      const daysUntilSunday = (7 - currentDay) % 7;\n      \n      // Calculate next weekend dates\n      const nextFriday = new Date(today);\n      nextFriday.setDate(today.getDate() + daysUntilFriday);\n      \n      const nextSunday = new Date(today);\n      nextSunday.setDate(today.getDate() + daysUntilSunday);\n      \n      switch (filters.date) {\n        case 'today':\n          // Event date must be today\n          return eventDate.toDateString() === today.toDateString();\n          \n        case 'tomorrow':\n          // Event date must be tomorrow\n          return eventDate.toDateString() === tomorrow.toDateString();\n          \n        case 'this_week':\n          // Event must be within the current week (next 7 days)\n          return eventDate >= today && eventDate < nextWeekStart;\n          \n        case 'next_week':\n          // Event must be within the next week (8-14 days from now)\n          return eventDate >= nextWeekStart && eventDate < nextWeekEnd;\n          \n        case 'weekend':\n          // Event must be on the upcoming weekend (Friday to Sunday)\n          return eventDate >= nextFriday && eventDate <= nextSunday;\n          \n        default:\n          return true;\n      }\n    }\n    \n    return true;\n  });\n\n  // Estado para controlar el menú contextual\n  const [contextMenu, setContextMenu] = useState<{\n    visible: boolean;\n    x: number;\n    y: number;\n    lngLat: mapboxgl.LngLat | null;\n  }>({\n    visible: false,\n    x: 0,\n    y: 0,\n    lngLat: null\n  });\n  \n  // Efecto principal para manejar los clics en el mapa (siempre activo)\n  useEffect(() => {\n    // Esta función se ejecutará cada vez que el usuario haga clic en el mapa\n    function handleMapClick(e: mapboxgl.MapMouseEvent) {\n      console.log(\"Clic en el mapa detectado\", locationMode ? \"en modo ubicación\" : \"en modo normal\");\n      \n      // Detener la propagación para evitar que otros handlers cierren nuestro menú\n      e.originalEvent.stopPropagation();\n      \n      // Limpiar cualquier marcador temporal previo\n      if (tempLocationMarker) {\n        tempLocationMarker.remove();\n        setTempLocationMarker(null);\n      }\n      \n      // SIEMPRE mostrar el menú contextual sin importar el modo\n      console.log(\"Abriendo menú contextual en\", e.lngLat);\n      \n      // IMPORTANTE: Activar el modo de ubicación al hacer clic en el mapa\n      // Esto permite que el menú contextual se muestre sin tener que hacer clic en \"Crear un evento\" primero\n      if (!locationMode) {\n        console.log(\"Activando modo de ubicación automáticamente\");\n        setLocationMode(true);\n      }\n      \n      // Crear un nuevo marcador en la ubicación del clic\n      if (mapRef.current) {\n        // Crear marcador con forma de gota estilo Google Maps pero amarillo\n        const markerElement = document.createElement('div');\n        markerElement.innerHTML = `\n          <svg width=\"25\" height=\"41\" viewBox=\"0 0 25 41\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n            <path d=\"M12.5 0C5.596 0 0 5.596 0 12.5C0 21.563 12.5 41 12.5 41S25 21.563 25 12.5C25 5.596 19.404 0 12.5 0Z\" fill=\"#FFEB3B\"/>\n            <path d=\"M12.5 0C5.596 0 0 5.596 0 12.5C0 21.563 12.5 41 12.5 41S25 21.563 25 12.5C25 5.596 19.404 0 12.5 0Z\" stroke=\"#F57C00\" stroke-width=\"1\"/>\n            <circle cx=\"12.5\" cy=\"12.5\" r=\"4\" fill=\"white\"/>\n          </svg>\n        `;\n        markerElement.style.width = '25px';\n        markerElement.style.height = '41px';\n        markerElement.style.position = 'relative';\n        markerElement.style.zIndex = '5';\n        markerElement.style.cursor = 'pointer';\n        \n        // Crear el marcador\n        const marker = new mapboxgl.Marker({\n          element: markerElement,\n          draggable: false\n        })\n          .setLngLat(e.lngLat)\n          .addTo(mapRef.current);\n          \n        // Guardar referencia del marcador\n        setTempLocationMarker(marker);\n        \n        // PASO CRUCIAL: Mostrar el menú contextual INMEDIATAMENTE\n        const point = mapRef.current.project(e.lngLat);\n        \n        // Actualizar en un solo paso para evitar renders parciales que causen problemas\n        setContextMenu({\n          visible: true,\n          x: point.x,\n          y: point.y - 20, // Posicionar por encima del marcador\n          lngLat: e.lngLat\n        });\n        \n        // También guardar los datos de ubicación temporales\n        setTempLocationData({\n          latitude: e.lngLat.lat,\n          longitude: e.lngLat.lng,\n          locationName: \"Ubicación seleccionada\", \n          locationAddress: \"Cargando dirección...\"\n        });\n      }\n      \n      // Usar ambos servicios en paralelo para obtener resultados más completos\n      const mapboxPromise = reverseGeocode(e.lngLat.lng, e.lngLat.lat);\n      const googlePromise = googleReverseGeocode(e.lngLat.lng, e.lngLat.lat);\n      const nearbyPlacesPromise = findNearbyPlaces(e.lngLat.lat, e.lngLat.lng, 100);\n      \n      // Procesar todos los resultados\n      Promise.all([mapboxPromise, googlePromise, nearbyPlacesPromise])\n        .then(([mapboxAddress, googleAddress, nearbyPlaces]) => {\n          console.log(\"Geocode results:\", { mapboxAddress, googleAddress });\n          console.log(\"Nearby places:\", nearbyPlaces);\n          \n          // Extraer nombre del lugar - primero comprobar si hay establecimientos cercanos\n          let locationName;\n          let address;\n          \n          // Prioridad 1: Si encontramos lugares importantes (parques, plazas, etc.) usar esos nombres\n          // Identificar posibles lugares importantes (parques, puntos de interés, etc.)\n          const importantPlaces = Array.isArray(nearbyPlaces) \n            ? nearbyPlaces.filter(place => \n                // Buscar parques, puntos de interés, atracciones, locales marcados, etc.\n                ['park', 'point_of_interest', 'establishment', 'premise', 'neighborhood', 'natural_feature']\n                  .some(type => place.types && place.types.includes(type))\n              )\n            : [];\n          \n          if (importantPlaces.length > 0) {\n            const place = importantPlaces[0]; // Usar el lugar más relevante\n            locationName = place.name || \"Lugar del evento\";\n            \n            // Para la dirección completa, usar el resultado de geocodificación inversa\n            if (googleAddress && googleAddress !== \"Dirección no encontrada\" && googleAddress !== \"Error al obtener dirección\") {\n              address = googleAddress;\n            } else {\n              address = mapboxAddress;\n            }\n            \n            console.log(\"Usando nombre de lugar importante:\", locationName);\n          } \n          // Prioridad 2: Cualquier establecimiento cercano\n          else if (Array.isArray(nearbyPlaces) && nearbyPlaces.length > 0) {\n            const place = nearbyPlaces[0];\n            locationName = place.name || \"Lugar del evento\";\n            \n            // Para la dirección completa, usar el resultado de geocodificación inversa\n            if (googleAddress && googleAddress !== \"Dirección no encontrada\" && googleAddress !== \"Error al obtener dirección\") {\n              address = googleAddress;\n            } else {\n              address = mapboxAddress;\n            }\n            \n            console.log(\"Usando nombre de establecimiento cercano:\", locationName);\n          } \n          // Prioridad 3: Usar los resultados de geocodificación inversa de Google\n          else if (googleAddress && googleAddress !== \"Dirección no encontrada\" && googleAddress !== \"Error al obtener dirección\") {\n            // Buscar un nombre significativo que no sea solo una dirección\n            // Primero verificar si hay algo como \"Parque X\" o \"Plaza Y\" en la dirección\n            const specialPlaceMatch = googleAddress.match(/(Parque|Plaza|Museo|Estadio|Monumento|Jardín|Biblioteca|Universidad|Teatro|Centro)\\s+([^,]+)/i);\n            \n            if (specialPlaceMatch) {\n              // Usamos el nombre del lugar especial si lo encontramos\n              locationName = specialPlaceMatch[0];\n            } else {\n              // Si no, usamos la primera parte de la dirección\n              const placeNameMatch = googleAddress.match(/^([^,]+)/);\n              locationName = placeNameMatch ? placeNameMatch[0] : \"Lugar del evento\";\n            }\n            \n            address = googleAddress;\n            console.log(\"Usando dirección de Google:\", address);\n          } \n          // Última opción: MapBox como fallback\n          else {\n            // Buscar un nombre significativo que no sea solo una dirección\n            const specialPlaceMatch = mapboxAddress.match(/(Parque|Plaza|Museo|Estadio|Monumento|Jardín|Biblioteca|Universidad|Teatro|Centro)\\s+([^,]+)/i);\n            \n            if (specialPlaceMatch) {\n              // Usamos el nombre del lugar especial si lo encontramos\n              locationName = specialPlaceMatch[0];\n            } else {\n              // Si no, usamos la primera parte de la dirección\n              const placeNameMatch = mapboxAddress.match(/^([^,]+)/);\n              locationName = placeNameMatch ? placeNameMatch[0] : \"Lugar del evento\";\n            }\n            \n            address = mapboxAddress;\n            console.log(\"Usando dirección de MapBox (fallback):\", address);\n          }\n          \n          // Store location data\n          const locationData = {\n            latitude: e.lngLat.lat,\n            longitude: e.lngLat.lng,\n            locationAddress: address,\n            locationName: locationName\n          };\n          \n          console.log(\"Guardando datos de ubicación:\", locationData);\n          setTempLocationData(locationData);\n          \n          toast({\n            title: \"Ubicación seleccionada\",\n            description: `${locationName}`,\n          });\n        })\n        .catch(error => {\n          console.error(\"Error getting address or nearby places:\", error);\n          toast({\n            title: \"Error\",\n            description: \"No se pudo obtener la dirección. Por favor, intenta de nuevo.\",\n            variant: \"destructive\",\n          });\n        });\n    }\n\n    if (mapRef.current) {\n      console.log(\"Configurando manejador de clics en el mapa\");\n      \n      // Primero eliminar cualquier manejador existente para evitar duplicados\n      mapRef.current.off('click', handleMapClick);\n      \n      // Luego añadir el manejador de clics\n      mapRef.current.on('click', handleMapClick);\n      \n      // Return cleanup function\n      return () => {\n        if (mapRef.current) {\n          console.log(\"Eliminando manejador de clics del mapa\");\n          mapRef.current.off('click', handleMapClick);\n        }\n      };\n    }\n  }, [toast, tempLocationMarker]); // Removed locationMode from dependencies to ensure the click handler stays consistent\n  \n  // Initialize map on component mount and center on user's location\n  useEffect(() => {\n    if (!mapContainerRef.current || mapRef.current) return;\n\n    console.log(\"Inicializando mapa y configurando eventos globales\");\n\n    // Initialize the map with default config\n    mapRef.current = initializeMap(mapContainerRef.current);\n    \n    // Add controls\n    mapRef.current.addControl(new mapboxgl.NavigationControl(), 'top-right');\n\n    // Try to center on user's location automatically\n    navigator.geolocation.getCurrentPosition(\n      (position) => {\n        const { longitude, latitude } = position.coords;\n        \n        if (mapRef.current) {\n          mapRef.current.setCenter([longitude, latitude]);\n          mapRef.current.setZoom(13);\n          \n          // Add a marker for the user's current position\n          new mapboxgl.Marker({ color: '#1DA1F2' })\n            .setLngLat([longitude, latitude])\n            .addTo(mapRef.current);\n            \n          // Try to get the city name for a better user experience\n          reverseGeocode(longitude, latitude)\n            .then(address => {\n              toast({\n                title: \"Ubicación detectada\",\n                description: `Te mostramos eventos cercanos a tu ubicación`,\n              });\n            })\n            .catch(err => console.error(\"Error getting address:\", err));\n        }\n      },\n      (error) => {\n        console.warn(\"Error getting location:\", error);\n        // Fallback to default location (centered on a major city)\n        if (mapRef.current) {\n          // Center on Buenos Aires by default (more relevant for Spanish-speaking users)\n          mapRef.current.setCenter([-58.3816, -34.6037]);\n          mapRef.current.setZoom(12);\n        }\n      },\n      { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }\n    );\n\n    return () => {\n      console.log(\"Limpiando el mapa al desmontar componente\");\n      \n      // Clean up on unmount\n      if (mapRef.current) {\n        try {\n          // Limpiar los marcadores y popups primero\n          markersRef.current.forEach(marker => marker.remove());\n          popupsRef.current.forEach(popup => popup.remove());\n          markersRef.current = [];\n          popupsRef.current = [];\n          \n          // Eliminar cualquier marcador temporal\n          if (tempLocationMarker) {\n            tempLocationMarker.remove();\n            setTempLocationMarker(null);\n          }\n          \n          // Eliminar el mapa\n          mapRef.current.remove();\n          mapRef.current = null;\n        } catch (error) {\n          console.error(\"Error limpiando recursos del mapa:\", error);\n        }\n      }\n    };\n  }, []);\n\n  // Efecto para cerrar el menú contextual y limpiar marcadores temporales al hacer clic en cualquier parte de la aplicación \n  // que no sea el mapa o los botones de acción\n  useEffect(() => {\n    function handleClickOutside(e: MouseEvent) {\n      const target = e.target as Element;\n      \n      // Comprobar si es un clic dentro del mapa\n      const isMapClick = target.closest('.mapboxgl-canvas-container');\n      \n      // Comprobar si es un clic en los botones de acción\n      const isActionButton = target.closest('button') && (\n        target.textContent?.includes('Buscar eventos aquí') || \n        target.textContent?.includes('Crear un evento aquí') ||\n        target.textContent?.includes('Ver eventos cercanos') ||\n        target.textContent?.includes('Crear evento aquí')\n      );\n      \n      // Comprobar si es un clic en el menú contextual\n      const isContextMenuClick = target.closest('.context-menu');\n      \n      // IMPORTANTE: Evitamos cerrar el menú contextual con clicks outside\n      // Solo cerramos en casos muy específicos, por ejemplo si se hace clic en otra parte \n      // de la aplicación que no sea el mapa, el menú o los botones de acción\n      // Agregamos un log para depuración\n      if (contextMenu.visible) {\n        console.log(\"Click outside detectado - contextMenu visible, analizando objetivo:\", {\n          isMapClick,\n          isContextMenuClick,\n          isActionButton\n        });\n        \n        // Solo cerramos si no es ninguno de los elementos permitidos\n        if (!isMapClick && !isContextMenuClick && !isActionButton) {\n          console.log(\"Cerrando menú contextual por clic fuera de elementos permitidos\");\n          closeContextMenu();\n        } else {\n          console.log(\"Manteniendo menú contextual visible\");\n        }\n      }\n      \n      // Limpiar el marcador temporal y ocultar botones de acción si el clic no fue en:\n      // - El mapa\n      // - Los botones de acción específicos\n      // - La barra de búsqueda\n      // - Controles del mapa\n      if (showActionsForLocation && \n          !isMapClick && \n          !isActionButton && \n          !target.closest('.google-places-search') && \n          !target.closest('.mapboxgl-ctrl')) {\n        \n        console.log(\"Clic fuera de la ubicación seleccionada, ocultando botones de acción\");\n        \n        // Ocultar botones de acciones específicas\n        setShowActionsForLocation(false);\n        \n        // Limpiar el marcador temporal si existe\n        if (tempLocationMarker) {\n          tempLocationMarker.remove();\n          setTempLocationMarker(null);\n        }\n      }\n    }\n    \n    document.addEventListener('click', handleClickOutside);\n    \n    return () => {\n      document.removeEventListener('click', handleClickOutside);\n    };\n  }, [contextMenu.visible, showActionsForLocation, tempLocationMarker]);\n  \n  // Efecto para detectar cuando se cierra el formulario de creación de evento\n  useEffect(() => {\n    if (resetLocationOnFormClose) {\n      console.log(\"Detectada señal de cierre de formulario, limpiando marcadores temporales\");\n      cleanupTempMarkers();\n    }\n  }, [resetLocationOnFormClose]);\n\n  // Add event markers when events or filters change\n  useEffect(() => {\n    if (!mapRef.current) return;\n    \n    // Clear existing markers and popups\n    markersRef.current.forEach(marker => marker.remove());\n    popupsRef.current.forEach(popup => popup.remove());\n    markersRef.current = [];\n    popupsRef.current = [];\n    \n    // Add markers for filtered events\n    filteredEvents.forEach((event: Event) => {\n      if (!mapRef.current) return;\n      \n      // Create custom React element for the marker\n      const el = document.createElement('div');\n      el.className = \"custom-marker-container\";\n\n      // Render React component to the element\n      const root = createRoot(el);\n      root.render(<EventPin category={event.category} />);\n      \n      // Create popup\n      const popup = new mapboxgl.Popup({ offset: 25 })\n        .setHTML(`\n          <div class=\"popup-content\">\n            <h3 class=\"font-bold\">${event.title}</h3>\n            <p class=\"text-sm\">${event.locationName}</p>\n            <p class=\"text-xs text-gray-500\">\n              ${new Date(event.date).toLocaleDateString('es-ES', { \n                month: 'short', \n                day: 'numeric',\n                hour: '2-digit',\n                minute: '2-digit'\n              })}\n            </p>\n          </div>\n        `);\n      \n      // Validar y convertir coordenadas\n      const lng = typeof event.longitude === 'string' ? parseFloat(event.longitude) : event.longitude;\n      const lat = typeof event.latitude === 'string' ? parseFloat(event.latitude) : event.latitude;\n      \n      // Verificar que las coordenadas sean números válidos\n      if (isNaN(lng) || isNaN(lat)) {\n        console.error('Coordenadas inválidas para el evento:', event.id, event.title, {\n          longitude: event.longitude,\n          latitude: event.latitude\n        });\n        return; // Saltar este evento si las coordenadas no son válidas\n      }\n      \n      // Crear marcador solo si las coordenadas son válidas\n      const marker = new mapboxgl.Marker(el)\n        .setLngLat([lng, lat])\n        .setPopup(popup)\n        .addTo(mapRef.current);\n      \n      // Add event listener to marker\n      el.addEventListener('click', () => {\n        onEventSelect(event);\n      });\n      \n      // Track markers and popups for cleanup\n      markersRef.current.push(marker);\n      popupsRef.current.push(popup);\n    });\n  }, [filteredEvents, onEventSelect]);\n\n  // Handle search functionality\n  const handleSearch = (term: string) => {\n    setSearchTerm(term);\n  };\n  \n  // Función para limpiar los marcadores temporales y resetear el estado relacionado\n  const cleanupTempMarkers = () => {\n    console.log(\"Ejecutando limpieza forzada de marcadores temporales\");\n    \n    // Limpiar el marcador temporal si existe\n    if (tempLocationMarker) {\n      console.log(\"Eliminando marcador temporal existente\");\n      tempLocationMarker.remove();\n      setTempLocationMarker(null);\n    }\n    \n    // También limpiar los datos de ubicación temporal\n    setTempLocationData(null);\n    \n    // Resetear el modo de ubicación si está activo\n    if (locationMode) {\n      console.log(\"Desactivando modo de ubicación\");\n      setLocationMode(false);\n    }\n    \n    // Ocultar los botones de acción\n    setShowActionsForLocation(false);\n    \n    // Cerrar cualquier menú contextual abierto\n    setContextMenu({\n      visible: false,\n      x: 0,\n      y: 0,\n      lngLat: null\n    });\n    \n    // Forzar limpieza de cualquier otro marcador que podría haberse quedado\n    // Este enfoque es más agresivo pero asegura que no queden marcadores huérfanos\n    if (mapRef.current) {\n      // Obtener todos los marcadores del mapa\n      const markers = Array.from(document.querySelectorAll('.mapboxgl-marker'));\n      if (markers.length > 0) {\n        console.log(`Limpiando ${markers.length} marcadores encontrados en el DOM`);\n        \n        // Eliminar solo los marcadores temporales (para evitar eliminar los de eventos)\n        markers.forEach(markerElement => {\n          // Los marcadores de eventos tienen la clase custom-marker-container como hijo\n          const isEventMarker = markerElement.querySelector('.custom-marker-container');\n          if (!isEventMarker) {\n            console.log(\"Eliminando marcador huérfano\");\n            markerElement.remove();\n          }\n        });\n      }\n    }\n  };\n  \n  // Función para cerrar el menú contextual \n  const closeContextMenu = () => {\n    // Asegurarse de que el menú contextual se cierre correctamente\n    setContextMenu({\n      visible: false,\n      x: 0,\n      y: 0,\n      lngLat: null\n    });\n    \n    // También ocultar los botones de acción que podrían estar visibles\n    setShowActionsForLocation(false);\n    \n    // Siempre limpiar el marcador temporal para que no quede visible en el mapa\n    // Esto asegura que al hacer clic en Cancelar, siempre se elimine el marcador\n    if (tempLocationMarker) {\n      console.log(\"Eliminando marcador temporal al cerrar/cancelar acción\");\n      tempLocationMarker.remove();\n      setTempLocationMarker(null);\n      setTempLocationData(null);\n    }\n    \n    // Al cerrar el menú contextual con Cancelar, además de eliminar el marcador,\n    // también salimos del modo de ubicación si estamos en él \n    // y regresamos al estado normal con los botones principales\n    if (locationMode) {\n      console.log(\"Saliendo del modo de ubicación al cancelar\");\n      setLocationMode(false);\n    }\n  };\n  \n  // Función para crear un evento en la ubicación del menú contextual\n  const handleCreateEventAtLocation = async () => {\n    if (contextMenu.lngLat) {\n      const { lng, lat } = contextMenu.lngLat;\n      \n      try {\n        // Obtener información sobre la ubicación seleccionada\n        const mapboxPromise = reverseGeocode(lng, lat);\n        const googlePromise = googleReverseGeocode(lng, lat);\n        const nearbyPlacesPromise = findNearbyPlaces(lat, lng, 100);\n        \n        // Procesar resultados\n        const [mapboxAddress, googleAddress, nearbyPlaces] = await Promise.all([\n          mapboxPromise, googlePromise, nearbyPlacesPromise\n        ]);\n        \n        // Determinar el nombre y dirección del lugar\n        let locationName;\n        let address;\n        \n        // Prioridad 1: Si encontramos lugares importantes (parques, plazas, etc.) usar esos nombres\n        // Identificar posibles lugares importantes (parques, puntos de interés, etc.)\n        const importantPlaces = Array.isArray(nearbyPlaces) \n          ? nearbyPlaces.filter(place => \n              // Buscar parques, puntos de interés, atracciones, locales marcados, etc.\n              ['park', 'point_of_interest', 'establishment', 'premise', 'neighborhood', 'natural_feature']\n                .some(type => place.types && place.types.includes(type))\n            )\n          : [];\n        \n        if (importantPlaces.length > 0) {\n          const place = importantPlaces[0]; // Usar el lugar más relevante\n          locationName = place.name || \"Lugar del evento\";\n          \n          // Para la dirección completa, usar el resultado de geocodificación inversa\n          address = googleAddress || mapboxAddress;\n          \n          console.log(\"Usando nombre de lugar importante (menú contextual):\", locationName);\n        } \n        // Prioridad 2: Cualquier establecimiento cercano\n        else if (Array.isArray(nearbyPlaces) && nearbyPlaces.length > 0) {\n          locationName = nearbyPlaces[0].name || \"Lugar del evento\";\n          \n          // Para la dirección completa usamos geocodificación inversa\n          address = googleAddress || mapboxAddress;\n          \n          console.log(\"Usando nombre de establecimiento cercano (menú contextual):\", locationName);\n        } \n        // Prioridad 3: Buscar nombres significativos en los resultados de geocodificación\n        else if (googleAddress && googleAddress !== \"Dirección no encontrada\") {\n          address = googleAddress;\n          \n          // Buscar si hay algo como \"Parque X\" o \"Plaza Y\" en la dirección\n          const specialPlaceMatch = address.match(/(Parque|Plaza|Museo|Estadio|Monumento|Jardín|Biblioteca|Universidad|Teatro|Centro)\\s+([^,]+)/i);\n          \n          if (specialPlaceMatch) {\n            // Usamos el nombre del lugar especial si lo encontramos\n            locationName = specialPlaceMatch[0];\n            console.log(\"Encontrado nombre de lugar en dirección Google:\", locationName);\n          } else {\n            // Si no, usamos la primera parte de la dirección\n            const namePart = googleAddress.split(',')[0];\n            locationName = namePart || \"Lugar del evento\";\n          }\n        }\n        // Última opción: MapBox como fallback\n        else {\n          address = mapboxAddress;\n          \n          // Buscar si hay algo como \"Parque X\" o \"Plaza Y\" en la dirección\n          const specialPlaceMatch = address.match(/(Parque|Plaza|Museo|Estadio|Monumento|Jardín|Biblioteca|Universidad|Teatro|Centro)\\s+([^,]+)/i);\n          \n          if (specialPlaceMatch) {\n            // Usamos el nombre del lugar especial si lo encontramos\n            locationName = specialPlaceMatch[0];\n            console.log(\"Encontrado nombre de lugar en dirección MapBox:\", locationName);\n          } else {\n            // Si no, usamos la primera parte de la dirección\n            const namePart = mapboxAddress.split(',')[0];\n            locationName = namePart || \"Lugar del evento\";\n          }\n        }\n        \n        // Crear objeto de ubicación\n        const locationData = {\n          latitude: lat,\n          longitude: lng,\n          locationAddress: address,\n          locationName: locationName\n        };\n        \n        // Cerrar menú contextual\n        closeContextMenu();\n        \n        // Iniciar creación de evento con esta ubicación\n        onCreateEventClick(locationData);\n      }\n      catch (error) {\n        console.error(\"Error al obtener información de la ubicación:\", error);\n        toast({\n          title: \"Error\",\n          description: \"No se pudo obtener información sobre esta ubicación. Inténtalo de nuevo.\",\n          variant: \"destructive\"\n        });\n      }\n    }\n  };\n  \n  // Función para buscar eventos cercanos desde una ubicación específica\n  const handleSearchNearbyEvents = (lngLat: mapboxgl.LngLat) => {\n    if (mapRef.current) {\n      // Obtener las coordenadas\n      const lng = lngLat.lng;\n      const lat = lngLat.lat;\n      \n      console.log(\"Buscando eventos cerca de:\", { lng, lat });\n      \n      // Centrar el mapa en la ubicación seleccionada\n      mapRef.current.flyTo({\n        center: [lng, lat],\n        zoom: 15,\n        essential: true,\n        duration: 1000\n      });\n      \n      // Mostrar un toast para indicar que se están buscando eventos\n      toast({\n        title: \"Buscando eventos\",\n        description: \"Buscando eventos cercanos a esta ubicación...\",\n      });\n      \n      // Actualizar el estado con la ubicación actual y mostrar panel de filtros\n      setCurrentLocation({\n        lng: lng,\n        lat: lat,\n        locationName: \"Ubicación seleccionada\",\n        locationAddress: \"\"\n      });\n      \n      // Mostrar panel de eventos\n      setEventsPanelVisible(true);\n      \n      // Aquí se podrían hacer otras acciones como cargar eventos desde la API\n    }\n  };\n  \n  // Función para buscar eventos cercanos a la ubicación del menú contextual\n  const handleFindNearbyEvents = () => {\n    if (contextMenu.lngLat && mapRef.current) {\n      // Guardar las coordenadas antes de cerrar el menú contextual\n      const lng = contextMenu.lngLat.lng;\n      const lat = contextMenu.lngLat.lat;\n      \n      // Cerrar menú contextual primero\n      closeContextMenu();\n      \n      // Centrar el mapa en la ubicación seleccionada\n      mapRef.current.flyTo({\n        center: [lng, lat],\n        zoom: 15,\n        essential: true,\n        duration: 1000\n      });\n      \n      // FILTROS ACTIVADOS: cargar eventos cercanos a las coordenadas seleccionadas\n      \n      // Actualizar el estado con la ubicación actual\n      setCurrentLocation({\n        lng: lng,\n        lat: lat,\n        locationName: \"Ubicación seleccionada\",\n        locationAddress: \"\"\n      });\n      \n      // Filtrar eventos por cercanía a estas coordenadas\n      const nearbyEvents = events.filter((event: Event) => {\n        // Verificar distancia (si hay coordenadas válidas)\n        let distanceMatch = false;\n        const eventLat = typeof event.latitude === 'string' ? parseFloat(event.latitude) : event.latitude;\n        const eventLng = typeof event.longitude === 'string' ? parseFloat(event.longitude) : event.longitude;\n        \n        if (!isNaN(eventLat) && !isNaN(eventLng)) {\n          const distance = calculateDistance(\n            lat, \n            lng, \n            eventLat, \n            eventLng\n          );\n          distanceMatch = distance <= 2; // Radio de 2 km\n        }\n        \n        return distanceMatch;\n      });\n      \n      // Actualizar el estado con los eventos filtrados\n      setLocationFilteredEvents(nearbyEvents);\n      \n      // Mostrar panel de eventos\n      setEventsPanelVisible(true);\n      \n      // Eliminar cualquier marcador temporal previo\n      cleanupTempMarkers();\n      \n      // Crear un nuevo marcador en la ubicación seleccionada\n      if (mapRef.current) {\n        const marker = new mapboxgl.Marker({\n          color: '#1DA1F2'\n        })\n          .setLngLat([lng, lat])\n          .addTo(mapRef.current);\n          \n        // Guardar la referencia del marcador para poder eliminarlo después\n        setTempLocationMarker(marker);\n        \n        // Programar la eliminación automática del marcador después de 5 segundos\n        setTimeout(() => {\n          if (marker) {\n            marker.remove();\n            setTempLocationMarker(null);\n          }\n        }, 5000);\n      }\n      \n      // Mostrar notificación según el número de eventos encontrados\n      if (nearbyEvents.length > 0) {\n        toast({\n          title: `${nearbyEvents.length} eventos encontrados`,\n          description: \"Mostrando eventos cercanos a este lugar\",\n        });\n      } else {\n        toast({\n          title: \"No se encontraron eventos\",\n          description: \"No hay eventos cerca de esta ubicación\",\n          variant: \"destructive\"\n        });\n      }\n    }\n  };\n\n  // Function to toggle location selection mode\n  const toggleLocationMode = () => {\n    // If we're exiting location mode, clean up\n    if (locationMode) {\n      resetLocationSelection();\n    } else {\n      // Enter location selection mode\n      toast({\n        title: \"Modo de selección activado\",\n        description: \"Haz clic en el mapa o busca un lugar para seleccionar la ubicación del evento\",\n      });\n      \n      // Asegurarnos de que se limpie cualquier menú contextual abierto\n      setContextMenu({\n        visible: false,\n        x: 0,\n        y: 0,\n        lngLat: null\n      });\n      \n      // Limpiar cualquier marcador temporal que pueda existir\n      if (tempLocationMarker) {\n        tempLocationMarker.remove();\n        setTempLocationMarker(null);\n      }\n    }\n    \n    // Toggle mode - esta variable controla si estamos en modo de crear evento específicamente\n    setLocationMode(!locationMode);\n  };\n  \n  // Function to handle place selection from the search bar\n  const handlePlaceSelect = async (place: {\n    latitude: number;\n    longitude: number;\n    locationName: string;\n    locationAddress: string;\n  }) => {\n    console.log(\"Lugar seleccionado en la búsqueda:\", place);\n    \n    // Si no estamos en modo de selección de ubicación, simplemente centrar el mapa\n    if (!locationMode && mapRef.current) {\n      const longitude = typeof place.longitude === 'string' ? parseFloat(place.longitude) : place.longitude;\n      const latitude = typeof place.latitude === 'string' ? parseFloat(place.latitude) : place.latitude;\n      \n      // Centrar el mapa en la ubicación seleccionada\n      mapRef.current.flyTo({\n        center: [longitude, latitude],\n        zoom: 15,\n        essential: true,\n        duration: 1000\n      });\n      \n      // Opcional: Añadir un marcador temporal\n      if (tempLocationMarker) {\n        tempLocationMarker.remove();\n      }\n      \n      const marker = new mapboxgl.Marker({\n        color: '#1DA1F2'\n      })\n        .setLngLat([longitude, latitude])\n        .addTo(mapRef.current);\n      \n      // Guardamos la referencia del marcador temporal\n      setTempLocationMarker(marker);\n      \n      // Guardar la ubicación actual para los botones de acción\n      setCurrentLocation({\n        lng: longitude,\n        lat: latitude,\n        locationName: place.locationName,\n        locationAddress: place.locationAddress\n      });\n      \n      // Mostrar los botones de acción para esta ubicación\n      setShowActionsForLocation(true);\n      \n      // Mostrar toast con información\n      toast({\n        title: place.locationName,\n        description: place.locationAddress,\n      });\n      \n      return;\n    }\n    \n    // Si estamos en modo de selección de ubicación, procesar normalmente\n    if (locationMode && mapRef.current) {\n      // Remove previous marker if exists\n      if (tempLocationMarker) {\n        tempLocationMarker.remove();\n      }\n      \n      // Asegurar que las coordenadas sean números\n      const latitude = typeof place.latitude === 'string' ? parseFloat(place.latitude) : place.latitude;\n      const longitude = typeof place.longitude === 'string' ? parseFloat(place.longitude) : place.longitude;\n      \n      console.log(\"Coordenadas recibidas:\", {\n        latitude,\n        longitude,\n        tipo_lat: typeof latitude,\n        tipo_lng: typeof longitude\n      });\n      \n      const coordinates: [number, number] = [longitude, latitude];\n      \n      // Create a new marker\n      const marker = new mapboxgl.Marker({\n        color: '#FF385C',\n        draggable: true\n      })\n        .setLngLat(coordinates)\n        .addTo(mapRef.current);\n      \n      // Fly to the location\n      mapRef.current.flyTo({\n        center: coordinates,\n        zoom: 15,\n        essential: true,\n        duration: 1000\n      });\n      \n      // Store the marker reference\n      setTempLocationMarker(marker);\n      \n      // Intentar utilizar geocodificación inversa de Google Maps para mejor consistencia\n      try {\n        console.log(\"Solicitando geocodificación inversa de Google para:\", longitude, latitude);\n        const googleAddress = await googleReverseGeocode(longitude, latitude);\n        console.log(\"Google devolvió la dirección:\", googleAddress);\n        \n        const locationData = {\n          latitude: parseFloat(String(latitude)),\n          longitude: parseFloat(String(longitude)),\n          // Usar la dirección completa de Google para la dirección\n          locationAddress: googleAddress || place.locationAddress,\n          // IMPORTANTE: Mantener el nombre original del lugar que el usuario seleccionó\n          locationName: place.locationName\n        };\n        \n        console.log(\"Guardando datos de ubicación (Google):\", locationData);\n        setTempLocationData(locationData);\n        \n        toast({\n          title: \"Ubicación seleccionada\",\n          description: googleAddress || place.locationAddress,\n        });\n      } catch (error) {\n        console.error(\"Error obteniendo dirección de Google:\", error);\n        \n        // Fallback a la dirección original\n        const fallbackData = {\n          latitude: parseFloat(String(latitude)),\n          longitude: parseFloat(String(longitude)),\n          locationAddress: place.locationAddress,\n          locationName: place.locationName\n        };\n        \n        console.log(\"Guardando datos de ubicación (fallback):\", fallbackData);\n        setTempLocationData(fallbackData);\n        \n        toast({\n          title: \"Ubicación seleccionada\",\n          description: place.locationAddress,\n        });\n      }\n      \n      // Add dragend event to update data when marker is dragged\n      marker.on('dragend', async () => {\n        const lngLat = marker.getLngLat();\n        \n        // Intentar obtener dirección usando Google primero para mantener consistencia\n        try {\n          const googleAddress = await googleReverseGeocode(lngLat.lng, lngLat.lat);\n          \n          const updatedData = {\n            latitude: parseFloat(String(lngLat.lat)),\n            longitude: parseFloat(String(lngLat.lng)),\n            locationAddress: googleAddress,\n            locationName: googleAddress.split(',')[0] || \"Ubicación seleccionada\"\n          };\n          \n          console.log(\"Actualizando ubicación tras arrastrar (Google):\", updatedData);\n          setTempLocationData(updatedData);\n          \n          toast({\n            title: \"Ubicación actualizada\",\n            description: googleAddress,\n          });\n        } catch (error) {\n          console.error(\"Error obteniendo dirección de Google al arrastrar:\", error);\n          \n          // Fallback a MapBox si Google falla\n          try {\n            const mapboxAddress = await reverseGeocode(lngLat.lng, lngLat.lat);\n            \n            const fallbackData = {\n              latitude: parseFloat(String(lngLat.lat)),\n              longitude: parseFloat(String(lngLat.lng)),\n              locationAddress: mapboxAddress,\n              locationName: mapboxAddress.split(',')[0] || \"Ubicación seleccionada\"\n            };\n            \n            console.log(\"Actualizando ubicación tras arrastrar (Mapbox):\", fallbackData);\n            setTempLocationData(fallbackData);\n            \n            toast({\n              title: \"Ubicación actualizada\",\n              description: mapboxAddress,\n            });\n          } catch (mapboxError) {\n            console.error(\"Error también con Mapbox:\", mapboxError);\n            \n            // Último recurso si ambos fallan\n            const basicData = {\n              latitude: parseFloat(String(lngLat.lat)),\n              longitude: parseFloat(String(lngLat.lng)),\n              locationAddress: \"Dirección desconocida\",\n              locationName: \"Lugar del evento\"\n            };\n            \n            console.log(\"Actualizando ubicación con datos básicos:\", basicData);\n            setTempLocationData(basicData);\n            \n            toast({\n              title: \"Ubicación actualizada\",\n              description: \"No se pudo obtener la dirección exacta\",\n              variant: \"destructive\"\n            });\n          }\n        }\n      });\n    }\n  };\n  \n  // Function to reset location selection - Simplified and improved version\n  const resetLocationSelection = () => {\n    console.log(\"Reseteando selección de ubicación\");\n    \n    // Limpiar el marcador temporal si existe\n    if (tempLocationMarker) {\n      tempLocationMarker.remove();\n      setTempLocationMarker(null);\n    }\n    \n    // Limpiar datos de ubicación temporal\n    setTempLocationData(null);\n    \n    // Asegurarse de que el menú contextual esté cerrado\n    setContextMenu({\n      visible: false,\n      x: 0,\n      y: 0,\n      lngLat: null\n    });\n    \n    // Resetear el modo de ubicación (si está activo)\n    if (locationMode) {\n      console.log(\"Limpiando modo de ubicación\");\n      setLocationMode(false);\n    }\n    \n    // Resetear cualquier otro estado relacionado con la selección de ubicación\n    setShowActionsForLocation(false);\n    \n    // Limpiar cualquier marcador huérfano que pueda haber quedado\n    console.log(\"Limpiando marcadores huérfanos del DOM\");\n    document.querySelectorAll('.mapboxgl-marker').forEach(element => {\n      element.remove();\n    });\n  };\n  \n  // Function to confirm location selection\n  const confirmLocationSelection = async () => {\n    if (tempLocationData) {\n      console.log(\"Confirmando ubicación original (Mapbox):\", tempLocationData);\n      \n      try {\n        // Intentar obtener la dirección usando Google Maps para consistencia\n        const googleAddress = await googleReverseGeocode(\n          tempLocationData.longitude, \n          tempLocationData.latitude\n        );\n        \n        // Crear objeto de ubicación con formato correcto para Google Maps\n        // Garantizamos explícitamente que las coordenadas son números\n        const locationData = {\n          latitude: Number(tempLocationData.latitude),\n          longitude: Number(tempLocationData.longitude),\n          // Usar la dirección de Google para la dirección completa pero mantener el nombre original\n          locationAddress: googleAddress || tempLocationData.locationAddress,\n          // Mantener el nombre original del lugar en vez de usar la primera parte de la dirección\n          locationName: tempLocationData.locationName\n        };\n        \n        console.log('COORDENADAS CONFIRMADAS:', {\n          latitude: locationData.latitude,\n          longitude: locationData.longitude,\n          tipoLat: typeof locationData.latitude,\n          tipoLon: typeof locationData.longitude\n        });\n        \n        console.log(\"Ubicación reformateada para Google Maps:\", locationData);\n        \n        // Call the function provided by parent to create event with the selected location\n        onCreateEventClick(locationData);\n        \n        // Clean up\n        resetLocationSelection();\n        setLocationMode(false);\n        \n        toast({\n          title: \"Ubicación confirmada\",\n          description: \"Ahora puedes completar los detalles del evento\",\n        });\n      } catch (error) {\n        console.error(\"Error al convertir coordenadas para Google Maps:\", error);\n        \n        // Usar datos originales de Mapbox como fallback\n        const fallbackLocationData = {\n          latitude: Number(tempLocationData.latitude),\n          longitude: Number(tempLocationData.longitude),\n          locationAddress: tempLocationData.locationAddress,\n          locationName: tempLocationData.locationName\n        };\n        \n        console.log('COORDENADAS FALLBACK:', {\n          latitude: fallbackLocationData.latitude,\n          longitude: fallbackLocationData.longitude,\n          tipoLat: typeof fallbackLocationData.latitude,\n          tipoLon: typeof fallbackLocationData.longitude\n        });\n        \n        console.log(\"Usando ubicación de fallback:\", fallbackLocationData);\n        onCreateEventClick(fallbackLocationData);\n        \n        resetLocationSelection();\n        setLocationMode(false);\n        \n        toast({\n          title: \"Ubicación confirmada\",\n          description: \"Ahora puedes completar los detalles del evento\",\n        });\n      }\n    } else {\n      toast({\n        title: \"No hay ubicación seleccionada\",\n        description: \"Haz clic en el mapa para seleccionar la ubicación del evento\",\n        variant: \"destructive\",\n      });\n    }\n  };\n  \n  // Función para calcular la distancia entre dos puntos de coordenadas en km (fórmula de Haversine)\n  const calculateDistance = (lat1: number, lon1: number, lat2: number, lon2: number): number => {\n    const R = 6371; // Radio de la Tierra en km\n    const dLat = (lat2 - lat1) * (Math.PI / 180);\n    const dLon = (lon2 - lon1) * (Math.PI / 180);\n    const a = \n      Math.sin(dLat/2) * Math.sin(dLat/2) +\n      Math.cos(lat1 * (Math.PI / 180)) * Math.cos(lat2 * (Math.PI / 180)) * \n      Math.sin(dLon/2) * Math.sin(dLon/2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n    const distance = R * c; // Distancia en km\n    return distance;\n  };\n  \n  // Función para buscar eventos cercanos a la ubicación actual\n  const handleSearchEventsAtLocation = () => {\n    if (currentLocation && mapRef.current) {\n      // Centrar el mapa en la ubicación seleccionada\n      mapRef.current.flyTo({\n        center: [currentLocation.lng, currentLocation.lat],\n        zoom: 15,\n        essential: true,\n        duration: 1000\n      });\n      \n      // Filtrar eventos por cercanía y por nombre\n      if (currentLocation.locationName) {\n        // Convertir a minúsculas para comparar\n        const placeName = currentLocation.locationName.toLowerCase();\n        \n        console.log(\"Buscando eventos relacionados con:\", placeName);\n        \n        // Filtrar eventos cercanos (radio de 2 km) o que contengan el nombre del lugar\n        const nearbyEvents = events.filter((event: Event) => {\n          // Verificar si la ubicación está en el nombre o descripción del evento\n          const nameMatch = event.title.toLowerCase().includes(placeName) || \n                          (event.description && event.description.toLowerCase().includes(placeName)) ||\n                          (event.locationName && event.locationName.toLowerCase().includes(placeName));\n          \n          // Verificar distancia (si hay coordenadas válidas)\n          let distanceMatch = false;\n          const eventLat = typeof event.latitude === 'string' ? parseFloat(event.latitude) : event.latitude;\n          const eventLng = typeof event.longitude === 'string' ? parseFloat(event.longitude) : event.longitude;\n          \n          if (!isNaN(eventLat) && !isNaN(eventLng)) {\n            const distance = calculateDistance(\n              currentLocation.lat, \n              currentLocation.lng, \n              eventLat, \n              eventLng\n            );\n            distanceMatch = distance <= 2; // Radio de 2 km\n            \n            if (distanceMatch) {\n              console.log(`Evento \"${event.title}\" está a ${distance.toFixed(2)} km`);\n            }\n          }\n          \n          // El evento coincide si está cerca o si contiene el nombre del lugar\n          return nameMatch || distanceMatch;\n        });\n        \n        console.log(\"Eventos cercanos o relacionados con\", currentLocation.locationName, \":\", nearbyEvents.length);\n        \n        // Actualizar el estado con los eventos filtrados\n        setLocationFilteredEvents(nearbyEvents);\n        \n        // Si hay eventos, mostrar notificación con el número\n        if (nearbyEvents.length > 0) {\n          toast({\n            title: `${nearbyEvents.length} eventos encontrados`,\n            description: `Eventos cerca de ${currentLocation.locationName}`,\n          });\n        } else {\n          toast({\n            title: \"No se encontraron eventos\",\n            description: `No hay eventos cerca de ${currentLocation.locationName}`,\n            variant: \"destructive\"\n          });\n        }\n      } else {\n        // Si no hay nombre de ubicación, usar todos los eventos\n        setLocationFilteredEvents(events);\n      }\n      \n      // Mostrar panel de eventos\n      setEventsPanelVisible(true);\n      \n      // Ocultar botones de acción\n      setShowActionsForLocation(false);\n      \n      // Limpiar marcadores\n      cleanupTempMarkers();\n      \n      // Importante: añadir un pequeño retraso para asegurar que no se quede el marcador\n      // Este enfoque asegura que cualquier otro marcador que pudiera ser generado\n      // por otras funciones también se elimine.\n      setTimeout(() => {\n        cleanupTempMarkers();\n      }, 100);\n    }\n  };\n  \n  // Función para crear un evento en la ubicación actual\n  const handleCreateEventAtCurrentLocation = async () => {\n    if (currentLocation) {\n      try {\n        // Intentar obtener más información sobre la ubicación\n        const googleAddress = await googleReverseGeocode(\n          currentLocation.lng, \n          currentLocation.lat\n        );\n        \n        // Crear objeto de ubicación con el formato esperado\n        const locationData = {\n          latitude: currentLocation.lat,\n          longitude: currentLocation.lng,\n          locationAddress: currentLocation.locationAddress || googleAddress || \"Dirección desconocida\",\n          locationName: currentLocation.locationName || googleAddress?.split(',')[0] || \"Lugar del evento\"\n        };\n        \n        // Iniciar creación de evento\n        onCreateEventClick(locationData);\n        \n        // Resetear estados\n        resetLocationSelection();\n        setShowActionsForLocation(false);\n      }\n      catch (error) {\n        console.error(\"Error al preparar la ubicación para el evento:\", error);\n        \n        // Usar los datos disponibles como fallback\n        const fallbackData = {\n          latitude: currentLocation.lat,\n          longitude: currentLocation.lng,\n          locationAddress: currentLocation.locationAddress || \"Dirección desconocida\",\n          locationName: currentLocation.locationName || \"Lugar del evento\"\n        };\n        \n        onCreateEventClick(fallbackData);\n        \n        // Resetear estados\n        resetLocationSelection();\n        setShowActionsForLocation(false);\n      }\n    }\n  };\n  \n  // Handle going to user's current location\n  const handleGoToCurrentLocation = async () => {\n    if (!mapRef.current) return;\n    \n    try {\n      const position = await getUserLocation(mapRef.current);\n      const { longitude, latitude } = position.coords;\n      \n      console.log(\"Obtenida ubicación actual:\", {\n        latitude,\n        longitude,\n        tipo_lat: typeof latitude,\n        tipo_lng: typeof longitude\n      });\n      \n      mapRef.current.flyTo({\n        center: [longitude, latitude],\n        zoom: 15,\n        essential: true\n      });\n      \n      // If in location selection mode, set this as the location\n      if (locationMode) {\n        // Remove existing marker if any\n        if (tempLocationMarker) {\n          tempLocationMarker.remove();\n        }\n        \n        // Crear marcador con forma de gota estilo Google Maps pero amarillo\n        const markerElement = document.createElement('div');\n        markerElement.innerHTML = `\n          <svg width=\"25\" height=\"41\" viewBox=\"0 0 25 41\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n            <path d=\"M12.5 0C5.596 0 0 5.596 0 12.5C0 21.563 12.5 41 12.5 41S25 21.563 25 12.5C25 5.596 19.404 0 12.5 0Z\" fill=\"#FFEB3B\"/>\n            <path d=\"M12.5 0C5.596 0 0 5.596 0 12.5C0 21.563 12.5 41 12.5 41S25 21.563 25 12.5C25 5.596 19.404 0 12.5 0Z\" stroke=\"#F57C00\" stroke-width=\"1\"/>\n            <circle cx=\"12.5\" cy=\"12.5\" r=\"4\" fill=\"white\"/>\n          </svg>\n        `;\n        markerElement.style.width = '25px';\n        markerElement.style.height = '41px';\n        markerElement.style.position = 'relative';\n        markerElement.style.zIndex = '5';\n        markerElement.style.cursor = 'pointer';\n        \n        // Create marker at current location\n        const marker = new mapboxgl.Marker({ \n          element: markerElement,\n          draggable: true \n        })\n          .setLngLat([longitude, latitude])\n          .addTo(mapRef.current);\n        \n        setTempLocationMarker(marker);\n        \n        // Intentar obtener la dirección usando Google Maps para mejor consistencia\n        try {\n          console.log(\"Solicitando dirección de Google para ubicación actual\");\n          const googleAddress = await googleReverseGeocode(longitude, latitude);\n          console.log(\"Google devolvió dirección para ubicación actual:\", googleAddress);\n          \n          // Extract place name\n          const locationName = googleAddress.split(',')[0] || \"Lugar del evento\";\n          \n          // Store location data\n          const locationData = {\n            latitude: parseFloat(String(latitude)),\n            longitude: parseFloat(String(longitude)),\n            locationAddress: googleAddress,\n            locationName: locationName\n          };\n          \n          console.log(\"Guardando datos de ubicación actual (Google):\", locationData);\n          setTempLocationData(locationData);\n          \n          toast({\n            title: \"Ubicación seleccionada\",\n            description: googleAddress,\n          });\n        } catch (googleError) {\n          console.error(\"Error obteniendo dirección de Google para ubicación actual:\", googleError);\n          \n          // Fallback a Mapbox si Google falla\n          try {\n            console.log(\"Intentando obtener dirección con Mapbox\");\n            const mapboxAddress = await reverseGeocode(longitude, latitude);\n            \n            // Extract place name\n            const locationName = mapboxAddress.split(',')[0] || \"Lugar del evento\";\n            \n            // Store location data\n            const fallbackData = {\n              latitude: parseFloat(String(latitude)),\n              longitude: parseFloat(String(longitude)),\n              locationAddress: mapboxAddress,\n              locationName: locationName\n            };\n            \n            console.log(\"Guardando datos de ubicación actual (Mapbox):\", fallbackData);\n            setTempLocationData(fallbackData);\n            \n            toast({\n              title: \"Ubicación seleccionada\",\n              description: mapboxAddress,\n            });\n          } catch (mapboxError) {\n            console.error(\"También falló Mapbox:\", mapboxError);\n            \n            // Último recurso: datos básicos sin dirección\n            const basicData = {\n              latitude: parseFloat(String(latitude)),\n              longitude: parseFloat(String(longitude)),\n              locationAddress: \"Dirección desconocida\",\n              locationName: \"Lugar del evento\"\n            };\n            \n            console.log(\"Guardando datos de ubicación básicos:\", basicData);\n            setTempLocationData(basicData);\n            \n            toast({\n              title: \"Ubicación seleccionada\",\n              description: \"No se pudo obtener la dirección. La ubicación ha sido seleccionada, pero sin dirección.\",\n              variant: \"destructive\",\n            });\n          }\n        }\n      } else {\n        // Just add a marker for current location if not in selection mode\n        new mapboxgl.Marker({ color: '#1DA1F2' })\n          .setLngLat([longitude, latitude])\n          .addTo(mapRef.current);\n        \n        toast({\n          title: \"Ubicación Actualizada\",\n          description: \"Mapa centrado en tu ubicación actual\",\n        });\n      }\n    } catch (error) {\n      console.error('Error getting location:', error);\n      toast({\n        title: \"Error de Ubicación\",\n        description: \"No se pudo acceder a tu ubicación\",\n        variant: \"destructive\",\n      });\n    }\n  };\n\n  return (\n    <div className=\"relative flex-1 h-full w-full bg-neutral-100 overflow-hidden\">\n      {/* Real Mapbox Map Container */}\n      <div \n        ref={mapContainerRef}\n        id=\"map-container\" \n        className=\"absolute top-0 left-0 right-0 bottom-0 z-0 map-container\"\n      ></div>\n      \n      {/* Events Panel - Only visible when eventsPanelVisible is true */}\n      {eventsPanelVisible && (\n        <div className=\"absolute bottom-20 left-0 right-0 max-h-72 overflow-y-auto z-20 bg-white rounded-t-xl shadow-lg p-4\">\n          <div className=\"flex items-center justify-between mb-4\">\n            <h2 className=\"text-lg font-bold\">\n              {currentLocation \n                ? `Eventos cerca de ${currentLocation.locationName || 'esta ubicación'}`\n                : 'Eventos cercanos'\n              }\n            </h2>\n            <button \n              onClick={() => {\n                setEventsPanelVisible(false);\n                cleanupTempMarkers();\n              }}\n              className=\"p-1 rounded-full hover:bg-gray-100\"\n            >\n              <X size={20} />\n            </button>\n          </div>\n          \n          {isLoading ? (\n            <div className=\"flex justify-center items-center py-8\">\n              <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-primary\"></div>\n            </div>\n          ) : locationFilteredEvents.length > 0 ? (\n            <div className=\"grid grid-cols-1 gap-3 pb-1\">\n              {locationFilteredEvents.map((event: Event) => (\n                <Card \n                  key={event.id} \n                  className=\"p-3 shadow-sm cursor-pointer hover:shadow-md transition-shadow flex flex-row gap-3 items-center\"\n                  onClick={() => {\n                    // Asegurarse de que latitude y longitude sean números antes de pasar el evento\n                    const formattedEvent = {\n                      ...event,\n                      latitude: typeof event.latitude === 'string' ? parseFloat(event.latitude) : event.latitude,\n                      longitude: typeof event.longitude === 'string' ? parseFloat(event.longitude) : event.longitude\n                    };\n                    \n                    onEventSelect(formattedEvent);\n                    setEventsPanelVisible(false);\n                  }}\n                >\n                  <div className=\"flex-shrink-0\">\n                    <div className=\"w-12 h-12 rounded-full bg-gray-100 flex items-center justify-center\">\n                      <CategoryPin category={event.category} size={24} />\n                    </div>\n                  </div>\n                  <div className=\"flex-1 min-w-0\">\n                    <div className=\"text-xs font-semibold uppercase text-gray-500 mb-1\">\n                      {event.category}\n                    </div>\n                    <h3 className=\"font-bold text-sm truncate\">{event.title}</h3>\n                    <p className=\"text-xs text-gray-600 truncate\">{event.locationName}</p>\n                    <p className=\"text-xs text-gray-500\">\n                      {new Date(event.date).toLocaleDateString('es-ES', { \n                        month: 'short', \n                        day: 'numeric', \n                        hour: '2-digit', \n                        minute: '2-digit' \n                      })}\n                    </p>\n                  </div>\n                </Card>\n              ))}\n            </div>\n          ) : currentLocation ? (\n            <div className=\"w-full text-center py-8 text-gray-500\">\n              <p>No hay eventos cerca de {currentLocation.locationName || 'esta ubicación'}</p>\n              <p className=\"text-sm\">Prueba con otra ubicación o crea un evento aquí</p>\n            </div>\n          ) : filteredEvents.length > 0 ? (\n            <div className=\"grid grid-cols-1 gap-3 pb-1\">\n              {filteredEvents.map((event: Event) => (\n                <Card \n                  key={event.id} \n                  className=\"p-3 shadow-sm cursor-pointer hover:shadow-md transition-shadow flex flex-row gap-3 items-center\"\n                  onClick={() => {\n                    // Asegurarse de que latitude y longitude sean números antes de pasar el evento\n                    const formattedEvent = {\n                      ...event,\n                      latitude: typeof event.latitude === 'string' ? parseFloat(event.latitude) : event.latitude,\n                      longitude: typeof event.longitude === 'string' ? parseFloat(event.longitude) : event.longitude\n                    };\n                    \n                    onEventSelect(formattedEvent);\n                    setEventsPanelVisible(false);\n                  }}\n                >\n                  <div className=\"flex-shrink-0\">\n                    <div className=\"w-12 h-12 rounded-full bg-gray-100 flex items-center justify-center\">\n                      <CategoryPin category={event.category} size={24} />\n                    </div>\n                  </div>\n                  <div className=\"flex-1 min-w-0\">\n                    <div className=\"text-xs font-semibold uppercase text-gray-500 mb-1\">\n                      {event.category}\n                    </div>\n                    <h3 className=\"font-bold text-sm truncate\">{event.title}</h3>\n                    <p className=\"text-xs text-gray-600 truncate\">{event.locationName}</p>\n                    <p className=\"text-xs text-gray-500\">\n                      {new Date(event.date).toLocaleDateString('es-ES', { \n                        month: 'short', \n                        day: 'numeric', \n                        hour: '2-digit', \n                        minute: '2-digit' \n                      })}\n                    </p>\n                  </div>\n                </Card>\n              ))}\n            </div>\n          ) : (\n            <div className=\"w-full text-center py-8 text-gray-500\">\n              <p>No hay eventos que coincidan con tus filtros</p>\n              <p className=\"text-sm\">Intenta con otros filtros o cambia de ubicación</p>\n            </div>\n          )}\n        </div>\n      )}\n      \n      {/* Search Bars */}\n      <div className=\"absolute top-4 left-4 right-4 z-10 flex flex-col gap-2\">\n        {/* Barra de búsqueda principal con filtros */}\n        <div className=\"flex items-center gap-2\">\n          <div className=\"flex-1\">\n            <GooglePlacesSearch \n              onPlaceSelect={handlePlaceSelect}\n              placeholder=\"Buscar lugares con Google Maps...\"\n            />\n          </div>\n          <Button \n            variant=\"outline\" \n            size=\"icon\" \n            className=\"h-11 w-11 rounded-full bg-white\"\n            onClick={() => setFiltersVisible(!filtersVisible)}\n          >\n            <Filter className=\"h-5 w-5\" />\n          </Button>\n        </div>\n        \n        {/* Barra de búsqueda de MapBox como fallback (temporal) */}\n        {false && (\n          <SearchBar \n            onSearch={handleSearch} \n            onFilterClick={() => setFiltersVisible(!filtersVisible)}\n            onPlaceSelect={locationMode ? handlePlaceSelect : undefined}\n          />\n        )}\n      </div>\n      \n      {/* Filters Panel */}\n      {filtersVisible && (\n        <EventFilters \n          onClose={() => setFiltersVisible(false)} \n          onApply={(newFilters) => {\n            // Apply the new filters to the parent component\n            if (filters && typeof filters === 'object') {\n              // Update category filter\n              if (newFilters.categories.length > 0) {\n                filters.category = newFilters.categories;\n              } else {\n                delete filters.category;\n              }\n              \n              // Update payment type filter\n              if (newFilters.paymentTypes.length > 0) {\n                filters.paymentType = newFilters.paymentTypes;\n              } else {\n                delete filters.paymentType;\n              }\n              \n              // Update date filter (will need date processing logic)\n              if (newFilters.dateFilter !== \"all\") {\n                filters.date = newFilters.dateFilter;\n              } else {\n                delete filters.date;\n              }\n            }\n            \n            // Close the filters panel\n            setFiltersVisible(false);\n            toast({\n              title: \"Filtros aplicados\",\n              description: \"Los eventos han sido filtrados según tus preferencias\",\n            });\n          }}\n        />\n      )}\n      \n      {/* Location Selection Mode Indicator */}\n      {locationMode && (\n        <div className=\"absolute top-16 left-0 right-0 z-20 flex justify-center\">\n          <div className=\"bg-primary text-white px-4 py-2 rounded-full shadow-lg\">\n            <span className=\"text-sm font-medium\">\n              Selecciona la ubicación para el evento\n            </span>\n          </div>\n        </div>\n      )}\n      \n      {/* Menú contextual cuando se hace clic en el mapa - ESTILO ANTIGUO tipo menú flotante */}\n      {/* Menú contextual - Siempre renderizamos pero usamos visibility para mostrar/ocultar */}\n      <div \n        className=\"absolute z-50 bg-white rounded-lg shadow-lg p-2 min-w-[180px] max-w-[300px] context-menu\"\n        style={{\n          visibility: contextMenu.visible ? 'visible' : 'hidden',\n          top: contextMenu.y - 100, // Ajustar para que aparezca sobre el marcador\n          left: contextMenu.x,\n          transform: 'translate(-50%, -50%)', // Centrar en el punto del click\n          pointerEvents: contextMenu.visible ? 'auto' : 'none' // Solo recibe eventos cuando es visible\n        }}\n        onClick={(e) => {\n          // Evitar cualquier cierre automático del menú contextual\n          e.stopPropagation();\n          e.preventDefault();\n          console.log(\"Click en el menú contextual capturado y detenido\");\n        }}\n        onMouseDown={(e) => {\n          // También prevenir mousedown para evitar problemas de propagación de eventos\n          e.stopPropagation();\n        }}\n      >\n        <div className=\"flex flex-col\">\n          {/* Título */}\n          <div className=\"p-2 text-center border-b border-gray-200\">\n            <span className=\"text-sm font-medium\">¿Qué quieres hacer?</span>\n          </div>\n          \n          {/* Opciones */}\n          <button \n            className=\"p-2 text-left hover:bg-gray-100 text-sm flex items-center gap-2\"\n            onClick={handleCreateEventAtLocation}\n          >\n            <Plus size={16} />\n            Crear evento aquí\n          </button>\n          \n          <button \n            className=\"p-2 text-left hover:bg-gray-100 text-sm flex items-center gap-2\"\n            onClick={() => {\n              closeContextMenu(); // Primero cerramos el menú\n              // Luego buscamos eventos cerca de la ubicación seleccionada\n              if (contextMenu.lngLat) {\n                handleSearchNearbyEvents(contextMenu.lngLat);\n              }\n            }}\n          >\n            <Compass size={16} />\n            Buscar eventos cerca\n          </button>\n          \n          <button \n            className=\"p-2 text-left hover:bg-gray-100 text-sm flex items-center gap-2\"\n            onClick={closeContextMenu}\n          >\n            <X size={16} />\n            Cancelar\n          </button>\n        </div>\n        </div>\n      )}\n      \n      {/* Solo mostramos el encabezado de selección sin la tarjeta de información */}\n      \n      {/* Current Location Button - Always visible */}\n      <button \n        className=\"absolute bottom-16 right-4 p-3 bg-white rounded-full shadow-lg text-neutral-700 border border-neutral-200 hover:bg-gray-50 flex items-center justify-center z-20\"\n        onClick={handleGoToCurrentLocation}\n        title=\"Ir a mi ubicación\"\n        aria-label=\"Ir a mi ubicación actual\"\n      >\n        <Circle size={24} />\n      </button>\n      \n      {/* Main action buttons - Centered at bottom - SIEMPRE VISIBLES */}\n      <div className=\"absolute bottom-6 left-0 right-0 z-20 flex justify-center gap-4 px-6\">\n        {showActionsForLocation ? (\n          // Botones específicos para la ubicación buscada\n          <>\n            {/* Buscar Eventos Cercanos */}\n            <button \n              className=\"flex-1 py-3 bg-white rounded-xl shadow-lg text-neutral-700 border border-neutral-200 flex items-center justify-center gap-2 font-medium\"\n              onClick={handleSearchEventsAtLocation}\n            >\n              <Compass size={20} />\n              Buscar eventos aquí\n            </button>\n            \n            {/* Crear Evento Aquí */}\n            <button \n              className=\"flex-1 py-3 bg-primary rounded-xl shadow-lg text-white flex items-center justify-center gap-2 font-medium\"\n              onClick={handleCreateEventAtCurrentLocation}\n            >\n              <Plus size={20} />\n              Crear un evento aquí\n            </button>\n          </>\n        ) : !locationMode ? (\n          // Botones normales - Modo estándar\n          <>\n            {/* Discover Events Button */}\n            <button \n              className=\"flex-1 py-3 bg-white rounded-xl shadow-lg text-neutral-700 border border-neutral-200 flex items-center justify-center gap-2 font-medium\"\n              onClick={() => setEventsPanelVisible(!eventsPanelVisible)}\n            >\n              <Compass size={20} />\n              Descubrir eventos\n            </button>\n            \n            {/* Create Event Button */}\n            <button \n              className=\"flex-1 py-3 bg-primary rounded-xl shadow-lg text-white flex items-center justify-center gap-2 font-medium\"\n              onClick={toggleLocationMode}\n            >\n              <Plus size={20} />\n              Crear un evento\n            </button>\n          </>\n        ) : (\n          // Botones para modo de selección de ubicación\n          <>\n            {/* Cancel Location Selection */}\n            <button \n              className=\"flex-1 py-3 bg-white rounded-xl shadow-lg text-red-600 border border-neutral-200 flex items-center justify-center gap-2 font-medium\"\n              onClick={() => {\n                setLocationMode(false);\n                resetLocationSelection();\n              }}\n            >\n              <X size={20} />\n              Cancelar\n            </button>\n            \n            {/* Confirm Location Button */}\n            <button \n              className=\"flex-1 py-3 bg-primary rounded-xl shadow-lg text-white flex items-center justify-center gap-2 font-medium\"\n              onClick={confirmLocationSelection}\n              disabled={!tempLocationData}\n            >\n              <Check size={20} />\n              Crear un evento aquí\n            </button>\n          </>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default MapView;\n","size_bytes":74738},"client/src/components/maps/map-view.tsx":{"content":"import React, { useState, useEffect, useRef } from \"react\";\nimport SearchBar from \"@/components/search/search-bar\";\nimport GooglePlacesSearch from \"@/components/search/google-places-search\";\nimport EventFilters from \"@/components/events/event-filters\";\nimport {\n  Circle,\n  MapPin,\n  MapIcon,\n  PinIcon,\n  Plus,\n  Pin,\n  MapPinned,\n  Check,\n  X,\n  Compass,\n  Filter,\n  Layers,\n  Settings,\n  Globe,\n  Building2,\n  Satellite,\n  Map as MapIcon2,\n  Bell,\n  Layers3,\n} from \"lucide-react\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { useAuth } from \"@/hooks/use-auth\";\nimport { useEvents } from \"@/hooks/use-events\";\nimport { useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport { useMap } from \"@/contexts/MapContext\";\nimport { Card } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { Slider } from \"@/components/ui/slider\";\nimport { apiRequest } from \"@/lib/queryClient\";\nimport NotificationsPanel from \"@/components/notifications/notifications-panel\";\n\nimport EventPin from \"./event-pin\";\nimport MapConfigPanel from \"./map-config-panel\";\nimport EventDetailSheet from \"@/components/events/event-detail-sheet\";\nimport EditEventSheet from \"@/components/events/edit-event-sheet\";\nimport mapboxgl from \"mapbox-gl\";\nimport {\n  initializeMap,\n  getUserLocation,\n  defaultMapConfig,\n  searchLocations,\n  reverseGeocode,\n  enable3DMap,\n  enable2DMap,\n  MapStyle,\n  getLightPresetByTime,\n  enableSatelliteMap,\n  applyMapConfig,\n  MapConfigOptions,\n  LightPreset,\n  MapTheme,\n  MapFont,\n} from \"@/lib/mapbox\";\n// Para debugging - importar también funciones de google\nimport {\n  reverseGeocode as googleReverseGeocode,\n  findNearbyPlaces,\n} from \"@/lib/google-maps\";\nimport { createRoot } from \"react-dom/client\";\nimport { motion, AnimatePresence } from \"framer-motion\";\n// Removed 3D marker manager import - only using 2D markers\n\n// Import new 3D Snap Map components\nimport PipolMap from \"./PipolMap\";\nimport { adaptEventsForMap3D } from \"@/lib/eventsAdapter\";\n\n// Helper function for category emojis\nconst getCategoryEmoji = (category: string): string => {\n  const categoryEmojis: Record<string, string> = {\n    social: \"👥\",\n    music: \"🎵\",\n    spiritual: \"🙏\",\n    education: \"📚\",\n    sports: \"⚽\",\n    food: \"🍽️\",\n    art: \"🎨\",\n    technology: \"💻\",\n    games: \"🎮\",\n    outdoor: \"🌲\",\n    networking: \"🤝\",\n    workshop: \"🔧\",\n    conference: \"📋\",\n    party: \"🎉\",\n    fair: \"🎪\",\n    exhibition: \"🖼️\",\n  };\n  return categoryEmojis[category] || \"📅\";\n};\n\n// Import Event type from shared schema\nimport { events, Event as SchemaEvent } from \"../../../../shared/schema\";\n\n// Create a more flexible Event type that matches the API response\ntype BaseEvent = {\n  id: number;\n  title: string;\n  description: string;\n  category: string;\n  date: Date | string;\n  latitude: string | number;\n  longitude: string | number;\n  locationName: string;\n  locationAddress: string;\n  paymentType: string;\n  price?: number | null;\n  maxCapacity?: number | null;\n  privacyType: string;\n  mediaItems?: string | null;\n  mainMediaType?: string | null;\n  mainMediaUrl?: string | null;\n  main_media_url?: string | null;\n  organizerId: number;\n  gender_preference?: string | null; // Agregado para el filtro de género\n  genderPreference?: string | null; // Formato camelCase alternativo\n  createdAt?: Date | string;\n  updatedAt?: Date | string;\n};\n\n// Extended Event type with populated relations for the map view\ntype EventWithRelations = BaseEvent & {\n  organizer?: {\n    id: number;\n    name: string;\n    avatar?: string;\n  };\n  attendees?: Array<{\n    id: number;\n    user: {\n      id: number;\n      name: string;\n      avatar?: string;\n    };\n  }>;\n};\n\ntype MapViewProps = {\n  onEventSelect: (event: EventWithRelations) => void;\n  onCreateEventClick: (locationData?: {\n    latitude: number;\n    longitude: number;\n    locationAddress: string;\n    locationName: string;\n  }) => void;\n  filters?: {\n    category?: string[];\n    paymentType?: string[];\n    date?: string;\n    distance?: number;\n  };\n  events?: EventWithRelations[]; // Eventos pasados desde el componente padre\n  resetLocationOnFormClose?: boolean; // Flag para controlar restablecimiento de marcadores\n  isFocusedMode?: boolean; // Estado del modo focalizado controlado por el padre\n  setIsFocusedMode?: (focused: boolean) => void; // Función para controlar el modo focalizado\n  overlaysHidden?: boolean; // Ocultar overlays cuando el panel de detalles está abierto\n};\n\nconst MapView = ({\n  onEventSelect,\n  onCreateEventClick,\n  filters,\n  events: propsEvents,\n  resetLocationOnFormClose,\n  isFocusedMode = false, // Default a false si no se provee\n  setIsFocusedMode = () => {}, // Default a función vacía si no se provee\n  overlaysHidden = false, // Default a false si no se provee\n}: MapViewProps) => {\n  // Unificar la lógica de visibilidad de overlays\n  const hideOverlays = overlaysHidden || isFocusedMode;\n  \n  const { user } = useAuth(); // Obtener el usuario actual\n  const [filtersVisible, setFiltersVisible] = useState(false);\n  const [searchTerm, setSearchTerm] = useState(\"\");\n  const [locationMode, setLocationMode] = useState(false);\n  const [editingEventId, setEditingEventId] = useState<number | null>(null);\n  const [editSheetVisible, setEditSheetVisible] = useState(false);\n\n  // Configurar ID del usuario actual como variable global para los marcadores\n  useEffect(() => {\n    if (user && user.id) {\n      // @ts-ignore - Definimos la propiedad global para el ID del usuario\n      window._currentUserId = user.id;\n    }\n  }, [user]);\n  const [eventsPanelVisible, setEventsPanelVisible] = useState(false);\n  const [tempLocationMarker, setTempLocationMarker] =\n    useState<mapboxgl.Marker | null>(null);\n  const [tempLocationData, setTempLocationData] = useState<{\n    latitude: number;\n    longitude: number;\n    locationAddress: string;\n    locationName: string;\n  } | null>(null);\n\n  // Estado para mostrar botones de acción en ubicación actual\n  const [showActionsForLocation, setShowActionsForLocation] = useState(false);\n\n  // Estado para guardar las coordenadas y datos de la ubicación actual del mapa\n  const [currentLocation, setCurrentLocation] = useState<{\n    lng: number;\n    lat: number;\n    locationName?: string;\n    locationAddress?: string;\n  } | null>(null);\n\n  // Estado para indicar si estamos detectando la ubicación\n  const [isDetectingLocation, setIsDetectingLocation] = useState(false);\n\n  // Function to get user's current location for distance filtering\n  const detectUserLocation = async () => {\n    if (isDetectingLocation) return currentLocation; // Evitar múltiples detecciones simultáneas\n    \n    setIsDetectingLocation(true);\n    console.log(\"🌍 Detectando ubicación del usuario...\");\n    \n    if (navigator.geolocation) {\n      try {\n        const position = await new Promise<GeolocationPosition>((resolve, reject) => {\n          navigator.geolocation.getCurrentPosition(\n            resolve, \n            reject, \n            { \n              enableHighAccuracy: true, \n              timeout: 10000, \n              maximumAge: 300000 // Cache for 5 minutes\n            }\n          );\n        });\n\n        const userLocation = {\n          lat: position.coords.latitude,\n          lng: position.coords.longitude,\n          locationName: \"Tu ubicación actual\",\n          locationAddress: \"Ubicación detectada automáticamente\"\n        };\n\n        setCurrentLocation(userLocation);\n        console.log(\"🌍 Ubicación detectada exitosamente:\", userLocation);\n        \n        // Center map on user location if map is available\n        if (mapRef.current) {\n          mapRef.current.flyTo({\n            center: [userLocation.lng, userLocation.lat],\n            zoom: 14,\n            duration: 1500\n          });\n        }\n\n        setIsDetectingLocation(false);\n        return userLocation;\n      } catch (error) {\n        console.warn(\"🌍 Could not detect user location:\", error);\n        \n        // Fallback to default location (Córdoba, Argentina)\n        const fallbackLocation = {\n          lat: -31.4201,\n          lng: -64.1888,\n          locationName: \"Córdoba, Argentina\",\n          locationAddress: \"Ubicación por defecto\"\n        };\n        \n        setCurrentLocation(fallbackLocation);\n        console.log(\"🌍 Usando ubicación por defecto:\", fallbackLocation);\n        setIsDetectingLocation(false);\n        return fallbackLocation;\n      }\n    } else {\n      console.warn(\"🌍 Geolocation is not supported by this browser\");\n      setIsDetectingLocation(false);\n      return null;\n    }\n  };\n\n  // Función para calcular la distancia entre dos puntos de coordenadas en km (fórmula de Haversine)\n  const calculateDistance = (\n    lat1: number,\n    lon1: number,\n    lat2: number,\n    lon2: number,\n  ): number => {\n    const R = 6371; // Radio de la Tierra en km\n    const dLat = (lat2 - lat1) * (Math.PI / 180);\n    const dLon = (lon2 - lon1) * (Math.PI / 180);\n    const a =\n      Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n      Math.cos(lat1 * (Math.PI / 180)) *\n        Math.cos(lat2 * (Math.PI / 180)) *\n        Math.sin(dLon / 2) *\n        Math.sin(dLon / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    const distance = R * c; // Distancia en km\n    return distance;\n  };\n\n  // Estado para guardar eventos filtrados por una ubicación específica\n  const [locationFilteredEvents, setLocationFilteredEvents] = useState<\n    EventWithRelations[]\n  >([]);\n\n  // Estados para los filtros del panel de eventos\n  const [selectedGender, setSelectedGender] = useState<string>(\"todos\");\n  const [selectedCategory, setSelectedCategory] = useState<string>(\"all\");\n  const [selectedDistance, setSelectedDistance] = useState<number>(100); // Default to 100km for \"all\" events\n  const [selectedDateFilter, setSelectedDateFilter] = useState<string>(\"all\");\n\n  // Usar los eventos proporcionados como props, o usar el hook useEvents para actualizaciones en tiempo real\n  const { events: eventsFromHook, isLoading, error } = useEvents();\n\n  // Usar eventos de props si existen, o los obtenidos del hook\n  const events: EventWithRelations[] = (propsEvents || eventsFromHook || []) as EventWithRelations[];\n\n  // Función para aplicar todos los filtros a una lista de eventos\n  const applyEventFilters = (eventsToFilter: EventWithRelations[], referenceLocation?: { lat: number; lng: number }) => {\n    return eventsToFilter.filter((event: EventWithRelations) => {\n      // Filtro por categoría\n      if (selectedCategory !== \"all\" && event.category !== selectedCategory) {\n        return false;\n      }\n\n      // Filtro por distancia (solo si hay ubicación de referencia)\n      if (referenceLocation) {\n        const eventLat = typeof event.latitude === \"string\" ? parseFloat(event.latitude) : event.latitude;\n        const eventLng = typeof event.longitude === \"string\" ? parseFloat(event.longitude) : event.longitude;\n        \n        if (!isNaN(eventLat) && !isNaN(eventLng)) {\n          const distance = calculateDistance(referenceLocation.lat, referenceLocation.lng, eventLat, eventLng);\n          if (distance > selectedDistance) {\n            return false;\n          }\n        }\n      }\n\n      // Filtro por fecha\n      if (selectedDateFilter !== \"all\") {\n        const eventDate = new Date(event.date);\n        const now = new Date();\n        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n        const tomorrow = new Date(today);\n        tomorrow.setDate(tomorrow.getDate() + 1);\n\n        switch (selectedDateFilter) {\n          case \"today\":\n            if (eventDate < today || eventDate >= tomorrow) return false;\n            break;\n          case \"tomorrow\":\n            const dayAfterTomorrow = new Date(tomorrow);\n            dayAfterTomorrow.setDate(dayAfterTomorrow.getDate() + 1);\n            if (eventDate < tomorrow || eventDate >= dayAfterTomorrow) return false;\n            break;\n          case \"weekend\":\n            const dayOfWeek = eventDate.getDay();\n            if (dayOfWeek !== 0 && dayOfWeek !== 6) return false; // 0 = Sunday, 6 = Saturday\n            break;\n          case \"week\":\n            const weekEnd = new Date(today);\n            weekEnd.setDate(weekEnd.getDate() + 7);\n            if (eventDate < today || eventDate >= weekEnd) return false;\n            break;\n          case \"month\":\n            const monthEnd = new Date(today.getFullYear(), today.getMonth() + 1, 1);\n            if (eventDate < today || eventDate >= monthEnd) return false;\n            break;\n          case \"next_months\":\n            const nextMonthsEnd = new Date(today);\n            nextMonthsEnd.setMonth(nextMonthsEnd.getMonth() + 3); // Next 3 months\n            if (eventDate < today || eventDate >= nextMonthsEnd) return false;\n            break;\n        }\n      }\n\n      // Por ahora, el filtro de género solo devuelve true (requiere datos adicionales en la base de datos)\n      // En el futuro, aquí se podría filtrar por el género del organizador o tipo de evento\n      \n      return true;\n    });\n  };\n\n  // Efecto para detectar ubicación automáticamente al cargar la aplicación\n  useEffect(() => {\n    const autoDetectLocation = async () => {\n      if (!currentLocation && !isDetectingLocation) {\n        console.log(\"🌍 Iniciando detección automática de ubicación...\");\n        try {\n          await detectUserLocation();\n        } catch (error) {\n          console.warn(\"🌍 Error en detección automática:\", error);\n        }\n      }\n    };\n\n    // Ejecutar con un pequeño delay para permitir que la UI cargue primero\n    const timer = setTimeout(autoDetectLocation, 1000);\n    return () => clearTimeout(timer);\n  }, []); // Solo ejecutar una vez al montar el componente\n\n  // Efecto para aplicar filtros automáticamente cuando cambien\n  useEffect(() => {\n    if (currentLocation && events && events.length > 0) {\n      // Buscar eventos que coincidan con la ubicación actual (incluyendo por nombre o cercanía)\n      let baseEvents = events.filter((event: EventWithRelations) => {\n        if (currentLocation.locationName) {\n          const placeName = currentLocation.locationName.toLowerCase();\n          const nameMatch =\n            event.title.toLowerCase().includes(placeName) ||\n            (event.description && event.description.toLowerCase().includes(placeName)) ||\n            (event.locationName && event.locationName.toLowerCase().includes(placeName));\n\n          const eventLat = typeof event.latitude === \"string\" ? parseFloat(event.latitude) : event.latitude;\n          const eventLng = typeof event.longitude === \"string\" ? parseFloat(event.longitude) : event.longitude;\n          let distanceMatch = false;\n\n          if (!isNaN(eventLat) && !isNaN(eventLng)) {\n            const distance = calculateDistance(currentLocation.lat, currentLocation.lng, eventLat, eventLng);\n            distanceMatch = distance <= selectedDistance;\n          }\n\n          return nameMatch || distanceMatch;\n        }\n        return false;\n      });\n\n      // Aplicar filtros adicionales\n      const filteredEvents = applyEventFilters(baseEvents, currentLocation);\n      setLocationFilteredEvents(filteredEvents);\n    }\n  }, [selectedGender, selectedCategory, selectedDistance, selectedDateFilter, currentLocation, events]);\n\n  // Map mode state (2D or 3D)\n  const [is3DMode, setIs3DMode] = useState(true);\n\n  // Snap Map 3D mode (new 3D style)\n  const [isSnapMap3D, setIsSnapMap3D] = useState(false);\n\n  // Map style state (satellite or standard)\n  const [isSatelliteMode, setIsSatelliteMode] = useState(false);\n\n  // Estado para controlar si mostrar etiquetas basado en zoom - INICIALIZADO CORRECTAMENTE\n  const [showEventLabels, setShowEventLabels] = useState(false);\n\n  // Controlador de estado persistente del mapa - guarda el estado actual del mapa\n  // para garantizar la persistencia entre cambios de modo\n  const mapStateRef = useRef({\n    style: \"standard\", // 'standard', 'satellite', 'dark'\n    is3D: true,\n    currentZoom: 13,\n    currentCenter: { lng: -64.185, lat: -31.428 }, // Centrado en Córdoba, Argentina\n    currentBearing: 0,\n    currentPitch: 45,\n  });\n\n  // Map configuration panel visibility\n  const [configPanelVisible, setConfigPanelVisible] = useState(false);\n\n  // Notification state\n  const [showNotifications, setShowNotifications] = useState(false);\n  const [notificationCount, setNotificationCount] = useState(0);\n\n  // Map configuration state\n  const [mapConfig, setMapConfig] = useState<MapConfigOptions>({\n    showPlaceLabels: true,\n    showRoadLabels: true,\n    showPointOfInterestLabels: true,\n    showTransitLabels: true,\n    show3dObjects: true,\n    theme: \"default\" as unknown as MapTheme,\n    lightPreset: \"day\" as LightPreset,\n    font: \"default\" as unknown as MapFont,\n    useAutoLightPreset: true,\n  });\n\n  const { toast } = useToast();\n  const queryClient = useQueryClient();\n  const { setMapInstance, saveCameraState, clearMapInstance } = useMap();\n  const mapContainerRef = useRef<HTMLDivElement>(null);\n  const mapRef = useRef<mapboxgl.Map | null>(null);\n\n\n  // Function to handle event selection from 3D Snap Map\n  const handleEventSelect = (eventId: string, coordinates?: [number, number]) => {\n    const event = mapEvents.find(e => e.id.toString() === eventId);\n    if (event) {\n      // Always activate focused mode when event is selected\n      setIsFocusedMode(true);\n      \n      // Format event data like in the existing click handlers\n      const formattedEvent = {\n        ...event,\n        latitude: typeof event.latitude === \"string\" ? parseFloat(event.latitude) : event.latitude,\n        longitude: typeof event.longitude === \"string\" ? parseFloat(event.longitude) : event.longitude,\n      };\n      onEventSelect(formattedEvent);\n    }\n  };\n  const markersRef = useRef<mapboxgl.Marker[]>([]);\n  const popupsRef = useRef<mapboxgl.Popup[]>([]);\n  // Removed 3D marker manager ref - only using 2D markers\n\n  // Se eliminó el estado para el panel de detalles del evento que ya no se usa\n\n  // Escuchar eventos personalizados showEventDetails y editEventFromMap\n  useEffect(() => {\n    // Función que maneja el evento showEventDetails (para ver detalles)\n    const handleShowEventDetails = (e: any) => {\n      // Acceder de forma segura al eventId desde el detalle del evento\n      const eventId = e?.detail?.eventId;\n      console.log(\n        \"Evento personalizado recibido: showEventDetails para el evento ID:\",\n        eventId,\n      );\n\n      if (eventId) {\n        // Encontrar el evento por su ID\n        const eventToShow = events.find((event) => event.id === eventId);\n        if (eventToShow) {\n          // Activate focused mode when event is selected\n          setIsFocusedMode(true);\n          // Solo pasar el evento al callback onEventSelect para que se muestre en la vista\n          onEventSelect(eventToShow);\n        } else {\n          console.error(\"No se encontró el evento con ID:\", eventId);\n        }\n      }\n    };\n\n    // Función que maneja el evento editEventFromMap (para editar evento desde el mapa)\n    const handleEditEventFromMap = (e: any) => {\n      // Acceder de forma segura al eventId desde el detalle del evento\n      const eventId = e?.detail?.eventId;\n      console.log(\n        \"Evento personalizado recibido: editEventFromMap para el evento ID:\",\n        eventId,\n      );\n\n      if (eventId) {\n        // Encontrar el evento por su ID\n        const eventToEdit = events.find((event) => event.id === eventId);\n        if (eventToEdit) {\n          // Abrir el panel de edición\n          setEditingEventId(eventId);\n          setEditSheetVisible(true);\n        } else {\n          console.error(\"No se encontró el evento con ID:\", eventId);\n        }\n      }\n    };\n\n    // Función para manejar actualizaciones de eventos\n    const handleEventUpdated = (e: any) => {\n      const eventData = e?.detail?.data;\n      const eventId = e?.detail?.eventId;\n\n      if (eventId && eventData) {\n        console.log(\"Evento actualizado detectado en MapView:\", eventId);\n\n        // Forzar una actualización completa de los marcadores\n        if (mapRef.current) {\n          // Remover todos los marcadores actuales\n          markersRef.current.forEach((marker) => marker.remove());\n          popupsRef.current.forEach((popup) => popup.remove());\n          markersRef.current = [];\n          popupsRef.current = [];\n\n          // Removed 3D marker cleanup - only using 2D markers\n\n          // Re-crear los marcadores con los datos actualizados\n          setTimeout(() => {\n            // Volver a cargar los marcadores para todos los eventos filtrados\n            console.log(\n              \"Actualizando marcadores con datos nuevos para los eventos\",\n            );\n\n            // Invalidar la consulta de eventos para forzar una recarga de datos\n            queryClient.invalidateQueries({ queryKey: [\"/api/events\"] });\n            console.log(\n              \"Marcadores actualizados después de la edición del evento:\",\n              eventId,\n            );\n          }, 100);\n        }\n      }\n    };\n\n    // Agregar event listeners para nuestros eventos personalizados\n    document.addEventListener(\"showEventDetails\", handleShowEventDetails);\n    document.addEventListener(\"editEventFromMap\", handleEditEventFromMap);\n    window.addEventListener(\"event-updated\", handleEventUpdated);\n\n    // Cleanup: eliminar los event listeners cuando el componente se desmonte\n    return () => {\n      document.removeEventListener(\"showEventDetails\", handleShowEventDetails);\n      document.removeEventListener(\"editEventFromMap\", handleEditEventFromMap);\n      window.removeEventListener(\"event-updated\", handleEventUpdated);\n    };\n  }, [events, onEventSelect]);\n\n  // Fetch notification count periodically\n  useEffect(() => {\n    if (user) {\n      const fetchNotificationCount = async () => {\n        try {\n          const response = await apiRequest(\"GET\", \"/api/notifications/count\");\n          if (response.ok) {\n            const data = await response.json();\n            setNotificationCount(data.count || 0);\n          }\n        } catch (error) {\n          console.error(\"Error fetching notification count:\", error);\n        }\n      };\n\n      fetchNotificationCount();\n      \n      // Poll for new notifications every 30 seconds\n      const interval = setInterval(fetchNotificationCount, 30000);\n      return () => clearInterval(interval);\n    }\n  }, [user]);\n\n  // IMPORTANT: NO filtering for the main map view\n  // The main map should always show ALL events\n  const mapEvents = events; // All events for the map\n  \n  // Separate filtering logic ONLY for the \"Descubrir eventos\" panel\n  const getFilteredEventsForPanel = () => {\n    return events.filter((event: EventWithRelations) => {\n      // Search filter (only applied in panel)\n      if (\n        searchTerm &&\n        !event.title.toLowerCase().includes(searchTerm.toLowerCase())\n      ) {\n        return false;\n      }\n\n      // Category filter from modal (only applied in panel)\n      if (selectedCategory !== \"all\" && event.category !== selectedCategory) {\n        return false;\n      }\n\n      // Distance filter (only applied in panel)\n      // Only apply distance filter if user has selected a distance < 100km and we have location\n      if (selectedDistance < 100 && currentLocation) {\n        const eventLat = typeof event.latitude === \"string\" ? parseFloat(event.latitude) : event.latitude;\n        const eventLng = typeof event.longitude === \"string\" ? parseFloat(event.longitude) : event.longitude;\n        \n        // Validate coordinates are valid numbers\n        if (!isNaN(eventLat) && !isNaN(eventLng) && \n            isFinite(eventLat) && isFinite(eventLng) &&\n            isFinite(currentLocation.lat) && isFinite(currentLocation.lng)) {\n          \n          const distance = calculateDistance(currentLocation.lat, currentLocation.lng, eventLat, eventLng);\n          \n          // Debug log for distance filtering (only in development)\n          if (process.env.NODE_ENV === 'development') {\n            console.log(`🎯 Distance filter: Event \"${event.title}\" is ${distance.toFixed(2)}km away (limit: ${selectedDistance}km)`);\n          }\n          \n          if (distance > selectedDistance) {\n            return false;\n          }\n        } else {\n          // If coordinates are invalid, log a warning but don't filter out the event\n          if (process.env.NODE_ENV === 'development') {\n            console.warn(`⚠️ Invalid coordinates for event \"${event.title}\": Event(${eventLat}, ${eventLng}), User(${currentLocation.lat}, ${currentLocation.lng})`);\n          }\n        }\n      }\n\n      // Date filter from modal (only applied in panel)\n      if (selectedDateFilter !== \"all\") {\n        const eventDate = new Date(event.date);\n        const now = new Date();\n        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n        const tomorrow = new Date(today);\n        tomorrow.setDate(tomorrow.getDate() + 1);\n\n        switch (selectedDateFilter) {\n          case \"today\":\n            if (eventDate < today || eventDate >= tomorrow) return false;\n            break;\n          case \"tomorrow\":\n            const dayAfterTomorrow = new Date(tomorrow);\n            dayAfterTomorrow.setDate(dayAfterTomorrow.getDate() + 1);\n            if (eventDate < tomorrow || eventDate >= dayAfterTomorrow) return false;\n            break;\n          case \"weekend\":\n            const dayOfWeek = eventDate.getDay();\n            if (dayOfWeek !== 0 && dayOfWeek !== 6) return false; // 0 = Sunday, 6 = Saturday\n            break;\n          case \"week\":\n            const weekEnd = new Date(today);\n            weekEnd.setDate(weekEnd.getDate() + 7);\n            if (eventDate < today || eventDate >= weekEnd) return false;\n            break;\n          case \"month\":\n            const monthEnd = new Date(today.getFullYear(), today.getMonth() + 1, 1);\n            if (eventDate < today || eventDate >= monthEnd) return false;\n            break;\n          case \"next_months\":\n            const nextMonthsEnd = new Date(today);\n            nextMonthsEnd.setMonth(nextMonthsEnd.getMonth() + 3); // Next 3 months\n            if (eventDate < today || eventDate >= nextMonthsEnd) return false;\n            break;\n        }\n      }\n\n      // Gender filter from modal (only applied in panel)\n      if (selectedGender !== \"todos\") {\n        // Filter by gender preference of the event\n        if (selectedGender === \"men\" && event.gender_preference !== \"men\") {\n          return false;\n        }\n        if (selectedGender === \"women\" && event.gender_preference !== \"women\") {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  };\n\n  // Estado para controlar el menú contextual\n  const [contextMenu, setContextMenu] = useState<{\n    visible: boolean;\n    x: number;\n    y: number;\n    lngLat: mapboxgl.LngLat | null;\n  }>({\n    visible: false,\n    x: 0,\n    y: 0,\n    lngLat: null,\n  });\n\n  // Efecto principal para manejar los clics en el mapa (siempre activo)\n  useEffect(() => {\n    // Esta función se ejecutará cada vez que el usuario haga clic en el mapa\n    function handleMapClick(e: mapboxgl.MapMouseEvent) {\n      console.log(\n        \"Clic en el mapa detectado\",\n        locationMode ? \"en modo ubicación\" : \"en modo normal\",\n      );\n\n      // IMPORTANTE: Activar el modo de ubicación automáticamente cuando se hace clic en el mapa\n      // Esto permite que el menú contextual aparezca sin tener que hacer clic en \"Crear un evento\" primero\n      if (!locationMode) {\n        console.log(\n          \"Activando modo de ubicación automáticamente al hacer clic en el mapa\",\n        );\n        setLocationMode(true);\n      }\n\n      // Siempre crear un marcador y mostrar el menú contextual al hacer clic\n      if (mapRef.current) {\n        console.log(\"Abriendo menú contextual en\", e.lngLat);\n\n        // Limpiar todo antes de empezar - esto es crucial para evitar marcadores duplicados\n        closeContextMenu();\n\n        // Remove existing temporary marker if any (extra comprobación para estar seguros)\n        if (tempLocationMarker) {\n          try {\n            tempLocationMarker.remove();\n            setTempLocationMarker(null);\n          } catch (err) {\n            console.error(\"Error al eliminar marcador temporal:\", err);\n          }\n        }\n\n        // Crear marcador con forma de gota estilo Google Maps pero amarillo\n        const markerElement = document.createElement(\"div\");\n        markerElement.innerHTML = `\n          <svg width=\"25\" height=\"41\" viewBox=\"0 0 25 41\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n            <path d=\"M12.5 0C5.596 0 0 5.596 0 12.5C0 21.563 12.5 41 12.5 41S25 21.563 25 12.5C25 5.596 19.404 0 12.5 0Z\" fill=\"#FFEB3B\"/>\n            <path d=\"M12.5 0C5.596 0 0 5.596 0 12.5C0 21.563 12.5 41 12.5 41S25 21.563 25 12.5C25 5.596 19.404 0 12.5 0Z\" stroke=\"#F57C00\" stroke-width=\"1\"/>\n            <circle cx=\"12.5\" cy=\"12.5\" r=\"4\" fill=\"white\"/>\n          </svg>\n        `;\n        markerElement.style.width = \"25px\";\n        markerElement.style.height = \"41px\";\n        markerElement.style.position = \"relative\";\n        markerElement.style.zIndex = \"5\";\n        markerElement.style.cursor = \"pointer\";\n\n        try {\n          // Create new marker with custom element - usar las coordenadas exactas\n          const newMarker = new mapboxgl.Marker({\n            element: markerElement,\n            draggable: true,\n          })\n            .setLngLat([e.lngLat.lng, e.lngLat.lat])\n            .addTo(mapRef.current);\n\n          // Set marker to state\n          setTempLocationMarker(newMarker);\n        } catch (err) {\n          console.error(\"Error al crear marcador:\", err);\n        }\n\n        // Limpiar cualquier menú contextual existente\n        setContextMenu({\n          visible: false,\n          x: 0,\n          y: 0,\n          lngLat: null,\n        });\n\n        // Mostrar nuevo menú contextual\n        // Un pequeño retraso para evitar problemas visuales\n        setTimeout(() => {\n          setContextMenu({\n            visible: true,\n            x: e.point.x,\n            y: e.point.y,\n            lngLat: e.lngLat,\n          });\n        }, 10);\n\n        // Usar ambos servicios en paralelo para obtener resultados más completos\n        const mapboxPromise = reverseGeocode(e.lngLat.lng, e.lngLat.lat);\n        const googlePromise = googleReverseGeocode(e.lngLat.lng, e.lngLat.lat);\n        const nearbyPlacesPromise = findNearbyPlaces(\n          e.lngLat.lat,\n          e.lngLat.lng,\n          100,\n        );\n\n        // Procesar todos los resultados\n        Promise.all([mapboxPromise, googlePromise, nearbyPlacesPromise])\n          .then(([mapboxAddress, googleAddress, nearbyPlaces]) => {\n            console.log(\"Geocode results:\", { mapboxAddress, googleAddress });\n            console.log(\"Nearby places:\", nearbyPlaces);\n\n            // Extraer nombre del lugar - primero comprobar si hay establecimientos cercanos\n            let locationName;\n            let address;\n\n            // Prioridad 1: Si encontramos lugares importantes (parques, plazas, etc.) usar esos nombres\n            // Identificar posibles lugares importantes (parques, puntos de interés, etc.)\n            const importantPlaces = Array.isArray(nearbyPlaces)\n              ? nearbyPlaces.filter((place) =>\n                  // Buscar parques, puntos de interés, atracciones, locales marcados, etc.\n                  [\n                    \"park\",\n                    \"point_of_interest\",\n                    \"establishment\",\n                    \"premise\",\n                    \"neighborhood\",\n                    \"natural_feature\",\n                  ].some((type) => place.types && place.types.includes(type)),\n                )\n              : [];\n\n            if (importantPlaces.length > 0) {\n              const place = importantPlaces[0]; // Usar el lugar más relevante\n              locationName = place.name || \"Lugar del evento\";\n\n              // Para la dirección completa, usar el resultado de geocodificación inversa\n              if (\n                googleAddress &&\n                googleAddress !== \"Dirección no encontrada\" &&\n                googleAddress !== \"Error al obtener dirección\"\n              ) {\n                address = googleAddress;\n              } else {\n                address = mapboxAddress;\n              }\n\n              console.log(\"Usando nombre de lugar importante:\", locationName);\n            }\n            // Prioridad 2: Cualquier establecimiento cercano\n            else if (Array.isArray(nearbyPlaces) && nearbyPlaces.length > 0) {\n              const place = nearbyPlaces[0];\n              locationName = place.name || \"Lugar del evento\";\n\n              // Para la dirección completa, usar el resultado de geocodificación inversa\n              if (\n                googleAddress &&\n                googleAddress !== \"Dirección no encontrada\" &&\n                googleAddress !== \"Error al obtener dirección\"\n              ) {\n                address = googleAddress;\n              } else {\n                address = mapboxAddress;\n              }\n\n              console.log(\n                \"Usando nombre de establecimiento cercano:\",\n                locationName,\n              );\n            }\n            // Prioridad 3: Usar los resultados de geocodificación inversa de Google\n            else if (\n              googleAddress &&\n              googleAddress !== \"Dirección no encontrada\" &&\n              googleAddress !== \"Error al obtener dirección\"\n            ) {\n              // Buscar un nombre significativo que no sea solo una dirección\n              // Primero verificar si hay algo como \"Parque X\" o \"Plaza Y\" en la dirección\n              const specialPlaceMatch = googleAddress.match(\n                /(Parque|Plaza|Museo|Estadio|Monumento|Jardín|Biblioteca|Universidad|Teatro|Centro)\\s+([^,]+)/i,\n              );\n\n              if (specialPlaceMatch) {\n                // Usamos el nombre del lugar especial si lo encontramos\n                locationName = specialPlaceMatch[0];\n              } else {\n                // Si no, usamos la primera parte de la dirección\n                const placeNameMatch = googleAddress.match(/^([^,]+)/);\n                locationName = placeNameMatch\n                  ? placeNameMatch[0]\n                  : \"Lugar del evento\";\n              }\n\n              address = googleAddress;\n              console.log(\"Usando dirección de Google:\", address);\n            }\n            // Última opción: MapBox como fallback\n            else {\n              // Buscar un nombre significativo que no sea solo una dirección\n              const specialPlaceMatch = mapboxAddress.match(\n                /(Parque|Plaza|Museo|Estadio|Monumento|Jardín|Biblioteca|Universidad|Teatro|Centro)\\s+([^,]+)/i,\n              );\n\n              if (specialPlaceMatch) {\n                // Usamos el nombre del lugar especial si lo encontramos\n                locationName = specialPlaceMatch[0];\n              } else {\n                // Si no, usamos la primera parte de la dirección\n                const placeNameMatch = mapboxAddress.match(/^([^,]+)/);\n                locationName = placeNameMatch\n                  ? placeNameMatch[0]\n                  : \"Lugar del evento\";\n              }\n\n              address = mapboxAddress;\n              console.log(\"Usando dirección de MapBox (fallback):\", address);\n            }\n\n            // Store location data\n            const locationData = {\n              latitude: e.lngLat.lat,\n              longitude: e.lngLat.lng,\n              locationAddress: address,\n              locationName: locationName,\n            };\n\n            console.log(\"Guardando datos de ubicación:\", locationData);\n            setTempLocationData(locationData);\n\n            toast({\n              title: \"Ubicación seleccionada\",\n              description: `${locationName}`,\n            });\n          })\n          .catch((error) => {\n            console.error(\"Error getting address or nearby places:\", error);\n            toast({\n              title: \"Error\",\n              description:\n                \"No se pudo obtener la dirección. Por favor, intenta de nuevo.\",\n              variant: \"destructive\",\n            });\n          });\n      }\n    }\n\n    if (mapRef.current) {\n      console.log(\"Configurando manejador de clics en el mapa\");\n\n      // Primero eliminar cualquier manejador existente para evitar duplicados\n      mapRef.current.off(\"click\", handleMapClick);\n\n      // Luego añadir el manejador de clics\n      mapRef.current.on(\"click\", handleMapClick);\n\n      // Return cleanup function\n      return () => {\n        if (mapRef.current) {\n          console.log(\"Eliminando manejador de clics del mapa\");\n          mapRef.current.off(\"click\", handleMapClick);\n        }\n      };\n    }\n  }, [locationMode, toast]);\n\n  // Efecto mejorado para evitar flickering - solo actualizar cuando cambien condiciones reales\n  useEffect(() => {\n    if (!mapRef.current) return;\n\n    let lastZoom = mapRef.current.getZoom();\n    let lastShowState = lastZoom >= 15;\n\n    const handleZoomEnd = () => {\n      if (mapRef.current) {\n        const currentZoom = mapRef.current.getZoom();\n        const shouldShow = currentZoom >= 15;\n\n        // Solo actualizar si realmente cambió el estado\n        if (shouldShow !== lastShowState) {\n          console.log(\n            `🔍 Zoom check: ${currentZoom.toFixed(1)} >= 15? ${shouldShow}`,\n          );\n          setShowEventLabels(shouldShow);\n          lastShowState = shouldShow;\n        }\n        lastZoom = currentZoom;\n      }\n    };\n\n    // Solo escuchar eventos de zoom, no verificar periódicamente\n    mapRef.current.on(\"zoomend\", handleZoomEnd);\n    mapRef.current.on(\"moveend\", handleZoomEnd);\n\n    // Verificación inicial\n    handleZoomEnd();\n\n    return () => {\n      if (mapRef.current) {\n        mapRef.current.off(\"zoomend\", handleZoomEnd);\n        mapRef.current.off(\"moveend\", handleZoomEnd);\n      }\n    };\n  }, []);\n\n  // Initialize map on component mount and center on user's location\n  useEffect(() => {\n    if (!mapContainerRef.current || mapRef.current) return;\n\n    console.log(\"Inicializando mapa y configurando eventos globales\");\n\n    // Initialize the map with default config - use 3D mode by default\n    mapRef.current = initializeMap(mapContainerRef.current, true);\n    \n    // Configure map instance in context\n    console.log(\"🗺️ MapView: Configurando mapa en contexto...\");\n    setMapInstance(mapRef.current);\n    console.log(\"🗺️ MapView: Mapa configurado en contexto\");\n\n    // Initialize 3D marker manager\n    // Removed 3D marker manager initialization - only using 2D markers\n\n    // Add controls\n    mapRef.current.addControl(new mapboxgl.NavigationControl(), \"top-right\");\n\n    // Sistema de etiquetas dinámicas con zoom - MEJORADO Y PERFECTO\n    let zoomTimeout: NodeJS.Timeout;\n    const handleZoomChange = () => {\n      if (!mapRef.current) return;\n\n      const currentZoom = mapRef.current.getZoom();\n      const shouldShowLabels = currentZoom >= 15;\n\n      console.log(\n        `🔍 Zoom check: ${currentZoom.toFixed(1)} >= 15? ${shouldShowLabels}`,\n      );\n\n      clearTimeout(zoomTimeout);\n      zoomTimeout = setTimeout(() => {\n        // Forzar actualización del estado SIEMPRE\n        console.log(\n          `📊 Before update: current state unknown, should be ${shouldShowLabels}`,\n        );\n        setShowEventLabels(shouldShowLabels);\n        console.log(\n          `🎯 FORCED state to: ${shouldShowLabels ? \"VISIBLE\" : \"HIDDEN\"}`,\n        );\n      }, 100); // Respuesta más rápida\n    };\n\n    // Múltiples eventos para captura completa\n    mapRef.current.on(\"zoom\", handleZoomChange);\n    mapRef.current.on(\"zoomend\", handleZoomChange);\n    mapRef.current.on(\"move\", handleZoomChange);\n\n    // Configuración inicial de zoom con múltiples verificaciones\n    const initializeLabels = () => {\n      if (mapRef.current) {\n        const initialZoom = mapRef.current.getZoom();\n        const shouldShow = initialZoom >= 15;\n        console.log(\n          `📍 Initial setup: zoom ${initialZoom.toFixed(1)} → labels ${shouldShow ? \"ON\" : \"OFF\"}`,\n        );\n        setShowEventLabels(shouldShow);\n      }\n    };\n\n    // Múltiples intentos para asegurar inicialización correcta\n    setTimeout(initializeLabels, 100);\n    setTimeout(initializeLabels, 300);\n    setTimeout(initializeLabels, 600);\n\n    // Configurar el manejador de clics directamente en la inicialización del mapa\n    if (mapRef.current) {\n      // Este manejador de clics estará activo siempre, independientemente del modo\n      mapRef.current.on(\"click\", (e) => {\n        console.log(\"Clic en el mapa detectado\");\n\n        // SOLUCIÓN MÁS RADICAL: Limpieza completa del DOM\n        // 1. Eliminar todos los marcadores del DOM\n        const existingMarkers = document.querySelectorAll(\".mapboxgl-marker\");\n        console.log(`Limpiando ${existingMarkers.length} marcadores del DOM`);\n\n        // 2. Eliminar manualmente todos los marcadores encontrados\n        existingMarkers.forEach((marker) => {\n          // Solo eliminamos si no es un marcador de evento (que tiene distintas clases/estilos)\n          if (\n            !marker.classList.contains(\"custom-marker-container\") &&\n            !marker.querySelector(\".custom-marker-container\")\n          ) {\n            marker.remove();\n          }\n        });\n\n        // 3. Limpiar también el estado y referencias\n        if (tempLocationMarker) {\n          try {\n            tempLocationMarker.remove();\n          } catch (err) {\n            console.error(\"Error al eliminar marcador de referencia:\", err);\n          } finally {\n            setTempLocationMarker(null);\n          }\n        }\n\n        // Si estamos en modo de ubicación, usar el comportamiento específico\n        if (locationMode) {\n          console.log(\"Clic en el mapa detectado en modo de ubicación\");\n\n          // Crear un elemento DOM personalizado para garantizar visibilidad\n          const markerElement = document.createElement(\"div\");\n          markerElement.id = `temp-marker-${Date.now()}`;\n          markerElement.className = \"temp-location-marker\"; // Clase para identificación\n          markerElement.innerHTML = `\n            <svg width=\"25\" height=\"41\" viewBox=\"0 0 25 41\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n              <path d=\"M12.5 0C5.596 0 0 5.596 0 12.5C0 21.563 12.5 41 12.5 41S25 21.563 25 12.5C25 5.596 19.404 0 12.5 0Z\" fill=\"#FFEB3B\"/>\n              <path d=\"M12.5 0C5.596 0 0 5.596 0 12.5C0 21.563 12.5 41 12.5 41S25 21.563 25 12.5C25 5.596 19.404 0 12.5 0Z\" stroke=\"#000000\" stroke-width=\"1\"/>\n              <circle cx=\"12.5\" cy=\"12.5\" r=\"4\" fill=\"white\"/>\n            </svg>\n          `;\n          markerElement.style.width = \"25px\";\n          markerElement.style.height = \"41px\";\n          markerElement.style.position = \"relative\";\n          markerElement.style.zIndex = \"5\";\n          markerElement.style.cursor = \"pointer\";\n\n          try {\n            // Crear un nuevo marcador visible en la posición del clic\n            const marker = new mapboxgl.Marker({\n              element: markerElement,\n              draggable: true,\n            })\n              .setLngLat([e.lngLat.lng, e.lngLat.lat])\n              .addTo(mapRef.current!);\n\n            setTempLocationMarker(marker);\n\n            console.log(\n              \"Nuevo marcador de ubicación creado:\",\n              markerElement.id,\n            );\n          } catch (err) {\n            console.error(\"Error al crear marcador en modo ubicación:\", err);\n          }\n\n          // Obtener información de la ubicación\n          // (Código existente para geocodificación inversa)\n          // ...\n        }\n        // Si no estamos en modo de ubicación, mostrar el menú contextual\n        else {\n          // Limpiar menú contextual existente\n          setContextMenu({\n            visible: false,\n            x: 0,\n            y: 0,\n            lngLat: null,\n          });\n\n          try {\n            // Crear un elemento DOM personalizado para el marcador\n            const markerElement = document.createElement(\"div\");\n            markerElement.id = `context-marker-${Date.now()}`;\n            markerElement.className = \"context-menu-marker\"; // Clase para identificación\n            markerElement.innerHTML = `\n              <svg width=\"25\" height=\"41\" viewBox=\"0 0 25 41\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n                <path d=\"M12.5 0C5.596 0 0 5.596 0 12.5C0 21.563 12.5 41 12.5 41S25 21.563 25 12.5C25 5.596 19.404 0 12.5 0Z\" fill=\"#FFEB3B\"/>\n                <path d=\"M12.5 0C5.596 0 0 5.596 0 12.5C0 21.563 12.5 41 12.5 41S25 21.563 25 12.5C25 5.596 19.404 0 12.5 0Z\" stroke=\"#000000\" stroke-width=\"1\"/>\n                <circle cx=\"12.5\" cy=\"12.5\" r=\"4\" fill=\"white\" stroke=\"#000000\" stroke-width=\"1\"/>\n              </svg>\n            `;\n            markerElement.style.width = \"25px\";\n            markerElement.style.height = \"41px\";\n            markerElement.style.position = \"relative\";\n            markerElement.style.zIndex = \"5\";\n            markerElement.style.cursor = \"pointer\";\n\n            // Crear nuevo marcador\n            const newMarker = new mapboxgl.Marker({\n              element: markerElement,\n              draggable: true,\n            })\n              .setLngLat([e.lngLat.lng, e.lngLat.lat])\n              .addTo(mapRef.current!);\n\n            // Guardar el marcador en el estado\n            setTempLocationMarker(newMarker);\n\n            console.log(\n              \"Nuevo marcador de menú contextual creado:\",\n              markerElement.id,\n            );\n          } catch (err) {\n            console.error(\"Error al crear marcador para menú contextual:\", err);\n          }\n\n          // Mostrar el menú contextual\n          setContextMenu({\n            visible: true,\n            x: e.point.x,\n            y: e.point.y,\n            lngLat: e.lngLat,\n          });\n\n          // Obtener información de la ubicación para que esté disponible\n          // aunque el usuario no haga clic en \"Crear evento aquí\"\n          const mapboxPromise = reverseGeocode(e.lngLat.lng, e.lngLat.lat);\n          const googlePromise = googleReverseGeocode(\n            e.lngLat.lng,\n            e.lngLat.lat,\n          );\n\n          Promise.all([mapboxPromise, googlePromise])\n            .then(([mapboxAddress, googleAddress]) => {\n              let locationName, address;\n\n              if (\n                googleAddress &&\n                googleAddress !== \"Dirección no encontrada\" &&\n                googleAddress !== \"Error al obtener dirección\"\n              ) {\n                const placeNameMatch = googleAddress.match(/^([^,]+)/);\n                locationName = placeNameMatch\n                  ? placeNameMatch[0]\n                  : \"Lugar del evento\";\n                address = googleAddress;\n              } else {\n                const placeNameMatch = mapboxAddress.match(/^([^,]+)/);\n                locationName = placeNameMatch\n                  ? placeNameMatch[0]\n                  : \"Lugar del evento\";\n                address = mapboxAddress;\n              }\n\n              // Guardar datos de ubicación\n              const locationData = {\n                latitude: e.lngLat.lat,\n                longitude: e.lngLat.lng,\n                locationAddress: address,\n                locationName: locationName,\n              };\n\n              setTempLocationData(locationData);\n            })\n            .catch((error) => {\n              console.error(\"Error al obtener dirección:\", error);\n            });\n        }\n      });\n    }\n\n    // Try to center on user's location automatically\n    navigator.geolocation.getCurrentPosition(\n      (position) => {\n        const { longitude, latitude } = position.coords;\n\n        // Set current location for distance filtering\n        setCurrentLocation({\n          lng: longitude,\n          lat: latitude,\n          locationName: \"Tu ubicación\",\n          locationAddress: \"Ubicación actual\"\n        });\n\n        if (mapRef.current) {\n          mapRef.current.setCenter([longitude, latitude]);\n          mapRef.current.setZoom(13);\n\n          // Crear un elemento DOM personalizado para el marcador de posición del usuario\n          const userMarkerElement = document.createElement(\"div\");\n          userMarkerElement.style.width = \"30px\";\n          userMarkerElement.style.height = \"30px\";\n          userMarkerElement.style.borderRadius = \"50%\";\n          userMarkerElement.style.backgroundColor = \"#1DA1F2\"; // Color azul Twitter\n          userMarkerElement.style.border = \"3px solid white\";\n          userMarkerElement.style.boxShadow = \"0 0 10px rgba(0, 0, 0, 0.5)\";\n\n          // Add a marker for the user's current position\n          new mapboxgl.Marker({\n            element: userMarkerElement,\n          })\n            .setLngLat([longitude, latitude])\n            .addTo(mapRef.current);\n\n          // Try to get the city name for a better user experience\n          reverseGeocode(longitude, latitude)\n            .then((address) => {\n              // Update current location with actual address\n              setCurrentLocation(prev => ({\n                ...prev!,\n                locationAddress: address || \"Ubicación actual\"\n              }));\n              \n              toast({\n                title: \"Ubicación detectada\",\n                description: `Te mostramos eventos cercanos a tu ubicación`,\n              });\n            })\n            .catch((err) => console.error(\"Error getting address:\", err));\n        }\n      },\n      (error) => {\n        console.warn(\"Error getting location:\", error);\n        // Fallback to default location (centered on a major city)\n        if (mapRef.current) {\n          // Center on Buenos Aires by default (more relevant for Spanish-speaking users)\n          mapRef.current.setCenter([-58.3816, -34.6037]);\n          mapRef.current.setZoom(12);\n        }\n      },\n      { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 },\n    );\n\n    return () => {\n      // Cleanup completo al desmontar componente\n      if (mapRef.current) {\n        console.log(\"🧹 Cleaning up map and event listeners\");\n\n        // Limpiar timeout de zoom si existe\n        if (zoomTimeout) {\n          clearTimeout(zoomTimeout);\n        }\n\n        // Remover event listeners específicos para zoom\n        try {\n          mapRef.current.off(\"zoom\", handleZoomChange);\n          mapRef.current.off(\"zoomend\", handleZoomChange);\n          mapRef.current.off(\"move\", handleZoomChange);\n        } catch (e) {\n          console.warn(\"Error removing zoom listeners:\", e);\n        }\n        // Ya que mapRef.current.remove() se encargará de limpiar todo\n\n        // Eliminar el mapa\n        mapRef.current.remove();\n        mapRef.current = null;\n      }\n\n      // Clear markers and popups\n      markersRef.current.forEach((marker) => marker.remove());\n      popupsRef.current.forEach((popup) => popup.remove());\n      markersRef.current = [];\n      popupsRef.current = [];\n      \n      // Clear map context\n      console.log(\"🗺️ MapView: Limpiando instancia del mapa del contexto\");\n      clearMapInstance();\n    };\n  }, []);\n\n  // Efecto para cerrar el menú contextual y limpiar marcadores temporales al hacer clic en cualquier parte de la aplicación\n  // que no sea el mapa o los botones de acción\n  useEffect(() => {\n    function handleClickOutside(e: MouseEvent) {\n      const target = e.target as Element;\n\n      // Comprobar si es un clic dentro del mapa\n      const isMapClick = target.closest(\".mapboxgl-canvas-container\");\n\n      // Comprobar si es un clic en los botones de acción\n      const isActionButton =\n        target.closest(\"button\") &&\n        (target.textContent?.includes(\"Buscar eventos aquí\") ||\n          target.textContent?.includes(\"Crear un evento aquí\") ||\n          target.textContent?.includes(\"Ver eventos cercanos\") ||\n          target.textContent?.includes(\"Crear evento aquí\"));\n\n      // Comprobar si es un clic en el menú contextual\n      const isContextMenuClick = target.closest(\".context-menu\");\n\n      // No cerrar el menú contextual si el clic fue en:\n      // - El propio menú contextual\n      // - Un botón dentro del menú\n      if (contextMenu.visible && !isMapClick && !isContextMenuClick) {\n        closeContextMenu();\n      }\n\n      // Limpiar el marcador temporal y ocultar botones de acción si el clic no fue en:\n      // - El mapa\n      // - Los botones de acción específicos\n      // - La barra de búsqueda\n      // - Controles del mapa\n      if (\n        showActionsForLocation &&\n        !isMapClick &&\n        !isActionButton &&\n        !target.closest(\".google-places-search\") &&\n        !target.closest(\".mapboxgl-ctrl\")\n      ) {\n        console.log(\n          \"Clic fuera de la ubicación seleccionada, ocultando botones de acción\",\n        );\n\n        // Ocultar botones de acciones específicas\n        setShowActionsForLocation(false);\n\n        // Limpiar el marcador temporal si existe\n        if (tempLocationMarker) {\n          tempLocationMarker.remove();\n          setTempLocationMarker(null);\n        }\n      }\n    }\n\n    document.addEventListener(\"click\", handleClickOutside);\n\n    return () => {\n      document.removeEventListener(\"click\", handleClickOutside);\n    };\n  }, [contextMenu.visible, showActionsForLocation, tempLocationMarker]);\n\n  // Add event markers when events, filters, or showEventLabels change\n  useEffect(() => {\n    if (!mapRef.current) return;\n\n    // Clear existing markers and popups\n    markersRef.current.forEach((marker) => marker.remove());\n    popupsRef.current.forEach((popup) => popup.remove());\n    markersRef.current = [];\n    popupsRef.current = [];\n\n    // Clear 3D markers if available\n    // Removed 3D marker clearing - only using 2D markers\n\n    // Show ALL events on the main map (no filtering)\n    const cordobaEvents = mapEvents.filter((event) => {\n      const lat =\n        typeof event.latitude === \"string\"\n          ? parseFloat(event.latitude)\n          : event.latitude;\n      return lat < 0; // Los eventos en Argentina tienen latitud negativa\n    });\n\n    // Add 3D markers in both 2D and 3D modes\n    // Removed 3D marker creation - only using 2D markers\n\n    // For 2D mode, add regular markers (also add these in 3D mode as fallback)\n    mapEvents.forEach((event: EventWithRelations) => {\n      if (!mapRef.current) return;\n\n      // Create custom React element for the marker\n      const el = document.createElement(\"div\");\n      el.className = \"custom-marker-container\";\n\n      // Unified media processing function\n      const getEventImageData = (event: EventWithRelations) => {\n        let hasImage = false;\n        let imageUrl = \"\";\n\n        // Priority 1: Main media URL (most reliable)\n        const mainMediaUrl =\n          (event as any).main_media_url || event.mainMediaUrl;\n        if (mainMediaUrl && mainMediaUrl.trim()) {\n          hasImage = true;\n          imageUrl = mainMediaUrl;\n          return { hasImage, imageUrl };\n        }\n\n        // Priority 2: Parse mediaItems JSON\n        try {\n          if (\n            event.mediaItems &&\n            event.mediaItems !== \"[]\" &&\n            event.mediaItems.trim()\n          ) {\n            const mediaItems = JSON.parse(event.mediaItems);\n            if (Array.isArray(mediaItems) && mediaItems.length > 0) {\n              // Find main image or first image\n              const mainImage =\n                mediaItems.find((item) => item.isMain && item.url) ||\n                mediaItems.find((item) => item.url);\n              if (mainImage?.url) {\n                hasImage = true;\n                imageUrl = mainImage.url;\n              }\n            }\n          }\n        } catch (e) {\n          console.error(\"Error parsing mediaItems for event:\", event.id, e);\n        }\n\n        return { hasImage, imageUrl };\n      };\n\n      const { hasImage: hasEventImage, imageUrl: eventImageUrl } =\n        getEventImageData(event);\n\n      // Render React component to the element with media data\n      const root = createRoot(el);\n      root.render(\n        <EventPin\n          category={event.category}\n          mainMediaUrl={hasEventImage ? eventImageUrl : undefined}\n          mainMediaType={hasEventImage ? \"photo\" : undefined}\n          eventTitle={event.title}\n          showLabel={showEventLabels}\n        />,\n      );\n\n      // Create popup with new design including an image and a button\n      const popup = new mapboxgl.Popup({ offset: 25, className: \"event-popup\" })\n        .setHTML(`\n          <div class=\"popup-content\" data-event-id=\"${event.id}\" onclick=\"document.dispatchEvent(new CustomEvent('showEventDetails', {detail: {eventId: ${event.id}}}))\">\n            <div class=\"event-popup-category\">${event.category.charAt(0).toUpperCase() + event.category.slice(1)}</div>\n            \n            <div class=\"event-popup-image\">\n              ${\n                hasEventImage\n                  ? `<img src=\"${eventImageUrl}\" alt=\"${event.title.replace(/\"/g, \"&quot;\")}\" \n                     style=\"width: 100%; height: 120px; object-fit: cover; border-radius: 6px; display: block;\" \n                     onerror=\"this.style.display='none'; this.nextElementSibling.style.display='flex';\" />`\n                  : \"\"\n              }\n              <div class=\"event-popup-image-placeholder category-${event.category}-light\" style=\"display: ${hasEventImage ? \"none\" : \"flex\"};\">\n                <span>${event.category.charAt(0).toUpperCase()}</span>\n              </div>\n            </div>\n            \n            <h3 class=\"event-popup-title\">${event.title}</h3>\n            <div class=\"event-popup-details\">\n              <div class=\"event-popup-date-time\">\n                <span class=\"event-popup-icon\">📅</span>\n                ${new Date(event.date).toLocaleDateString(\"es-ES\", {\n                  day: \"numeric\",\n                  month: \"short\",\n                })}, ${new Date(event.date).toLocaleTimeString(\"es-ES\", {\n                  hour: \"2-digit\",\n                  minute: \"2-digit\",\n                })}\n              </div>\n              <div class=\"event-popup-location\">\n                <span class=\"event-popup-icon\">📍</span>\n                ${event.locationName}\n              </div>\n            </div>\n            <div class=\"event-popup-footer\">\n              <div class=\"event-popup-attendees\">\n                <span class=\"event-popup-icon\">👥</span>\n                ${event.attendees?.length || 0} asistentes\n              </div>\n              <div class=\"event-popup-payment-type ${event.paymentType === \"free\" ? \"free\" : \"paid\"}\">\n                ${event.paymentType === \"free\" ? \"Free\" : `$${event.price || \"\"}`}\n              </div>\n            </div>\n            <button class=\"event-popup-button\" onclick=\"document.dispatchEvent(new CustomEvent('showEventDetails', {detail: {eventId: ${event.id}}}))\">\n              Ver detalles\n            </button>\n          </div>\n        `);\n\n      // Validar y convertir coordenadas\n      const lng =\n        typeof event.longitude === \"string\"\n          ? parseFloat(event.longitude)\n          : event.longitude;\n      const lat =\n        typeof event.latitude === \"string\"\n          ? parseFloat(event.latitude)\n          : event.latitude;\n\n      // Verificar que las coordenadas sean números válidos\n      if (isNaN(lng) || isNaN(lat)) {\n        console.error(\n          \"Coordenadas inválidas para el evento:\",\n          event.id,\n          event.title,\n          {\n            longitude: event.longitude,\n            latitude: event.latitude,\n          },\n        );\n        return; // Saltar este evento si las coordenadas no son válidas\n      }\n\n      // Only add 2D markers in 2D mode (to avoid duplicates with 3D markers)\n      // In 3D mode, we'll exclusively use 3D markers\n      // Always add 2D markers (removed 3D mode condition)\n      const marker = new mapboxgl.Marker(el)\n        .setLngLat([lng, lat])\n        .setPopup(popup)\n        .addTo(mapRef.current);\n\n      // Add event listener to marker with zoom functionality\n      el.addEventListener(\"click\", () => {\n        // Activate focused mode when event is selected\n        setIsFocusedMode(true);\n        \n        // Add zoom to marker functionality with offset to avoid panel covering\n        if (mapRef.current) {\n          // Calculate safe offset to position marker in visible area above panel\n          // Using conservative 35% to avoid pushing marker off-screen while keeping it visible\n          const screenHeight = mapRef.current.getContainer().clientHeight;\n          const offsetPixels = screenHeight * 0.35; // Safe 35% offset upward to keep marker visible above panel\n          \n          // SAVE camera state before moving to marker\n          console.log(\"🚨 DEBUG: Guardando estado de cámara antes de ir al marcador\");\n          saveCameraState();\n          \n          mapRef.current.flyTo({\n            center: [lng, lat],\n            zoom: 18, // Zoom más cercano para efecto focal\n            duration: 1200, // Animación más larga y suave\n            essential: true,\n            pitch: is3DMode ? 60 : 0, // Mantener vista 3D si está activada, sino usar 0 para 2D\n            bearing: mapRef.current.getBearing(), // Mantener rotación actual\n            offset: [0, -offsetPixels] // Offset negative (upward) to keep marker visible\n          });\n        }\n        \n        onEventSelect(event);\n      });\n\n      // Track markers and popups for cleanup\n      markersRef.current.push(marker);\n      popupsRef.current.push(popup);\n    });\n  }, [mapEvents, onEventSelect, showEventLabels]);\n\n  // Removed 3D mode toggle - only using 2D markers\n\n  // Función auxiliar para determinar con precisión el estilo de mapa actual\n  // y actualizar el estado de referencia persistente\n  const detectAndUpdateMapStyle = (): {\n    isStandard: boolean;\n    isSatellite: boolean;\n    isLight: boolean;\n    isDark: boolean;\n  } => {\n    if (!mapRef.current) {\n      return {\n        isStandard: true,\n        isSatellite: false,\n        isLight: true,\n        isDark: false,\n      };\n    }\n\n    try {\n      const style = mapRef.current.getStyle();\n      const styleId = style.name || \"\";\n      const styleUrl = style.sprite || \"\";\n      const styleJson = JSON.stringify(style).toLowerCase();\n\n      // Resultados de la detección\n      const isSatellite =\n        styleJson.includes(\"satellite\") || styleUrl.includes(\"satellite\");\n      const isDark =\n        styleJson.includes(\"dark\") ||\n        styleUrl.includes(\"dark\") ||\n        styleId.includes(\"dark\");\n      const isStandard = !isSatellite; // Si no es satélite, consideramos que es estándar\n      const isLight = !isDark; // Si no es oscuro, consideramos que es claro\n\n      console.log(\"Estilo de mapa detectado:\", {\n        isSatellite,\n        isDark,\n        styleUrl,\n        styleId,\n      });\n\n      // Actualizar el estado persistente con el estilo detectado\n      if (isSatellite) {\n        mapStateRef.current.style = \"satellite\";\n      } else if (isDark) {\n        mapStateRef.current.style = \"dark\";\n      } else {\n        mapStateRef.current.style = \"standard\";\n      }\n\n      // Actualizar también otros parámetros del estado persistente\n      if (mapRef.current) {\n        mapStateRef.current.currentZoom = mapRef.current.getZoom();\n        mapStateRef.current.currentCenter = mapRef.current.getCenter();\n        mapStateRef.current.currentBearing = mapRef.current.getBearing();\n        mapStateRef.current.currentPitch = mapRef.current.getPitch();\n        mapStateRef.current.is3D = mapStateRef.current.currentPitch > 0;\n      }\n\n      return { isStandard, isSatellite, isLight, isDark };\n    } catch (error) {\n      console.error(\"Error al detectar estilo de mapa:\", error);\n      return {\n        isStandard: true,\n        isSatellite: false,\n        isLight: true,\n        isDark: false,\n      };\n    }\n  };\n\n  // Toggle between 2D and 3D map views with style preservation\n  const handleToggleMapView = () => {\n    if (!mapRef.current) return;\n\n    // Guardar el estado actual del mapa en nuestro estado persistente\n    detectAndUpdateMapStyle();\n\n    // Obtener preset de iluminación basado en la hora\n    const currentTimePreset = getLightPresetByTime();\n\n    // Próximo estado del mapa - alternar entre 2D y 3D\n    const nextIs3DMode = !is3DMode;\n\n    // Actualizar la referencia de estado persistente\n    mapStateRef.current.is3D = nextIs3DMode;\n\n    // Variables de estilo objetivo\n    let targetStyle;\n    let styleDescription;\n\n    // Seleccionar el estilo de mapa basado en el estado persistente\n    // y el nuevo modo de visualización\n    if (nextIs3DMode) {\n      // Cambiando a modo 3D\n      if (mapStateRef.current.style === \"satellite\") {\n        targetStyle = MapStyle.STANDARD_SATELLITE;\n        styleDescription = \"mapa satelital 3D\";\n        setIsSatelliteMode(true);\n      } else if (mapStateRef.current.style === \"dark\") {\n        targetStyle = MapStyle.STANDARD_3D; // No hay específico oscuro 3D\n        styleDescription = \"mapa estándar 3D\";\n        setIsSatelliteMode(false);\n      } else {\n        targetStyle = MapStyle.STANDARD_3D;\n        styleDescription = \"mapa estándar 3D\";\n        setIsSatelliteMode(false);\n      }\n\n      // Actualizar estado y configuración\n      console.log(\"Cambiando a 3D:\", {\n        estilo: mapStateRef.current.style,\n        targetStyle,\n        zoom: mapStateRef.current.currentZoom,\n      });\n\n      // Aplicar el estilo y la inclinación\n      mapRef.current.setStyle(targetStyle);\n      mapRef.current.setPitch(45);\n      setIs3DMode(true);\n\n      // Aplicar configuración una vez que el estilo termine de cargarse\n      mapRef.current.once(\"style.load\", () => {\n        if (mapRef.current) {\n          try {\n            // Habilitar objetos 3D\n            mapRef.current.setConfigProperty(\"basemap\", \"show3dObjects\", true);\n\n            // Aplicar iluminación basada en tiempo\n            mapRef.current.setConfigProperty(\n              \"basemap\",\n              \"useAutoLightPreset\",\n              true,\n            );\n            mapRef.current.setConfigProperty(\n              \"basemap\",\n              \"lightPreset\",\n              currentTimePreset,\n            );\n\n            // Actualizar estado de configuración\n            setMapConfig((prev) => ({\n              ...prev,\n              lightPreset: currentTimePreset as LightPreset,\n              useAutoLightPreset: true,\n              show3dObjects: true,\n            }));\n\n            // Restaurar valores de posición/zoom guardados\n            mapRef.current.setZoom(mapStateRef.current.currentZoom);\n            mapRef.current.setCenter(mapStateRef.current.currentCenter);\n            mapRef.current.setBearing(mapStateRef.current.currentBearing);\n          } catch (error) {\n            console.error(\"Error al aplicar configuración 3D:\", error);\n          }\n        }\n      });\n\n      toast({\n        title: \"Vista 3D activada\",\n        description: `Cambiado a vista de ${styleDescription}.`,\n      });\n    } else {\n      // Cambiando a modo 2D\n      if (mapStateRef.current.style === \"satellite\") {\n        targetStyle = MapStyle.SATELLITE_2D;\n        styleDescription = \"mapa satelital 2D\";\n        setIsSatelliteMode(true);\n      } else {\n        // Siempre usar el estilo estándar para 2D (no usar tema oscuro)\n        targetStyle = MapStyle.STREETS_2D;\n        styleDescription = \"mapa estándar 2D\";\n        setIsSatelliteMode(false);\n      }\n\n      // Información de depuración\n      console.log(\"Cambiando a 2D:\", {\n        estilo: mapStateRef.current.style,\n        targetStyle,\n        zoom: mapStateRef.current.currentZoom,\n      });\n\n      // Aplicar el estilo y quitar la inclinación\n      mapRef.current.setStyle(targetStyle);\n      mapRef.current.setPitch(0);\n      setIs3DMode(false);\n\n      // Restaurar configuración de vista\n      mapRef.current.once(\"style.load\", () => {\n        if (mapRef.current) {\n          // Restaurar valores de posición/zoom guardados\n          mapRef.current.setZoom(mapStateRef.current.currentZoom);\n          mapRef.current.setCenter(mapStateRef.current.currentCenter);\n          mapRef.current.setBearing(mapStateRef.current.currentBearing);\n        }\n      });\n\n      toast({\n        title: \"Vista 2D activada\",\n        description: `Cambiado a vista de ${styleDescription}.`,\n      });\n    }\n  };\n\n  // Handle search functionality\n  const handleSearch = (term: string) => {\n    setSearchTerm(term);\n  };\n\n  // Alternar entre vistas estándar y satelital con preservación de modo 2D/3D\n  const handleToggleSatelliteView = () => {\n    if (!mapRef.current) return;\n\n    // Guardar el estado actual del mapa\n    detectAndUpdateMapStyle();\n\n    // Alternar entre satelital y estándar\n    const newIsSatelliteMode = !isSatelliteMode;\n\n    // Actualizar estado persistente\n    mapStateRef.current.style = newIsSatelliteMode ? \"satellite\" : \"standard\";\n\n    // Variables para aplicar el estilo correcto\n    let targetStyle;\n    let styleDescription;\n\n    // Seleccionar el estilo correcto basado en el modo actual (2D/3D)\n    if (newIsSatelliteMode) {\n      // Cambiar a satelital (en 2D o 3D según el modo actual)\n      targetStyle = is3DMode\n        ? MapStyle.STANDARD_SATELLITE\n        : MapStyle.SATELLITE_2D;\n      styleDescription = is3DMode ? \"mapa satelital 3D\" : \"mapa satelital 2D\";\n    } else {\n      // Cambiar a estándar (en 2D o 3D según el modo actual)\n      targetStyle = is3DMode ? MapStyle.STANDARD_3D : MapStyle.STREETS_2D;\n      styleDescription = is3DMode ? \"mapa estándar 3D\" : \"mapa estándar 2D\";\n    }\n\n    // Actualizar el estado de React\n    setIsSatelliteMode(newIsSatelliteMode);\n\n    // Información de depuración\n    console.log(\"Cambiando estilo de mapa:\", {\n      nuevoEstilo: mapStateRef.current.style,\n      targetStyle,\n      is3D: is3DMode,\n    });\n\n    // Aplicar el estilo\n    mapRef.current.setStyle(targetStyle);\n\n    // Mantener la inclinación según el modo actual\n    mapRef.current.setPitch(is3DMode ? 45 : 0);\n\n    // Si estamos en 3D, aplicar configuraciones adicionales\n    if (is3DMode) {\n      const currentTimePreset = getLightPresetByTime();\n\n      mapRef.current.once(\"style.load\", () => {\n        if (!mapRef.current) return;\n\n        try {\n          // Configurar objetos 3D y luz\n          mapRef.current.setConfigProperty(\"basemap\", \"show3dObjects\", true);\n          mapRef.current.setConfigProperty(\n            \"basemap\",\n            \"useAutoLightPreset\",\n            true,\n          );\n          mapRef.current.setConfigProperty(\n            \"basemap\",\n            \"lightPreset\",\n            currentTimePreset,\n          );\n\n          // Actualizar estado de configuración\n          setMapConfig((prev) => ({\n            ...prev,\n            lightPreset: currentTimePreset as LightPreset,\n            useAutoLightPreset: true,\n            show3dObjects: true,\n          }));\n        } catch (error) {\n          console.error(\n            \"Error al aplicar configuración 3D en modo satelital:\",\n            error,\n          );\n        }\n      });\n    }\n\n    // Restaurar vista después de cargar el estilo\n    mapRef.current.once(\"style.load\", () => {\n      if (!mapRef.current) return;\n\n      // Restaurar valores de zoom y posición guardados\n      mapRef.current.setZoom(mapStateRef.current.currentZoom);\n      mapRef.current.setCenter(mapStateRef.current.currentCenter);\n      mapRef.current.setBearing(mapStateRef.current.currentBearing);\n    });\n\n    // Notificar al usuario\n    toast({\n      title: newIsSatelliteMode ? \"Mapa Satelital\" : \"Mapa Estándar\",\n      description: `Vista de ${styleDescription} activada`,\n    });\n  };\n\n  // Función para eliminar todos los marcadores personalizados del mapa\n  const removeAllCustomMarkers = () => {\n    console.log(\"⚠️ LIMPIEZA RADICAL DE MARCADORES ⚠️\");\n\n    // PASO 1: Limpiar el estado\n    if (tempLocationMarker) {\n      try {\n        tempLocationMarker.remove();\n      } catch (err) {\n        console.error(\"Error al eliminar marcador temporal del estado:\", err);\n      } finally {\n        setTempLocationMarker(null);\n      }\n    }\n\n    // PASO 2: Limpieza directa de todos los marcadores en el DOM\n    try {\n      // Buscar TODOS los marcadores de Mapbox\n      const allMarkers = document.querySelectorAll(\".mapboxgl-marker\");\n\n      console.log(`Encontrados ${allMarkers.length} marcadores en el DOM`);\n\n      // Filtrar y eliminar solo los marcadores temporales (no los de eventos)\n      let markersRemoved = 0;\n\n      allMarkers.forEach((marker) => {\n        try {\n          // Verificar si es un marcador de evento (que queremos conservar)\n          const isEventMarker =\n            marker.classList.contains(\"custom-marker-container\") ||\n            marker.querySelector(\".custom-marker-container\");\n\n          if (!isEventMarker) {\n            marker.remove();\n            markersRemoved++;\n          }\n        } catch (err) {\n          console.error(\"Error al procesar marcador individual:\", err);\n        }\n      });\n\n      console.log(`Se eliminaron ${markersRemoved} marcadores temporales`);\n    } catch (err) {\n      console.error(\"Error grave durante la limpieza de marcadores:\", err);\n    }\n\n    // PASO 3: Forzar una actualización del mapa\n    if (mapRef.current) {\n      try {\n        // Este resize puede ayudar a refrescar la UI del mapa\n        mapRef.current.resize();\n      } catch (err) {\n        console.error(\"Error al actualizar el mapa:\", err);\n      }\n    }\n  };\n\n  // Función para limpiar los marcadores temporales (versión original - mantenida por compatibilidad)\n  const cleanupTempMarkers = () => {\n    removeAllCustomMarkers();\n  };\n\n  // Función para cerrar el menú contextual\n  const closeContextMenu = () => {\n    console.log(\"Cerrando menú contextual y limpiando estado\");\n\n    // Asegurarse de que el menú contextual se cierre correctamente\n    setContextMenu({\n      visible: false,\n      x: 0,\n      y: 0,\n      lngLat: null,\n    });\n\n    // IMPORTANTE: Resetear el modo de ubicación al cancelar\n    // Esto arregla el problema de los botones que no vuelven al estado inicial\n    setLocationMode(false);\n\n    // Eliminar TODOS los marcadores personalizados\n    removeAllCustomMarkers();\n\n    // Resetear cualquier otro estado relacionado con la ubicación\n    setTempLocationData(null);\n\n    // Asegurarnos de que los botones de acción no se muestren\n    setShowActionsForLocation(false);\n\n    // Forzar un refresco para eliminar cualquier elemento visual persistente\n    if (mapRef.current) {\n      mapRef.current.resize();\n    }\n\n    console.log(\"Estado limpiado correctamente\");\n  };\n\n  // Función para crear un evento en la ubicación del menú contextual\n  const handleCreateEventAtLocation = async () => {\n    // Primero verificar si ya tenemos los datos de la ubicación\n    if (tempLocationData && contextMenu.lngLat) {\n      // Usar los datos que ya hemos obtenido\n      onCreateEventClick({\n        latitude: tempLocationData.latitude,\n        longitude: tempLocationData.longitude,\n        locationAddress: tempLocationData.locationAddress,\n        locationName: tempLocationData.locationName,\n      });\n\n      // Cerrar el menú contextual\n      closeContextMenu();\n      return;\n    }\n\n    // Si no tenemos datos previos, obtenerlos\n    if (contextMenu.lngLat) {\n      const { lng, lat } = contextMenu.lngLat;\n\n      try {\n        // Obtener información sobre la ubicación seleccionada\n        const mapboxPromise = reverseGeocode(lng, lat);\n        const googlePromise = googleReverseGeocode(lng, lat);\n        const nearbyPlacesPromise = findNearbyPlaces(lat, lng, 100);\n\n        // Procesar resultados\n        const [mapboxAddress, googleAddress, nearbyPlaces] = await Promise.all([\n          mapboxPromise,\n          googlePromise,\n          nearbyPlacesPromise,\n        ]);\n\n        // Determinar el nombre y dirección del lugar\n        let locationName;\n        let address;\n\n        // Prioridad 1: Si encontramos lugares importantes (parques, plazas, etc.) usar esos nombres\n        // Identificar posibles lugares importantes (parques, puntos de interés, etc.)\n        const importantPlaces = Array.isArray(nearbyPlaces)\n          ? nearbyPlaces.filter((place) =>\n              // Buscar parques, puntos de interés, atracciones, locales marcados, etc.\n              [\n                \"park\",\n                \"point_of_interest\",\n                \"establishment\",\n                \"premise\",\n                \"neighborhood\",\n                \"natural_feature\",\n              ].some((type) => place.types && place.types.includes(type)),\n            )\n          : [];\n\n        if (importantPlaces.length > 0) {\n          const place = importantPlaces[0]; // Usar el lugar más relevante\n          locationName = place.name || \"Lugar del evento\";\n\n          // Para la dirección completa, usar el resultado de geocodificación inversa\n          address = googleAddress || mapboxAddress;\n\n          console.log(\n            \"Usando nombre de lugar importante (menú contextual):\",\n            locationName,\n          );\n        }\n        // Prioridad 2: Cualquier establecimiento cercano\n        else if (Array.isArray(nearbyPlaces) && nearbyPlaces.length > 0) {\n          locationName = nearbyPlaces[0].name || \"Lugar del evento\";\n\n          // Para la dirección completa usamos geocodificación inversa\n          address = googleAddress || mapboxAddress;\n\n          console.log(\n            \"Usando nombre de establecimiento cercano (menú contextual):\",\n            locationName,\n          );\n        }\n        // Prioridad 3: Buscar nombres significativos en los resultados de geocodificación\n        else if (googleAddress && googleAddress !== \"Dirección no encontrada\") {\n          address = googleAddress;\n\n          // Buscar si hay algo como \"Parque X\" o \"Plaza Y\" en la dirección\n          const specialPlaceMatch = address.match(\n            /(Parque|Plaza|Museo|Estadio|Monumento|Jardín|Biblioteca|Universidad|Teatro|Centro)\\s+([^,]+)/i,\n          );\n\n          if (specialPlaceMatch) {\n            // Usamos el nombre del lugar especial si lo encontramos\n            locationName = specialPlaceMatch[0];\n            console.log(\n              \"Encontrado nombre de lugar en dirección Google:\",\n              locationName,\n            );\n          } else {\n            // Si no, usamos la primera parte de la dirección\n            const namePart = googleAddress.split(\",\")[0];\n            locationName = namePart || \"Lugar del evento\";\n          }\n        }\n        // Última opción: MapBox como fallback\n        else {\n          address = mapboxAddress;\n\n          // Buscar si hay algo como \"Parque X\" o \"Plaza Y\" en la dirección\n          const specialPlaceMatch = address.match(\n            /(Parque|Plaza|Museo|Estadio|Monumento|Jardín|Biblioteca|Universidad|Teatro|Centro)\\s+([^,]+)/i,\n          );\n\n          if (specialPlaceMatch) {\n            // Usamos el nombre del lugar especial si lo encontramos\n            locationName = specialPlaceMatch[0];\n            console.log(\n              \"Encontrado nombre de lugar en dirección MapBox:\",\n              locationName,\n            );\n          } else {\n            // Si no, usamos la primera parte de la dirección\n            const namePart = mapboxAddress.split(\",\")[0];\n            locationName = namePart || \"Lugar del evento\";\n          }\n        }\n\n        // Crear objeto de ubicación\n        const locationData = {\n          latitude: lat,\n          longitude: lng,\n          locationAddress: address,\n          locationName: locationName,\n        };\n\n        // Cerrar menú contextual\n        closeContextMenu();\n\n        // Iniciar creación de evento con esta ubicación\n        onCreateEventClick(locationData);\n      } catch (error) {\n        console.error(\"Error al obtener información de la ubicación:\", error);\n        toast({\n          title: \"Error\",\n          description:\n            \"No se pudo obtener información sobre esta ubicación. Inténtalo de nuevo.\",\n          variant: \"destructive\",\n        });\n      }\n    }\n  };\n\n  // Función para buscar eventos cercanos a la ubicación del menú contextual\n  const handleFindNearbyEvents = () => {\n    if (contextMenu.lngLat && mapRef.current) {\n      // Guardar las coordenadas antes de cerrar el menú contextual\n      const lng = contextMenu.lngLat.lng;\n      const lat = contextMenu.lngLat.lat;\n\n      // Cerrar menú contextual primero\n      closeContextMenu();\n\n      // Centrar el mapa en la ubicación seleccionada\n      mapRef.current.flyTo({\n        center: [lng, lat],\n        zoom: 15,\n        essential: true,\n        duration: 1000,\n      });\n\n      // FILTROS ACTIVADOS: cargar eventos cercanos a las coordenadas seleccionadas\n\n      // Actualizar el estado con la ubicación actual\n      setCurrentLocation({\n        lng: lng,\n        lat: lat,\n        locationName: \"Ubicación seleccionada\",\n        locationAddress: \"\",\n      });\n\n      // Filtrar eventos por cercanía a estas coordenadas (sin filtros adicionales inicialmente)\n      const baseNearbyEvents = events.filter((event: EventWithRelations) => {\n        const eventLat = typeof event.latitude === \"string\" ? parseFloat(event.latitude) : event.latitude;\n        const eventLng = typeof event.longitude === \"string\" ? parseFloat(event.longitude) : event.longitude;\n\n        if (!isNaN(eventLat) && !isNaN(eventLng)) {\n          const distance = calculateDistance(lat, lng, eventLat, eventLng);\n          return distance <= selectedDistance;\n        }\n        return false;\n      });\n\n      // Aplicar filtros adicionales\n      const nearbyEvents = applyEventFilters(baseNearbyEvents, { lat, lng });\n\n      // Actualizar el estado con los eventos filtrados\n      setLocationFilteredEvents(nearbyEvents);\n\n      // Mostrar panel de eventos\n      setEventsPanelVisible(true);\n\n      // Eliminar cualquier marcador temporal previo\n      cleanupTempMarkers();\n\n      // Crear un nuevo marcador en la ubicación seleccionada\n      if (mapRef.current) {\n        const marker = new mapboxgl.Marker({\n          color: \"#1DA1F2\",\n        })\n          .setLngLat([lng, lat])\n          .addTo(mapRef.current);\n\n        // Guardar la referencia del marcador para poder eliminarlo después\n        setTempLocationMarker(marker);\n\n        // Programar la eliminación automática del marcador después de 5 segundos\n        setTimeout(() => {\n          if (marker) {\n            marker.remove();\n            setTempLocationMarker(null);\n          }\n        }, 5000);\n      }\n\n      // Mostrar notificación según el número de eventos encontrados\n      if (nearbyEvents.length > 0) {\n        toast({\n          title: `${nearbyEvents.length} eventos encontrados`,\n          description: \"Mostrando eventos cercanos a este lugar\",\n        });\n      } else {\n        toast({\n          title: \"No se encontraron eventos\",\n          description: \"No hay eventos cerca de esta ubicación\",\n          variant: \"destructive\",\n        });\n      }\n    }\n  };\n\n  // Function to toggle location selection mode\n  const toggleLocationMode = () => {\n    console.log(\"Configurando modo de ubicación:\", !locationMode);\n\n    // Eliminar TODOS los marcadores existentes primero\n    removeAllCustomMarkers();\n\n    // If we're exiting location mode, clean up\n    if (locationMode) {\n      resetLocationSelection();\n    } else {\n      // Enter location selection mode\n      toast({\n        title: \"Modo de selección activado\",\n        description:\n          \"Haz clic en el mapa o busca un lugar para seleccionar la ubicación del evento\",\n      });\n    }\n\n    // Toggle mode\n    setLocationMode(!locationMode);\n  };\n\n  // Function to handle place selection from the search bar\n  const handlePlaceSelect = async (place: {\n    latitude: number;\n    longitude: number;\n    locationName: string;\n    locationAddress: string;\n  }) => {\n    console.log(\"Lugar seleccionado en la búsqueda:\", place);\n\n    // Si no estamos en modo de selección de ubicación, simplemente centrar el mapa\n    if (!locationMode && mapRef.current) {\n      const longitude =\n        typeof place.longitude === \"string\"\n          ? parseFloat(place.longitude)\n          : place.longitude;\n      const latitude =\n        typeof place.latitude === \"string\"\n          ? parseFloat(place.latitude)\n          : place.latitude;\n\n      // Centrar el mapa en la ubicación seleccionada\n      mapRef.current.flyTo({\n        center: [longitude, latitude],\n        zoom: 15,\n        essential: true,\n        duration: 1000,\n      });\n\n      // Opcional: Añadir un marcador temporal\n      if (tempLocationMarker) {\n        tempLocationMarker.remove();\n      }\n\n      const marker = new mapboxgl.Marker({\n        color: \"#1DA1F2\",\n      })\n        .setLngLat([longitude, latitude])\n        .addTo(mapRef.current);\n\n      // Guardamos la referencia del marcador temporal\n      setTempLocationMarker(marker);\n\n      // Guardar la ubicación actual para los botones de acción\n      setCurrentLocation({\n        lng: longitude,\n        lat: latitude,\n        locationName: place.locationName,\n        locationAddress: place.locationAddress,\n      });\n\n      // Mostrar los botones de acción para esta ubicación\n      setShowActionsForLocation(true);\n\n      // Mostrar toast con información\n      toast({\n        title: place.locationName,\n        description: place.locationAddress,\n      });\n\n      return;\n    }\n\n    // Si estamos en modo de selección de ubicación, procesar normalmente\n    if (locationMode && mapRef.current) {\n      // Remove previous marker if exists\n      if (tempLocationMarker) {\n        tempLocationMarker.remove();\n      }\n\n      // Asegurar que las coordenadas sean números\n      const latitude =\n        typeof place.latitude === \"string\"\n          ? parseFloat(place.latitude)\n          : place.latitude;\n      const longitude =\n        typeof place.longitude === \"string\"\n          ? parseFloat(place.longitude)\n          : place.longitude;\n\n      console.log(\"Coordenadas recibidas:\", {\n        latitude,\n        longitude,\n        tipo_lat: typeof latitude,\n        tipo_lng: typeof longitude,\n      });\n\n      const coordinates: [number, number] = [longitude, latitude];\n\n      // Create a new marker\n      const marker = new mapboxgl.Marker({\n        color: \"#FF385C\",\n        draggable: true,\n      })\n        .setLngLat(coordinates)\n        .addTo(mapRef.current);\n\n      // Fly to the location\n      mapRef.current.flyTo({\n        center: coordinates,\n        zoom: 15,\n        essential: true,\n        duration: 1000,\n      });\n\n      // Store the marker reference\n      setTempLocationMarker(marker);\n\n      // Intentar utilizar geocodificación inversa de Google Maps para mejor consistencia\n      try {\n        console.log(\n          \"Solicitando geocodificación inversa de Google para:\",\n          longitude,\n          latitude,\n        );\n        const googleAddress = await googleReverseGeocode(longitude, latitude);\n        console.log(\"Google devolvió la dirección:\", googleAddress);\n\n        const locationData = {\n          latitude: parseFloat(String(latitude)),\n          longitude: parseFloat(String(longitude)),\n          // Usar la dirección completa de Google para la dirección\n          locationAddress: googleAddress || place.locationAddress,\n          // IMPORTANTE: Mantener el nombre original del lugar que el usuario seleccionó\n          locationName: place.locationName,\n        };\n\n        console.log(\"Guardando datos de ubicación (Google):\", locationData);\n        setTempLocationData(locationData);\n\n        toast({\n          title: \"Ubicación seleccionada\",\n          description: googleAddress || place.locationAddress,\n        });\n      } catch (error) {\n        console.error(\"Error obteniendo dirección de Google:\", error);\n\n        // Fallback a la dirección original\n        const fallbackData = {\n          latitude: parseFloat(String(latitude)),\n          longitude: parseFloat(String(longitude)),\n          locationAddress: place.locationAddress,\n          locationName: place.locationName,\n        };\n\n        console.log(\"Guardando datos de ubicación (fallback):\", fallbackData);\n        setTempLocationData(fallbackData);\n\n        toast({\n          title: \"Ubicación seleccionada\",\n          description: place.locationAddress,\n        });\n      }\n\n      // Add dragend event to update data when marker is dragged\n      marker.on(\"dragend\", async () => {\n        const lngLat = marker.getLngLat();\n\n        // Intentar obtener dirección usando Google primero para mantener consistencia\n        try {\n          const googleAddress = await googleReverseGeocode(\n            lngLat.lng,\n            lngLat.lat,\n          );\n\n          const updatedData = {\n            latitude: parseFloat(String(lngLat.lat)),\n            longitude: parseFloat(String(lngLat.lng)),\n            locationAddress: googleAddress,\n            locationName:\n              googleAddress.split(\",\")[0] || \"Ubicación seleccionada\",\n          };\n\n          console.log(\n            \"Actualizando ubicación tras arrastrar (Google):\",\n            updatedData,\n          );\n          setTempLocationData(updatedData);\n\n          toast({\n            title: \"Ubicación actualizada\",\n            description: googleAddress,\n          });\n        } catch (error) {\n          console.error(\n            \"Error obteniendo dirección de Google al arrastrar:\",\n            error,\n          );\n\n          // Fallback a MapBox si Google falla\n          try {\n            const mapboxAddress = await reverseGeocode(lngLat.lng, lngLat.lat);\n\n            const fallbackData = {\n              latitude: parseFloat(String(lngLat.lat)),\n              longitude: parseFloat(String(lngLat.lng)),\n              locationAddress: mapboxAddress,\n              locationName:\n                mapboxAddress.split(\",\")[0] || \"Ubicación seleccionada\",\n            };\n\n            console.log(\n              \"Actualizando ubicación tras arrastrar (Mapbox):\",\n              fallbackData,\n            );\n            setTempLocationData(fallbackData);\n\n            toast({\n              title: \"Ubicación actualizada\",\n              description: mapboxAddress,\n            });\n          } catch (mapboxError) {\n            console.error(\"Error también con Mapbox:\", mapboxError);\n\n            // Último recurso si ambos fallan\n            const basicData = {\n              latitude: parseFloat(String(lngLat.lat)),\n              longitude: parseFloat(String(lngLat.lng)),\n              locationAddress: \"Dirección desconocida\",\n              locationName: \"Lugar del evento\",\n            };\n\n            console.log(\"Actualizando ubicación con datos básicos:\", basicData);\n            setTempLocationData(basicData);\n\n            toast({\n              title: \"Ubicación actualizada\",\n              description: \"No se pudo obtener la dirección exacta\",\n              variant: \"destructive\",\n            });\n          }\n        }\n      });\n    }\n  };\n\n  // Function to reset location selection\n  const resetLocationSelection = () => {\n    console.log(\"Reseteando selección de ubicación\");\n\n    // Usar nuestra función más potente para eliminar todos los marcadores\n    removeAllCustomMarkers();\n\n    // Resetear también los datos de ubicación temporal\n    setTempLocationData(null);\n  };\n\n  // Function to confirm location selection with verificación adicional\n  const confirmLocationSelection = async () => {\n    if (tempLocationData) {\n      console.log(\"Confirmando ubicación original (Mapbox):\", tempLocationData);\n\n      try {\n        // Verificar que todos los campos necesarios existen\n        if (\n          tempLocationData.latitude === undefined ||\n          tempLocationData.longitude === undefined\n        ) {\n          console.error(\"Error: Coordenadas indefinidas\", tempLocationData);\n          toast({\n            title: \"Error al confirmar ubicación\",\n            description:\n              \"No se pudieron obtener las coordenadas. Por favor, intenta seleccionar otra ubicación.\",\n            variant: \"destructive\",\n          });\n          return;\n        }\n\n        // Intentar obtener la dirección usando Google Maps para consistencia\n        const googleAddress = await googleReverseGeocode(\n          tempLocationData.longitude,\n          tempLocationData.latitude,\n        );\n\n        // Verificar y asignar valores por defecto para evitar undefined\n        const locationName =\n          tempLocationData.locationName || \"Evento sin nombre\";\n        const locationAddress =\n          googleAddress ||\n          tempLocationData.locationAddress ||\n          \"Dirección desconocida\";\n\n        // Crear objeto de ubicación con formato correcto para Google Maps\n        // Garantizamos explícitamente que las coordenadas son números\n        const locationData = {\n          latitude: Number(tempLocationData.latitude),\n          longitude: Number(tempLocationData.longitude),\n          locationAddress: locationAddress,\n          locationName: locationName,\n        };\n\n        console.log(\"COORDENADAS CONFIRMADAS:\", {\n          latitude: locationData.latitude,\n          longitude: locationData.longitude,\n          tipoLat: typeof locationData.latitude,\n          tipoLon: typeof locationData.longitude,\n        });\n\n        console.log(\"Ubicación reformateada para Google Maps:\", locationData);\n\n        // Call the function provided by parent to create event with the selected location\n        if (typeof onCreateEventClick === \"function\") {\n          onCreateEventClick(locationData);\n        } else {\n          console.error(\"Error: onCreateEventClick no es una función\");\n          toast({\n            title: \"Error al crear evento\",\n            description:\n              \"Hubo un problema al iniciar la creación del evento. Por favor, intenta nuevamente.\",\n            variant: \"destructive\",\n          });\n          return;\n        }\n\n        // Clean up\n        resetLocationSelection();\n        setLocationMode(false);\n\n        toast({\n          title: \"Ubicación confirmada\",\n          description: \"Ahora puedes completar los detalles del evento\",\n        });\n      } catch (error) {\n        console.error(\n          \"Error al convertir coordenadas para Google Maps:\",\n          error,\n        );\n\n        // Usar datos originales de Mapbox como fallback\n        const fallbackLocationData = {\n          latitude: Number(tempLocationData.latitude),\n          longitude: Number(tempLocationData.longitude),\n          locationAddress: tempLocationData.locationAddress,\n          locationName: tempLocationData.locationName,\n        };\n\n        console.log(\"COORDENADAS FALLBACK:\", {\n          latitude: fallbackLocationData.latitude,\n          longitude: fallbackLocationData.longitude,\n          tipoLat: typeof fallbackLocationData.latitude,\n          tipoLon: typeof fallbackLocationData.longitude,\n        });\n\n        console.log(\"Usando ubicación de fallback:\", fallbackLocationData);\n        onCreateEventClick(fallbackLocationData);\n\n        resetLocationSelection();\n        setLocationMode(false);\n\n        toast({\n          title: \"Ubicación confirmada\",\n          description: \"Ahora puedes completar los detalles del evento\",\n        });\n      }\n    } else {\n      toast({\n        title: \"No hay ubicación seleccionada\",\n        description:\n          \"Haz clic en el mapa para seleccionar la ubicación del evento\",\n        variant: \"destructive\",\n      });\n    }\n  };\n\n  // Función para buscar eventos cercanos a la ubicación actual\n  const handleSearchEventsAtLocation = () => {\n    if (currentLocation && mapRef.current) {\n      // Centrar el mapa en la ubicación seleccionada\n      mapRef.current.flyTo({\n        center: [currentLocation.lng, currentLocation.lat],\n        zoom: 15,\n        essential: true,\n        duration: 1000,\n      });\n\n      // Filtrar eventos por cercanía y por nombre\n      if (currentLocation.locationName) {\n        // Convertir a minúsculas para comparar\n        const placeName = currentLocation.locationName.toLowerCase();\n\n        console.log(\"Buscando eventos relacionados con:\", placeName);\n\n        // Filtrar eventos cercanos (radio de 2 km) o que contengan el nombre del lugar\n        const baseNearbyEvents = events.filter((event: EventWithRelations) => {\n          // Verificar si la ubicación está en el nombre o descripción del evento\n          const nameMatch =\n            event.title.toLowerCase().includes(placeName) ||\n            (event.description && event.description.toLowerCase().includes(placeName)) ||\n            (event.locationName && event.locationName.toLowerCase().includes(placeName));\n\n          // Verificar distancia (si hay coordenadas válidas)\n          let distanceMatch = false;\n          const eventLat = typeof event.latitude === \"string\" ? parseFloat(event.latitude) : event.latitude;\n          const eventLng = typeof event.longitude === \"string\" ? parseFloat(event.longitude) : event.longitude;\n\n          if (!isNaN(eventLat) && !isNaN(eventLng)) {\n            const distance = calculateDistance(currentLocation.lat, currentLocation.lng, eventLat, eventLng);\n            const maxDistance = selectedDistance;\n            distanceMatch = distance <= maxDistance;\n\n            if (distanceMatch) {\n              console.log(`Evento \"${event.title}\" está a ${distance.toFixed(2)} km`);\n            }\n          }\n\n          // El evento coincide si está cerca o si contiene el nombre del lugar\n          return nameMatch || distanceMatch;\n        });\n\n        // Aplicar filtros adicionales\n        const nearbyEvents = applyEventFilters(baseNearbyEvents, currentLocation);\n\n        console.log(\"Eventos cercanos o relacionados con\", currentLocation.locationName, \":\", nearbyEvents.length);\n\n        // Actualizar el estado con los eventos filtrados\n        setLocationFilteredEvents(nearbyEvents);\n\n        // Si hay eventos, mostrar notificación con el número\n        if (nearbyEvents.length > 0) {\n          toast({\n            title: `${nearbyEvents.length} eventos encontrados`,\n            description: `Eventos cerca de ${currentLocation.locationName}`,\n          });\n        } else {\n          toast({\n            title: \"No se encontraron eventos\",\n            description: `No hay eventos cerca de ${currentLocation.locationName}`,\n            variant: \"destructive\",\n          });\n        }\n      } else {\n        // Si no hay nombre de ubicación, usar todos los eventos\n        setLocationFilteredEvents(events);\n      }\n\n      // Mostrar panel de eventos\n      setEventsPanelVisible(true);\n\n      // Ocultar botones de acción\n      setShowActionsForLocation(false);\n\n      // Limpiar marcadores\n      cleanupTempMarkers();\n\n      // Importante: añadir un pequeño retraso para asegurar que no se quede el marcador\n      // Este enfoque asegura que cualquier otro marcador que pudiera ser generado\n      // por otras funciones también se elimine.\n      setTimeout(() => {\n        cleanupTempMarkers();\n      }, 100);\n    }\n  };\n\n  // Función para crear un evento en la ubicación actual\n  const handleCreateEventAtCurrentLocation = async () => {\n    console.log(\"Creando evento en la ubicación actual\");\n\n    // Limpiar TODOS los marcadores primero\n    removeAllCustomMarkers();\n\n    if (currentLocation) {\n      try {\n        // Intentar obtener más información sobre la ubicación\n        const googleAddress = await googleReverseGeocode(\n          currentLocation.lng,\n          currentLocation.lat,\n        );\n\n        // Crear objeto de ubicación con el formato esperado\n        const locationData = {\n          latitude: currentLocation.lat,\n          longitude: currentLocation.lng,\n          locationAddress:\n            currentLocation.locationAddress ||\n            googleAddress ||\n            \"Dirección desconocida\",\n          locationName:\n            currentLocation.locationName ||\n            googleAddress?.split(\",\")[0] ||\n            \"Lugar del evento\",\n        };\n\n        console.log(\"Iniciando creación de evento con datos:\", locationData);\n\n        // Iniciar creación de evento\n        onCreateEventClick(locationData);\n\n        // Resetear estados\n        resetLocationSelection();\n        setShowActionsForLocation(false);\n      } catch (error) {\n        console.error(\"Error al preparar la ubicación para el evento:\", error);\n\n        // Usar los datos disponibles como fallback\n        const fallbackData = {\n          latitude: currentLocation.lat,\n          longitude: currentLocation.lng,\n          locationAddress:\n            currentLocation.locationAddress || \"Dirección desconocida\",\n          locationName: currentLocation.locationName || \"Lugar del evento\",\n        };\n\n        console.log(\n          \"Usando datos de fallback para creación de evento:\",\n          fallbackData,\n        );\n\n        onCreateEventClick(fallbackData);\n\n        // Resetear estados\n        resetLocationSelection();\n        setShowActionsForLocation(false);\n      }\n    }\n  };\n\n  // Handle going to user's current location\n  const handleGoToCurrentLocation = async () => {\n    if (!mapRef.current) return;\n\n    try {\n      const position = await getUserLocation(mapRef.current);\n      const { longitude, latitude } = position.coords;\n\n      console.log(\"Obtenida ubicación actual:\", {\n        latitude,\n        longitude,\n        tipo_lat: typeof latitude,\n        tipo_lng: typeof longitude,\n      });\n\n      mapRef.current.flyTo({\n        center: [longitude, latitude],\n        zoom: 15,\n        essential: true,\n      });\n\n      // If in location selection mode, set this as the location\n      if (locationMode) {\n        // Remove existing marker if any\n        if (tempLocationMarker) {\n          tempLocationMarker.remove();\n        }\n\n        // Create marker at current location\n        const marker = new mapboxgl.Marker({\n          color: \"#FF5A5F\",\n          draggable: true,\n        })\n          .setLngLat([longitude, latitude])\n          .addTo(mapRef.current);\n\n        setTempLocationMarker(marker);\n\n        // Intentar obtener la dirección usando Google Maps para mejor consistencia\n        try {\n          console.log(\"Solicitando dirección de Google para ubicación actual\");\n          const googleAddress = await googleReverseGeocode(longitude, latitude);\n          console.log(\n            \"Google devolvió dirección para ubicación actual:\",\n            googleAddress,\n          );\n\n          // Extract place name\n          const locationName =\n            googleAddress.split(\",\")[0] || \"Lugar del evento\";\n\n          // Store location data\n          const locationData = {\n            latitude: parseFloat(String(latitude)),\n            longitude: parseFloat(String(longitude)),\n            locationAddress: googleAddress,\n            locationName: locationName,\n          };\n\n          console.log(\n            \"Guardando datos de ubicación actual (Google):\",\n            locationData,\n          );\n          setTempLocationData(locationData);\n\n          toast({\n            title: \"Ubicación seleccionada\",\n            description: googleAddress,\n          });\n        } catch (googleError) {\n          console.error(\n            \"Error obteniendo dirección de Google para ubicación actual:\",\n            googleError,\n          );\n\n          // Fallback a Mapbox si Google falla\n          try {\n            console.log(\"Intentando obtener dirección con Mapbox\");\n            const mapboxAddress = await reverseGeocode(longitude, latitude);\n\n            // Extract place name\n            const locationName =\n              mapboxAddress.split(\",\")[0] || \"Lugar del evento\";\n\n            // Store location data\n            const fallbackData = {\n              latitude: parseFloat(String(latitude)),\n              longitude: parseFloat(String(longitude)),\n              locationAddress: mapboxAddress,\n              locationName: locationName,\n            };\n\n            console.log(\n              \"Guardando datos de ubicación actual (Mapbox):\",\n              fallbackData,\n            );\n            setTempLocationData(fallbackData);\n\n            toast({\n              title: \"Ubicación seleccionada\",\n              description: mapboxAddress,\n            });\n          } catch (mapboxError) {\n            console.error(\"También falló Mapbox:\", mapboxError);\n\n            // Último recurso: datos básicos sin dirección\n            const basicData = {\n              latitude: parseFloat(String(latitude)),\n              longitude: parseFloat(String(longitude)),\n              locationAddress: \"Dirección desconocida\",\n              locationName: \"Lugar del evento\",\n            };\n\n            console.log(\"Guardando datos de ubicación básicos:\", basicData);\n            setTempLocationData(basicData);\n\n            toast({\n              title: \"Ubicación seleccionada\",\n              description:\n                \"No se pudo obtener la dirección. La ubicación ha sido seleccionada, pero sin dirección.\",\n              variant: \"destructive\",\n            });\n          }\n        }\n      } else {\n        // Just add a marker for current location if not in selection mode\n        new mapboxgl.Marker({ color: \"#1DA1F2\" })\n          .setLngLat([longitude, latitude])\n          .addTo(mapRef.current);\n\n        toast({\n          title: \"Ubicación Actualizada\",\n          description: \"Mapa centrado en tu ubicación actual\",\n        });\n      }\n    } catch (error) {\n      console.error(\"Error getting location:\", error);\n      toast({\n        title: \"Error de Ubicación\",\n        description: \"No se pudo acceder a tu ubicación\",\n        variant: \"destructive\",\n      });\n    }\n  };\n\n  return (\n    <div className=\"relative flex-1 h-full w-full bg-neutral-100 overflow-hidden\">\n      {/* Map Container - Shows either traditional Mapbox or new 3D Snap Map */}\n      {isSnapMap3D ? (\n        <div className=\"absolute top-0 left-0 right-0 bottom-0 z-0\">\n          <PipolMap \n            events={adaptEventsForMap3D(mapEvents)}\n            center={[\n              mapStateRef.current?.currentCenter?.lng || -64.185,\n              mapStateRef.current?.currentCenter?.lat || -31.428\n            ]}\n            onEventClick={handleEventSelect}\n          />\n        </div>\n      ) : (\n        <div\n          ref={mapContainerRef}\n          id=\"map-container\"\n          className=\"absolute top-0 left-0 right-0 bottom-0 z-0 map-container\"\n        ></div>\n      )}\n\n      {/* Events Panel - Only visible when eventsPanelVisible is true */}\n      <AnimatePresence>\n        {eventsPanelVisible && (\n          <>\n            {/* Semi-transparent background overlay with backdrop blur */}\n            <motion.div\n              initial={{ opacity: 0 }}\n              animate={{ opacity: 1 }}\n              exit={{ opacity: 0 }}\n              transition={{ duration: 0.2 }}\n              className=\"fixed inset-0 bg-black/30 backdrop-blur-sm z-[9999]\"\n              onClick={() => {\n                setEventsPanelVisible(false);\n                cleanupTempMarkers();\n              }}\n            />\n\n            {/* Events panel with glassy effect */}\n            <motion.div\n              initial={{ scale: 0.95, opacity: 0, y: 20 }}\n              animate={{ scale: 1, opacity: 1, y: 0 }}\n              exit={{ scale: 0.95, opacity: 0, y: 20 }}\n              transition={{ \n                type: \"spring\",\n                damping: 25,\n                stiffness: 300,\n                duration: 0.3\n              }}\n              className=\"fixed inset-0 flex items-center justify-center z-[99999] p-4 pointer-events-none\"\n            >\n              <div className=\"bg-white/10 backdrop-blur-lg rounded-2xl max-w-2xl w-full max-h-[85vh] overflow-hidden shadow-2xl border border-white/20 pointer-events-auto\">\n                {/* Header with glassy effect */}\n                <motion.div\n                  initial={{ y: -20, opacity: 0 }}\n                  animate={{ y: 0, opacity: 1 }}\n                  transition={{ delay: 0.1, duration: 0.3 }}\n                  className=\"flex items-center justify-between p-6 border-b border-white/10 bg-white/5\"\n                >\n                  <h2 className=\"text-lg font-bold text-white\">\n                    Descubrir eventos\n                  </h2>\n                  <button\n                    onClick={() => {\n                      setEventsPanelVisible(false);\n                      cleanupTempMarkers();\n                    }}\n                    className=\"p-1 rounded-full hover:bg-white/20 transition-all duration-200 text-white/80 hover:text-white\"\n                  >\n                    <X size={20} />\n                  </button>\n                </motion.div>\n\n                {/* Filters Section */}\n                <motion.div\n                  initial={{ opacity: 0, y: -10 }}\n                  animate={{ opacity: 1, y: 0 }}\n                  transition={{ delay: 0.15, duration: 0.3 }}\n                  className=\"p-2 border-b border-white/10 bg-white/5 flex-shrink-0\"\n                >\n                  <div className=\"space-y-1.5\">\n                    {/* Compact Filter Grid */}\n                    <div className=\"space-y-2\">\n                      {/* First Row: Para and Fecha */}\n                      <div className=\"grid grid-cols-2 gap-2\">\n                        <select\n                          value={selectedGender}\n                          onChange={(e) => setSelectedGender(e.target.value)}\n                          className=\"w-full px-3 py-2 rounded-xl bg-white/10 text-white border border-white/20 text-sm focus:outline-none focus:ring-1 focus:ring-white/30 backdrop-blur-md shadow-lg\"\n                        >\n                          <option value=\"todos\" className=\"bg-gray-800\">\n                            Todos\n                          </option>\n                          <option value=\"men\" className=\"bg-gray-800\">\n                            Hombres\n                          </option>\n                          <option value=\"women\" className=\"bg-gray-800\">\n                            Mujeres\n                          </option>\n                        </select>\n                        \n                        <select\n                          value={selectedDateFilter}\n                          onChange={(e) => setSelectedDateFilter(e.target.value)}\n                          className=\"w-full px-3 py-2 rounded-xl bg-white/10 text-white border border-white/20 text-sm focus:outline-none focus:ring-1 focus:ring-white/30 backdrop-blur-md shadow-lg\"\n                        >\n                          <option value=\"all\" className=\"bg-gray-800\">\n                            Todas las fechas\n                          </option>\n                          <option value=\"today\" className=\"bg-gray-800\">\n                            Hoy\n                          </option>\n                          <option value=\"tomorrow\" className=\"bg-gray-800\">\n                            Mañana\n                          </option>\n                          <option value=\"weekend\" className=\"bg-gray-800\">\n                            Fin de semana\n                          </option>\n                          <option value=\"week\" className=\"bg-gray-800\">\n                            Esta semana\n                          </option>\n                          <option value=\"month\" className=\"bg-gray-800\">\n                            Este mes\n                          </option>\n                          <option value=\"next_months\" className=\"bg-gray-800\">\n                            Próximos meses\n                          </option>\n                        </select>\n                      </div>\n\n                      {/* Second Row: Tema and Limpiar Filtros */}\n                      <div className=\"grid grid-cols-2 gap-2\">\n                        <select\n                          value={selectedCategory}\n                          onChange={(e) => setSelectedCategory(e.target.value)}\n                          className=\"w-full px-3 py-2 rounded-xl bg-white/10 text-white border border-white/20 text-sm focus:outline-none focus:ring-1 focus:ring-white/30 backdrop-blur-md shadow-lg\"\n                        >\n                          <option value=\"all\" className=\"bg-gray-800\">\n                            Todos los temas\n                          </option>\n                          <option value=\"social\" className=\"bg-gray-800\">\n                            Social\n                          </option>\n                          <option value=\"music\" className=\"bg-gray-800\">\n                            Música\n                          </option>\n                          <option value=\"sports\" className=\"bg-gray-800\">\n                            Deportes\n                          </option>\n                          <option value=\"food\" className=\"bg-gray-800\">\n                            Comida\n                          </option>\n                          <option value=\"art\" className=\"bg-gray-800\">\n                            Arte\n                          </option>\n                          <option value=\"party\" className=\"bg-gray-800\">\n                            Fiestas\n                          </option>\n                          <option value=\"education\" className=\"bg-gray-800\">\n                            Educación\n                          </option>\n                          <option value=\"technology\" className=\"bg-gray-800\">\n                            Tecnología\n                          </option>\n                        </select>\n\n                        <button\n                          onClick={() => {\n                            setSelectedGender(\"todos\");\n                            setSelectedCategory(\"all\");\n                            setSelectedDistance(100);\n                            setSelectedDateFilter(\"all\");\n                          }}\n                          className=\"w-full px-3 py-2 rounded-xl bg-white/10 text-white/90 border border-white/20 hover:bg-white/20 transition-all duration-200 text-sm font-medium backdrop-blur-md shadow-lg\"\n                        >\n                          Limpiar Filtros\n                        </button>\n                      </div>\n\n                      {/* Distance Filter - More Compact */}\n                      <div className=\"flex items-center gap-3\">\n                        <span className=\"text-white/80 text-sm font-medium whitespace-nowrap\">\n                          Distancia:\n                        </span>\n                        <div className=\"flex-1\">\n                          <Slider\n                            value={[\n                              (() => {\n                                const distanceOptions = [\n                                  1, 5, 10, 20, 50, 80, 100,\n                                ];\n                                return distanceOptions.indexOf(selectedDistance);\n                              })(),\n                            ]}\n                            onValueChange={(values) => {\n                              const distanceOptions = [1, 5, 10, 20, 50, 80, 100];\n                              setSelectedDistance(distanceOptions[values[0]]);\n                            }}\n                            max={6}\n                            min={0}\n                            step={1}\n                            className=\"slider-distance w-full\"\n                          />\n                        </div>\n                        <span className=\"text-white/80 text-sm font-medium whitespace-nowrap\">\n                          {selectedDistance >= 100 ? '+100km' : selectedDistance >= 80 ? '+80km' : selectedDistance >= 50 ? '+50km' : `${selectedDistance}km`}\n                        </span>\n                      </div>\n                    </div>\n                  </div>\n                </motion.div>\n\n                {/* Events List with scroll */}\n                <motion.div\n                  initial={{ opacity: 0 }}\n                  animate={{ opacity: 1 }}\n                  transition={{ delay: 0.2, duration: 0.4 }}\n                  className=\"flex-1 overflow-y-auto bg-white/5 backdrop-blur-xl events-scroll-container p-3\"\n                  style={{\n                    scrollbarWidth: \"thin\",\n                    scrollbarColor: \"rgba(255,255,255,0.3) transparent\",\n                    WebkitOverflowScrolling: \"touch\",\n                    minHeight: \"300px\",\n                    maxHeight: \"calc(85vh - 140px)\", // Optimized for mobile and desktop\n                  }}\n                >\n                  {(() => {\n                    // Apply filtering ONLY for the panel view using our dedicated function\n                    const panelFilteredEvents = getFilteredEventsForPanel();\n\n                    return isLoading ? (\n                      <div className=\"flex justify-center items-center py-8\">\n                        <div className=\"animate-spin w-8 h-8 border-4 border-white/30 border-t-white rounded-full\" />\n                      </div>\n                    ) : panelFilteredEvents.length > 0 ? (\n                      <div className=\"grid grid-cols-1 gap-2 pb-20\">\n                        {panelFilteredEvents.map(\n                          (event: EventWithRelations) => (\n                            <Card\n                              key={event.id}\n                              className=\"shadow-sm cursor-pointer hover:bg-white/5 transition-all duration-200 bg-white/10 backdrop-blur rounded-xl border border-white/20 flex flex-row overflow-hidden h-[90px]\"\n                              onClick={() => {\n                                // Asegurarse de que latitude y longitude sean números antes de pasar el evento\n                                const formattedEvent = {\n                                  ...event,\n                                  latitude:\n                                    typeof event.latitude === \"string\"\n                                      ? parseFloat(event.latitude)\n                                      : event.latitude,\n                                  longitude:\n                                    typeof event.longitude === \"string\"\n                                      ? parseFloat(event.longitude)\n                                      : event.longitude,\n                                };\n\n                                // Aplicar la misma secuencia completa del focused mode que cuando se hace clic en un marker\n                                const lng = formattedEvent.longitude;\n                                const lat = formattedEvent.latitude;\n\n                                // Verificar que las coordenadas sean válidas antes de proceder\n                                if (!isNaN(lng) && !isNaN(lat)) {\n                                  // 1. Guardar estado de la cámara antes de hacer flyTo\n                                  console.log(\"🚨 DEBUG: Guardando estado de cámara antes de ir al evento desde panel\");\n                                  saveCameraState();\n\n                                  // 2. Hacer flyTo hacia el evento con la misma configuración que los markers\n                                  if (mapRef.current) {\n                                    // Calcular offset para posicionar el marker en área visible sobre el panel\n                                    const screenHeight = mapRef.current.getContainer().clientHeight;\n                                    const offsetPixels = screenHeight * 0.35; // Offset conservativo del 35% hacia arriba\n\n                                    mapRef.current.flyTo({\n                                      center: [lng, lat],\n                                      zoom: 18, // Zoom más cercano para efecto focal\n                                      duration: 1200, // Animación más larga y suave\n                                      essential: true,\n                                      pitch: is3DMode ? 60 : 0, // Mantener vista 3D si está activada, sino usar 0 para 2D\n                                      bearing: mapRef.current.getBearing(), // Mantener rotación actual\n                                      offset: [0, -offsetPixels] // Offset negativo (hacia arriba) para mantener marker visible\n                                    });\n                                  }\n                                }\n\n                                // 3. Activar focused mode\n                                setIsFocusedMode(true);\n                                \n                                // 4. Seleccionar el evento (esto abrirá el panel de detalles)\n                                onEventSelect(formattedEvent);\n                                \n                                // 5. Cerrar el panel de descubrir eventos\n                                setEventsPanelVisible(false);\n                              }}\n                            >\n                              <div className=\"flex-shrink-0 w-24 h-[90px]\">\n                                <div className=\"w-full h-full bg-gray-100 flex items-center justify-center rounded-l-xl overflow-hidden\">\n                                  {event.mainMediaUrl ? (\n                                    <img \n                                      src={event.mainMediaUrl} \n                                      alt={event.title}\n                                      className=\"w-full h-full object-cover\"\n                                    />\n                                  ) : (\n                                    <div className=\"text-lg\">\n                                      {getCategoryEmoji(event.category)}\n                                    </div>\n                                  )}\n                                </div>\n                              </div>\n                              <div className=\"flex-1 min-w-0 p-3\">\n                                <div className=\"text-xs font-semibold uppercase text-white/60 mb-1\">\n                                  {event.category}\n                                </div>\n                                <h3 className=\"font-bold text-sm truncate text-white\">\n                                  {event.title}\n                                </h3>\n                                <p className=\"text-xs text-white/70 truncate\">\n                                  {event.locationName}\n                                </p>\n                                <div className=\"flex items-center justify-between\">\n                                  <p className=\"text-xs text-white/60\">\n                                    {new Date(event.date).toLocaleDateString(\n                                      \"es-ES\",\n                                      {\n                                        month: \"short\",\n                                        day: \"numeric\",\n                                        hour: \"2-digit\",\n                                        minute: \"2-digit\",\n                                      },\n                                    )}\n                                  </p>\n                                  {currentLocation && (() => {\n                                    const eventLat = typeof event.latitude === \"string\" ? parseFloat(event.latitude) : event.latitude;\n                                    const eventLng = typeof event.longitude === \"string\" ? parseFloat(event.longitude) : event.longitude;\n                                    \n                                    if (!isNaN(eventLat) && !isNaN(eventLng)) {\n                                      const distance = calculateDistance(currentLocation.lat, currentLocation.lng, eventLat, eventLng);\n                                      return (\n                                        <p className=\"text-xs text-white/60 bg-white/10 px-2 py-1 rounded-full\">\n                                          {distance < 1 ? `${Math.round(distance * 1000)}m` : `${distance.toFixed(1)}km`}\n                                        </p>\n                                      );\n                                    }\n                                    return null;\n                                  })()}\n                                </div>\n                              </div>\n                            </Card>\n                          ),\n                        )}\n                      </div>\n                    ) : (\n                      <div className=\"w-full text-center py-8 text-white/80\">\n                        <p>No hay eventos que coincidan con tus filtros</p>\n                        <p className=\"text-sm text-white/60\">\n                          Intenta con otros filtros o cambia de ubicación\n                        </p>\n                      </div>\n                    );\n                  })()}\n                </motion.div>\n              </div>\n            </motion.div>\n          </>\n        )}\n      </AnimatePresence>\n\n      {/* Search Bars - Ocultar cuando overlays están ocultos o en modo focalizado */}\n      {!hideOverlays && (\n        <div className=\"absolute top-4 left-4 right-4 z-10 flex flex-col gap-2\">\n        {/* Barra de búsqueda principal con filtros */}\n        <div className=\"flex items-center gap-2\">\n          <div className=\"flex-1\">\n            <GooglePlacesSearch\n              onPlaceSelect={handlePlaceSelect}\n              onEventSelect={onEventSelect}\n              placeholder=\"Buscar lugares con Google Maps...\"\n            />\n          </div>\n          <Button\n            variant=\"outline\"\n            size=\"icon\"\n            className=\"h-11 w-11 rounded-full bg-white\"\n            onClick={async () => {\n              // Auto-detect user location when opening filters for better distance filtering\n              if (!filtersVisible && !currentLocation) {\n                await detectUserLocation();\n              }\n              setFiltersVisible(!filtersVisible);\n            }}\n          >\n            <Filter className=\"h-5 w-5\" />\n          </Button>\n        </div>\n\n        {/* Barra de búsqueda de MapBox como fallback (temporal) */}\n        {false && (\n          <SearchBar\n            onSearch={handleSearch}\n            onFilterClick={() => setFiltersVisible(!filtersVisible)}\n            onPlaceSelect={locationMode ? handlePlaceSelect : undefined}\n          />\n        )}\n        </div>\n      )}\n\n      {/* Filters Panel */}\n      {filtersVisible && (\n        <EventFilters\n          onClose={() => setFiltersVisible(false)}\n          onApply={(newFilters) => {\n            // Apply category filter\n            if (newFilters.categories.length > 0) {\n              setSelectedCategory(newFilters.categories[0]); // Use first selected category\n            } else {\n              setSelectedCategory(\"all\");\n            }\n\n            // Apply date filter\n            setSelectedDateFilter(newFilters.dateFilter);\n\n            // Apply distance filter\n            setSelectedDistance(newFilters.distance);\n\n            // Apply gender filter\n            setSelectedGender(newFilters.genderFilter);\n\n            // Apply the new filters to the parent component if needed\n            if (filters && typeof filters === \"object\") {\n              // Update category filter\n              if (newFilters.categories.length > 0) {\n                filters.category = newFilters.categories;\n              } else {\n                delete filters.category;\n              }\n\n              // Update payment type filter\n              if (newFilters.paymentTypes.length > 0) {\n                filters.paymentType = newFilters.paymentTypes;\n              } else {\n                delete filters.paymentType;\n              }\n\n              // Update date filter\n              if (newFilters.dateFilter !== \"all\") {\n                filters.date = newFilters.dateFilter;\n              } else {\n                delete filters.date;\n              }\n\n              // Update distance filter\n              filters.distance = newFilters.distance;\n\n              // Update gender filter (if genderFilter property exists)\n              if (newFilters.genderFilter !== \"todos\") {\n                (filters as any).genderFilter = newFilters.genderFilter;\n              } else {\n                delete (filters as any).genderFilter;\n              }\n            }\n\n            // Close the filters panel\n            setFiltersVisible(false);\n            toast({\n              title: \"Filtros aplicados\",\n              description:\n                \"Los eventos han sido filtrados según tus preferencias\",\n            });\n          }}\n        />\n      )}\n\n      {/* Location Selection Mode Indicator */}\n      {locationMode && (\n        <div className=\"absolute top-16 left-0 right-0 z-20 flex justify-center\">\n          <div className=\"bg-primary text-white px-4 py-2 rounded-full shadow-lg\">\n            <span className=\"text-sm font-medium\">\n              Selecciona la ubicación para el evento\n            </span>\n          </div>\n        </div>\n      )}\n\n      {/* Menú contextual cuando se hace clic en el mapa */}\n      {contextMenu.visible && (\n        <div\n          className=\"absolute z-40 bg-white rounded-lg shadow-lg p-2 min-w-[180px] context-menu\"\n          style={{\n            top: contextMenu.y - 10,\n            left: contextMenu.x,\n            transform: \"translate(-50%, -100%)\",\n          }}\n          onClick={(e) => {\n            // Evitar que se cierre el menú al hacer clic en él\n            e.stopPropagation();\n          }}\n        >\n          <div className=\"flex flex-col\">\n            {/* Título */}\n            <div className=\"p-2 text-center border-b border-gray-200\">\n              <span className=\"text-sm font-medium\">¿Qué quieres hacer?</span>\n            </div>\n\n            {/* Opciones */}\n            <button\n              className=\"p-2 text-left hover:bg-gray-100 text-sm flex items-center gap-2\"\n              onClick={handleFindNearbyEvents}\n            >\n              <Compass size={16} />\n              Ver eventos cercanos\n            </button>\n\n            <button\n              className=\"p-2 text-left hover:bg-gray-100 text-sm flex items-center gap-2\"\n              onClick={handleCreateEventAtLocation}\n            >\n              <Plus size={16} />\n              Crear evento aquí\n            </button>\n\n            <button\n              className=\"p-2 text-left hover:bg-gray-100 text-sm flex items-center gap-2\"\n              onClick={closeContextMenu}\n            >\n              <X size={16} />\n              Cancelar\n            </button>\n          </div>\n        </div>\n      )}\n\n      {/* Solo mostramos el encabezado de selección sin la tarjeta de información */}\n\n      {/* Control buttons - map group (vertical layout) - Ocultar cuando overlays están ocultos o en modo focalizado */}\n      {!hideOverlays && (\n        <div className=\"absolute top-[90px] left-4 flex flex-col gap-3\">\n        {/* 3D/2D Toggle Button (Traditional Mapbox) */}\n        {!isSnapMap3D && (\n          <button\n            className=\"p-3 bg-white rounded-full shadow-card text-neutral-700 border border-neutral-200 hover:bg-gray-50 flex items-center justify-center\"\n            onClick={handleToggleMapView}\n            title={is3DMode ? \"Cambiar a vista 2D\" : \"Cambiar a vista 3D\"}\n            aria-label={is3DMode ? \"Cambiar a vista 2D\" : \"Cambiar a vista 3D\"}\n          >\n            <span className=\"text-sm font-semibold\">{is3DMode ? \"2D\" : \"3D\"}</span>\n          </button>\n        )}\n\n        {/* Notifications Button */}\n        {user && (\n          <button\n            onClick={() => setShowNotifications(true)}\n            className=\"p-3 bg-white rounded-full shadow-card text-neutral-700 border border-neutral-200 hover:bg-gray-50 flex items-center justify-center relative\"\n            title=\"Notificaciones\"\n            aria-label=\"Ver notificaciones\"\n          >\n            <Bell size={22} />\n            {notificationCount > 0 && (\n              <span className=\"absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center\">\n                {notificationCount}\n              </span>\n            )}\n          </button>\n        )}\n\n        {/* Current Location Button */}\n        <button\n          className=\"p-3 bg-white rounded-full shadow-card text-neutral-700 border border-neutral-200 hover:bg-gray-50 flex items-center justify-center\"\n          onClick={handleGoToCurrentLocation}\n          title=\"Ir a mi ubicación\"\n          aria-label=\"Ir a mi ubicación actual\"\n        >\n          <MapPin size={22} />\n        </button>\n        </div>\n      )}\n\n      {/* Map Configuration Panel */}\n      <MapConfigPanel\n        map={mapRef.current}\n        isOpen={configPanelVisible}\n        onClose={() => setConfigPanelVisible(false)}\n        onConfigChange={(config) => {\n          setMapConfig((prev) => ({ ...prev, ...config }));\n\n          // Apply settings to map if available\n          if (mapRef.current) {\n            applyMapConfig(mapRef.current, config);\n          }\n        }}\n        config={mapConfig}\n        is3DMode={is3DMode}\n      />\n\n      {/* Main action buttons - Positioned above tab bar, ocultar cuando overlays están ocultos o en modo focalizado */}\n      {!hideOverlays && (\n        <div className=\"absolute bottom-[120px] left-0 right-0 z-10 flex justify-center gap-4 px-6\">\n        {contextMenu.visible ? (\n          // Botones cuando hay un menú contextual activo\n          <>\n            {/* Cancel Button */}\n            <button\n              className=\"flex-1 py-3 bg-white rounded-xl shadow-lg text-red-600 border border-neutral-200 flex items-center justify-center gap-2 font-medium\"\n              onClick={closeContextMenu}\n            >\n              <X size={20} />\n              Cancelar\n            </button>\n\n            {/* Crear Evento Aquí Button */}\n            <button\n              className=\"flex-1 py-3 bg-primary rounded-xl shadow-lg text-white flex items-center justify-center gap-2 font-medium\"\n              onClick={handleCreateEventAtLocation}\n            >\n              <Plus size={20} />\n              Crear un evento aquí\n            </button>\n          </>\n        ) : showActionsForLocation ? (\n          // Botones específicos para la ubicación buscada\n          <>\n            {/* Buscar Eventos Cercanos */}\n            <button\n              className=\"flex-1 py-3 bg-white rounded-xl shadow-lg text-neutral-700 border border-neutral-200 flex items-center justify-center gap-2 font-medium\"\n              onClick={handleSearchEventsAtLocation}\n            >\n              <Compass size={20} />\n              Buscar eventos aquí\n            </button>\n\n            {/* Crear Evento Aquí */}\n            <button\n              className=\"flex-1 py-3 bg-primary rounded-xl shadow-lg text-white flex items-center justify-center gap-2 font-medium\"\n              onClick={handleCreateEventAtCurrentLocation}\n            >\n              <Plus size={20} />\n              Crear un evento aquí\n            </button>\n          </>\n        ) : !locationMode ? (\n          // Botones normales\n          <>\n            {/* Discover Events Button */}\n            <button\n              className=\"flex-1 py-3 bg-white rounded-xl shadow-lg text-neutral-700 border border-neutral-200 flex items-center justify-center gap-2 text-sm font-medium\"\n              onClick={async () => {\n                console.log(\"Botón Descubrir eventos clickeado\");\n                setEventsPanelVisible(!eventsPanelVisible);\n                // Detectar ubicación inmediatamente al abrir el panel\n                if (!eventsPanelVisible && !currentLocation) {\n                  await detectUserLocation();\n                }\n              }}\n            >\n              {isDetectingLocation ? (\n                <div className=\"animate-spin w-4 h-4 border-2 border-neutral-400 border-t-transparent rounded-full\" />\n              ) : (\n                <Compass size={18} />\n              )}\n              {isDetectingLocation ? \"Detectando ubicación...\" : \"Descubrir eventos\"}\n            </button>\n\n            {/* Create Event Button */}\n            <button\n              className=\"flex-1 py-3 bg-primary rounded-xl shadow-lg text-white flex items-center justify-center gap-2 text-sm font-medium\"\n              onClick={toggleLocationMode}\n            >\n              <Plus size={18} />\n              Crear un evento\n            </button>\n          </>\n        ) : (\n          // Botones para modo de selección de ubicación\n          <>\n            {/* Cancel Location Selection */}\n            <button\n              className=\"flex-1 py-3 bg-white rounded-xl shadow-lg text-red-600 border border-neutral-200 flex items-center justify-center gap-2 font-medium\"\n              onClick={() => {\n                setLocationMode(false);\n                resetLocationSelection();\n              }}\n            >\n              <X size={20} />\n              Cancelar\n            </button>\n\n            {/* Confirm Location Button */}\n            <button\n              className=\"flex-1 py-3 bg-primary rounded-xl shadow-lg text-white flex items-center justify-center gap-2 font-medium\"\n              onClick={confirmLocationSelection}\n              disabled={!tempLocationData}\n            >\n              <Check size={20} />\n              Crear un evento aquí\n            </button>\n          </>\n        )}\n        </div>\n      )}\n\n      {/* Panel deslizante para editar eventos (similar a event-detail-sheet) */}\n      {editingEventId !== null && editSheetVisible && (\n        <EditEventSheet\n          eventId={editingEventId}\n          isOpen={editSheetVisible}\n          onClose={() => {\n            setEditSheetVisible(false);\n            setEditingEventId(null);\n          }}\n        />\n      )}\n\n      {/* Notifications Panel */}\n      {showNotifications && (\n        <NotificationsPanel\n          isOpen={showNotifications}\n          onClose={() => setShowNotifications(false)}\n        />\n      )}\n    </div>\n  );\n};\n\nexport default MapView;\n","size_bytes":138173},"client/src/components/multimedia/multimedia-display.tsx":{"content":"import React, { useState } from 'react';\n\ninterface MediaItem {\n  type: 'photo' | 'video';\n  url: string;\n  isMain?: boolean;\n  order?: number;\n}\n\ninterface MultimediaDisplayProps {\n  mediaItems?: string | MediaItem[] | null;\n  mainMediaType?: string | null;\n  mainMediaUrl?: string | null;\n  fallbackCategory?: string;\n  eventTitle?: string;\n  className?: string;\n}\n\nconst MultimediaDisplay: React.FC<MultimediaDisplayProps> = ({\n  mediaItems,\n  mainMediaType,\n  mainMediaUrl,\n  fallbackCategory = 'default',\n  eventTitle = '',\n  className = 'w-full h-full'\n}) => {\n  const [imageError, setImageError] = useState(false);\n\n  // Parse multimedia items safely\n  const parseMediaItems = (): MediaItem[] => {\n    if (!mediaItems) return [];\n    \n    try {\n      if (typeof mediaItems === 'string') {\n        return JSON.parse(mediaItems);\n      }\n      if (Array.isArray(mediaItems)) {\n        return mediaItems;\n      }\n    } catch (error) {\n      console.error('Error parsing media items:', error);\n    }\n    \n    return [];\n  };\n\n  // Get the main media item\n  const getMainMedia = (): { type: string; url: string } | null => {\n    const items = parseMediaItems();\n    \n    // Try to find main item from mediaItems\n    const mainItem = items.find(item => item.isMain) || items[0];\n    if (mainItem?.url) {\n      return { type: mainItem.type, url: mainItem.url };\n    }\n    \n    // Fallback to mainMediaType and mainMediaUrl\n    if (mainMediaType && mainMediaUrl) {\n      return { type: mainMediaType, url: mainMediaUrl };\n    }\n    \n    return null;\n  };\n\n  const mainMedia = getMainMedia();\n\n  // Handle image error with multiple fallbacks\n  const handleImageError = (e: React.SyntheticEvent<HTMLImageElement>) => {\n    const target = e.target as HTMLImageElement;\n    \n    if (!target.src.includes('/images/')) {\n      // First fallback: try local images\n      target.src = `/images/1.jpg`;\n    } else if (target.src.includes('1.jpg')) {\n      // Second fallback: try another local image\n      target.src = `/images/2.jpg`;\n    } else {\n      // Final fallback: SVG placeholder\n      const svgPlaceholder = `data:image/svg+xml;base64,${btoa(`\n        <svg width=\"600\" height=\"200\" xmlns=\"http://www.w3.org/2000/svg\">\n          <rect width=\"100%\" height=\"100%\" fill=\"#e5e7eb\"/>\n          <text x=\"50%\" y=\"50%\" text-anchor=\"middle\" dy=\"0.3em\" \n                font-family=\"sans-serif\" font-size=\"16\" fill=\"#6b7280\">\n            ${eventTitle || 'Evento'}\n          </text>\n        </svg>\n      `)}`;\n      target.src = svgPlaceholder;\n      setImageError(true);\n    }\n  };\n\n  // Render multimedia content\n  if (!mainMedia) {\n    // No media available - show placeholder\n    return (\n      <div className={`${className} bg-neutral-200 flex items-center justify-center`}>\n        <div className=\"text-center text-neutral-500\">\n          <div className=\"text-2xl mb-2\">🖼️</div>\n          <div className=\"text-sm\">Sin multimedia</div>\n        </div>\n      </div>\n    );\n  }\n\n  if (mainMedia.type === 'video') {\n    return (\n      <div className={`${className} relative`}>\n        <video\n          src={mainMedia.url}\n          className=\"w-full h-full object-cover\"\n          preload=\"metadata\"\n          muted\n          onError={(e) => {\n            console.error('Video load error:', mainMedia.url);\n          }}\n        />\n        {/* Video play overlay */}\n        <div className=\"absolute inset-0 flex items-center justify-center bg-black/30\">\n          <div className=\"w-12 h-12 rounded-full bg-white/80 flex items-center justify-center\">\n            <svg\n              xmlns=\"http://www.w3.org/2000/svg\"\n              width=\"24\"\n              height=\"24\"\n              viewBox=\"0 0 24 24\"\n              fill=\"none\"\n              stroke=\"currentColor\"\n              strokeWidth=\"2\"\n              strokeLinecap=\"round\"\n              strokeLinejoin=\"round\"\n              className=\"text-primary\"\n            >\n              <polygon points=\"5 3 19 12 5 21 5 3\"></polygon>\n            </svg>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  // Default to image display\n  return (\n    <img\n      src={mainMedia.url}\n      alt={eventTitle}\n      className={`${className} object-cover`}\n      onError={handleImageError}\n      loading=\"lazy\"\n    />\n  );\n};\n\nexport default MultimediaDisplay;","size_bytes":4299},"client/src/components/notifications/notifications-panel.tsx":{"content":"import React, { useState, useEffect, useRef } from 'react';\nimport { X, CheckCircle, XCircle, Clock, User, Calendar, MapPin, MessageSquare } from 'lucide-react';\nimport { formatDate } from '@/lib/utils';\nimport { apiRequest } from '@/lib/queryClient';\nimport { useToast } from '@/hooks/use-toast';\nimport { motion, AnimatePresence } from 'framer-motion';\nimport { useUserProfile } from '@/contexts/user-profile-context';\n\ninterface EventRequest {\n  id: number;\n  eventId: number;\n  userId: number;\n  status: string;\n  createdAt: string;\n  applicationAnswers?: Record<string, string>;\n  user: {\n    id: number;\n    name: string;\n    email: string;\n    avatar?: string;\n  };\n  event: {\n    id: number;\n    title: string;\n    date: string;\n    privateAccessType?: string;\n    applicationQuestions?: Record<string, string>;\n  };\n}\n\ninterface UserNotification {\n  type: 'user_notification';\n  id: number;\n  notificationType: string;\n  title: string;\n  message: string;\n  eventId?: number;\n  requestId?: number;\n  isRead: boolean;\n  createdAt: string;\n  event?: {\n    title: string;\n  };\n}\n\ninterface PendingRequest {\n  type: 'pending_request';\n  id: number;\n  eventId: number;\n  userId: number;\n  status: string;\n  createdAt: string;\n  user: {\n    id: number;\n    name: string;\n    email: string;\n    avatar?: string;\n  };\n  event: {\n    id: number;\n    title: string;\n    date: string;\n  };\n}\n\ntype NotificationItem = UserNotification | PendingRequest;\n\ninterface NotificationsPanelProps {\n  isOpen: boolean;\n  onClose: () => void;\n}\n\nexport default function NotificationsPanel({ isOpen, onClose }: NotificationsPanelProps) {\n  const [notifications, setNotifications] = useState<NotificationItem[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [processing, setProcessing] = useState<Record<number, boolean>>({});\n  const { toast } = useToast();\n  const { showUserProfile } = useUserProfile();\n  const panelRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    if (isOpen) {\n      fetchAllNotifications();\n      markAllAsRead();\n    }\n  }, [isOpen]);\n\n  // Handle click outside to close\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (panelRef.current && !panelRef.current.contains(event.target as Node)) {\n        onClose();\n      }\n    };\n\n    if (isOpen) {\n      document.addEventListener('mousedown', handleClickOutside);\n    }\n\n    return () => {\n      document.removeEventListener('mousedown', handleClickOutside);\n    };\n  }, [isOpen, onClose]);\n\n  const fetchAllNotifications = async () => {\n    try {\n      setLoading(true);\n      const response = await apiRequest(\"GET\", \"/api/notifications/all\");\n      const data = await response.json();\n      setNotifications(data.notifications || []);\n    } catch (error) {\n      console.error('Error fetching notifications:', error);\n      toast({\n        title: \"Error\",\n        description: \"No se pudieron cargar las notificaciones\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleApprove = async (requestId: number) => {\n    try {\n      setProcessing(prev => ({ ...prev, [requestId]: true }));\n      \n      const response = await apiRequest(\"POST\", \"/api/events/approve-attendee\", {\n        requestId\n      });\n\n      if (response.ok) {\n        setNotifications(prev => prev.filter(notif => \n          notif.type === 'pending_request' ? notif.id !== requestId : true\n        ));\n        toast({\n          title: \"Solicitud aprobada\",\n          description: \"El usuario ha sido agregado al evento\",\n        });\n      } else {\n        throw new Error('Failed to approve request');\n      }\n    } catch (error) {\n      console.error('Error approving request:', error);\n      toast({\n        title: \"Error\",\n        description: \"No se pudo aprobar la solicitud\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setProcessing(prev => ({ ...prev, [requestId]: false }));\n    }\n  };\n\n  const handleReject = async (requestId: number) => {\n    try {\n      setProcessing(prev => ({ ...prev, [requestId]: true }));\n      \n      const response = await apiRequest(\"POST\", \"/api/events/reject-attendee\", {\n        requestId\n      });\n\n      if (response.ok) {\n        setNotifications(prev => prev.filter(notif => \n          notif.type === 'pending_request' ? notif.id !== requestId : true\n        ));\n        toast({\n          title: \"Solicitud rechazada\",\n          description: \"La solicitud ha sido rechazada\",\n        });\n      } else {\n        throw new Error('Failed to reject request');\n      }\n    } catch (error) {\n      console.error('Error rejecting request:', error);\n      toast({\n        title: \"Error\",\n        description: \"No se pudo rechazar la solicitud\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setProcessing(prev => ({ ...prev, [requestId]: false }));\n    }\n  };\n\n  const markAllAsRead = async () => {\n    try {\n      const response = await apiRequest(\"POST\", \"/api/notifications/mark-all-read\");\n      if (response.ok) {\n        // Update local state to mark all user notifications as read\n        setNotifications(prev => \n          prev.map(notif => \n            notif.type === 'user_notification' \n              ? { ...notif, isRead: true }\n              : notif\n          )\n        );\n      }\n    } catch (error) {\n      console.error('Error marking notifications as read:', error);\n      // Don't show error toast for this - it's not critical to user experience\n    }\n  };\n\n  const getAccessTypeLabel = (accessType: string) => {\n    switch (accessType) {\n      case 'request': return 'Por solicitud';\n      case 'application': return 'Por postulación';\n      case 'paid': return 'Solo de pago';\n      default: return accessType;\n    }\n  };\n\n  return (\n    <AnimatePresence>\n      {isOpen && (\n        <>\n          {/* Semi-transparent background overlay with backdrop blur */}\n          <motion.div\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            exit={{ opacity: 0 }}\n            transition={{ duration: 0.2 }}\n            className=\"fixed inset-0 bg-black/30 backdrop-blur-sm z-[9999]\"\n            onClick={onClose}\n          />\n\n          {/* Notifications panel with glassy effect */}\n          <motion.div\n            ref={panelRef}\n            initial={{ scale: 0.95, opacity: 0, y: 20 }}\n            animate={{ scale: 1, opacity: 1, y: 0 }}\n            exit={{ scale: 0.95, opacity: 0, y: 20 }}\n            transition={{ \n              type: \"spring\",\n              damping: 25,\n              stiffness: 300,\n              duration: 0.3\n            }}\n            className=\"fixed inset-0 flex items-center justify-center z-[99999] p-4 pointer-events-none\"\n          >\n            <div className=\"bg-white/10 backdrop-blur-lg rounded-2xl max-w-2xl w-full max-h-[80vh] overflow-hidden shadow-2xl border border-white/20 pointer-events-auto\">\n              {/* Header with glassy effect */}\n              <motion.div\n                initial={{ y: -20, opacity: 0 }}\n                animate={{ y: 0, opacity: 1 }}\n                transition={{ delay: 0.1, duration: 0.3 }}\n                className=\"flex items-center justify-between p-6 border-b border-white/10 bg-white/5\"\n              >\n                <h2 className=\"text-xl font-semibold text-white\">Notificaciones</h2>\n                <button\n                  onClick={onClose}\n                  className=\"p-2 hover:bg-white/20 rounded-full transition-all duration-200 text-white/80 hover:text-white\"\n                >\n                  <X className=\"w-5 h-5\" />\n                </button>\n              </motion.div>\n\n              {/* Content area with enhanced glassy effect */}\n              <motion.div\n                initial={{ opacity: 0 }}\n                animate={{ opacity: 1 }}\n                transition={{ delay: 0.2, duration: 0.4 }}\n                className=\"overflow-y-auto max-h-[calc(80vh-120px)] bg-white/5 backdrop-blur-xl\"\n              >\n                {loading ? (\n                  <div className=\"flex items-center justify-center p-8\">\n                    <div className=\"animate-spin w-8 h-8 border-4 border-white/30 border-t-white rounded-full\" />\n                  </div>\n                ) : notifications.length === 0 ? (\n                  <div className=\"text-center p-8 text-white/80\">\n                    <Clock className=\"w-12 h-12 mx-auto mb-4 text-white/50\" />\n                    <p>No tienes notificaciones pendientes</p>\n                  </div>\n                ) : (\n                  <div className=\"divide-y divide-white/10\">\n                    {notifications.map((notification, index) => (\n                      <motion.div\n                        key={`${notification.type}-${notification.id}`}\n                        initial={{ opacity: 0, y: 20 }}\n                        animate={{ opacity: 1, y: 0 }}\n                        transition={{ delay: 0.1 * index, duration: 0.3 }}\n                        className=\"p-6 hover:bg-white/5 transition-colors duration-200\"\n                      >\n                        {notification.type === 'pending_request' ? (\n                          // Pending request from organizer's perspective\n                          <div className=\"flex items-start gap-4\">\n                            <div \n                              className=\"flex-shrink-0 cursor-pointer hover:scale-105 transition-transform duration-200\"\n                              onClick={() => showUserProfile({\n                                id: notification.user.id,\n                                name: notification.user.name,\n                                email: notification.user.email,\n                                avatar: notification.user.avatar\n                              })}\n                            >\n                              {notification.user.avatar ? (\n                                <img\n                                  src={notification.user.avatar}\n                                  alt={notification.user.name}\n                                  className=\"w-12 h-12 rounded-full object-cover border-2 border-white/20 hover:border-white/40 transition-colors\"\n                                />\n                              ) : (\n                                <div className=\"w-12 h-12 bg-white/20 rounded-full flex items-center justify-center border-2 border-white/20 hover:border-white/40 hover:bg-white/30 transition-colors\">\n                                  <User className=\"w-6 h-6 text-white/70\" />\n                                </div>\n                              )}\n                            </div>\n\n                            <div className=\"flex-1 min-w-0\">\n                              <div className=\"flex items-center gap-2 mb-2\">\n                                <h3 \n                                  className=\"font-medium text-white cursor-pointer hover:text-blue-300 transition-colors\"\n                                  onClick={() => showUserProfile({\n                                    id: notification.user.id,\n                                    name: notification.user.name,\n                                    email: notification.user.email,\n                                    avatar: notification.user.avatar\n                                  })}\n                                >\n                                  {notification.user.name}\n                                </h3>\n                                <span className=\"text-sm text-white/70\">\n                                  solicita unirse a tu evento\n                                </span>\n                              </div>\n\n                              <div className=\"space-y-2 mb-4\">\n                                <div className=\"flex items-center gap-2 text-sm text-white/80\">\n                                  <Calendar className=\"w-4 h-4\" />\n                                  <span className=\"font-medium\">{notification.event.title}</span>\n                                </div>\n                                \n                                <div className=\"flex items-center gap-2 text-sm text-white/60\">\n                                  <Clock className=\"w-4 h-4\" />\n                                  <span>{formatDate(notification.event.date)}</span>\n                                </div>\n                              </div>\n\n                              <div className=\"flex gap-3\">\n                                <button\n                                  onClick={() => handleApprove(notification.id)}\n                                  disabled={processing[notification.id]}\n                                  className=\"flex items-center gap-2 px-4 py-2 bg-green-600/80 backdrop-blur text-white rounded-lg hover:bg-green-600 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200\"\n                                >\n                                  <CheckCircle className=\"w-4 h-4\" />\n                                  {processing[notification.id] ? 'Aprobando...' : 'Aprobar'}\n                                </button>\n                                \n                                <button\n                                  onClick={() => handleReject(notification.id)}\n                                  disabled={processing[notification.id]}\n                                  className=\"flex items-center gap-2 px-4 py-2 bg-red-600/80 backdrop-blur text-white rounded-lg hover:bg-red-600 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200\"\n                                >\n                                  <XCircle className=\"w-4 h-4\" />\n                                  {processing[notification.id] ? 'Rechazando...' : 'Rechazar'}\n                                </button>\n                              </div>\n                            </div>\n                          </div>\n                        ) : (\n                          // User notifications (approvals, rejections, etc.)\n                          <div className=\"flex items-start gap-4\">\n                            <div className=\"flex-shrink-0\">\n                              <div className=\"w-12 h-12 bg-green-500/20 backdrop-blur rounded-full flex items-center justify-center border-2 border-green-500/30\">\n                                <CheckCircle className=\"w-6 h-6 text-green-400\" />\n                              </div>\n                            </div>\n\n                            <div className=\"flex-1 min-w-0\">\n                              <div className=\"flex items-center gap-2 mb-2\">\n                                <h3 className=\"font-medium text-white\">{notification.title}</h3>\n                                {!notification.isRead && (\n                                  <div className=\"w-2 h-2 bg-blue-400 rounded-full\"></div>\n                                )}\n                              </div>\n\n                              <p className=\"text-sm text-white/80 mb-2\">{notification.message}</p>\n\n                              {notification.event && (\n                                <div className=\"flex items-center gap-2 text-sm text-white/60 mb-2\">\n                                  <Calendar className=\"w-4 h-4\" />\n                                  <span>{notification.event.title}</span>\n                                </div>\n                              )}\n\n                              <div className=\"flex items-center gap-2 text-xs text-white/50\">\n                                <Clock className=\"w-3 h-3\" />\n                                <span>{formatDate(notification.createdAt)}</span>\n                              </div>\n                            </div>\n                          </div>\n                        )}\n                      </motion.div>\n                    ))}\n                  </div>\n                )}\n              </motion.div>\n            </div>\n          </motion.div>\n        </>\n      )}\n    </AnimatePresence>\n  );\n}","size_bytes":15951},"client/src/components/search/google-places-search.tsx":{"content":"import React, { useState, useEffect, useRef } from \"react\";\nimport { Input } from \"@/components/ui/input\";\nimport { Search, MapPin, Building, Calendar } from \"lucide-react\";\nimport { GOOGLE_MAPS_API_KEY, libraries } from \"@/lib/google-maps\";\nimport { useLoadScript } from \"@react-google-maps/api\";\nimport LoadingSpinner from \"@/components/ui/loading-spinner\";\n\n// Tipo para sugerencias de lugares de Google\ntype GooglePlaceSuggestion = {\n  id: string;\n  place_name: string;\n  text: string;\n  center: [number, number]; // Un par de coordenadas [longitud, latitud]\n  properties: {\n    category: string;\n  };\n};\n\ntype GooglePlacesSearchProps = {\n  onSearch?: (term: string) => void;\n  onPlaceSelect?: (place: {\n    latitude: number;\n    longitude: number;\n    locationName: string;\n    locationAddress: string;\n  }) => void;\n  onEventSelect?: (event: any) => void;\n  placeholder?: string;\n  className?: string;\n};\n\nconst GooglePlacesSearch = ({ \n  onSearch, \n  onPlaceSelect, \n  onEventSelect,\n  placeholder = \"Buscar lugares...\", \n  className = \"\" \n}: GooglePlacesSearchProps) => {\n  const [searchTerm, setSearchTerm] = useState(\"\");\n  const [suggestions, setSuggestions] = useState<GooglePlaceSuggestion[]>([]);\n  const [eventSuggestions, setEventSuggestions] = useState<any[]>([]);\n  const [showSuggestions, setShowSuggestions] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const suggestionRef = useRef<HTMLDivElement>(null);\n  const inputRef = useRef<HTMLInputElement>(null);\n  const autocompleteServiceRef = useRef<google.maps.places.AutocompleteService | null>(null);\n  const placesServiceRef = useRef<google.maps.places.PlacesService | null>(null);\n  const dummyElRef = useRef<HTMLDivElement | null>(null);\n\n  // Cargar la API de Google Maps\n  const { isLoaded, loadError } = useLoadScript({\n    googleMapsApiKey: GOOGLE_MAPS_API_KEY,\n    libraries,\n  });\n\n  // Inicializar servicios de Google Maps cuando la API está cargada\n  useEffect(() => {\n    if (isLoaded && !autocompleteServiceRef.current) {\n      autocompleteServiceRef.current = new google.maps.places.AutocompleteService();\n      \n      // Necesitamos un elemento HTML para el PlacesService\n      if (!dummyElRef.current) {\n        dummyElRef.current = document.createElement('div');\n      }\n      \n      placesServiceRef.current = new google.maps.places.PlacesService(dummyElRef.current);\n      console.log('Servicios de Google Places inicializados correctamente');\n    }\n  }, [isLoaded]);\n\n  // Manejar clic fuera de las sugerencias para cerrarlas\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (\n        suggestionRef.current &&\n        !suggestionRef.current.contains(event.target as Node) &&\n        inputRef.current &&\n        !inputRef.current.contains(event.target as Node)\n      ) {\n        setShowSuggestions(false);\n      }\n    };\n\n    document.addEventListener(\"mousedown\", handleClickOutside);\n    return () => {\n      document.removeEventListener(\"mousedown\", handleClickOutside);\n    };\n  }, []);\n\n  // Buscar eventos\n  const fetchEventSuggestions = async (term: string) => {\n    if (term.trim().length < 2) {\n      setEventSuggestions([]);\n      return;\n    }\n\n    try {\n      const response = await fetch(`/api/events?search=${encodeURIComponent(term)}`);\n      if (response.ok) {\n        const events = await response.json();\n        setEventSuggestions(events.slice(0, 5)); // Limitar a 5 eventos\n      }\n    } catch (error) {\n      console.error('Error buscando eventos:', error);\n      setEventSuggestions([]);\n    }\n  };\n\n  // Buscar lugares cuando el usuario escribe\n  useEffect(() => {\n    const fetchSuggestions = async () => {\n      if (!isLoaded || !autocompleteServiceRef.current || searchTerm.trim().length < 3) {\n        setSuggestions([]);\n        setEventSuggestions([]);\n        return;\n      }\n\n      setIsLoading(true);\n      try {\n        // Obtener la ubicación actual para biasing\n        let locationBias = undefined;\n        try {\n          const position = await new Promise<GeolocationPosition>((resolve, reject) => {\n            navigator.geolocation.getCurrentPosition(resolve, reject, {\n              enableHighAccuracy: true,\n              timeout: 5000,\n              maximumAge: 0\n            });\n          });\n          \n          if (position && position.coords) {\n            locationBias = {\n              lat: position.coords.latitude,\n              lng: position.coords.longitude,\n              radius: 50000 // 50km\n            };\n            console.log('Usando ubicación actual para mejorar resultados:', locationBias);\n          }\n        } catch (locError) {\n          console.log('No se pudo obtener ubicación para biasing:', locError);\n        }\n\n        // Configurar opciones para la búsqueda\n        const request: google.maps.places.AutocompletionRequest = {\n          input: searchTerm,\n          language: 'es',\n          componentRestrictions: { country: 'ar' },  // Restringir a Argentina\n          types: ['geocode', 'establishment']        // Tipos de resultados\n        };\n\n        // Agregar location bias si está disponible\n        if (locationBias) {\n          request.locationBias = {\n            radius: locationBias.radius,\n            center: { lat: locationBias.lat, lng: locationBias.lng }\n          };\n        }\n\n        // Usar el proxy del servidor en lugar de la API directa de Google\n        try {\n          const proxyUrl = new URLSearchParams({\n            input: searchTerm,\n            language: 'es',\n            components: 'country:ar'\n          });\n          \n          if (locationBias) {\n            proxyUrl.append('location', `${locationBias.lat},${locationBias.lng}`);\n            proxyUrl.append('radius', locationBias.radius.toString());\n          }\n          \n          const response = await fetch(`/api/google-proxy/place/autocomplete/json?${proxyUrl.toString()}`);\n          const data = await response.json();\n          \n          if (data.status === 'OK' && data.predictions) {\n            console.log('Google Places Autocomplete resultados via proxy:', data.predictions.length);\n            \n            // Convertir predicciones al formato requerido\n            const formattedSuggestions = data.predictions.map((prediction: any) => ({\n              id: prediction.place_id,\n              place_name: prediction.description,\n              text: prediction.structured_formatting?.main_text || prediction.description,\n              center: [0, 0] as [number, number],\n              properties: {\n                category: prediction.types?.[0] || 'place'\n              }\n            }));\n            \n            setSuggestions(formattedSuggestions);\n          } else {\n            console.log('No se encontraron sugerencias o error:', data.error_message || data.status);\n            setSuggestions([]);\n          }\n        } catch (proxyError) {\n          console.error('Error usando proxy para Places API:', proxyError);\n          setSuggestions([]);\n        }\n        \n        setIsLoading(false);\n      } catch (error) {\n        console.error('Error en Google Places Autocomplete:', error);\n        setSuggestions([]);\n        setIsLoading(false);\n      }\n    };\n\n    const fetchAllSuggestions = async () => {\n      await Promise.all([\n        fetchSuggestions(),\n        fetchEventSuggestions(searchTerm)\n      ]);\n    };\n\n    // Debounce para no hacer demasiadas solicitudes\n    const timeoutId = setTimeout(fetchAllSuggestions, 300);\n    return () => clearTimeout(timeoutId);\n  }, [searchTerm, isLoaded]);\n\n  // Función para obtener detalles completos de un lugar usando proxy\n  const getPlaceDetails = async (placeId: string): Promise<{\n    latitude: number;\n    longitude: number;\n    locationName: string;\n    locationAddress: string;\n  } | null> => {\n    try {\n      const response = await fetch(`/api/google-proxy/place/details/json?place_id=${placeId}&language=es&fields=name,formatted_address,geometry,place_id`);\n      const data = await response.json();\n      \n      if (data.status === 'OK' && data.result) {\n        const result = data.result;\n        if (result.geometry?.location) {\n          const lat = result.geometry.location.lat;\n          const lng = result.geometry.location.lng;\n          \n          return {\n            latitude: lat,\n            longitude: lng,\n            locationName: result.name || 'Lugar seleccionado',\n            locationAddress: result.formatted_address || 'Dirección no disponible'\n          };\n        }\n      }\n      \n      console.error('No se pudieron obtener los detalles del lugar');\n      return null;\n    } catch (error) {\n      console.error('Error obteniendo detalles del lugar via proxy:', error);\n      return null;\n    }\n  };\n\n  // Manejar la selección de un lugar\n  const handlePlaceSelect = async (suggestion: GooglePlaceSuggestion) => {\n    try {\n      setIsLoading(true);\n      const placeDetails = await getPlaceDetails(suggestion.id);\n      setIsLoading(false);\n      \n      if (placeDetails && onPlaceSelect) {\n        // Usar el texto de la búsqueda como nombre del lugar si está disponible\n        // Esto preserva el nombre que el usuario vio y seleccionó\n        const enhancedPlaceDetails = {\n          ...placeDetails,\n          // Usar el texto del resultado seleccionado como nombre del lugar\n          // en lugar del nombre de la calle que devuelve la API de geocodificación\n          locationName: suggestion.text || placeDetails.locationName\n        };\n        \n        console.log('Lugar seleccionado (Google Places):', enhancedPlaceDetails);\n        onPlaceSelect(enhancedPlaceDetails);\n        setSearchTerm(enhancedPlaceDetails.locationName);\n        setShowSuggestions(false);\n      }\n    } catch (error) {\n      console.error('Error obteniendo detalles del lugar:', error);\n      setIsLoading(false);\n    }\n  };\n\n  // Manejar la selección de un evento\n  const handleEventSelect = (event: any) => {\n    if (onEventSelect) {\n      console.log('Evento seleccionado:', event);\n      onEventSelect(event);\n      setSearchTerm(event.title);\n      setShowSuggestions(false);\n    }\n  };\n\n  // Manejar cambios en el input\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const value = e.target.value;\n    setSearchTerm(value);\n    setShowSuggestions(value.trim().length > 0);\n    \n    if (onSearch) {\n      onSearch(value);\n    }\n  };\n\n  // Focus en el input\n  const handleInputFocus = () => {\n    setShowSuggestions(true);\n  };\n\n  // Manejar click en la barra\n  const handleBarClick = () => {\n    setShowSuggestions(true);\n    setTimeout(() => {\n      inputRef.current?.focus();\n    }, 0);\n  };\n\n  return (\n    <div className={`relative w-full google-places-search ${className}`}>\n      <div className=\"relative\">\n        <div \n          className=\"w-full bg-white rounded-full border border-gray-200 shadow-sm px-4 py-3 cursor-text flex items-center\"\n          onClick={handleBarClick}\n        >\n          <Search className=\"h-5 w-5 text-gray-400 mr-3 flex-shrink-0\" />\n          <div className=\"flex-1\">\n            {!searchTerm && !showSuggestions ? (\n              <div className=\"flex flex-col\">\n                <div className=\"text-sm font-medium text-gray-900\">\n                  ¿De qué quieres participar hoy?\n                </div>\n                <div className=\"text-xs text-gray-500\">\n                  Cualquier evento, plan o actividad\n                </div>\n              </div>\n            ) : (\n              <Input\n                ref={inputRef}\n                type=\"text\"\n                placeholder=\"Buscar eventos o lugares...\"\n                value={searchTerm}\n                onChange={handleInputChange}\n                onFocus={handleInputFocus}\n                className=\"border-none p-0 h-auto bg-transparent focus:ring-0 focus:border-none shadow-none text-sm\"\n                style={{ outline: 'none', boxShadow: 'none' }}\n              />\n            )}\n          </div>\n          {isLoading && (\n            <div className=\"ml-2 flex-shrink-0\">\n              <LoadingSpinner size={16} />\n            </div>\n          )}\n        </div>\n      </div>\n\n      {/* Suggestions */}\n      {showSuggestions && (\n        <div \n          ref={suggestionRef}\n          className=\"absolute z-10 mt-1 w-full bg-white shadow-lg max-h-60 rounded-md py-1 text-base overflow-auto focus:outline-none sm:text-sm border border-gray-200\"\n        >\n          {/* Mostrar eventos primero */}\n          {eventSuggestions.length > 0 && (\n            <>\n              <div className=\"px-4 py-2 text-xs font-semibold text-gray-400 uppercase border-b border-gray-100\">\n                Eventos\n              </div>\n              {eventSuggestions.map((event) => (\n                <div\n                  key={`event-${event.id}`}\n                  className=\"cursor-pointer flex items-center px-4 py-2 hover:bg-gray-100\"\n                  onClick={() => handleEventSelect(event)}\n                >\n                  <div className=\"mr-2\">\n                    <Calendar className=\"h-4 w-4 text-primary\" />\n                  </div>\n                  <div className=\"flex flex-col\">\n                    <span className=\"text-sm font-medium\">{event.title}</span>\n                    <span className=\"text-xs text-gray-500 line-clamp-1\">\n                      {event.locationName} • {new Date(event.date).toLocaleDateString()}\n                    </span>\n                  </div>\n                </div>\n              ))}\n            </>\n          )}\n          \n          {/* Mostrar lugares después */}\n          {suggestions.length > 0 && (\n            <>\n              {eventSuggestions.length > 0 && (\n                <div className=\"px-4 py-2 text-xs font-semibold text-gray-400 uppercase border-b border-gray-100\">\n                  Lugares\n                </div>\n              )}\n              {suggestions.map((suggestion) => (\n                <div\n                  key={suggestion.id}\n                  className=\"cursor-pointer flex items-center px-4 py-2 hover:bg-gray-100\"\n                  onClick={() => handlePlaceSelect(suggestion)}\n                >\n                  <div className=\"mr-2\">\n                    {suggestion.properties.category === 'address' || \n                    suggestion.properties.category === 'street_address' ? (\n                      <MapPin className=\"h-4 w-4 text-gray-500\" />\n                    ) : (\n                      <Building className=\"h-4 w-4 text-gray-500\" />\n                    )}\n                  </div>\n                  <div className=\"flex flex-col\">\n                    <span className=\"text-sm font-medium\">{suggestion.text}</span>\n                    <span className=\"text-xs text-gray-500 line-clamp-1\">\n                      {suggestion.place_name}\n                    </span>\n                  </div>\n                </div>\n              ))}\n            </>\n          )}\n          \n          {/* Mensaje cuando no hay resultados */}\n          {suggestions.length === 0 && eventSuggestions.length === 0 && (\n            <div className=\"px-4 py-2 text-sm text-gray-500\">\n              {isLoading ? \"Buscando...\" : \"No se encontraron resultados\"}\n            </div>\n          )}\n        </div>\n      )}\n      \n      {/* Elemento invisible para PlacesService */}\n      <div ref={dummyElRef} style={{ display: 'none' }}></div>\n    </div>\n  );\n};\n\nexport default GooglePlacesSearch;","size_bytes":15415},"client/src/components/search/search-bar.tsx":{"content":"import React, { useState, useEffect, useRef } from \"react\";\nimport { Input } from \"@/components/ui/input\";\nimport { Search, Settings, MapPin, Building } from \"lucide-react\";\nimport { searchPlaces } from \"@/lib/google-maps\";\nimport { searchLocations } from \"@/lib/mapbox\";\nimport LoadingSpinner from \"@/components/ui/loading-spinner\";\n\n// Definición del tipo para las sugerencias de lugares\ntype PlaceSuggestion = {\n  id: string;\n  place_name: string;\n  center: [number, number];\n  text: string;\n  properties: {\n    category?: string;\n  };\n};\n\ntype SearchBarProps = {\n  onSearch: (term: string) => void;\n  onFilterClick: () => void;\n  onPlaceSelect?: (place: {\n    latitude: number;\n    longitude: number;\n    locationName: string;\n    locationAddress: string;\n  }) => void;\n  hideSettings?: boolean; // Ocultar botón Settings cuando el panel está abierto\n};\n\nconst SearchBar = ({ onSearch, onFilterClick, onPlaceSelect, hideSettings = false }: SearchBarProps) => {\n  const [searchTerm, setSearchTerm] = useState(\"\");\n  const [suggestions, setSuggestions] = useState<PlaceSuggestion[]>([]);\n  const [showSuggestions, setShowSuggestions] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const suggestionRef = useRef<HTMLDivElement>(null);\n\n  // Fetch suggestions when user types\n  useEffect(() => {\n    const fetchSuggestions = async () => {\n      if (searchTerm.trim().length < 3) {\n        setSuggestions([]);\n        return;\n      }\n\n      setIsLoading(true);\n      try {\n        // Usar Google Places API para buscar lugares\n        const results = await searchPlaces(searchTerm);\n        console.log('Google Places results:', results);\n        \n        if (results && results.length > 0) {\n          setSuggestions(results);\n        } else {\n          // Si Google Places no devuelve resultados, usar MapBox como fallback\n          console.log('No se encontraron resultados con Google Places, usando MapBox como fallback');\n          const mapboxResults = await searchLocations(searchTerm, [\n            'address', \n            'poi', \n            'poi.landmark', \n            'place'\n          ]);\n          setSuggestions(mapboxResults);\n        }\n      } catch (error) {\n        console.error(\"Error fetching suggestions from Google Places:\", error);\n        \n        // Si hay un error con Google Places, usar MapBox como fallback\n        try {\n          console.log('Error con Google Places, usando MapBox como fallback');\n          const mapboxResults = await searchLocations(searchTerm, [\n            'address', \n            'poi', \n            'poi.landmark', \n            'place'\n          ]);\n          setSuggestions(mapboxResults);\n        } catch (mapboxError) {\n          console.error(\"Error con MapBox fallback:\", mapboxError);\n        }\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    // Debounce to avoid too many API calls\n    const timer = setTimeout(() => {\n      fetchSuggestions();\n    }, 300);\n\n    return () => clearTimeout(timer);\n  }, [searchTerm]);\n\n  // Close suggestions when clicking outside\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (suggestionRef.current && !suggestionRef.current.contains(event.target as Node)) {\n        setShowSuggestions(false);\n      }\n    };\n\n    document.addEventListener(\"mousedown\", handleClickOutside);\n    return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n  }, []);\n\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const value = e.target.value;\n    setSearchTerm(value);\n    onSearch(value);\n    setShowSuggestions(true);\n  };\n\n  const handleSuggestionClick = (suggestion: PlaceSuggestion) => {\n    setSearchTerm(suggestion.place_name);\n    setShowSuggestions(false);\n    onSearch(suggestion.place_name);\n\n    // If onPlaceSelect is provided, call it with the selected place data\n    if (onPlaceSelect) {\n      onPlaceSelect({\n        latitude: suggestion.center[1],\n        longitude: suggestion.center[0],\n        locationName: suggestion.text || suggestion.place_name.split(',')[0],\n        locationAddress: suggestion.place_name\n      });\n    }\n  };\n\n  return (\n    <div className=\"flex items-center gap-2\">\n      <div className=\"relative flex-1\" ref={suggestionRef}>\n        <div className=\"absolute left-3 top-1/2 -translate-y-1/2 text-neutral-400\">\n          <Search size={18} />\n        </div>\n        <Input\n          type=\"text\"\n          placeholder=\"¿De qué quieres participar hoy? Cualquier evento, plan o actividad\"\n          className=\"w-full py-4 pl-10 pr-4 rounded-full border-0 focus:outline-none text-sm bg-transparent\"\n          value={searchTerm}\n          onChange={handleInputChange}\n          onFocus={() => searchTerm.length >= 3 && setShowSuggestions(true)}\n        />\n\n        {/* Suggestions dropdown */}\n        {showSuggestions && suggestions.length > 0 && (\n          <div className=\"absolute z-20 w-full mt-1 bg-white rounded-xl shadow-lg border border-neutral-200 max-h-72 overflow-y-auto\">\n            {suggestions.map((suggestion) => (\n              <div \n                key={suggestion.id} \n                className=\"px-4 py-3 cursor-pointer hover:bg-neutral-50 flex items-start gap-2 border-b border-neutral-100 last:border-0\"\n                onClick={() => handleSuggestionClick(suggestion)}\n              >\n                <div className=\"text-primary mt-1\">\n                  {suggestion.properties?.category === \"poi\" ? (\n                    <Building size={16} />\n                  ) : (\n                    <MapPin size={16} />\n                  )}\n                </div>\n                <div>\n                  <div className=\"font-medium\">{suggestion.text}</div>\n                  <div className=\"text-xs text-neutral-500\">{suggestion.place_name}</div>\n                </div>\n              </div>\n            ))}\n          </div>\n        )}\n\n        {/* Loading indicator */}\n        {isLoading && (\n          <div className=\"absolute right-3 top-1/2 -translate-y-1/2\">\n            <LoadingSpinner size={16} />\n          </div>\n        )}\n      </div>\n      {!hideSettings && (\n        <button \n          className=\"p-3 rounded-xl text-neutral-700\"\n          onClick={onFilterClick}\n        >\n          <Settings size={18} />\n        </button>\n      )}\n    </div>\n  );\n};\n\nexport default SearchBar;\n","size_bytes":6358},"client/src/components/ui/accordion.tsx":{"content":"import * as React from \"react\"\nimport * as AccordionPrimitive from \"@radix-ui/react-accordion\"\nimport { ChevronDown } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Accordion = AccordionPrimitive.Root\n\nconst AccordionItem = React.forwardRef<\n  React.ElementRef<typeof AccordionPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>\n>(({ className, ...props }, ref) => (\n  <AccordionPrimitive.Item\n    ref={ref}\n    className={cn(\"border-b\", className)}\n    {...props}\n  />\n))\nAccordionItem.displayName = \"AccordionItem\"\n\nconst AccordionTrigger = React.forwardRef<\n  React.ElementRef<typeof AccordionPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <AccordionPrimitive.Header className=\"flex\">\n    <AccordionPrimitive.Trigger\n      ref={ref}\n      className={cn(\n        \"flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180\",\n        className\n      )}\n      {...props}\n    >\n      {children}\n      <ChevronDown className=\"h-4 w-4 shrink-0 transition-transform duration-200\" />\n    </AccordionPrimitive.Trigger>\n  </AccordionPrimitive.Header>\n))\nAccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName\n\nconst AccordionContent = React.forwardRef<\n  React.ElementRef<typeof AccordionPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <AccordionPrimitive.Content\n    ref={ref}\n    className=\"overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down\"\n    {...props}\n  >\n    <div className={cn(\"pb-4 pt-0\", className)}>{children}</div>\n  </AccordionPrimitive.Content>\n))\n\nAccordionContent.displayName = AccordionPrimitive.Content.displayName\n\nexport { Accordion, AccordionItem, AccordionTrigger, AccordionContent }\n","size_bytes":1977},"client/src/components/ui/alert-dialog.tsx":{"content":"import * as React from \"react\"\nimport * as AlertDialogPrimitive from \"@radix-ui/react-alert-dialog\"\n\nimport { cn } from \"@/lib/utils\"\nimport { buttonVariants } from \"@/components/ui/button\"\n\nconst AlertDialog = AlertDialogPrimitive.Root\n\nconst AlertDialogTrigger = AlertDialogPrimitive.Trigger\n\nconst AlertDialogPortal = AlertDialogPrimitive.Portal\n\nconst AlertDialogOverlay = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Overlay\n    className={cn(\n      \"fixed inset-0 z-[9999999] bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  />\n))\nAlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName\n\nconst AlertDialogContent = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPortal>\n    <AlertDialogOverlay />\n    <AlertDialogPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed left-[50%] top-[50%] z-[9999999] grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\n        className\n      )}\n      {...props}\n    />\n  </AlertDialogPortal>\n))\nAlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName\n\nconst AlertDialogHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-2 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nAlertDialogHeader.displayName = \"AlertDialogHeader\"\n\nconst AlertDialogFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nAlertDialogFooter.displayName = \"AlertDialogFooter\"\n\nconst AlertDialogTitle = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Title\n    ref={ref}\n    className={cn(\"text-lg font-semibold\", className)}\n    {...props}\n  />\n))\nAlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName\n\nconst AlertDialogDescription = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nAlertDialogDescription.displayName =\n  AlertDialogPrimitive.Description.displayName\n\nconst AlertDialogAction = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Action>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Action\n    ref={ref}\n    className={cn(buttonVariants(), className)}\n    {...props}\n  />\n))\nAlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName\n\nconst AlertDialogCancel = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Cancel\n    ref={ref}\n    className={cn(\n      buttonVariants({ variant: \"outline\" }),\n      \"mt-2 sm:mt-0\",\n      className\n    )}\n    {...props}\n  />\n))\nAlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName\n\nexport {\n  AlertDialog,\n  AlertDialogPortal,\n  AlertDialogOverlay,\n  AlertDialogTrigger,\n  AlertDialogContent,\n  AlertDialogHeader,\n  AlertDialogFooter,\n  AlertDialogTitle,\n  AlertDialogDescription,\n  AlertDialogAction,\n  AlertDialogCancel,\n}\n","size_bytes":4434},"client/src/components/ui/alert.tsx":{"content":"import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst alertVariants = cva(\n  \"relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-background text-foreground\",\n        destructive:\n          \"border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nconst Alert = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>\n>(({ className, variant, ...props }, ref) => (\n  <div\n    ref={ref}\n    role=\"alert\"\n    className={cn(alertVariants({ variant }), className)}\n    {...props}\n  />\n))\nAlert.displayName = \"Alert\"\n\nconst AlertTitle = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLHeadingElement>\n>(({ className, ...props }, ref) => (\n  <h5\n    ref={ref}\n    className={cn(\"mb-1 font-medium leading-none tracking-tight\", className)}\n    {...props}\n  />\n))\nAlertTitle.displayName = \"AlertTitle\"\n\nconst AlertDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"text-sm [&_p]:leading-relaxed\", className)}\n    {...props}\n  />\n))\nAlertDescription.displayName = \"AlertDescription\"\n\nexport { Alert, AlertTitle, AlertDescription }\n","size_bytes":1584},"client/src/components/ui/aspect-ratio.tsx":{"content":"import * as AspectRatioPrimitive from \"@radix-ui/react-aspect-ratio\"\n\nconst AspectRatio = AspectRatioPrimitive.Root\n\nexport { AspectRatio }\n","size_bytes":140},"client/src/components/ui/avatar.tsx":{"content":"import * as React from \"react\"\nimport * as AvatarPrimitive from \"@radix-ui/react-avatar\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Avatar = React.forwardRef<\n  React.ElementRef<typeof AvatarPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <AvatarPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full\",\n      className\n    )}\n    {...props}\n  />\n))\nAvatar.displayName = AvatarPrimitive.Root.displayName\n\nconst AvatarImage = React.forwardRef<\n  React.ElementRef<typeof AvatarPrimitive.Image>,\n  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>\n>(({ className, ...props }, ref) => (\n  <AvatarPrimitive.Image\n    ref={ref}\n    className={cn(\"aspect-square h-full w-full\", className)}\n    {...props}\n  />\n))\nAvatarImage.displayName = AvatarPrimitive.Image.displayName\n\nconst AvatarFallback = React.forwardRef<\n  React.ElementRef<typeof AvatarPrimitive.Fallback>,\n  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>\n>(({ className, ...props }, ref) => (\n  <AvatarPrimitive.Fallback\n    ref={ref}\n    className={cn(\n      \"flex h-full w-full items-center justify-center rounded-full bg-muted\",\n      className\n    )}\n    {...props}\n  />\n))\nAvatarFallback.displayName = AvatarPrimitive.Fallback.displayName\n\nexport { Avatar, AvatarImage, AvatarFallback }\n","size_bytes":1405},"client/src/components/ui/badge.tsx":{"content":"import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst badgeVariants = cva(\n  \"inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"border-transparent bg-primary text-primary-foreground hover:bg-primary/80\",\n        secondary:\n          \"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        destructive:\n          \"border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80\",\n        outline: \"text-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nexport interface BadgeProps\n  extends React.HTMLAttributes<HTMLDivElement>,\n    VariantProps<typeof badgeVariants> {}\n\nfunction Badge({ className, variant, ...props }: BadgeProps) {\n  return (\n    <div className={cn(badgeVariants({ variant }), className)} {...props} />\n  )\n}\n\nexport { Badge, badgeVariants }\n","size_bytes":1128},"client/src/components/ui/breadcrumb.tsx":{"content":"import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { ChevronRight, MoreHorizontal } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Breadcrumb = React.forwardRef<\n  HTMLElement,\n  React.ComponentPropsWithoutRef<\"nav\"> & {\n    separator?: React.ReactNode\n  }\n>(({ ...props }, ref) => <nav ref={ref} aria-label=\"breadcrumb\" {...props} />)\nBreadcrumb.displayName = \"Breadcrumb\"\n\nconst BreadcrumbList = React.forwardRef<\n  HTMLOListElement,\n  React.ComponentPropsWithoutRef<\"ol\">\n>(({ className, ...props }, ref) => (\n  <ol\n    ref={ref}\n    className={cn(\n      \"flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5\",\n      className\n    )}\n    {...props}\n  />\n))\nBreadcrumbList.displayName = \"BreadcrumbList\"\n\nconst BreadcrumbItem = React.forwardRef<\n  HTMLLIElement,\n  React.ComponentPropsWithoutRef<\"li\">\n>(({ className, ...props }, ref) => (\n  <li\n    ref={ref}\n    className={cn(\"inline-flex items-center gap-1.5\", className)}\n    {...props}\n  />\n))\nBreadcrumbItem.displayName = \"BreadcrumbItem\"\n\nconst BreadcrumbLink = React.forwardRef<\n  HTMLAnchorElement,\n  React.ComponentPropsWithoutRef<\"a\"> & {\n    asChild?: boolean\n  }\n>(({ asChild, className, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"a\"\n\n  return (\n    <Comp\n      ref={ref}\n      className={cn(\"transition-colors hover:text-foreground\", className)}\n      {...props}\n    />\n  )\n})\nBreadcrumbLink.displayName = \"BreadcrumbLink\"\n\nconst BreadcrumbPage = React.forwardRef<\n  HTMLSpanElement,\n  React.ComponentPropsWithoutRef<\"span\">\n>(({ className, ...props }, ref) => (\n  <span\n    ref={ref}\n    role=\"link\"\n    aria-disabled=\"true\"\n    aria-current=\"page\"\n    className={cn(\"font-normal text-foreground\", className)}\n    {...props}\n  />\n))\nBreadcrumbPage.displayName = \"BreadcrumbPage\"\n\nconst BreadcrumbSeparator = ({\n  children,\n  className,\n  ...props\n}: React.ComponentProps<\"li\">) => (\n  <li\n    role=\"presentation\"\n    aria-hidden=\"true\"\n    className={cn(\"[&>svg]:w-3.5 [&>svg]:h-3.5\", className)}\n    {...props}\n  >\n    {children ?? <ChevronRight />}\n  </li>\n)\nBreadcrumbSeparator.displayName = \"BreadcrumbSeparator\"\n\nconst BreadcrumbEllipsis = ({\n  className,\n  ...props\n}: React.ComponentProps<\"span\">) => (\n  <span\n    role=\"presentation\"\n    aria-hidden=\"true\"\n    className={cn(\"flex h-9 w-9 items-center justify-center\", className)}\n    {...props}\n  >\n    <MoreHorizontal className=\"h-4 w-4\" />\n    <span className=\"sr-only\">More</span>\n  </span>\n)\nBreadcrumbEllipsis.displayName = \"BreadcrumbElipssis\"\n\nexport {\n  Breadcrumb,\n  BreadcrumbList,\n  BreadcrumbItem,\n  BreadcrumbLink,\n  BreadcrumbPage,\n  BreadcrumbSeparator,\n  BreadcrumbEllipsis,\n}\n","size_bytes":2712},"client/src/components/ui/button.tsx":{"content":"import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-primary text-primary-foreground hover:bg-primary/90\",\n        destructive:\n          \"bg-destructive text-destructive-foreground hover:bg-destructive/90\",\n        outline:\n          \"border border-input bg-background hover:bg-accent hover:text-accent-foreground\",\n        secondary:\n          \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        ghost: \"hover:bg-accent hover:text-accent-foreground\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-10 px-4 py-2\",\n        sm: \"h-9 rounded-md px-3\",\n        lg: \"h-11 rounded-md px-8\",\n        icon: \"h-10 w-10\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nexport interface ButtonProps\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\n    VariantProps<typeof buttonVariants> {\n  asChild?: boolean\n}\n\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\n    const Comp = asChild ? Slot : \"button\"\n    return (\n      <Comp\n        className={cn(buttonVariants({ variant, size, className }))}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nButton.displayName = \"Button\"\n\nexport { Button, buttonVariants }\n","size_bytes":1901},"client/src/components/ui/calendar.tsx":{"content":"import * as React from \"react\"\nimport { ChevronLeft, ChevronRight } from \"lucide-react\"\nimport { DayPicker } from \"react-day-picker\"\n\nimport { cn } from \"@/lib/utils\"\nimport { buttonVariants } from \"@/components/ui/button\"\n\nexport type CalendarProps = React.ComponentProps<typeof DayPicker>\n\nfunction Calendar({\n  className,\n  classNames,\n  showOutsideDays = true,\n  ...props\n}: CalendarProps) {\n  return (\n    <DayPicker\n      showOutsideDays={showOutsideDays}\n      className={cn(\"p-3\", className)}\n      classNames={{\n        months: \"flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0\",\n        month: \"space-y-4\",\n        caption: \"flex justify-center pt-1 relative items-center\",\n        caption_label: \"text-sm font-medium\",\n        nav: \"space-x-1 flex items-center\",\n        nav_button: cn(\n          buttonVariants({ variant: \"outline\" }),\n          \"h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100\"\n        ),\n        nav_button_previous: \"absolute left-1\",\n        nav_button_next: \"absolute right-1\",\n        table: \"w-full border-collapse space-y-1\",\n        head_row: \"flex\",\n        head_cell:\n          \"text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]\",\n        row: \"flex w-full mt-2\",\n        cell: \"h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20\",\n        day: cn(\n          buttonVariants({ variant: \"ghost\" }),\n          \"h-9 w-9 p-0 font-normal aria-selected:opacity-100\"\n        ),\n        day_range_end: \"day-range-end\",\n        day_selected:\n          \"bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground\",\n        day_today: \"bg-accent text-accent-foreground\",\n        day_outside:\n          \"day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30\",\n        day_disabled: \"text-muted-foreground opacity-50\",\n        day_range_middle:\n          \"aria-selected:bg-accent aria-selected:text-accent-foreground\",\n        day_hidden: \"invisible\",\n        ...classNames,\n      }}\n      components={{\n        IconLeft: ({ ...props }) => <ChevronLeft className=\"h-4 w-4\" />,\n        IconRight: ({ ...props }) => <ChevronRight className=\"h-4 w-4\" />,\n      }}\n      {...props}\n    />\n  )\n}\nCalendar.displayName = \"Calendar\"\n\nexport { Calendar }\n","size_bytes":2609},"client/src/components/ui/card.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Card = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\n      \"rounded-lg border bg-card text-card-foreground shadow-sm\",\n      className\n    )}\n    {...props}\n  />\n))\nCard.displayName = \"Card\"\n\nconst CardHeader = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex flex-col space-y-1.5 p-6\", className)}\n    {...props}\n  />\n))\nCardHeader.displayName = \"CardHeader\"\n\nconst CardTitle = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLHeadingElement>\n>(({ className, ...props }, ref) => (\n  <h3\n    ref={ref}\n    className={cn(\n      \"text-2xl font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nCardTitle.displayName = \"CardTitle\"\n\nconst CardDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => (\n  <p\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nCardDescription.displayName = \"CardDescription\"\n\nconst CardContent = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div ref={ref} className={cn(\"p-6 pt-0\", className)} {...props} />\n))\nCardContent.displayName = \"CardContent\"\n\nconst CardFooter = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex items-center p-6 pt-0\", className)}\n    {...props}\n  />\n))\nCardFooter.displayName = \"CardFooter\"\n\nexport { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }\n","size_bytes":1877},"client/src/components/ui/carousel.tsx":{"content":"import * as React from \"react\"\nimport useEmblaCarousel, {\n  type UseEmblaCarouselType,\n} from \"embla-carousel-react\"\nimport { ArrowLeft, ArrowRight } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\n\ntype CarouselApi = UseEmblaCarouselType[1]\ntype UseCarouselParameters = Parameters<typeof useEmblaCarousel>\ntype CarouselOptions = UseCarouselParameters[0]\ntype CarouselPlugin = UseCarouselParameters[1]\n\ntype CarouselProps = {\n  opts?: CarouselOptions\n  plugins?: CarouselPlugin\n  orientation?: \"horizontal\" | \"vertical\"\n  setApi?: (api: CarouselApi) => void\n}\n\ntype CarouselContextProps = {\n  carouselRef: ReturnType<typeof useEmblaCarousel>[0]\n  api: ReturnType<typeof useEmblaCarousel>[1]\n  scrollPrev: () => void\n  scrollNext: () => void\n  canScrollPrev: boolean\n  canScrollNext: boolean\n} & CarouselProps\n\nconst CarouselContext = React.createContext<CarouselContextProps | null>(null)\n\nfunction useCarousel() {\n  const context = React.useContext(CarouselContext)\n\n  if (!context) {\n    throw new Error(\"useCarousel must be used within a <Carousel />\")\n  }\n\n  return context\n}\n\nconst Carousel = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement> & CarouselProps\n>(\n  (\n    {\n      orientation = \"horizontal\",\n      opts,\n      setApi,\n      plugins,\n      className,\n      children,\n      ...props\n    },\n    ref\n  ) => {\n    const [carouselRef, api] = useEmblaCarousel(\n      {\n        ...opts,\n        axis: orientation === \"horizontal\" ? \"x\" : \"y\",\n      },\n      plugins\n    )\n    const [canScrollPrev, setCanScrollPrev] = React.useState(false)\n    const [canScrollNext, setCanScrollNext] = React.useState(false)\n\n    const onSelect = React.useCallback((api: CarouselApi) => {\n      if (!api) {\n        return\n      }\n\n      setCanScrollPrev(api.canScrollPrev())\n      setCanScrollNext(api.canScrollNext())\n    }, [])\n\n    const scrollPrev = React.useCallback(() => {\n      api?.scrollPrev()\n    }, [api])\n\n    const scrollNext = React.useCallback(() => {\n      api?.scrollNext()\n    }, [api])\n\n    const handleKeyDown = React.useCallback(\n      (event: React.KeyboardEvent<HTMLDivElement>) => {\n        if (event.key === \"ArrowLeft\") {\n          event.preventDefault()\n          scrollPrev()\n        } else if (event.key === \"ArrowRight\") {\n          event.preventDefault()\n          scrollNext()\n        }\n      },\n      [scrollPrev, scrollNext]\n    )\n\n    React.useEffect(() => {\n      if (!api || !setApi) {\n        return\n      }\n\n      setApi(api)\n    }, [api, setApi])\n\n    React.useEffect(() => {\n      if (!api) {\n        return\n      }\n\n      onSelect(api)\n      api.on(\"reInit\", onSelect)\n      api.on(\"select\", onSelect)\n\n      return () => {\n        api?.off(\"select\", onSelect)\n      }\n    }, [api, onSelect])\n\n    return (\n      <CarouselContext.Provider\n        value={{\n          carouselRef,\n          api: api,\n          opts,\n          orientation:\n            orientation || (opts?.axis === \"y\" ? \"vertical\" : \"horizontal\"),\n          scrollPrev,\n          scrollNext,\n          canScrollPrev,\n          canScrollNext,\n        }}\n      >\n        <div\n          ref={ref}\n          onKeyDownCapture={handleKeyDown}\n          className={cn(\"relative\", className)}\n          role=\"region\"\n          aria-roledescription=\"carousel\"\n          {...props}\n        >\n          {children}\n        </div>\n      </CarouselContext.Provider>\n    )\n  }\n)\nCarousel.displayName = \"Carousel\"\n\nconst CarouselContent = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const { carouselRef, orientation } = useCarousel()\n\n  return (\n    <div ref={carouselRef} className=\"overflow-hidden\">\n      <div\n        ref={ref}\n        className={cn(\n          \"flex\",\n          orientation === \"horizontal\" ? \"-ml-4\" : \"-mt-4 flex-col\",\n          className\n        )}\n        {...props}\n      />\n    </div>\n  )\n})\nCarouselContent.displayName = \"CarouselContent\"\n\nconst CarouselItem = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const { orientation } = useCarousel()\n\n  return (\n    <div\n      ref={ref}\n      role=\"group\"\n      aria-roledescription=\"slide\"\n      className={cn(\n        \"min-w-0 shrink-0 grow-0 basis-full\",\n        orientation === \"horizontal\" ? \"pl-4\" : \"pt-4\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nCarouselItem.displayName = \"CarouselItem\"\n\nconst CarouselPrevious = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<typeof Button>\n>(({ className, variant = \"outline\", size = \"icon\", ...props }, ref) => {\n  const { orientation, scrollPrev, canScrollPrev } = useCarousel()\n\n  return (\n    <Button\n      ref={ref}\n      variant={variant}\n      size={size}\n      className={cn(\n        \"absolute  h-8 w-8 rounded-full\",\n        orientation === \"horizontal\"\n          ? \"-left-12 top-1/2 -translate-y-1/2\"\n          : \"-top-12 left-1/2 -translate-x-1/2 rotate-90\",\n        className\n      )}\n      disabled={!canScrollPrev}\n      onClick={scrollPrev}\n      {...props}\n    >\n      <ArrowLeft className=\"h-4 w-4\" />\n      <span className=\"sr-only\">Previous slide</span>\n    </Button>\n  )\n})\nCarouselPrevious.displayName = \"CarouselPrevious\"\n\nconst CarouselNext = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<typeof Button>\n>(({ className, variant = \"outline\", size = \"icon\", ...props }, ref) => {\n  const { orientation, scrollNext, canScrollNext } = useCarousel()\n\n  return (\n    <Button\n      ref={ref}\n      variant={variant}\n      size={size}\n      className={cn(\n        \"absolute h-8 w-8 rounded-full\",\n        orientation === \"horizontal\"\n          ? \"-right-12 top-1/2 -translate-y-1/2\"\n          : \"-bottom-12 left-1/2 -translate-x-1/2 rotate-90\",\n        className\n      )}\n      disabled={!canScrollNext}\n      onClick={scrollNext}\n      {...props}\n    >\n      <ArrowRight className=\"h-4 w-4\" />\n      <span className=\"sr-only\">Next slide</span>\n    </Button>\n  )\n})\nCarouselNext.displayName = \"CarouselNext\"\n\nexport {\n  type CarouselApi,\n  Carousel,\n  CarouselContent,\n  CarouselItem,\n  CarouselPrevious,\n  CarouselNext,\n}\n","size_bytes":6210},"client/src/components/ui/chart.tsx":{"content":"import * as React from \"react\"\nimport * as RechartsPrimitive from \"recharts\"\n\nimport { cn } from \"@/lib/utils\"\n\n// Format: { THEME_NAME: CSS_SELECTOR }\nconst THEMES = { light: \"\", dark: \".dark\" } as const\n\nexport type ChartConfig = {\n  [k in string]: {\n    label?: React.ReactNode\n    icon?: React.ComponentType\n  } & (\n    | { color?: string; theme?: never }\n    | { color?: never; theme: Record<keyof typeof THEMES, string> }\n  )\n}\n\ntype ChartContextProps = {\n  config: ChartConfig\n}\n\nconst ChartContext = React.createContext<ChartContextProps | null>(null)\n\nfunction useChart() {\n  const context = React.useContext(ChartContext)\n\n  if (!context) {\n    throw new Error(\"useChart must be used within a <ChartContainer />\")\n  }\n\n  return context\n}\n\nconst ChartContainer = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & {\n    config: ChartConfig\n    children: React.ComponentProps<\n      typeof RechartsPrimitive.ResponsiveContainer\n    >[\"children\"]\n  }\n>(({ id, className, children, config, ...props }, ref) => {\n  const uniqueId = React.useId()\n  const chartId = `chart-${id || uniqueId.replace(/:/g, \"\")}`\n\n  return (\n    <ChartContext.Provider value={{ config }}>\n      <div\n        data-chart={chartId}\n        ref={ref}\n        className={cn(\n          \"flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none\",\n          className\n        )}\n        {...props}\n      >\n        <ChartStyle id={chartId} config={config} />\n        <RechartsPrimitive.ResponsiveContainer>\n          {children}\n        </RechartsPrimitive.ResponsiveContainer>\n      </div>\n    </ChartContext.Provider>\n  )\n})\nChartContainer.displayName = \"Chart\"\n\nconst ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {\n  const colorConfig = Object.entries(config).filter(\n    ([_, config]) => config.theme || config.color\n  )\n\n  if (!colorConfig.length) {\n    return null\n  }\n\n  return (\n    <style\n      dangerouslySetInnerHTML={{\n        __html: Object.entries(THEMES)\n          .map(\n            ([theme, prefix]) => `\n${prefix} [data-chart=${id}] {\n${colorConfig\n  .map(([key, itemConfig]) => {\n    const color =\n      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||\n      itemConfig.color\n    return color ? `  --color-${key}: ${color};` : null\n  })\n  .join(\"\\n\")}\n}\n`\n          )\n          .join(\"\\n\"),\n      }}\n    />\n  )\n}\n\nconst ChartTooltip = RechartsPrimitive.Tooltip\n\nconst ChartTooltipContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &\n    React.ComponentProps<\"div\"> & {\n      hideLabel?: boolean\n      hideIndicator?: boolean\n      indicator?: \"line\" | \"dot\" | \"dashed\"\n      nameKey?: string\n      labelKey?: string\n    }\n>(\n  (\n    {\n      active,\n      payload,\n      className,\n      indicator = \"dot\",\n      hideLabel = false,\n      hideIndicator = false,\n      label,\n      labelFormatter,\n      labelClassName,\n      formatter,\n      color,\n      nameKey,\n      labelKey,\n    },\n    ref\n  ) => {\n    const { config } = useChart()\n\n    const tooltipLabel = React.useMemo(() => {\n      if (hideLabel || !payload?.length) {\n        return null\n      }\n\n      const [item] = payload\n      const key = `${labelKey || item.dataKey || item.name || \"value\"}`\n      const itemConfig = getPayloadConfigFromPayload(config, item, key)\n      const value =\n        !labelKey && typeof label === \"string\"\n          ? config[label as keyof typeof config]?.label || label\n          : itemConfig?.label\n\n      if (labelFormatter) {\n        return (\n          <div className={cn(\"font-medium\", labelClassName)}>\n            {labelFormatter(value, payload)}\n          </div>\n        )\n      }\n\n      if (!value) {\n        return null\n      }\n\n      return <div className={cn(\"font-medium\", labelClassName)}>{value}</div>\n    }, [\n      label,\n      labelFormatter,\n      payload,\n      hideLabel,\n      labelClassName,\n      config,\n      labelKey,\n    ])\n\n    if (!active || !payload?.length) {\n      return null\n    }\n\n    const nestLabel = payload.length === 1 && indicator !== \"dot\"\n\n    return (\n      <div\n        ref={ref}\n        className={cn(\n          \"grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl\",\n          className\n        )}\n      >\n        {!nestLabel ? tooltipLabel : null}\n        <div className=\"grid gap-1.5\">\n          {payload.map((item, index) => {\n            const key = `${nameKey || item.name || item.dataKey || \"value\"}`\n            const itemConfig = getPayloadConfigFromPayload(config, item, key)\n            const indicatorColor = color || item.payload.fill || item.color\n\n            return (\n              <div\n                key={item.dataKey}\n                className={cn(\n                  \"flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground\",\n                  indicator === \"dot\" && \"items-center\"\n                )}\n              >\n                {formatter && item?.value !== undefined && item.name ? (\n                  formatter(item.value, item.name, item, index, item.payload)\n                ) : (\n                  <>\n                    {itemConfig?.icon ? (\n                      <itemConfig.icon />\n                    ) : (\n                      !hideIndicator && (\n                        <div\n                          className={cn(\n                            \"shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]\",\n                            {\n                              \"h-2.5 w-2.5\": indicator === \"dot\",\n                              \"w-1\": indicator === \"line\",\n                              \"w-0 border-[1.5px] border-dashed bg-transparent\":\n                                indicator === \"dashed\",\n                              \"my-0.5\": nestLabel && indicator === \"dashed\",\n                            }\n                          )}\n                          style={\n                            {\n                              \"--color-bg\": indicatorColor,\n                              \"--color-border\": indicatorColor,\n                            } as React.CSSProperties\n                          }\n                        />\n                      )\n                    )}\n                    <div\n                      className={cn(\n                        \"flex flex-1 justify-between leading-none\",\n                        nestLabel ? \"items-end\" : \"items-center\"\n                      )}\n                    >\n                      <div className=\"grid gap-1.5\">\n                        {nestLabel ? tooltipLabel : null}\n                        <span className=\"text-muted-foreground\">\n                          {itemConfig?.label || item.name}\n                        </span>\n                      </div>\n                      {item.value && (\n                        <span className=\"font-mono font-medium tabular-nums text-foreground\">\n                          {item.value.toLocaleString()}\n                        </span>\n                      )}\n                    </div>\n                  </>\n                )}\n              </div>\n            )\n          })}\n        </div>\n      </div>\n    )\n  }\n)\nChartTooltipContent.displayName = \"ChartTooltip\"\n\nconst ChartLegend = RechartsPrimitive.Legend\n\nconst ChartLegendContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> &\n    Pick<RechartsPrimitive.LegendProps, \"payload\" | \"verticalAlign\"> & {\n      hideIcon?: boolean\n      nameKey?: string\n    }\n>(\n  (\n    { className, hideIcon = false, payload, verticalAlign = \"bottom\", nameKey },\n    ref\n  ) => {\n    const { config } = useChart()\n\n    if (!payload?.length) {\n      return null\n    }\n\n    return (\n      <div\n        ref={ref}\n        className={cn(\n          \"flex items-center justify-center gap-4\",\n          verticalAlign === \"top\" ? \"pb-3\" : \"pt-3\",\n          className\n        )}\n      >\n        {payload.map((item) => {\n          const key = `${nameKey || item.dataKey || \"value\"}`\n          const itemConfig = getPayloadConfigFromPayload(config, item, key)\n\n          return (\n            <div\n              key={item.value}\n              className={cn(\n                \"flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground\"\n              )}\n            >\n              {itemConfig?.icon && !hideIcon ? (\n                <itemConfig.icon />\n              ) : (\n                <div\n                  className=\"h-2 w-2 shrink-0 rounded-[2px]\"\n                  style={{\n                    backgroundColor: item.color,\n                  }}\n                />\n              )}\n              {itemConfig?.label}\n            </div>\n          )\n        })}\n      </div>\n    )\n  }\n)\nChartLegendContent.displayName = \"ChartLegend\"\n\n// Helper to extract item config from a payload.\nfunction getPayloadConfigFromPayload(\n  config: ChartConfig,\n  payload: unknown,\n  key: string\n) {\n  if (typeof payload !== \"object\" || payload === null) {\n    return undefined\n  }\n\n  const payloadPayload =\n    \"payload\" in payload &&\n    typeof payload.payload === \"object\" &&\n    payload.payload !== null\n      ? payload.payload\n      : undefined\n\n  let configLabelKey: string = key\n\n  if (\n    key in payload &&\n    typeof payload[key as keyof typeof payload] === \"string\"\n  ) {\n    configLabelKey = payload[key as keyof typeof payload] as string\n  } else if (\n    payloadPayload &&\n    key in payloadPayload &&\n    typeof payloadPayload[key as keyof typeof payloadPayload] === \"string\"\n  ) {\n    configLabelKey = payloadPayload[\n      key as keyof typeof payloadPayload\n    ] as string\n  }\n\n  return configLabelKey in config\n    ? config[configLabelKey]\n    : config[key as keyof typeof config]\n}\n\nexport {\n  ChartContainer,\n  ChartTooltip,\n  ChartTooltipContent,\n  ChartLegend,\n  ChartLegendContent,\n  ChartStyle,\n}\n","size_bytes":10466},"client/src/components/ui/checkbox.tsx":{"content":"import * as React from \"react\"\nimport * as CheckboxPrimitive from \"@radix-ui/react-checkbox\"\nimport { Check } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Checkbox = React.forwardRef<\n  React.ElementRef<typeof CheckboxPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <CheckboxPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground\",\n      className\n    )}\n    {...props}\n  >\n    <CheckboxPrimitive.Indicator\n      className={cn(\"flex items-center justify-center text-current\")}\n    >\n      <Check className=\"h-4 w-4\" />\n    </CheckboxPrimitive.Indicator>\n  </CheckboxPrimitive.Root>\n))\nCheckbox.displayName = CheckboxPrimitive.Root.displayName\n\nexport { Checkbox }\n","size_bytes":1056},"client/src/components/ui/collapsible.tsx":{"content":"import * as CollapsiblePrimitive from \"@radix-ui/react-collapsible\"\n\nconst Collapsible = CollapsiblePrimitive.Root\n\nconst CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger\n\nconst CollapsibleContent = CollapsiblePrimitive.CollapsibleContent\n\nexport { Collapsible, CollapsibleTrigger, CollapsibleContent }\n","size_bytes":315},"client/src/components/ui/command.tsx":{"content":"import * as React from \"react\"\nimport { type DialogProps } from \"@radix-ui/react-dialog\"\nimport { Command as CommandPrimitive } from \"cmdk\"\nimport { Search } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Dialog, DialogContent } from \"@/components/ui/dialog\"\n\nconst Command = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive\n    ref={ref}\n    className={cn(\n      \"flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\nCommand.displayName = CommandPrimitive.displayName\n\ninterface CommandDialogProps extends DialogProps {}\n\nconst CommandDialog = ({ children, ...props }: CommandDialogProps) => {\n  return (\n    <Dialog {...props}>\n      <DialogContent className=\"overflow-hidden p-0 shadow-lg\">\n        <Command className=\"[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5\">\n          {children}\n        </Command>\n      </DialogContent>\n    </Dialog>\n  )\n}\n\nconst CommandInput = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Input>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>\n>(({ className, ...props }, ref) => (\n  <div className=\"flex items-center border-b px-3\" cmdk-input-wrapper=\"\">\n    <Search className=\"mr-2 h-4 w-4 shrink-0 opacity-50\" />\n    <CommandPrimitive.Input\n      ref={ref}\n      className={cn(\n        \"flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    />\n  </div>\n))\n\nCommandInput.displayName = CommandPrimitive.Input.displayName\n\nconst CommandList = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.List>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.List\n    ref={ref}\n    className={cn(\"max-h-[300px] overflow-y-auto overflow-x-hidden\", className)}\n    {...props}\n  />\n))\n\nCommandList.displayName = CommandPrimitive.List.displayName\n\nconst CommandEmpty = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Empty>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>\n>((props, ref) => (\n  <CommandPrimitive.Empty\n    ref={ref}\n    className=\"py-6 text-center text-sm\"\n    {...props}\n  />\n))\n\nCommandEmpty.displayName = CommandPrimitive.Empty.displayName\n\nconst CommandGroup = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Group>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Group\n    ref={ref}\n    className={cn(\n      \"overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\n\nCommandGroup.displayName = CommandPrimitive.Group.displayName\n\nconst CommandSeparator = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 h-px bg-border\", className)}\n    {...props}\n  />\n))\nCommandSeparator.displayName = CommandPrimitive.Separator.displayName\n\nconst CommandItem = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50\",\n      className\n    )}\n    {...props}\n  />\n))\n\nCommandItem.displayName = CommandPrimitive.Item.displayName\n\nconst CommandShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\n        \"ml-auto text-xs tracking-widest text-muted-foreground\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\nCommandShortcut.displayName = \"CommandShortcut\"\n\nexport {\n  Command,\n  CommandDialog,\n  CommandInput,\n  CommandList,\n  CommandEmpty,\n  CommandGroup,\n  CommandItem,\n  CommandShortcut,\n  CommandSeparator,\n}\n","size_bytes":4879},"client/src/components/ui/context-menu.tsx":{"content":"import * as React from \"react\"\nimport * as ContextMenuPrimitive from \"@radix-ui/react-context-menu\"\nimport { Check, ChevronRight, Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ContextMenu = ContextMenuPrimitive.Root\n\nconst ContextMenuTrigger = ContextMenuPrimitive.Trigger\n\nconst ContextMenuGroup = ContextMenuPrimitive.Group\n\nconst ContextMenuPortal = ContextMenuPrimitive.Portal\n\nconst ContextMenuSub = ContextMenuPrimitive.Sub\n\nconst ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup\n\nconst ContextMenuSubTrigger = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {\n    inset?: boolean\n  }\n>(({ className, inset, children, ...props }, ref) => (\n  <ContextMenuPrimitive.SubTrigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <ChevronRight className=\"ml-auto h-4 w-4\" />\n  </ContextMenuPrimitive.SubTrigger>\n))\nContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName\n\nconst ContextMenuSubContent = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>\n>(({ className, ...props }, ref) => (\n  <ContextMenuPrimitive.SubContent\n    ref={ref}\n    className={cn(\n      \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n      className\n    )}\n    {...props}\n  />\n))\nContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName\n\nconst ContextMenuContent = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <ContextMenuPrimitive.Portal>\n    <ContextMenuPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n        className\n      )}\n      {...props}\n    />\n  </ContextMenuPrimitive.Portal>\n))\nContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName\n\nconst ContextMenuItem = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <ContextMenuPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName\n\nconst ContextMenuCheckboxItem = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>\n>(({ className, children, checked, ...props }, ref) => (\n  <ContextMenuPrimitive.CheckboxItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    checked={checked}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <ContextMenuPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </ContextMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </ContextMenuPrimitive.CheckboxItem>\n))\nContextMenuCheckboxItem.displayName =\n  ContextMenuPrimitive.CheckboxItem.displayName\n\nconst ContextMenuRadioItem = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>\n>(({ className, children, ...props }, ref) => (\n  <ContextMenuPrimitive.RadioItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <ContextMenuPrimitive.ItemIndicator>\n        <Circle className=\"h-2 w-2 fill-current\" />\n      </ContextMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </ContextMenuPrimitive.RadioItem>\n))\nContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName\n\nconst ContextMenuLabel = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <ContextMenuPrimitive.Label\n    ref={ref}\n    className={cn(\n      \"px-2 py-1.5 text-sm font-semibold text-foreground\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName\n\nconst ContextMenuSeparator = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <ContextMenuPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-border\", className)}\n    {...props}\n  />\n))\nContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName\n\nconst ContextMenuShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\n        \"ml-auto text-xs tracking-widest text-muted-foreground\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\nContextMenuShortcut.displayName = \"ContextMenuShortcut\"\n\nexport {\n  ContextMenu,\n  ContextMenuTrigger,\n  ContextMenuContent,\n  ContextMenuItem,\n  ContextMenuCheckboxItem,\n  ContextMenuRadioItem,\n  ContextMenuLabel,\n  ContextMenuSeparator,\n  ContextMenuShortcut,\n  ContextMenuGroup,\n  ContextMenuPortal,\n  ContextMenuSub,\n  ContextMenuSubContent,\n  ContextMenuSubTrigger,\n  ContextMenuRadioGroup,\n}\n","size_bytes":7246},"client/src/components/ui/dialog.tsx":{"content":"import * as React from \"react\"\nimport * as DialogPrimitive from \"@radix-ui/react-dialog\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Dialog = DialogPrimitive.Root\n\nconst DialogTrigger = DialogPrimitive.Trigger\n\nconst DialogPortal = DialogPrimitive.Portal\n\nconst DialogClose = DialogPrimitive.Close\n\nconst DialogOverlay = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Overlay\n    ref={ref}\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n  />\n))\nDialogOverlay.displayName = DialogPrimitive.Overlay.displayName\n\nconst DialogContent = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <DialogPortal>\n    <DialogOverlay />\n    <DialogPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\n        className\n      )}\n      {...props}\n    >\n      {children}\n      <DialogPrimitive.Close className=\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground\">\n        <X className=\"h-4 w-4\" />\n        <span className=\"sr-only\">Close</span>\n      </DialogPrimitive.Close>\n    </DialogPrimitive.Content>\n  </DialogPortal>\n))\nDialogContent.displayName = DialogPrimitive.Content.displayName\n\nconst DialogHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-1.5 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogHeader.displayName = \"DialogHeader\"\n\nconst DialogFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogFooter.displayName = \"DialogFooter\"\n\nconst DialogTitle = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Title\n    ref={ref}\n    className={cn(\n      \"text-lg font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nDialogTitle.displayName = DialogPrimitive.Title.displayName\n\nconst DialogDescription = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nDialogDescription.displayName = DialogPrimitive.Description.displayName\n\nexport {\n  Dialog,\n  DialogPortal,\n  DialogOverlay,\n  DialogClose,\n  DialogTrigger,\n  DialogContent,\n  DialogHeader,\n  DialogFooter,\n  DialogTitle,\n  DialogDescription,\n}\n","size_bytes":3835},"client/src/components/ui/drawer.tsx":{"content":"import * as React from \"react\"\nimport { Drawer as DrawerPrimitive } from \"vaul\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Drawer = ({\n  shouldScaleBackground = true,\n  ...props\n}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (\n  <DrawerPrimitive.Root\n    shouldScaleBackground={shouldScaleBackground}\n    {...props}\n  />\n)\nDrawer.displayName = \"Drawer\"\n\nconst DrawerTrigger = DrawerPrimitive.Trigger\n\nconst DrawerPortal = DrawerPrimitive.Portal\n\nconst DrawerClose = DrawerPrimitive.Close\n\nconst DrawerOverlay = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <DrawerPrimitive.Overlay\n    ref={ref}\n    className={cn(\"fixed inset-0 z-50 bg-black/80\", className)}\n    {...props}\n  />\n))\nDrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName\n\nconst DrawerContent = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <DrawerPortal>\n    <DrawerOverlay />\n    <DrawerPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background\",\n        className\n      )}\n      {...props}\n    >\n      <div className=\"mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted\" />\n      {children}\n    </DrawerPrimitive.Content>\n  </DrawerPortal>\n))\nDrawerContent.displayName = \"DrawerContent\"\n\nconst DrawerHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\"grid gap-1.5 p-4 text-center sm:text-left\", className)}\n    {...props}\n  />\n)\nDrawerHeader.displayName = \"DrawerHeader\"\n\nconst DrawerFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\"mt-auto flex flex-col gap-2 p-4\", className)}\n    {...props}\n  />\n)\nDrawerFooter.displayName = \"DrawerFooter\"\n\nconst DrawerTitle = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <DrawerPrimitive.Title\n    ref={ref}\n    className={cn(\n      \"text-lg font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nDrawerTitle.displayName = DrawerPrimitive.Title.displayName\n\nconst DrawerDescription = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <DrawerPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nDrawerDescription.displayName = DrawerPrimitive.Description.displayName\n\nexport {\n  Drawer,\n  DrawerPortal,\n  DrawerOverlay,\n  DrawerTrigger,\n  DrawerClose,\n  DrawerContent,\n  DrawerHeader,\n  DrawerFooter,\n  DrawerTitle,\n  DrawerDescription,\n}\n","size_bytes":3007},"client/src/components/ui/dropdown-menu.tsx":{"content":"import * as React from \"react\"\nimport * as DropdownMenuPrimitive from \"@radix-ui/react-dropdown-menu\"\nimport { Check, ChevronRight, Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst DropdownMenu = DropdownMenuPrimitive.Root\n\nconst DropdownMenuTrigger = DropdownMenuPrimitive.Trigger\n\nconst DropdownMenuGroup = DropdownMenuPrimitive.Group\n\nconst DropdownMenuPortal = DropdownMenuPrimitive.Portal\n\nconst DropdownMenuSub = DropdownMenuPrimitive.Sub\n\nconst DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup\n\nconst DropdownMenuSubTrigger = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {\n    inset?: boolean\n  }\n>(({ className, inset, children, ...props }, ref) => (\n  <DropdownMenuPrimitive.SubTrigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <ChevronRight className=\"ml-auto h-4 w-4\" />\n  </DropdownMenuPrimitive.SubTrigger>\n))\nDropdownMenuSubTrigger.displayName =\n  DropdownMenuPrimitive.SubTrigger.displayName\n\nconst DropdownMenuSubContent = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>\n>(({ className, ...props }, ref) => (\n  <DropdownMenuPrimitive.SubContent\n    ref={ref}\n    className={cn(\n      \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n      className\n    )}\n    {...props}\n  />\n))\nDropdownMenuSubContent.displayName =\n  DropdownMenuPrimitive.SubContent.displayName\n\nconst DropdownMenuContent = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>\n>(({ className, sideOffset = 4, ...props }, ref) => (\n  <DropdownMenuPrimitive.Portal>\n    <DropdownMenuPrimitive.Content\n      ref={ref}\n      sideOffset={sideOffset}\n      className={cn(\n        \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n        className\n      )}\n      {...props}\n    />\n  </DropdownMenuPrimitive.Portal>\n))\nDropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName\n\nconst DropdownMenuItem = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <DropdownMenuPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nDropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName\n\nconst DropdownMenuCheckboxItem = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>\n>(({ className, children, checked, ...props }, ref) => (\n  <DropdownMenuPrimitive.CheckboxItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    checked={checked}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <DropdownMenuPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </DropdownMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </DropdownMenuPrimitive.CheckboxItem>\n))\nDropdownMenuCheckboxItem.displayName =\n  DropdownMenuPrimitive.CheckboxItem.displayName\n\nconst DropdownMenuRadioItem = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>\n>(({ className, children, ...props }, ref) => (\n  <DropdownMenuPrimitive.RadioItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <DropdownMenuPrimitive.ItemIndicator>\n        <Circle className=\"h-2 w-2 fill-current\" />\n      </DropdownMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </DropdownMenuPrimitive.RadioItem>\n))\nDropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName\n\nconst DropdownMenuLabel = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <DropdownMenuPrimitive.Label\n    ref={ref}\n    className={cn(\n      \"px-2 py-1.5 text-sm font-semibold\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nDropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName\n\nconst DropdownMenuSeparator = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <DropdownMenuPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nDropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName\n\nconst DropdownMenuShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\"ml-auto text-xs tracking-widest opacity-60\", className)}\n      {...props}\n    />\n  )\n}\nDropdownMenuShortcut.displayName = \"DropdownMenuShortcut\"\n\nexport {\n  DropdownMenu,\n  DropdownMenuTrigger,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuCheckboxItem,\n  DropdownMenuRadioItem,\n  DropdownMenuLabel,\n  DropdownMenuSeparator,\n  DropdownMenuShortcut,\n  DropdownMenuGroup,\n  DropdownMenuPortal,\n  DropdownMenuSub,\n  DropdownMenuSubContent,\n  DropdownMenuSubTrigger,\n  DropdownMenuRadioGroup,\n}\n","size_bytes":7361},"client/src/components/ui/form.tsx":{"content":"import * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport {\n  Controller,\n  ControllerProps,\n  FieldPath,\n  FieldValues,\n  FormProvider,\n  useFormContext,\n} from \"react-hook-form\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Label } from \"@/components/ui/label\"\n\nconst Form = FormProvider\n\ntype FormFieldContextValue<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>\n> = {\n  name: TName\n}\n\nconst FormFieldContext = React.createContext<FormFieldContextValue>(\n  {} as FormFieldContextValue\n)\n\nconst FormField = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>\n>({\n  ...props\n}: ControllerProps<TFieldValues, TName>) => {\n  return (\n    <FormFieldContext.Provider value={{ name: props.name }}>\n      <Controller {...props} />\n    </FormFieldContext.Provider>\n  )\n}\n\nconst useFormField = () => {\n  const fieldContext = React.useContext(FormFieldContext)\n  const itemContext = React.useContext(FormItemContext)\n  const { getFieldState, formState } = useFormContext()\n\n  const fieldState = getFieldState(fieldContext.name, formState)\n\n  if (!fieldContext) {\n    throw new Error(\"useFormField should be used within <FormField>\")\n  }\n\n  const { id } = itemContext\n\n  return {\n    id,\n    name: fieldContext.name,\n    formItemId: `${id}-form-item`,\n    formDescriptionId: `${id}-form-item-description`,\n    formMessageId: `${id}-form-item-message`,\n    ...fieldState,\n  }\n}\n\ntype FormItemContextValue = {\n  id: string\n}\n\nconst FormItemContext = React.createContext<FormItemContextValue>(\n  {} as FormItemContextValue\n)\n\nconst FormItem = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const id = React.useId()\n\n  return (\n    <FormItemContext.Provider value={{ id }}>\n      <div ref={ref} className={cn(\"space-y-2\", className)} {...props} />\n    </FormItemContext.Provider>\n  )\n})\nFormItem.displayName = \"FormItem\"\n\nconst FormLabel = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>\n>(({ className, ...props }, ref) => {\n  const { error, formItemId } = useFormField()\n\n  return (\n    <Label\n      ref={ref}\n      className={cn(error && \"text-destructive\", className)}\n      htmlFor={formItemId}\n      {...props}\n    />\n  )\n})\nFormLabel.displayName = \"FormLabel\"\n\nconst FormControl = React.forwardRef<\n  React.ElementRef<typeof Slot>,\n  React.ComponentPropsWithoutRef<typeof Slot>\n>(({ ...props }, ref) => {\n  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()\n\n  return (\n    <Slot\n      ref={ref}\n      id={formItemId}\n      aria-describedby={\n        !error\n          ? `${formDescriptionId}`\n          : `${formDescriptionId} ${formMessageId}`\n      }\n      aria-invalid={!!error}\n      {...props}\n    />\n  )\n})\nFormControl.displayName = \"FormControl\"\n\nconst FormDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => {\n  const { formDescriptionId } = useFormField()\n\n  return (\n    <p\n      ref={ref}\n      id={formDescriptionId}\n      className={cn(\"text-sm text-muted-foreground\", className)}\n      {...props}\n    />\n  )\n})\nFormDescription.displayName = \"FormDescription\"\n\nconst FormMessage = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, children, ...props }, ref) => {\n  const { error, formMessageId } = useFormField()\n  const body = error ? String(error?.message) : children\n\n  if (!body) {\n    return null\n  }\n\n  return (\n    <p\n      ref={ref}\n      id={formMessageId}\n      className={cn(\"text-sm font-medium text-destructive\", className)}\n      {...props}\n    >\n      {body}\n    </p>\n  )\n})\nFormMessage.displayName = \"FormMessage\"\n\nexport {\n  useFormField,\n  Form,\n  FormItem,\n  FormLabel,\n  FormControl,\n  FormDescription,\n  FormMessage,\n  FormField,\n}\n","size_bytes":4085},"client/src/components/ui/hover-card.tsx":{"content":"import * as React from \"react\"\nimport * as HoverCardPrimitive from \"@radix-ui/react-hover-card\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst HoverCard = HoverCardPrimitive.Root\n\nconst HoverCardTrigger = HoverCardPrimitive.Trigger\n\nconst HoverCardContent = React.forwardRef<\n  React.ElementRef<typeof HoverCardPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>\n>(({ className, align = \"center\", sideOffset = 4, ...props }, ref) => (\n  <HoverCardPrimitive.Content\n    ref={ref}\n    align={align}\n    sideOffset={sideOffset}\n    className={cn(\n      \"z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n      className\n    )}\n    {...props}\n  />\n))\nHoverCardContent.displayName = HoverCardPrimitive.Content.displayName\n\nexport { HoverCard, HoverCardTrigger, HoverCardContent }\n","size_bytes":1184},"client/src/components/ui/input-otp.tsx":{"content":"import * as React from \"react\"\nimport { OTPInput, OTPInputContext } from \"input-otp\"\nimport { Dot } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst InputOTP = React.forwardRef<\n  React.ElementRef<typeof OTPInput>,\n  React.ComponentPropsWithoutRef<typeof OTPInput>\n>(({ className, containerClassName, ...props }, ref) => (\n  <OTPInput\n    ref={ref}\n    containerClassName={cn(\n      \"flex items-center gap-2 has-[:disabled]:opacity-50\",\n      containerClassName\n    )}\n    className={cn(\"disabled:cursor-not-allowed\", className)}\n    {...props}\n  />\n))\nInputOTP.displayName = \"InputOTP\"\n\nconst InputOTPGroup = React.forwardRef<\n  React.ElementRef<\"div\">,\n  React.ComponentPropsWithoutRef<\"div\">\n>(({ className, ...props }, ref) => (\n  <div ref={ref} className={cn(\"flex items-center\", className)} {...props} />\n))\nInputOTPGroup.displayName = \"InputOTPGroup\"\n\nconst InputOTPSlot = React.forwardRef<\n  React.ElementRef<\"div\">,\n  React.ComponentPropsWithoutRef<\"div\"> & { index: number }\n>(({ index, className, ...props }, ref) => {\n  const inputOTPContext = React.useContext(OTPInputContext)\n  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index]\n\n  return (\n    <div\n      ref={ref}\n      className={cn(\n        \"relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md\",\n        isActive && \"z-10 ring-2 ring-ring ring-offset-background\",\n        className\n      )}\n      {...props}\n    >\n      {char}\n      {hasFakeCaret && (\n        <div className=\"pointer-events-none absolute inset-0 flex items-center justify-center\">\n          <div className=\"h-4 w-px animate-caret-blink bg-foreground duration-1000\" />\n        </div>\n      )}\n    </div>\n  )\n})\nInputOTPSlot.displayName = \"InputOTPSlot\"\n\nconst InputOTPSeparator = React.forwardRef<\n  React.ElementRef<\"div\">,\n  React.ComponentPropsWithoutRef<\"div\">\n>(({ ...props }, ref) => (\n  <div ref={ref} role=\"separator\" {...props}>\n    <Dot />\n  </div>\n))\nInputOTPSeparator.displayName = \"InputOTPSeparator\"\n\nexport { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }\n","size_bytes":2154},"client/src/components/ui/input.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nexport interface InputProps\n  extends React.InputHTMLAttributes<HTMLInputElement> {}\n\nconst Input = React.forwardRef<HTMLInputElement, InputProps>(\n  ({ className, type, ...props }, ref) => {\n    return (\n      <input\n        type={type}\n        className={cn(\n          \"flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n          className\n        )}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nInput.displayName = \"Input\"\n\nexport { Input }\n","size_bytes":845},"client/src/components/ui/label.tsx":{"content":"import * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst labelVariants = cva(\n  \"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\"\n)\n\nconst Label = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &\n    VariantProps<typeof labelVariants>\n>(({ className, ...props }, ref) => (\n  <LabelPrimitive.Root\n    ref={ref}\n    className={cn(labelVariants(), className)}\n    {...props}\n  />\n))\nLabel.displayName = LabelPrimitive.Root.displayName\n\nexport { Label }\n","size_bytes":710},"client/src/components/ui/loading-spinner.tsx":{"content":"import React from 'react';\n\ninterface LoadingSpinnerProps {\n  size?: 'sm' | 'md' | 'lg' | 'xl' | number;\n  className?: string;\n}\n\nconst LoadingSpinner: React.FC<LoadingSpinnerProps> = ({ \n  size = 'md', \n  className = '' \n}) => {\n  // Determinar el tamaño del spinner\n  const getSize = () => {\n    if (typeof size === 'number') {\n      return { width: size, height: size };\n    }\n    \n    switch (size) {\n      case 'sm': return { width: 16, height: 16 };\n      case 'md': return { width: 24, height: 24 };\n      case 'lg': return { width: 48, height: 48 };\n      case 'xl': return { width: 64, height: 64 };\n      default: return { width: 24, height: 24 };\n    }\n  };\n\n  const dimensions = getSize();\n\n  return (\n    <div \n      className={`inline-block animate-spin ${className}`}\n      style={dimensions}\n    >\n      <svg\n        className=\"w-full h-full\"\n        viewBox=\"0 0 24 24\"\n        fill=\"none\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n      >\n        <circle\n          className=\"opacity-25\"\n          cx=\"12\"\n          cy=\"12\"\n          r=\"10\"\n          stroke=\"#FCD34D\"\n          strokeWidth=\"4\"\n        />\n        <path\n          className=\"opacity-75\"\n          fill=\"#FCD34D\"\n          d=\"m12 2a10 10 0 0 1 10 10h-4a6 6 0 0 0-6-6V2z\"\n        />\n      </svg>\n    </div>\n  );\n};\n\nexport default LoadingSpinner;","size_bytes":1329},"client/src/components/ui/loading-wrapper.tsx":{"content":"import React from 'react';\nimport LoadingSpinner from './loading-spinner';\n\ninterface LoadingWrapperProps {\n  isLoading: boolean;\n  children: React.ReactNode;\n  size?: 'sm' | 'md' | 'lg' | 'xl' | number;\n  className?: string;\n  spinnerClassName?: string;\n}\n\nconst LoadingWrapper: React.FC<LoadingWrapperProps> = ({\n  isLoading,\n  children,\n  size = 'md',\n  className = '',\n  spinnerClassName = ''\n}) => {\n  if (isLoading) {\n    return (\n      <div className={`flex items-center justify-center ${className}`}>\n        <LoadingSpinner size={size} className={spinnerClassName} />\n      </div>\n    );\n  }\n\n  return <>{children}</>;\n};\n\nexport default LoadingWrapper;","size_bytes":662},"client/src/components/ui/menubar.tsx":{"content":"import * as React from \"react\"\nimport * as MenubarPrimitive from \"@radix-ui/react-menubar\"\nimport { Check, ChevronRight, Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst MenubarMenu = MenubarPrimitive.Menu\n\nconst MenubarGroup = MenubarPrimitive.Group\n\nconst MenubarPortal = MenubarPrimitive.Portal\n\nconst MenubarSub = MenubarPrimitive.Sub\n\nconst MenubarRadioGroup = MenubarPrimitive.RadioGroup\n\nconst Menubar = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"flex h-10 items-center space-x-1 rounded-md border bg-background p-1\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubar.displayName = MenubarPrimitive.Root.displayName\n\nconst MenubarTrigger = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName\n\nconst MenubarSubTrigger = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {\n    inset?: boolean\n  }\n>(({ className, inset, children, ...props }, ref) => (\n  <MenubarPrimitive.SubTrigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <ChevronRight className=\"ml-auto h-4 w-4\" />\n  </MenubarPrimitive.SubTrigger>\n))\nMenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName\n\nconst MenubarSubContent = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.SubContent>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.SubContent\n    ref={ref}\n    className={cn(\n      \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName\n\nconst MenubarContent = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>\n>(\n  (\n    { className, align = \"start\", alignOffset = -4, sideOffset = 8, ...props },\n    ref\n  ) => (\n    <MenubarPrimitive.Portal>\n      <MenubarPrimitive.Content\n        ref={ref}\n        align={align}\n        alignOffset={alignOffset}\n        sideOffset={sideOffset}\n        className={cn(\n          \"z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n          className\n        )}\n        {...props}\n      />\n    </MenubarPrimitive.Portal>\n  )\n)\nMenubarContent.displayName = MenubarPrimitive.Content.displayName\n\nconst MenubarItem = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <MenubarPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarItem.displayName = MenubarPrimitive.Item.displayName\n\nconst MenubarCheckboxItem = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>\n>(({ className, children, checked, ...props }, ref) => (\n  <MenubarPrimitive.CheckboxItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    checked={checked}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <MenubarPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </MenubarPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </MenubarPrimitive.CheckboxItem>\n))\nMenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName\n\nconst MenubarRadioItem = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.RadioItem>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>\n>(({ className, children, ...props }, ref) => (\n  <MenubarPrimitive.RadioItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <MenubarPrimitive.ItemIndicator>\n        <Circle className=\"h-2 w-2 fill-current\" />\n      </MenubarPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </MenubarPrimitive.RadioItem>\n))\nMenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName\n\nconst MenubarLabel = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <MenubarPrimitive.Label\n    ref={ref}\n    className={cn(\n      \"px-2 py-1.5 text-sm font-semibold\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarLabel.displayName = MenubarPrimitive.Label.displayName\n\nconst MenubarSeparator = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nMenubarSeparator.displayName = MenubarPrimitive.Separator.displayName\n\nconst MenubarShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\n        \"ml-auto text-xs tracking-widest text-muted-foreground\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\nMenubarShortcut.displayname = \"MenubarShortcut\"\n\nexport {\n  Menubar,\n  MenubarMenu,\n  MenubarTrigger,\n  MenubarContent,\n  MenubarItem,\n  MenubarSeparator,\n  MenubarLabel,\n  MenubarCheckboxItem,\n  MenubarRadioGroup,\n  MenubarRadioItem,\n  MenubarPortal,\n  MenubarSubContent,\n  MenubarSubTrigger,\n  MenubarGroup,\n  MenubarSub,\n  MenubarShortcut,\n}\n","size_bytes":7974},"client/src/components/ui/navigation-menu.tsx":{"content":"import * as React from \"react\"\nimport * as NavigationMenuPrimitive from \"@radix-ui/react-navigation-menu\"\nimport { cva } from \"class-variance-authority\"\nimport { ChevronDown } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst NavigationMenu = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>\n>(({ className, children, ...props }, ref) => (\n  <NavigationMenuPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative z-10 flex max-w-max flex-1 items-center justify-center\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <NavigationMenuViewport />\n  </NavigationMenuPrimitive.Root>\n))\nNavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName\n\nconst NavigationMenuList = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.List>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>\n>(({ className, ...props }, ref) => (\n  <NavigationMenuPrimitive.List\n    ref={ref}\n    className={cn(\n      \"group flex flex-1 list-none items-center justify-center space-x-1\",\n      className\n    )}\n    {...props}\n  />\n))\nNavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName\n\nconst NavigationMenuItem = NavigationMenuPrimitive.Item\n\nconst navigationMenuTriggerStyle = cva(\n  \"group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50\"\n)\n\nconst NavigationMenuTrigger = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <NavigationMenuPrimitive.Trigger\n    ref={ref}\n    className={cn(navigationMenuTriggerStyle(), \"group\", className)}\n    {...props}\n  >\n    {children}{\" \"}\n    <ChevronDown\n      className=\"relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180\"\n      aria-hidden=\"true\"\n    />\n  </NavigationMenuPrimitive.Trigger>\n))\nNavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName\n\nconst NavigationMenuContent = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <NavigationMenuPrimitive.Content\n    ref={ref}\n    className={cn(\n      \"left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto \",\n      className\n    )}\n    {...props}\n  />\n))\nNavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName\n\nconst NavigationMenuLink = NavigationMenuPrimitive.Link\n\nconst NavigationMenuViewport = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>\n>(({ className, ...props }, ref) => (\n  <div className={cn(\"absolute left-0 top-full flex justify-center\")}>\n    <NavigationMenuPrimitive.Viewport\n      className={cn(\n        \"origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]\",\n        className\n      )}\n      ref={ref}\n      {...props}\n    />\n  </div>\n))\nNavigationMenuViewport.displayName =\n  NavigationMenuPrimitive.Viewport.displayName\n\nconst NavigationMenuIndicator = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>\n>(({ className, ...props }, ref) => (\n  <NavigationMenuPrimitive.Indicator\n    ref={ref}\n    className={cn(\n      \"top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in\",\n      className\n    )}\n    {...props}\n  >\n    <div className=\"relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md\" />\n  </NavigationMenuPrimitive.Indicator>\n))\nNavigationMenuIndicator.displayName =\n  NavigationMenuPrimitive.Indicator.displayName\n\nexport {\n  navigationMenuTriggerStyle,\n  NavigationMenu,\n  NavigationMenuList,\n  NavigationMenuItem,\n  NavigationMenuContent,\n  NavigationMenuTrigger,\n  NavigationMenuLink,\n  NavigationMenuIndicator,\n  NavigationMenuViewport,\n}\n","size_bytes":5046},"client/src/components/ui/pagination.tsx":{"content":"import * as React from \"react\"\nimport { ChevronLeft, ChevronRight, MoreHorizontal } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { ButtonProps, buttonVariants } from \"@/components/ui/button\"\n\nconst Pagination = ({ className, ...props }: React.ComponentProps<\"nav\">) => (\n  <nav\n    role=\"navigation\"\n    aria-label=\"pagination\"\n    className={cn(\"mx-auto flex w-full justify-center\", className)}\n    {...props}\n  />\n)\nPagination.displayName = \"Pagination\"\n\nconst PaginationContent = React.forwardRef<\n  HTMLUListElement,\n  React.ComponentProps<\"ul\">\n>(({ className, ...props }, ref) => (\n  <ul\n    ref={ref}\n    className={cn(\"flex flex-row items-center gap-1\", className)}\n    {...props}\n  />\n))\nPaginationContent.displayName = \"PaginationContent\"\n\nconst PaginationItem = React.forwardRef<\n  HTMLLIElement,\n  React.ComponentProps<\"li\">\n>(({ className, ...props }, ref) => (\n  <li ref={ref} className={cn(\"\", className)} {...props} />\n))\nPaginationItem.displayName = \"PaginationItem\"\n\ntype PaginationLinkProps = {\n  isActive?: boolean\n} & Pick<ButtonProps, \"size\"> &\n  React.ComponentProps<\"a\">\n\nconst PaginationLink = ({\n  className,\n  isActive,\n  size = \"icon\",\n  ...props\n}: PaginationLinkProps) => (\n  <a\n    aria-current={isActive ? \"page\" : undefined}\n    className={cn(\n      buttonVariants({\n        variant: isActive ? \"outline\" : \"ghost\",\n        size,\n      }),\n      className\n    )}\n    {...props}\n  />\n)\nPaginationLink.displayName = \"PaginationLink\"\n\nconst PaginationPrevious = ({\n  className,\n  ...props\n}: React.ComponentProps<typeof PaginationLink>) => (\n  <PaginationLink\n    aria-label=\"Go to previous page\"\n    size=\"default\"\n    className={cn(\"gap-1 pl-2.5\", className)}\n    {...props}\n  >\n    <ChevronLeft className=\"h-4 w-4\" />\n    <span>Previous</span>\n  </PaginationLink>\n)\nPaginationPrevious.displayName = \"PaginationPrevious\"\n\nconst PaginationNext = ({\n  className,\n  ...props\n}: React.ComponentProps<typeof PaginationLink>) => (\n  <PaginationLink\n    aria-label=\"Go to next page\"\n    size=\"default\"\n    className={cn(\"gap-1 pr-2.5\", className)}\n    {...props}\n  >\n    <span>Next</span>\n    <ChevronRight className=\"h-4 w-4\" />\n  </PaginationLink>\n)\nPaginationNext.displayName = \"PaginationNext\"\n\nconst PaginationEllipsis = ({\n  className,\n  ...props\n}: React.ComponentProps<\"span\">) => (\n  <span\n    aria-hidden\n    className={cn(\"flex h-9 w-9 items-center justify-center\", className)}\n    {...props}\n  >\n    <MoreHorizontal className=\"h-4 w-4\" />\n    <span className=\"sr-only\">More pages</span>\n  </span>\n)\nPaginationEllipsis.displayName = \"PaginationEllipsis\"\n\nexport {\n  Pagination,\n  PaginationContent,\n  PaginationEllipsis,\n  PaginationItem,\n  PaginationLink,\n  PaginationNext,\n  PaginationPrevious,\n}\n","size_bytes":2751},"client/src/components/ui/popover.tsx":{"content":"import * as React from \"react\"\nimport * as PopoverPrimitive from \"@radix-ui/react-popover\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Popover = PopoverPrimitive.Root\n\nconst PopoverTrigger = PopoverPrimitive.Trigger\n\nconst PopoverContent = React.forwardRef<\n  React.ElementRef<typeof PopoverPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>\n>(({ className, align = \"center\", sideOffset = 4, ...props }, ref) => (\n  <PopoverPrimitive.Portal>\n    <PopoverPrimitive.Content\n      ref={ref}\n      align={align}\n      sideOffset={sideOffset}\n      className={cn(\n        \"z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n        className\n      )}\n      {...props}\n    />\n  </PopoverPrimitive.Portal>\n))\nPopoverContent.displayName = PopoverPrimitive.Content.displayName\n\nexport { Popover, PopoverTrigger, PopoverContent }\n","size_bytes":1230},"client/src/components/ui/progress.tsx":{"content":"import * as React from \"react\"\nimport * as ProgressPrimitive from \"@radix-ui/react-progress\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Progress = React.forwardRef<\n  React.ElementRef<typeof ProgressPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>\n>(({ className, value, ...props }, ref) => (\n  <ProgressPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative h-4 w-full overflow-hidden rounded-full bg-secondary\",\n      className\n    )}\n    {...props}\n  >\n    <ProgressPrimitive.Indicator\n      className=\"h-full w-full flex-1 bg-primary transition-all\"\n      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}\n    />\n  </ProgressPrimitive.Root>\n))\nProgress.displayName = ProgressPrimitive.Root.displayName\n\nexport { Progress }\n","size_bytes":777},"client/src/components/ui/radio-group.tsx":{"content":"import * as React from \"react\"\nimport * as RadioGroupPrimitive from \"@radix-ui/react-radio-group\"\nimport { Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst RadioGroup = React.forwardRef<\n  React.ElementRef<typeof RadioGroupPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>\n>(({ className, ...props }, ref) => {\n  return (\n    <RadioGroupPrimitive.Root\n      className={cn(\"grid gap-2\", className)}\n      {...props}\n      ref={ref}\n    />\n  )\n})\nRadioGroup.displayName = RadioGroupPrimitive.Root.displayName\n\nconst RadioGroupItem = React.forwardRef<\n  React.ElementRef<typeof RadioGroupPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>\n>(({ className, ...props }, ref) => {\n  return (\n    <RadioGroupPrimitive.Item\n      ref={ref}\n      className={cn(\n        \"aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    >\n      <RadioGroupPrimitive.Indicator className=\"flex items-center justify-center\">\n        <Circle className=\"h-2.5 w-2.5 fill-current text-current\" />\n      </RadioGroupPrimitive.Indicator>\n    </RadioGroupPrimitive.Item>\n  )\n})\nRadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName\n\nexport { RadioGroup, RadioGroupItem }\n","size_bytes":1467},"client/src/components/ui/resizable.tsx":{"content":"import { GripVertical } from \"lucide-react\"\nimport * as ResizablePrimitive from \"react-resizable-panels\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ResizablePanelGroup = ({\n  className,\n  ...props\n}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (\n  <ResizablePrimitive.PanelGroup\n    className={cn(\n      \"flex h-full w-full data-[panel-group-direction=vertical]:flex-col\",\n      className\n    )}\n    {...props}\n  />\n)\n\nconst ResizablePanel = ResizablePrimitive.Panel\n\nconst ResizableHandle = ({\n  withHandle,\n  className,\n  ...props\n}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {\n  withHandle?: boolean\n}) => (\n  <ResizablePrimitive.PanelResizeHandle\n    className={cn(\n      \"relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90\",\n      className\n    )}\n    {...props}\n  >\n    {withHandle && (\n      <div className=\"z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border\">\n        <GripVertical className=\"h-2.5 w-2.5\" />\n      </div>\n    )}\n  </ResizablePrimitive.PanelResizeHandle>\n)\n\nexport { ResizablePanelGroup, ResizablePanel, ResizableHandle }\n","size_bytes":1709},"client/src/components/ui/scroll-area.tsx":{"content":"import * as React from \"react\"\nimport * as ScrollAreaPrimitive from \"@radix-ui/react-scroll-area\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ScrollArea = React.forwardRef<\n  React.ElementRef<typeof ScrollAreaPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>\n>(({ className, children, ...props }, ref) => (\n  <ScrollAreaPrimitive.Root\n    ref={ref}\n    className={cn(\"relative overflow-hidden\", className)}\n    {...props}\n  >\n    <ScrollAreaPrimitive.Viewport className=\"h-full w-full rounded-[inherit]\">\n      {children}\n    </ScrollAreaPrimitive.Viewport>\n    <ScrollBar />\n    <ScrollAreaPrimitive.Corner />\n  </ScrollAreaPrimitive.Root>\n))\nScrollArea.displayName = ScrollAreaPrimitive.Root.displayName\n\nconst ScrollBar = React.forwardRef<\n  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,\n  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>\n>(({ className, orientation = \"vertical\", ...props }, ref) => (\n  <ScrollAreaPrimitive.ScrollAreaScrollbar\n    ref={ref}\n    orientation={orientation}\n    className={cn(\n      \"flex touch-none select-none transition-colors\",\n      orientation === \"vertical\" &&\n        \"h-full w-2.5 border-l border-l-transparent p-[1px]\",\n      orientation === \"horizontal\" &&\n        \"h-2.5 flex-col border-t border-t-transparent p-[1px]\",\n      className\n    )}\n    {...props}\n  >\n    <ScrollAreaPrimitive.ScrollAreaThumb className=\"relative flex-1 rounded-full bg-border\" />\n  </ScrollAreaPrimitive.ScrollAreaScrollbar>\n))\nScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName\n\nexport { ScrollArea, ScrollBar }\n","size_bytes":1642},"client/src/components/ui/select.tsx":{"content":"import * as React from \"react\"\nimport * as SelectPrimitive from \"@radix-ui/react-select\"\nimport { Check, ChevronDown, ChevronUp } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\n// Definimos primero la interfaz para extender Window\ndeclare global {\n  interface Window {\n    __PIPOL_UI_STATE: {\n      selectMenuOpen: boolean;\n      setSelectMenuOpen: (isOpen: boolean) => void;\n      preventPanelClose: boolean;\n    };\n  }\n}\n\n// Creamos una variable global para un store sencillo\n// Esto nos permitirá comunicar entre componentes sin props\nwindow.__PIPOL_UI_STATE = window.__PIPOL_UI_STATE || {\n  selectMenuOpen: false,\n  setSelectMenuOpen: (isOpen: boolean) => {\n    window.__PIPOL_UI_STATE.selectMenuOpen = isOpen;\n    console.log(`Estado global de menú select: ${isOpen ? 'ABIERTO' : 'CERRADO'}`);\n  },\n  preventPanelClose: false\n};\n\nconst Select = SelectPrimitive.Root\n\nconst SelectGroup = SelectPrimitive.Group\n\nconst SelectValue = SelectPrimitive.Value\n\nconst SelectTrigger = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <SelectPrimitive.Icon asChild>\n      <ChevronDown className=\"h-4 w-4 opacity-50\" />\n    </SelectPrimitive.Icon>\n  </SelectPrimitive.Trigger>\n))\nSelectTrigger.displayName = SelectPrimitive.Trigger.displayName\n\nconst SelectScrollUpButton = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.ScrollUpButton\n    ref={ref}\n    className={cn(\n      \"flex cursor-default items-center justify-center py-1\",\n      className\n    )}\n    {...props}\n  >\n    <ChevronUp className=\"h-4 w-4\" />\n  </SelectPrimitive.ScrollUpButton>\n))\nSelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName\n\nconst SelectScrollDownButton = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.ScrollDownButton\n    ref={ref}\n    className={cn(\n      \"flex cursor-default items-center justify-center py-1\",\n      className\n    )}\n    {...props}\n  >\n    <ChevronDown className=\"h-4 w-4\" />\n  </SelectPrimitive.ScrollDownButton>\n))\nSelectScrollDownButton.displayName =\n  SelectPrimitive.ScrollDownButton.displayName\n\nconst SelectContent = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>\n>(({ className, children, position = \"popper\", ...props }, ref) => {\n  // SOLUCIÓN DEFINITIVA PARA SELECT DROPDOWN\n  \n  React.useEffect(() => {\n    // Notificar a la app que un menú select está abierto\n    if (window.__PIPOL_UI_STATE) {\n      window.__PIPOL_UI_STATE.setSelectMenuOpen(true);\n      window.__PIPOL_UI_STATE.preventPanelClose = true;\n      \n      // Marcar todos los contenedores de dropdown y sus hijos para interceptar eventos\n      setTimeout(() => {\n        const contentWrappers = document.querySelectorAll('[data-radix-popper-content-wrapper]');\n        contentWrappers.forEach(wrapper => {\n          // Añadir atributo para identificación fácil\n          wrapper.setAttribute('data-pipol-dropdown', 'true');\n          \n          // Añadir clase para facilitar selección por CSS\n          wrapper.classList.add('pipol-dropdown-content');\n          \n          // CRÍTICO: Evitar propagación de eventos de mousedown\n          wrapper.addEventListener('mousedown', (e) => {\n            console.log('⚡ Evento mousedown capturado en dropdown wrapper');\n            e.stopPropagation();\n          }, true);\n          \n          // Capturar todos los eventos click\n          wrapper.addEventListener('click', (e) => {\n            console.log('⚡ Evento click capturado en dropdown wrapper');\n            e.stopPropagation();\n          }, true);\n          \n          // Aplicar a todos los elementos internos\n          const allChildren = wrapper.querySelectorAll('*');\n          allChildren.forEach(child => {\n            child.addEventListener('mousedown', (e) => {\n              e.stopPropagation();\n            }, true);\n          });\n          \n          // Añadir un overlay invisible que capture clics\n          const overlay = document.createElement('div');\n          overlay.style.position = 'fixed';\n          overlay.style.top = '0';\n          overlay.style.left = '0';\n          overlay.style.width = '100vw';\n          overlay.style.height = '100vh';\n          overlay.style.backgroundColor = 'transparent';\n          overlay.style.pointerEvents = 'none';\n          overlay.style.zIndex = '9998';\n          document.body.appendChild(overlay);\n          \n          // Después de un segundo, lo eliminamos\n          setTimeout(() => {\n            document.body.removeChild(overlay);\n          }, 1000);\n        });\n      }, 10);\n    }\n    \n    // Limpieza al desmontar\n    return () => {\n      if (window.__PIPOL_UI_STATE) {\n        window.__PIPOL_UI_STATE.setSelectMenuOpen(false);\n        \n        // Mantener el preventPanelClose por un tiempo después de cerrar\n        setTimeout(() => {\n          window.__PIPOL_UI_STATE.preventPanelClose = false;\n        }, 500);\n      }\n      \n      // Eliminar atributos de los elementos marcados\n      document.querySelectorAll('[data-pipol-dropdown]').forEach(el => {\n        el.removeAttribute('data-pipol-dropdown');\n      });\n    };\n  }, []);\n  \n  // Interceptar clics en todo el contenido\n  const handleContentInteraction = React.useCallback((e: React.MouseEvent) => {\n    e.stopPropagation();\n    console.log('⚡ Interacción interceptada en SelectContent');\n  }, []);\n  \n  return (\n    <SelectPrimitive.Portal>\n      <div \n        className=\"pipol-select-wrapper\"\n        style={{ \n          position: 'relative',\n          zIndex: 9999999,\n          pointerEvents: 'auto'\n        }}\n        onClick={handleContentInteraction}\n        onMouseDown={handleContentInteraction}\n      >\n        <SelectPrimitive.Content\n          ref={ref}\n          className={cn(\n            \"relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n            position === \"popper\" &&\n              \"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1\",\n            className\n          )}\n          position={position}\n          {...props}\n          onMouseDown={(e) => {\n            e.stopPropagation();\n            props.onMouseDown?.(e as any);\n          }}\n          onClick={(e) => {\n            e.stopPropagation(); \n            props.onClick?.(e as any);\n          }}\n          onPointerDownOutside={(e) => {\n            // Evitar que se cierre el panel cuando se hace clic fuera del dropdown\n            if (window.__PIPOL_UI_STATE) {\n              window.__PIPOL_UI_STATE.preventPanelClose = true;\n              setTimeout(() => {\n                window.__PIPOL_UI_STATE.preventPanelClose = false;\n              }, 500);\n            }\n            \n            // Ejecutar el manejador original si existe\n            props.onPointerDownOutside?.(e);\n          }}\n        >\n          <SelectScrollUpButton />\n          <SelectPrimitive.Viewport\n            className={cn(\n              \"p-1\",\n              position === \"popper\" &&\n                \"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]\"\n            )}\n            onClick={handleContentInteraction}\n            onMouseDown={handleContentInteraction}\n          >\n            {children}\n          </SelectPrimitive.Viewport>\n          <SelectScrollDownButton />\n        </SelectPrimitive.Content>\n      </div>\n    </SelectPrimitive.Portal>\n  );\n})\nSelectContent.displayName = SelectPrimitive.Content.displayName\n\nconst SelectLabel = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Label\n    ref={ref}\n    className={cn(\"py-1.5 pl-8 pr-2 text-sm font-semibold\", className)}\n    {...props}\n  />\n))\nSelectLabel.displayName = SelectPrimitive.Label.displayName\n\nconst SelectItem = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <SelectPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </SelectPrimitive.ItemIndicator>\n    </span>\n\n    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>\n  </SelectPrimitive.Item>\n))\nSelectItem.displayName = SelectPrimitive.Item.displayName\n\nconst SelectSeparator = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nSelectSeparator.displayName = SelectPrimitive.Separator.displayName\n\nexport {\n  Select,\n  SelectGroup,\n  SelectValue,\n  SelectTrigger,\n  SelectContent,\n  SelectLabel,\n  SelectItem,\n  SelectSeparator,\n  SelectScrollUpButton,\n  SelectScrollDownButton,\n}\n","size_bytes":10592},"client/src/components/ui/separator.tsx":{"content":"import * as React from \"react\"\nimport * as SeparatorPrimitive from \"@radix-ui/react-separator\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Separator = React.forwardRef<\n  React.ElementRef<typeof SeparatorPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>\n>(\n  (\n    { className, orientation = \"horizontal\", decorative = true, ...props },\n    ref\n  ) => (\n    <SeparatorPrimitive.Root\n      ref={ref}\n      decorative={decorative}\n      orientation={orientation}\n      className={cn(\n        \"shrink-0 bg-border\",\n        orientation === \"horizontal\" ? \"h-[1px] w-full\" : \"h-full w-[1px]\",\n        className\n      )}\n      {...props}\n    />\n  )\n)\nSeparator.displayName = SeparatorPrimitive.Root.displayName\n\nexport { Separator }\n","size_bytes":756},"client/src/components/ui/sheet.tsx":{"content":"import * as React from \"react\"\nimport * as SheetPrimitive from \"@radix-ui/react-dialog\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Sheet = SheetPrimitive.Root\n\nconst SheetTrigger = SheetPrimitive.Trigger\n\nconst SheetClose = SheetPrimitive.Close\n\nconst SheetPortal = SheetPrimitive.Portal\n\nconst SheetOverlay = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <SheetPrimitive.Overlay\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  />\n))\nSheetOverlay.displayName = SheetPrimitive.Overlay.displayName\n\nconst sheetVariants = cva(\n  \"fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500\",\n  {\n    variants: {\n      side: {\n        top: \"inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top\",\n        bottom:\n          \"inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom\",\n        left: \"inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm\",\n        right:\n          \"inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm\",\n      },\n    },\n    defaultVariants: {\n      side: \"right\",\n    },\n  }\n)\n\ninterface SheetContentProps\n  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,\n    VariantProps<typeof sheetVariants> {}\n\nconst SheetContent = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Content>,\n  SheetContentProps\n>(({ side = \"right\", className, children, ...props }, ref) => (\n  <SheetPortal>\n    <SheetOverlay />\n    <SheetPrimitive.Content\n      ref={ref}\n      className={cn(sheetVariants({ side }), className)}\n      {...props}\n    >\n      {children}\n      <SheetPrimitive.Close className=\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary\">\n        <X className=\"h-4 w-4\" />\n        <span className=\"sr-only\">Close</span>\n      </SheetPrimitive.Close>\n    </SheetPrimitive.Content>\n  </SheetPortal>\n))\nSheetContent.displayName = SheetPrimitive.Content.displayName\n\nconst SheetHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-2 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nSheetHeader.displayName = \"SheetHeader\"\n\nconst SheetFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nSheetFooter.displayName = \"SheetFooter\"\n\nconst SheetTitle = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <SheetPrimitive.Title\n    ref={ref}\n    className={cn(\"text-lg font-semibold text-foreground\", className)}\n    {...props}\n  />\n))\nSheetTitle.displayName = SheetPrimitive.Title.displayName\n\nconst SheetDescription = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <SheetPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nSheetDescription.displayName = SheetPrimitive.Description.displayName\n\nexport {\n  Sheet,\n  SheetPortal,\n  SheetOverlay,\n  SheetTrigger,\n  SheetClose,\n  SheetContent,\n  SheetHeader,\n  SheetFooter,\n  SheetTitle,\n  SheetDescription,\n}\n","size_bytes":4267},"client/src/components/ui/sidebar.tsx":{"content":"import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { VariantProps, cva } from \"class-variance-authority\"\nimport { PanelLeft } from \"lucide-react\"\n\nimport { useIsMobile } from \"@/hooks/use-mobile\"\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\nimport { Input } from \"@/components/ui/input\"\nimport { Separator } from \"@/components/ui/separator\"\nimport { Sheet, SheetContent } from \"@/components/ui/sheet\"\nimport { Skeleton } from \"@/components/ui/skeleton\"\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\"\n\nconst SIDEBAR_COOKIE_NAME = \"sidebar:state\"\nconst SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7\nconst SIDEBAR_WIDTH = \"16rem\"\nconst SIDEBAR_WIDTH_MOBILE = \"18rem\"\nconst SIDEBAR_WIDTH_ICON = \"3rem\"\nconst SIDEBAR_KEYBOARD_SHORTCUT = \"b\"\n\ntype SidebarContext = {\n  state: \"expanded\" | \"collapsed\"\n  open: boolean\n  setOpen: (open: boolean) => void\n  openMobile: boolean\n  setOpenMobile: (open: boolean) => void\n  isMobile: boolean\n  toggleSidebar: () => void\n}\n\nconst SidebarContext = React.createContext<SidebarContext | null>(null)\n\nfunction useSidebar() {\n  const context = React.useContext(SidebarContext)\n  if (!context) {\n    throw new Error(\"useSidebar must be used within a SidebarProvider.\")\n  }\n\n  return context\n}\n\nconst SidebarProvider = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & {\n    defaultOpen?: boolean\n    open?: boolean\n    onOpenChange?: (open: boolean) => void\n  }\n>(\n  (\n    {\n      defaultOpen = true,\n      open: openProp,\n      onOpenChange: setOpenProp,\n      className,\n      style,\n      children,\n      ...props\n    },\n    ref\n  ) => {\n    const isMobile = useIsMobile()\n    const [openMobile, setOpenMobile] = React.useState(false)\n\n    // This is the internal state of the sidebar.\n    // We use openProp and setOpenProp for control from outside the component.\n    const [_open, _setOpen] = React.useState(defaultOpen)\n    const open = openProp ?? _open\n    const setOpen = React.useCallback(\n      (value: boolean | ((value: boolean) => boolean)) => {\n        if (setOpenProp) {\n          return setOpenProp?.(\n            typeof value === \"function\" ? value(open) : value\n          )\n        }\n\n        _setOpen(value)\n\n        // This sets the cookie to keep the sidebar state.\n        document.cookie = `${SIDEBAR_COOKIE_NAME}=${open}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`\n      },\n      [setOpenProp, open]\n    )\n\n    // Helper to toggle the sidebar.\n    const toggleSidebar = React.useCallback(() => {\n      return isMobile\n        ? setOpenMobile((open) => !open)\n        : setOpen((open) => !open)\n    }, [isMobile, setOpen, setOpenMobile])\n\n    // Adds a keyboard shortcut to toggle the sidebar.\n    React.useEffect(() => {\n      const handleKeyDown = (event: KeyboardEvent) => {\n        if (\n          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&\n          (event.metaKey || event.ctrlKey)\n        ) {\n          event.preventDefault()\n          toggleSidebar()\n        }\n      }\n\n      window.addEventListener(\"keydown\", handleKeyDown)\n      return () => window.removeEventListener(\"keydown\", handleKeyDown)\n    }, [toggleSidebar])\n\n    // We add a state so that we can do data-state=\"expanded\" or \"collapsed\".\n    // This makes it easier to style the sidebar with Tailwind classes.\n    const state = open ? \"expanded\" : \"collapsed\"\n\n    const contextValue = React.useMemo<SidebarContext>(\n      () => ({\n        state,\n        open,\n        setOpen,\n        isMobile,\n        openMobile,\n        setOpenMobile,\n        toggleSidebar,\n      }),\n      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]\n    )\n\n    return (\n      <SidebarContext.Provider value={contextValue}>\n        <TooltipProvider delayDuration={0}>\n          <div\n            style={\n              {\n                \"--sidebar-width\": SIDEBAR_WIDTH,\n                \"--sidebar-width-icon\": SIDEBAR_WIDTH_ICON,\n                ...style,\n              } as React.CSSProperties\n            }\n            className={cn(\n              \"group/sidebar-wrapper flex min-h-svh w-full text-sidebar-foreground has-[[data-variant=inset]]:bg-sidebar\",\n              className\n            )}\n            ref={ref}\n            {...props}\n          >\n            {children}\n          </div>\n        </TooltipProvider>\n      </SidebarContext.Provider>\n    )\n  }\n)\nSidebarProvider.displayName = \"SidebarProvider\"\n\nconst Sidebar = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & {\n    side?: \"left\" | \"right\"\n    variant?: \"sidebar\" | \"floating\" | \"inset\"\n    collapsible?: \"offcanvas\" | \"icon\" | \"none\"\n  }\n>(\n  (\n    {\n      side = \"left\",\n      variant = \"sidebar\",\n      collapsible = \"offcanvas\",\n      className,\n      children,\n      ...props\n    },\n    ref\n  ) => {\n    const { isMobile, state, openMobile, setOpenMobile } = useSidebar()\n\n    if (collapsible === \"none\") {\n      return (\n        <div\n          className={cn(\n            \"flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground\",\n            className\n          )}\n          ref={ref}\n          {...props}\n        >\n          {children}\n        </div>\n      )\n    }\n\n    if (isMobile) {\n      return (\n        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>\n          <SheetContent\n            data-sidebar=\"sidebar\"\n            data-mobile=\"true\"\n            className=\"w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden\"\n            style={\n              {\n                \"--sidebar-width\": SIDEBAR_WIDTH_MOBILE,\n              } as React.CSSProperties\n            }\n            side={side}\n          >\n            <div className=\"flex h-full w-full flex-col\">{children}</div>\n          </SheetContent>\n        </Sheet>\n      )\n    }\n\n    return (\n      <div\n        ref={ref}\n        className=\"group peer hidden md:block\"\n        data-state={state}\n        data-collapsible={state === \"collapsed\" ? collapsible : \"\"}\n        data-variant={variant}\n        data-side={side}\n      >\n        {/* This is what handles the sidebar gap on desktop */}\n        <div\n          className={cn(\n            \"duration-200 relative h-svh w-[--sidebar-width] bg-transparent transition-[width] ease-linear\",\n            \"group-data-[collapsible=offcanvas]:w-0\",\n            \"group-data-[side=right]:rotate-180\",\n            variant === \"floating\" || variant === \"inset\"\n              ? \"group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]\"\n              : \"group-data-[collapsible=icon]:w-[--sidebar-width-icon]\"\n          )}\n        />\n        <div\n          className={cn(\n            \"duration-200 fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] ease-linear md:flex\",\n            side === \"left\"\n              ? \"left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]\"\n              : \"right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]\",\n            // Adjust the padding for floating and inset variants.\n            variant === \"floating\" || variant === \"inset\"\n              ? \"p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]\"\n              : \"group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l\",\n            className\n          )}\n          {...props}\n        >\n          <div\n            data-sidebar=\"sidebar\"\n            className=\"flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow\"\n          >\n            {children}\n          </div>\n        </div>\n      </div>\n    )\n  }\n)\nSidebar.displayName = \"Sidebar\"\n\nconst SidebarTrigger = React.forwardRef<\n  React.ElementRef<typeof Button>,\n  React.ComponentProps<typeof Button>\n>(({ className, onClick, ...props }, ref) => {\n  const { toggleSidebar } = useSidebar()\n\n  return (\n    <Button\n      ref={ref}\n      data-sidebar=\"trigger\"\n      variant=\"ghost\"\n      size=\"icon\"\n      className={cn(\"h-7 w-7\", className)}\n      onClick={(event) => {\n        onClick?.(event)\n        toggleSidebar()\n      }}\n      {...props}\n    >\n      <PanelLeft />\n      <span className=\"sr-only\">Toggle Sidebar</span>\n    </Button>\n  )\n})\nSidebarTrigger.displayName = \"SidebarTrigger\"\n\nconst SidebarRail = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<\"button\">\n>(({ className, ...props }, ref) => {\n  const { toggleSidebar } = useSidebar()\n\n  return (\n    <button\n      ref={ref}\n      data-sidebar=\"rail\"\n      aria-label=\"Toggle Sidebar\"\n      tabIndex={-1}\n      onClick={toggleSidebar}\n      title=\"Toggle Sidebar\"\n      className={cn(\n        \"absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex\",\n        \"[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize\",\n        \"[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize\",\n        \"group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar\",\n        \"[[data-side=left][data-collapsible=offcanvas]_&]:-right-2\",\n        \"[[data-side=right][data-collapsible=offcanvas]_&]:-left-2\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarRail.displayName = \"SidebarRail\"\n\nconst SidebarInset = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"main\">\n>(({ className, ...props }, ref) => {\n  return (\n    <main\n      ref={ref}\n      className={cn(\n        \"relative flex min-h-svh flex-1 flex-col bg-background\",\n        \"peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarInset.displayName = \"SidebarInset\"\n\nconst SidebarInput = React.forwardRef<\n  React.ElementRef<typeof Input>,\n  React.ComponentProps<typeof Input>\n>(({ className, ...props }, ref) => {\n  return (\n    <Input\n      ref={ref}\n      data-sidebar=\"input\"\n      className={cn(\n        \"h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarInput.displayName = \"SidebarInput\"\n\nconst SidebarHeader = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"header\"\n      className={cn(\"flex flex-col gap-2 p-2\", className)}\n      {...props}\n    />\n  )\n})\nSidebarHeader.displayName = \"SidebarHeader\"\n\nconst SidebarFooter = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"footer\"\n      className={cn(\"flex flex-col gap-2 p-2\", className)}\n      {...props}\n    />\n  )\n})\nSidebarFooter.displayName = \"SidebarFooter\"\n\nconst SidebarSeparator = React.forwardRef<\n  React.ElementRef<typeof Separator>,\n  React.ComponentProps<typeof Separator>\n>(({ className, ...props }, ref) => {\n  return (\n    <Separator\n      ref={ref}\n      data-sidebar=\"separator\"\n      className={cn(\"mx-2 w-auto bg-sidebar-border\", className)}\n      {...props}\n    />\n  )\n})\nSidebarSeparator.displayName = \"SidebarSeparator\"\n\nconst SidebarContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"content\"\n      className={cn(\n        \"flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarContent.displayName = \"SidebarContent\"\n\nconst SidebarGroup = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"group\"\n      className={cn(\"relative flex w-full min-w-0 flex-col p-2\", className)}\n      {...props}\n    />\n  )\n})\nSidebarGroup.displayName = \"SidebarGroup\"\n\nconst SidebarGroupLabel = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & { asChild?: boolean }\n>(({ className, asChild = false, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"div\"\n\n  return (\n    <Comp\n      ref={ref}\n      data-sidebar=\"group-label\"\n      className={cn(\n        \"duration-200 flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opa] ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0\",\n        \"group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarGroupLabel.displayName = \"SidebarGroupLabel\"\n\nconst SidebarGroupAction = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<\"button\"> & { asChild?: boolean }\n>(({ className, asChild = false, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      ref={ref}\n      data-sidebar=\"group-action\"\n      className={cn(\n        \"absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0\",\n        // Increases the hit area of the button on mobile.\n        \"after:absolute after:-inset-2 after:md:hidden\",\n        \"group-data-[collapsible=icon]:hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarGroupAction.displayName = \"SidebarGroupAction\"\n\nconst SidebarGroupContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    data-sidebar=\"group-content\"\n    className={cn(\"w-full text-sm\", className)}\n    {...props}\n  />\n))\nSidebarGroupContent.displayName = \"SidebarGroupContent\"\n\nconst SidebarMenu = React.forwardRef<\n  HTMLUListElement,\n  React.ComponentProps<\"ul\">\n>(({ className, ...props }, ref) => (\n  <ul\n    ref={ref}\n    data-sidebar=\"menu\"\n    className={cn(\"flex w-full min-w-0 flex-col gap-1\", className)}\n    {...props}\n  />\n))\nSidebarMenu.displayName = \"SidebarMenu\"\n\nconst SidebarMenuItem = React.forwardRef<\n  HTMLLIElement,\n  React.ComponentProps<\"li\">\n>(({ className, ...props }, ref) => (\n  <li\n    ref={ref}\n    data-sidebar=\"menu-item\"\n    className={cn(\"group/menu-item relative\", className)}\n    {...props}\n  />\n))\nSidebarMenuItem.displayName = \"SidebarMenuItem\"\n\nconst sidebarMenuButtonVariants = cva(\n  \"peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0\",\n  {\n    variants: {\n      variant: {\n        default: \"hover:bg-sidebar-accent hover:text-sidebar-accent-foreground\",\n        outline:\n          \"bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]\",\n      },\n      size: {\n        default: \"h-8 text-sm\",\n        sm: \"h-7 text-xs\",\n        lg: \"h-12 text-sm group-data-[collapsible=icon]:!p-0\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nconst SidebarMenuButton = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<\"button\"> & {\n    asChild?: boolean\n    isActive?: boolean\n    tooltip?: string | React.ComponentProps<typeof TooltipContent>\n  } & VariantProps<typeof sidebarMenuButtonVariants>\n>(\n  (\n    {\n      asChild = false,\n      isActive = false,\n      variant = \"default\",\n      size = \"default\",\n      tooltip,\n      className,\n      ...props\n    },\n    ref\n  ) => {\n    const Comp = asChild ? Slot : \"button\"\n    const { isMobile, state } = useSidebar()\n\n    const button = (\n      <Comp\n        ref={ref}\n        data-sidebar=\"menu-button\"\n        data-size={size}\n        data-active={isActive}\n        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}\n        {...props}\n      />\n    )\n\n    if (!tooltip) {\n      return button\n    }\n\n    if (typeof tooltip === \"string\") {\n      tooltip = {\n        children: tooltip,\n      }\n    }\n\n    return (\n      <Tooltip>\n        <TooltipTrigger asChild>{button}</TooltipTrigger>\n        <TooltipContent\n          side=\"right\"\n          align=\"center\"\n          hidden={state !== \"collapsed\" || isMobile}\n          {...tooltip}\n        />\n      </Tooltip>\n    )\n  }\n)\nSidebarMenuButton.displayName = \"SidebarMenuButton\"\n\nconst SidebarMenuAction = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<\"button\"> & {\n    asChild?: boolean\n    showOnHover?: boolean\n  }\n>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      ref={ref}\n      data-sidebar=\"menu-action\"\n      className={cn(\n        \"absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0\",\n        // Increases the hit area of the button on mobile.\n        \"after:absolute after:-inset-2 after:md:hidden\",\n        \"peer-data-[size=sm]/menu-button:top-1\",\n        \"peer-data-[size=default]/menu-button:top-1.5\",\n        \"peer-data-[size=lg]/menu-button:top-2.5\",\n        \"group-data-[collapsible=icon]:hidden\",\n        showOnHover &&\n          \"group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarMenuAction.displayName = \"SidebarMenuAction\"\n\nconst SidebarMenuBadge = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    data-sidebar=\"menu-badge\"\n    className={cn(\n      \"absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground select-none pointer-events-none\",\n      \"peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground\",\n      \"peer-data-[size=sm]/menu-button:top-1\",\n      \"peer-data-[size=default]/menu-button:top-1.5\",\n      \"peer-data-[size=lg]/menu-button:top-2.5\",\n      \"group-data-[collapsible=icon]:hidden\",\n      className\n    )}\n    {...props}\n  />\n))\nSidebarMenuBadge.displayName = \"SidebarMenuBadge\"\n\nconst SidebarMenuSkeleton = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & {\n    showIcon?: boolean\n  }\n>(({ className, showIcon = false, ...props }, ref) => {\n  // Random width between 50 to 90%.\n  const width = React.useMemo(() => {\n    return `${Math.floor(Math.random() * 40) + 50}%`\n  }, [])\n\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"menu-skeleton\"\n      className={cn(\"rounded-md h-8 flex gap-2 px-2 items-center\", className)}\n      {...props}\n    >\n      {showIcon && (\n        <Skeleton\n          className=\"size-4 rounded-md\"\n          data-sidebar=\"menu-skeleton-icon\"\n        />\n      )}\n      <Skeleton\n        className=\"h-4 flex-1 max-w-[--skeleton-width]\"\n        data-sidebar=\"menu-skeleton-text\"\n        style={\n          {\n            \"--skeleton-width\": width,\n          } as React.CSSProperties\n        }\n      />\n    </div>\n  )\n})\nSidebarMenuSkeleton.displayName = \"SidebarMenuSkeleton\"\n\nconst SidebarMenuSub = React.forwardRef<\n  HTMLUListElement,\n  React.ComponentProps<\"ul\">\n>(({ className, ...props }, ref) => (\n  <ul\n    ref={ref}\n    data-sidebar=\"menu-sub\"\n    className={cn(\n      \"mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5\",\n      \"group-data-[collapsible=icon]:hidden\",\n      className\n    )}\n    {...props}\n  />\n))\nSidebarMenuSub.displayName = \"SidebarMenuSub\"\n\nconst SidebarMenuSubItem = React.forwardRef<\n  HTMLLIElement,\n  React.ComponentProps<\"li\">\n>(({ ...props }, ref) => <li ref={ref} {...props} />)\nSidebarMenuSubItem.displayName = \"SidebarMenuSubItem\"\n\nconst SidebarMenuSubButton = React.forwardRef<\n  HTMLAnchorElement,\n  React.ComponentProps<\"a\"> & {\n    asChild?: boolean\n    size?: \"sm\" | \"md\"\n    isActive?: boolean\n  }\n>(({ asChild = false, size = \"md\", isActive, className, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"a\"\n\n  return (\n    <Comp\n      ref={ref}\n      data-sidebar=\"menu-sub-button\"\n      data-size={size}\n      data-active={isActive}\n      className={cn(\n        \"flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground\",\n        \"data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground\",\n        size === \"sm\" && \"text-xs\",\n        size === \"md\" && \"text-sm\",\n        \"group-data-[collapsible=icon]:hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarMenuSubButton.displayName = \"SidebarMenuSubButton\"\n\nexport {\n  Sidebar,\n  SidebarContent,\n  SidebarFooter,\n  SidebarGroup,\n  SidebarGroupAction,\n  SidebarGroupContent,\n  SidebarGroupLabel,\n  SidebarHeader,\n  SidebarInput,\n  SidebarInset,\n  SidebarMenu,\n  SidebarMenuAction,\n  SidebarMenuBadge,\n  SidebarMenuButton,\n  SidebarMenuItem,\n  SidebarMenuSkeleton,\n  SidebarMenuSub,\n  SidebarMenuSubButton,\n  SidebarMenuSubItem,\n  SidebarProvider,\n  SidebarRail,\n  SidebarSeparator,\n  SidebarTrigger,\n  useSidebar,\n}\n","size_bytes":23337},"client/src/components/ui/skeleton.tsx":{"content":"import { cn } from \"@/lib/utils\"\n\nfunction Skeleton({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) {\n  return (\n    <div\n      className={cn(\"animate-pulse rounded-md bg-muted\", className)}\n      {...props}\n    />\n  )\n}\n\nexport { Skeleton }\n","size_bytes":261},"client/src/components/ui/slider.tsx":{"content":"import * as React from \"react\"\nimport * as SliderPrimitive from \"@radix-ui/react-slider\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Slider = React.forwardRef<\n  React.ElementRef<typeof SliderPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <SliderPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative flex w-full touch-none select-none items-center\",\n      className\n    )}\n    {...props}\n  >\n    <SliderPrimitive.Track className=\"relative h-2 w-full grow overflow-hidden rounded-full bg-secondary\">\n      <SliderPrimitive.Range className=\"absolute h-full bg-primary\" />\n    </SliderPrimitive.Track>\n    <SliderPrimitive.Thumb className=\"block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\" />\n  </SliderPrimitive.Root>\n))\nSlider.displayName = SliderPrimitive.Root.displayName\n\nexport { Slider }\n","size_bytes":1077},"client/src/components/ui/switch.tsx":{"content":"import * as React from \"react\"\nimport * as SwitchPrimitives from \"@radix-ui/react-switch\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Switch = React.forwardRef<\n  React.ElementRef<typeof SwitchPrimitives.Root>,\n  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>\n>(({ className, ...props }, ref) => (\n  <SwitchPrimitives.Root\n    className={cn(\n      \"peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  >\n    <SwitchPrimitives.Thumb\n      className={cn(\n        \"pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0\"\n      )}\n    />\n  </SwitchPrimitives.Root>\n))\nSwitch.displayName = SwitchPrimitives.Root.displayName\n\nexport { Switch }\n","size_bytes":1139},"client/src/components/ui/table.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Table = React.forwardRef<\n  HTMLTableElement,\n  React.HTMLAttributes<HTMLTableElement>\n>(({ className, ...props }, ref) => (\n  <div className=\"relative w-full overflow-auto\">\n    <table\n      ref={ref}\n      className={cn(\"w-full caption-bottom text-sm\", className)}\n      {...props}\n    />\n  </div>\n))\nTable.displayName = \"Table\"\n\nconst TableHeader = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <thead ref={ref} className={cn(\"[&_tr]:border-b\", className)} {...props} />\n))\nTableHeader.displayName = \"TableHeader\"\n\nconst TableBody = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <tbody\n    ref={ref}\n    className={cn(\"[&_tr:last-child]:border-0\", className)}\n    {...props}\n  />\n))\nTableBody.displayName = \"TableBody\"\n\nconst TableFooter = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <tfoot\n    ref={ref}\n    className={cn(\n      \"border-t bg-muted/50 font-medium [&>tr]:last:border-b-0\",\n      className\n    )}\n    {...props}\n  />\n))\nTableFooter.displayName = \"TableFooter\"\n\nconst TableRow = React.forwardRef<\n  HTMLTableRowElement,\n  React.HTMLAttributes<HTMLTableRowElement>\n>(({ className, ...props }, ref) => (\n  <tr\n    ref={ref}\n    className={cn(\n      \"border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted\",\n      className\n    )}\n    {...props}\n  />\n))\nTableRow.displayName = \"TableRow\"\n\nconst TableHead = React.forwardRef<\n  HTMLTableCellElement,\n  React.ThHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n  <th\n    ref={ref}\n    className={cn(\n      \"h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0\",\n      className\n    )}\n    {...props}\n  />\n))\nTableHead.displayName = \"TableHead\"\n\nconst TableCell = React.forwardRef<\n  HTMLTableCellElement,\n  React.TdHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n  <td\n    ref={ref}\n    className={cn(\"p-4 align-middle [&:has([role=checkbox])]:pr-0\", className)}\n    {...props}\n  />\n))\nTableCell.displayName = \"TableCell\"\n\nconst TableCaption = React.forwardRef<\n  HTMLTableCaptionElement,\n  React.HTMLAttributes<HTMLTableCaptionElement>\n>(({ className, ...props }, ref) => (\n  <caption\n    ref={ref}\n    className={cn(\"mt-4 text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nTableCaption.displayName = \"TableCaption\"\n\nexport {\n  Table,\n  TableHeader,\n  TableBody,\n  TableFooter,\n  TableHead,\n  TableRow,\n  TableCell,\n  TableCaption,\n}\n","size_bytes":2765},"client/src/components/ui/tabs.tsx":{"content":"import * as React from \"react\"\nimport * as TabsPrimitive from \"@radix-ui/react-tabs\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Tabs = TabsPrimitive.Root\n\nconst TabsList = React.forwardRef<\n  React.ElementRef<typeof TabsPrimitive.List>,\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>\n>(({ className, ...props }, ref) => (\n  <TabsPrimitive.List\n    ref={ref}\n    className={cn(\n      \"inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\nTabsList.displayName = TabsPrimitive.List.displayName\n\nconst TabsTrigger = React.forwardRef<\n  React.ElementRef<typeof TabsPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>\n>(({ className, ...props }, ref) => (\n  <TabsPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm\",\n      className\n    )}\n    {...props}\n  />\n))\nTabsTrigger.displayName = TabsPrimitive.Trigger.displayName\n\nconst TabsContent = React.forwardRef<\n  React.ElementRef<typeof TabsPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <TabsPrimitive.Content\n    ref={ref}\n    className={cn(\n      \"mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\",\n      className\n    )}\n    {...props}\n  />\n))\nTabsContent.displayName = TabsPrimitive.Content.displayName\n\nexport { Tabs, TabsList, TabsTrigger, TabsContent }\n","size_bytes":1883},"client/src/components/ui/textarea.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nexport interface TextareaProps\n  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}\n\nconst Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(\n  ({ className, ...props }, ref) => {\n    return (\n      <textarea\n        className={cn(\n          \"flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n          className\n        )}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nTextarea.displayName = \"Textarea\"\n\nexport { Textarea }\n","size_bytes":772},"client/src/components/ui/toast.tsx":{"content":"import * as React from \"react\"\nimport * as ToastPrimitives from \"@radix-ui/react-toast\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ToastProvider = ToastPrimitives.Provider\n\nconst ToastViewport = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Viewport>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Viewport\n    ref={ref}\n    className={cn(\n      \"fixed top-0 z-[9999999] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]\",\n      className\n    )}\n    {...props}\n  />\n))\nToastViewport.displayName = ToastPrimitives.Viewport.displayName\n\nconst toastVariants = cva(\n  \"group pointer-events-none relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full\",\n  {\n    variants: {\n      variant: {\n        default: \"border bg-background text-foreground\",\n        destructive:\n          \"destructive group border-destructive bg-destructive text-destructive-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nconst Toast = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Root>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &\n    VariantProps<typeof toastVariants>\n>(({ className, variant, ...props }, ref) => {\n  return (\n    <ToastPrimitives.Root\n      ref={ref}\n      className={cn(toastVariants({ variant }), className)}\n      {...props}\n    />\n  )\n})\nToast.displayName = ToastPrimitives.Root.displayName\n\nconst ToastAction = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Action>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Action\n    ref={ref}\n    className={cn(\n      \"inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive\",\n      className\n    )}\n    {...props}\n  />\n))\nToastAction.displayName = ToastPrimitives.Action.displayName\n\nconst ToastClose = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Close>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Close\n    ref={ref}\n    className={cn(\n      \"absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600 pointer-events-auto\",\n      className\n    )}\n    toast-close=\"\"\n    {...props}\n  >\n    <X className=\"h-4 w-4\" />\n  </ToastPrimitives.Close>\n))\nToastClose.displayName = ToastPrimitives.Close.displayName\n\nconst ToastTitle = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Title>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Title\n    ref={ref}\n    className={cn(\"text-sm font-semibold\", className)}\n    {...props}\n  />\n))\nToastTitle.displayName = ToastPrimitives.Title.displayName\n\nconst ToastDescription = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Description>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Description\n    ref={ref}\n    className={cn(\"text-sm opacity-90\", className)}\n    {...props}\n  />\n))\nToastDescription.displayName = ToastPrimitives.Description.displayName\n\ntype ToastProps = React.ComponentPropsWithoutRef<typeof Toast>\n\ntype ToastActionElement = React.ReactElement<typeof ToastAction>\n\nexport {\n  type ToastProps,\n  type ToastActionElement,\n  ToastProvider,\n  ToastViewport,\n  Toast,\n  ToastTitle,\n  ToastDescription,\n  ToastClose,\n  ToastAction,\n}\n","size_bytes":4869},"client/src/components/ui/toaster.tsx":{"content":"import { useToast } from \"@/hooks/use-toast\"\nimport {\n  Toast,\n  ToastClose,\n  ToastDescription,\n  ToastProvider,\n  ToastTitle,\n  ToastViewport,\n} from \"@/components/ui/toast\"\n\nexport function Toaster() {\n  const { toasts } = useToast()\n\n  return (\n    <ToastProvider>\n      {toasts.map(function ({ id, title, description, action, ...props }) {\n        return (\n          <Toast key={id} {...props}>\n            <div className=\"grid gap-1\">\n              {title && <ToastTitle>{title}</ToastTitle>}\n              {description && (\n                <ToastDescription>{description}</ToastDescription>\n              )}\n            </div>\n            {action}\n            <ToastClose />\n          </Toast>\n        )\n      })}\n      <ToastViewport />\n    </ToastProvider>\n  )\n}\n","size_bytes":772},"client/src/components/ui/toggle-group.tsx":{"content":"import * as React from \"react\"\nimport * as ToggleGroupPrimitive from \"@radix-ui/react-toggle-group\"\nimport { type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\nimport { toggleVariants } from \"@/components/ui/toggle\"\n\nconst ToggleGroupContext = React.createContext<\n  VariantProps<typeof toggleVariants>\n>({\n  size: \"default\",\n  variant: \"default\",\n})\n\nconst ToggleGroup = React.forwardRef<\n  React.ElementRef<typeof ToggleGroupPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &\n    VariantProps<typeof toggleVariants>\n>(({ className, variant, size, children, ...props }, ref) => (\n  <ToggleGroupPrimitive.Root\n    ref={ref}\n    className={cn(\"flex items-center justify-center gap-1\", className)}\n    {...props}\n  >\n    <ToggleGroupContext.Provider value={{ variant, size }}>\n      {children}\n    </ToggleGroupContext.Provider>\n  </ToggleGroupPrimitive.Root>\n))\n\nToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName\n\nconst ToggleGroupItem = React.forwardRef<\n  React.ElementRef<typeof ToggleGroupPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &\n    VariantProps<typeof toggleVariants>\n>(({ className, children, variant, size, ...props }, ref) => {\n  const context = React.useContext(ToggleGroupContext)\n\n  return (\n    <ToggleGroupPrimitive.Item\n      ref={ref}\n      className={cn(\n        toggleVariants({\n          variant: context.variant || variant,\n          size: context.size || size,\n        }),\n        className\n      )}\n      {...props}\n    >\n      {children}\n    </ToggleGroupPrimitive.Item>\n  )\n})\n\nToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName\n\nexport { ToggleGroup, ToggleGroupItem }\n","size_bytes":1739},"client/src/components/ui/toggle.tsx":{"content":"import * as React from \"react\"\nimport * as TogglePrimitive from \"@radix-ui/react-toggle\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst toggleVariants = cva(\n  \"inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-transparent\",\n        outline:\n          \"border border-input bg-transparent hover:bg-accent hover:text-accent-foreground\",\n      },\n      size: {\n        default: \"h-10 px-3\",\n        sm: \"h-9 px-2.5\",\n        lg: \"h-11 px-5\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nconst Toggle = React.forwardRef<\n  React.ElementRef<typeof TogglePrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &\n    VariantProps<typeof toggleVariants>\n>(({ className, variant, size, ...props }, ref) => (\n  <TogglePrimitive.Root\n    ref={ref}\n    className={cn(toggleVariants({ variant, size, className }))}\n    {...props}\n  />\n))\n\nToggle.displayName = TogglePrimitive.Root.displayName\n\nexport { Toggle, toggleVariants }\n","size_bytes":1435},"client/src/components/ui/tooltip.tsx":{"content":"import * as React from \"react\"\nimport * as TooltipPrimitive from \"@radix-ui/react-tooltip\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst TooltipProvider = TooltipPrimitive.Provider\n\nconst Tooltip = TooltipPrimitive.Root\n\nconst TooltipTrigger = TooltipPrimitive.Trigger\n\nconst TooltipContent = React.forwardRef<\n  React.ElementRef<typeof TooltipPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>\n>(({ className, sideOffset = 4, ...props }, ref) => (\n  <TooltipPrimitive.Content\n    ref={ref}\n    sideOffset={sideOffset}\n    className={cn(\n      \"z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n      className\n    )}\n    {...props}\n  />\n))\nTooltipContent.displayName = TooltipPrimitive.Content.displayName\n\nexport { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }\n","size_bytes":1145},"client/src/components/users/user-profile-panel.tsx":{"content":"import React, { useEffect, useRef, useState } from 'react';\nimport { motion, AnimatePresence } from 'framer-motion';\nimport { X, User, Calendar, Mail, MessageSquare, UserPlus, UserCheck, Star } from 'lucide-react';\nimport { Avatar } from '@/components/ui/avatar';\nimport { Button } from '@/components/ui/button';\nimport { useUserProfile } from '@/contexts/user-profile-context';\nimport { formatDate } from '@/lib/utils';\nimport { apiRequest } from '@/lib/queryClient';\nimport { useAuth } from '@/hooks/use-auth';\nimport { useToast } from '@/hooks/use-toast';\n\nexport default function UserProfilePanel() {\n  const { selectedUser, isProfileOpen, hideUserProfile } = useUserProfile();\n  const { user: currentUser } = useAuth();\n  const { toast } = useToast();\n  const panelRef = useRef<HTMLDivElement>(null);\n  const [userInterests, setUserInterests] = useState<string[]>([]);\n  const [isLoadingInterests, setIsLoadingInterests] = useState(false);\n  const [userAura, setUserAura] = useState<{ aura: number; count: number } | null>(null);\n  const [canRate, setCanRate] = useState<{ canRate: boolean; reason?: string } | null>(null);\n  const [isRating, setIsRating] = useState(false);\n  const [selectedRating, setSelectedRating] = useState(0);\n\n  // Handle click outside to close\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (panelRef.current && !panelRef.current.contains(event.target as Node)) {\n        hideUserProfile();\n      }\n    };\n\n    if (isProfileOpen) {\n      document.addEventListener('mousedown', handleClickOutside);\n    }\n\n    return () => {\n      document.removeEventListener('mousedown', handleClickOutside);\n    };\n  }, [isProfileOpen, hideUserProfile]);\n\n  // Fetch user data when profile opens\n  useEffect(() => {\n    if (isProfileOpen && selectedUser) {\n      fetchUserInterests();\n      fetchUserAura();\n      if (!isOwnProfile) {\n        checkCanRate();\n      }\n    }\n  }, [isProfileOpen, selectedUser]);\n\n  const fetchUserInterests = async () => {\n    if (!selectedUser) return;\n    \n    try {\n      setIsLoadingInterests(true);\n      const response = await apiRequest(\"GET\", `/api/users/${selectedUser.id}/interests`);\n      if (response.ok) {\n        const data = await response.json();\n        setUserInterests(data.interests || []);\n      }\n    } catch (error) {\n      console.error('Error fetching user interests:', error);\n    } finally {\n      setIsLoadingInterests(false);\n    }\n  };\n\n  const handleSendMessage = () => {\n    // TODO: Implementar funcionalidad de enviar mensaje\n    toast({\n      title: \"Próximamente\",\n      description: \"La función de mensajes se implementará pronto\",\n    });\n  };\n\n  const fetchUserAura = async () => {\n    if (!selectedUser) return;\n    \n    try {\n      const response = await apiRequest(\"GET\", `/api/users/${selectedUser.id}/aura`);\n      if (response.ok) {\n        const data = await response.json();\n        setUserAura(data);\n      }\n    } catch (error) {\n      console.error('Error fetching user aura:', error);\n    }\n  };\n\n  const checkCanRate = async () => {\n    if (!selectedUser) return;\n    \n    try {\n      const response = await apiRequest(\"GET\", `/api/users/${selectedUser.id}/can-rate`);\n      if (response.ok) {\n        const data = await response.json();\n        setCanRate(data);\n      }\n    } catch (error) {\n      console.error('Error checking rating eligibility:', error);\n    }\n  };\n\n  const handleRateUser = async (rating: number) => {\n    if (!selectedUser || isRating) return;\n    \n    try {\n      setIsRating(true);\n      const response = await apiRequest(\"POST\", `/api/users/${selectedUser.id}/rate`, {\n        rating\n      });\n      \n      if (response.ok) {\n        toast({\n          title: \"Rating enviado\",\n          description: `Has dado ${rating}/10 aura a ${selectedUser.name}`,\n        });\n        \n        // Refresh aura and can rate status\n        fetchUserAura();\n        checkCanRate();\n        setSelectedRating(0);\n      } else {\n        const errorData = await response.json();\n        toast({\n          title: \"Error\",\n          description: errorData.message || \"No se pudo enviar el rating\",\n          variant: \"destructive\",\n        });\n      }\n    } catch (error) {\n      toast({\n        title: \"Error\",\n        description: \"Error al enviar el rating\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setIsRating(false);\n    }\n  };\n\n  const handleAddFriend = () => {\n    // TODO: Implementar funcionalidad de agregar amigo\n    toast({\n      title: \"Próximamente\", \n      description: \"La función de amigos se implementará pronto\",\n    });\n  };\n\n  // Función para traducir categorías al español\n  const translateCategory = (category: string): string => {\n    const translations: Record<string, string> = {\n      social: 'Social',\n      music: 'Música',\n      spiritual: 'Espiritual',\n      education: 'Educación',\n      sports: 'Deportes',\n      food: 'Comida',\n      art: 'Arte',\n      technology: 'Tecnología',\n      games: 'Juegos',\n      outdoor: 'Aire libre',\n      networking: 'Networking',\n      workshop: 'Talleres',\n      conference: 'Conferencias',\n      party: 'Fiestas',\n      fair: 'Ferias',\n      exhibition: 'Exposiciones'\n    };\n    return translations[category] || category;\n  };\n\n  if (!selectedUser) return null;\n\n  const isOwnProfile = currentUser?.id === selectedUser.id;\n\n  return (\n    <AnimatePresence>\n      {isProfileOpen && (\n        <motion.div\n          initial={{ opacity: 0 }}\n          animate={{ opacity: 1 }}\n          exit={{ opacity: 0 }}\n          transition={{ duration: 0.2 }}\n          className=\"fixed inset-0 bg-black/60 backdrop-blur-sm z-[99999] flex items-center justify-center p-4\"\n        >\n          <motion.div\n            ref={panelRef}\n            initial={{ opacity: 0, y: 20, scale: 0.95 }}\n            animate={{ opacity: 1, y: 0, scale: 1 }}\n            exit={{ opacity: 0, y: 20, scale: 0.95 }}\n            transition={{ delay: 0.1, duration: 0.3 }}\n            className=\"bg-white/10 backdrop-blur-lg rounded-2xl max-w-md w-full max-h-[80vh] overflow-hidden shadow-2xl border border-white/20 pointer-events-auto\"\n          >\n            {/* Header with glassy effect */}\n            <motion.div\n              initial={{ y: -20, opacity: 0 }}\n              animate={{ y: 0, opacity: 1 }}\n              transition={{ delay: 0.1, duration: 0.3 }}\n              className=\"flex items-center justify-between p-6 border-b border-white/10 bg-white/5\"\n            >\n              <h2 className=\"text-xl font-semibold text-white\">Perfil de Usuario</h2>\n              <button\n                onClick={hideUserProfile}\n                className=\"p-2 hover:bg-white/20 rounded-full transition-all duration-200 text-white/80 hover:text-white\"\n              >\n                <X className=\"w-5 h-5\" />\n              </button>\n            </motion.div>\n\n            {/* Profile Content */}\n            <div className=\"p-6 space-y-6 overflow-y-auto max-h-[calc(80vh-80px)]\">\n              {/* Avatar and Basic Info */}\n              <motion.div\n                initial={{ y: 20, opacity: 0 }}\n                animate={{ y: 0, opacity: 1 }}\n                transition={{ delay: 0.2, duration: 0.3 }}\n                className=\"flex flex-col items-center text-center space-y-4\"\n              >\n                <Avatar className=\"w-24 h-24 border-4 border-white/20\">\n                  {selectedUser.avatar ? (\n                    <img\n                      src={selectedUser.avatar}\n                      alt={selectedUser.name}\n                      className=\"w-full h-full object-cover\"\n                    />\n                  ) : (\n                    <div className=\"w-full h-full bg-gradient-to-br from-purple-500 to-pink-500 flex items-center justify-center text-white text-2xl font-bold\">\n                      {selectedUser.name.charAt(0).toUpperCase()}\n                    </div>\n                  )}\n                </Avatar>\n\n                <div className=\"space-y-2\">\n                  <h3 className=\"text-2xl font-bold text-white\">{selectedUser.name}</h3>\n                  {selectedUser.username && (\n                    <p className=\"text-white/70\">@{selectedUser.username}</p>\n                  )}\n                  {selectedUser.bio && (\n                    <p className=\"text-white/80 text-sm max-w-xs mx-auto\">\n                      {selectedUser.bio}\n                    </p>\n                  )}\n                </div>\n              </motion.div>\n\n              {/* User Details */}\n              <motion.div\n                initial={{ y: 20, opacity: 0 }}\n                animate={{ y: 0, opacity: 1 }}\n                transition={{ delay: 0.3, duration: 0.3 }}\n                className=\"space-y-3\"\n              >\n                {selectedUser.bio && (\n                  <div className=\"bg-white/10 rounded-lg p-3 border border-white/20\">\n                    <p className=\"text-white/90 text-sm text-center italic\">\n                      \"{selectedUser.bio}\"\n                    </p>\n                  </div>\n                )}\n                \n                {selectedUser.createdAt && (\n                  <div className=\"flex items-center justify-center space-x-2 text-white/60\">\n                    <Calendar className=\"w-4 h-4\" />\n                    <span className=\"text-xs\">\n                      Miembro desde {formatDate(selectedUser.createdAt)}\n                    </span>\n                  </div>\n                )}\n              </motion.div>\n\n              {/* Aura Section */}\n              <motion.div\n                initial={{ y: 20, opacity: 0 }}\n                animate={{ y: 0, opacity: 1 }}\n                transition={{ delay: 0.35, duration: 0.3 }}\n                className=\"bg-white/10 rounded-lg p-4 border border-white/20 text-center\"\n              >\n                <h4 className=\"text-lg font-semibold text-white mb-2 flex items-center justify-center gap-2\">\n                  <Star className=\"w-5 h-5 text-yellow-400 fill-yellow-400\" />\n                  Aura\n                </h4>\n                {userAura ? (\n                  <div className=\"space-y-1\">\n                    <div className=\"text-3xl font-bold text-yellow-400\">\n                      {userAura.aura > 0 \n                        ? `${userAura.aura % 1 === 0 ? userAura.aura : userAura.aura.toFixed(1)}/10` \n                        : \"N/A\"\n                      }\n                    </div>\n                    <div className=\"text-xs text-white/60\">\n                      {userAura.count > 0 \n                        ? `Basado en ${userAura.count} ${userAura.count === 1 ? 'rating' : 'ratings'}`\n                        : \"Sin ratings aún\"\n                      }\n                    </div>\n                  </div>\n                ) : (\n                  <div className=\"animate-pulse\">\n                    <div className=\"w-16 h-8 bg-white/20 rounded mx-auto mb-2\"></div>\n                    <div className=\"w-24 h-3 bg-white/10 rounded mx-auto\"></div>\n                  </div>\n                )}\n              </motion.div>\n\n              {/* Rating Section */}\n              {!isOwnProfile && canRate && (\n                <motion.div\n                  initial={{ y: 20, opacity: 0 }}\n                  animate={{ y: 0, opacity: 1 }}\n                  transition={{ delay: 0.4, duration: 0.3 }}\n                  className=\"bg-white/10 rounded-lg p-4 border border-white/20\"\n                >\n                  {canRate.canRate ? (\n                    <div className=\"space-y-3\">\n                      <h4 className=\"text-sm font-semibold text-white text-center\">\n                        Dar Aura a {selectedUser.name}\n                      </h4>\n                      <div className=\"flex justify-center space-x-1\">\n                        {[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map((rating) => (\n                          <button\n                            key={rating}\n                            onClick={() => setSelectedRating(rating)}\n                            className={`w-6 h-6 text-xs rounded-full border transition-all duration-200 ${\n                              selectedRating >= rating\n                                ? 'bg-yellow-400 text-black border-yellow-400'\n                                : 'bg-white/20 text-white/70 border-white/30 hover:border-yellow-400 hover:text-yellow-400'\n                            }`}\n                            disabled={isRating}\n                          >\n                            {rating}\n                          </button>\n                        ))}\n                      </div>\n                      {selectedRating > 0 && (\n                        <div className=\"flex justify-center\">\n                          <Button\n                            onClick={() => handleRateUser(selectedRating)}\n                            disabled={isRating}\n                            className=\"bg-yellow-500 hover:bg-yellow-600 text-black text-sm px-4 py-2\"\n                          >\n                            {isRating ? 'Enviando...' : `Dar ${selectedRating}/10`}\n                          </Button>\n                        </div>\n                      )}\n                    </div>\n                  ) : (\n                    <div className=\"text-center\">\n                      <p className=\"text-white/70 text-sm\">\n                        {canRate.reason}\n                      </p>\n                    </div>\n                  )}\n                </motion.div>\n              )}\n\n              {/* User Interests */}\n              <motion.div\n                initial={{ y: 20, opacity: 0 }}\n                animate={{ y: 0, opacity: 1 }}\n                transition={{ delay: 0.4, duration: 0.3 }}\n                className=\"space-y-3\"\n              >\n                <h4 className=\"text-lg font-semibold text-white\">Intereses</h4>\n                {isLoadingInterests ? (\n                  <div className=\"flex items-center justify-center py-4\">\n                    <div className=\"animate-spin rounded-full h-6 w-6 border-b-2 border-white\"></div>\n                  </div>\n                ) : userInterests.length > 0 ? (\n                  <div className=\"flex flex-wrap gap-2\">\n                    {userInterests.map((interest, index) => (\n                      <span\n                        key={index}\n                        className=\"px-3 py-1 bg-white/20 text-white text-xs rounded-full border border-white/30\"\n                      >\n                        {translateCategory(interest)}\n                      </span>\n                    ))}\n                  </div>\n                ) : (\n                  <p className=\"text-white/60 text-sm\">No hay intereses disponibles</p>\n                )}\n              </motion.div>\n\n              {/* Action Buttons */}\n              {!isOwnProfile && (\n                <motion.div\n                  initial={{ y: 20, opacity: 0 }}\n                  animate={{ y: 0, opacity: 1 }}\n                  transition={{ delay: 0.5, duration: 0.3 }}\n                  className=\"flex space-x-3\"\n                >\n                  <Button\n                    onClick={handleSendMessage}\n                    className=\"flex-1 bg-white/20 text-white border border-white/30 hover:bg-white/30 transition-all duration-200\"\n                    variant=\"outline\"\n                  >\n                    <MessageSquare className=\"w-4 h-4 mr-2\" />\n                    Mensaje\n                  </Button>\n                  <Button\n                    onClick={handleAddFriend}\n                    className=\"flex-1 bg-white/20 text-white border border-white/30 hover:bg-white/30 transition-all duration-200\"\n                    variant=\"outline\"\n                  >\n                    <UserPlus className=\"w-4 h-4 mr-2\" />\n                    Seguir\n                  </Button>\n                </motion.div>\n              )}\n            </div>\n          </motion.div>\n        </motion.div>\n      )}\n    </AnimatePresence>\n  );\n}","size_bytes":15967},"client/src/pages/auth/login.tsx":{"content":"import { useState } from \"react\";\nimport { useLocation } from \"wouter\";\nimport { z } from \"zod\";\nimport { useForm } from \"react-hook-form\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from \"@/components/ui/form\";\nimport { Input } from \"@/components/ui/input\";\nimport { Button } from \"@/components/ui/button\";\nimport { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Eye, EyeOff } from \"lucide-react\";\nimport { apiRequest } from \"@/lib/queryClient\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { useAuth } from \"@/hooks/use-auth\";\nimport LoadingSpinner from \"@/components/ui/loading-spinner\";\n\n// Login form schema\nconst loginSchema = z.object({\n  email: z.string().email(\"Please enter a valid email address\"),\n  password: z.string().min(8, \"Password must be at least 8 characters\"),\n});\n\ntype LoginFormValues = z.infer<typeof loginSchema>;\n\nconst Login = () => {\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [showPassword, setShowPassword] = useState(false);\n  const [_, navigate] = useLocation();\n  const { toast } = useToast();\n  const { loginMutation } = useAuth();\n\n  // Initialize form\n  const form = useForm<LoginFormValues>({\n    resolver: zodResolver(loginSchema),\n    defaultValues: {\n      email: \"\",\n      password: \"\",\n    },\n  });\n\n  // Handle form submission\n  const onSubmit = async (values: LoginFormValues) => {\n    try {\n      setIsSubmitting(true);\n      \n      await loginMutation.mutateAsync(values);\n      \n      toast({\n        title: \"Welcome back!\",\n        description: \"You have successfully logged in\",\n      });\n      \n      // Redirect to home page\n      navigate(\"/\");\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      toast({\n        title: \"Login failed\",\n        description: \"Invalid email or password. Please try again.\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  return (\n    <div className=\"min-h-screen flex flex-col bg-neutral-50 p-4\">\n      <div className=\"mb-8 mt-8 text-center\">\n        <h1 className=\"text-3xl font-bold text-primary-500\">Pipol</h1>\n        <p className=\"text-neutral-500 mt-2\">Discover real events near you</p>\n      </div>\n      \n      <div className=\"flex-1 flex items-center justify-center\">\n        <Card className=\"w-full max-w-md shadow-card\">\n          <CardHeader className=\"space-y-1\">\n            <CardTitle className=\"text-2xl font-bold\">Login</CardTitle>\n            <CardDescription>\n              Enter your email and password to access your account\n            </CardDescription>\n          </CardHeader>\n          \n          <CardContent>\n            <Form {...form}>\n              <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-4\">\n                <FormField\n                  control={form.control}\n                  name=\"email\"\n                  render={({ field }) => (\n                    <FormItem>\n                      <FormLabel>Email</FormLabel>\n                      <FormControl>\n                        <Input \n                          placeholder=\"your.email@example.com\" \n                          {...field} \n                          className=\"p-3 rounded-xl\"\n                        />\n                      </FormControl>\n                      <FormMessage />\n                    </FormItem>\n                  )}\n                />\n                \n                <FormField\n                  control={form.control}\n                  name=\"password\"\n                  render={({ field }) => (\n                    <FormItem>\n                      <FormLabel>Password</FormLabel>\n                      <FormControl>\n                        <div className=\"relative\">\n                          <Input \n                            type={showPassword ? \"text\" : \"password\"} \n                            placeholder=\"••••••••\" \n                            {...field} \n                            className=\"p-3 rounded-xl\"\n                          />\n                          <button \n                            type=\"button\"\n                            className=\"absolute right-3 top-1/2 -translate-y-1/2 text-neutral-400\"\n                            onClick={() => setShowPassword(!showPassword)}\n                          >\n                            {showPassword ? <EyeOff size={18} /> : <Eye size={18} />}\n                          </button>\n                        </div>\n                      </FormControl>\n                      <FormMessage />\n                    </FormItem>\n                  )}\n                />\n                \n                <Button \n                  type=\"submit\" \n                  className=\"w-full bg-primary-500 hover:bg-primary-600 text-white p-3 rounded-xl font-medium mt-6\"\n                  disabled={isSubmitting}\n                >\n                  {isSubmitting ? (\n                    <div className=\"flex items-center justify-center\">\n                      <LoadingSpinner size=\"sm\" className=\"mr-2\" />\n                      Logging in...\n                    </div>\n                  ) : (\n                    \"Login\"\n                  )}\n                </Button>\n              </form>\n            </Form>\n          </CardContent>\n          \n          <CardFooter className=\"flex flex-col space-y-4\">\n            <div className=\"text-center text-sm\">\n              <span className=\"text-neutral-500\">Don't have an account? </span>\n              <Button \n                variant=\"link\" \n                className=\"p-0 text-primary-500\"\n                onClick={() => navigate(\"/register\")}\n              >\n                Sign up\n              </Button>\n            </div>\n            \n            <Button \n              variant=\"outline\" \n              className=\"w-full\"\n              onClick={() => navigate(\"/\")}\n            >\n              Continue as Guest\n            </Button>\n          </CardFooter>\n        </Card>\n      </div>\n    </div>\n  );\n};\n\nexport default Login;\n","size_bytes":6120},"client/src/pages/auth/register.tsx":{"content":"import { useState } from \"react\";\nimport { useLocation } from \"wouter\";\nimport { z } from \"zod\";\nimport { useForm } from \"react-hook-form\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from \"@/components/ui/form\";\nimport { Input } from \"@/components/ui/input\";\nimport { Button } from \"@/components/ui/button\";\nimport { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Eye, EyeOff } from \"lucide-react\";\nimport { apiRequest } from \"@/lib/queryClient\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { useAuth } from \"@/hooks/use-auth\";\nimport LoadingSpinner from \"@/components/ui/loading-spinner\";\n\n// Registration form schema\nconst registerSchema = z.object({\n  username: z.string().min(3, \"Username must be at least 3 characters\"),\n  name: z.string().min(2, \"Name must be at least 2 characters\"),\n  email: z.string().email(\"Please enter a valid email address\"),\n  password: z.string().min(8, \"Password must be at least 8 characters\"),\n  confirmPassword: z.string().min(8, \"Password must be at least 8 characters\"),\n}).refine((data) => data.password === data.confirmPassword, {\n  message: \"Passwords do not match\",\n  path: [\"confirmPassword\"],\n});\n\ntype RegisterFormValues = z.infer<typeof registerSchema>;\n\nconst Register = () => {\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [showPassword, setShowPassword] = useState(false);\n  const [showConfirmPassword, setShowConfirmPassword] = useState(false);\n  const [_, navigate] = useLocation();\n  const { toast } = useToast();\n  const { registerMutation } = useAuth();\n\n  // Initialize form\n  const form = useForm<RegisterFormValues>({\n    resolver: zodResolver(registerSchema),\n    defaultValues: {\n      username: \"\",\n      name: \"\",\n      email: \"\",\n      password: \"\",\n      confirmPassword: \"\",\n    },\n  });\n\n  // Handle form submission\n  const onSubmit = async (values: RegisterFormValues) => {\n    try {\n      setIsSubmitting(true);\n      \n      // Remove confirmPassword as it's not needed in the API request\n      const { confirmPassword, ...userData } = values;\n      \n      await registerMutation.mutateAsync(userData);\n      \n      toast({\n        title: \"Registration successful!\",\n        description: \"Your account has been created\",\n      });\n      \n      // Redirect to home page\n      navigate(\"/\");\n    } catch (error) {\n      console.error(\"Registration error:\", error);\n      toast({\n        title: \"Registration failed\",\n        description: \"There was a problem creating your account. Please try again.\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  return (\n    <div className=\"min-h-screen flex flex-col bg-neutral-50 p-4\">\n      <div className=\"mb-8 mt-8 text-center\">\n        <h1 className=\"text-3xl font-bold text-primary-500\">Pipol</h1>\n        <p className=\"text-neutral-500 mt-2\">Discover real events near you</p>\n      </div>\n      \n      <div className=\"flex-1 flex items-center justify-center\">\n        <Card className=\"w-full max-w-md shadow-card\">\n          <CardHeader className=\"space-y-1\">\n            <CardTitle className=\"text-2xl font-bold\">Create Account</CardTitle>\n            <CardDescription>\n              Register to discover and create events\n            </CardDescription>\n          </CardHeader>\n          \n          <CardContent>\n            <Form {...form}>\n              <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-4\">\n                <FormField\n                  control={form.control}\n                  name=\"username\"\n                  render={({ field }) => (\n                    <FormItem>\n                      <FormLabel>Username</FormLabel>\n                      <FormControl>\n                        <Input \n                          placeholder=\"username\" \n                          {...field} \n                          className=\"p-3 rounded-xl\"\n                        />\n                      </FormControl>\n                      <FormMessage />\n                    </FormItem>\n                  )}\n                />\n                \n                <FormField\n                  control={form.control}\n                  name=\"name\"\n                  render={({ field }) => (\n                    <FormItem>\n                      <FormLabel>Full Name</FormLabel>\n                      <FormControl>\n                        <Input \n                          placeholder=\"John Doe\" \n                          {...field} \n                          className=\"p-3 rounded-xl\"\n                        />\n                      </FormControl>\n                      <FormMessage />\n                    </FormItem>\n                  )}\n                />\n                \n                <FormField\n                  control={form.control}\n                  name=\"email\"\n                  render={({ field }) => (\n                    <FormItem>\n                      <FormLabel>Email</FormLabel>\n                      <FormControl>\n                        <Input \n                          placeholder=\"your.email@example.com\" \n                          type=\"email\"\n                          {...field} \n                          className=\"p-3 rounded-xl\"\n                        />\n                      </FormControl>\n                      <FormMessage />\n                    </FormItem>\n                  )}\n                />\n                \n                <FormField\n                  control={form.control}\n                  name=\"password\"\n                  render={({ field }) => (\n                    <FormItem>\n                      <FormLabel>Password</FormLabel>\n                      <FormControl>\n                        <div className=\"relative\">\n                          <Input \n                            type={showPassword ? \"text\" : \"password\"} \n                            placeholder=\"••••••••\" \n                            {...field} \n                            className=\"p-3 rounded-xl\"\n                          />\n                          <button \n                            type=\"button\"\n                            className=\"absolute right-3 top-1/2 -translate-y-1/2 text-neutral-400\"\n                            onClick={() => setShowPassword(!showPassword)}\n                          >\n                            {showPassword ? <EyeOff size={18} /> : <Eye size={18} />}\n                          </button>\n                        </div>\n                      </FormControl>\n                      <FormMessage />\n                    </FormItem>\n                  )}\n                />\n                \n                <FormField\n                  control={form.control}\n                  name=\"confirmPassword\"\n                  render={({ field }) => (\n                    <FormItem>\n                      <FormLabel>Confirm Password</FormLabel>\n                      <FormControl>\n                        <div className=\"relative\">\n                          <Input \n                            type={showConfirmPassword ? \"text\" : \"password\"} \n                            placeholder=\"••••••••\" \n                            {...field} \n                            className=\"p-3 rounded-xl\"\n                          />\n                          <button \n                            type=\"button\"\n                            className=\"absolute right-3 top-1/2 -translate-y-1/2 text-neutral-400\"\n                            onClick={() => setShowConfirmPassword(!showConfirmPassword)}\n                          >\n                            {showConfirmPassword ? <EyeOff size={18} /> : <Eye size={18} />}\n                          </button>\n                        </div>\n                      </FormControl>\n                      <FormMessage />\n                    </FormItem>\n                  )}\n                />\n                \n                <Button \n                  type=\"submit\" \n                  className=\"w-full bg-primary-500 hover:bg-primary-600 text-white p-3 rounded-xl font-medium mt-6\"\n                  disabled={isSubmitting}\n                >\n                  {isSubmitting ? (\n                    <div className=\"flex items-center justify-center\">\n                      <LoadingSpinner size=\"sm\" className=\"mr-2\" />\n                      Creating account...\n                    </div>\n                  ) : (\n                    \"Create Account\"\n                  )}\n                </Button>\n              </form>\n            </Form>\n          </CardContent>\n          \n          <CardFooter className=\"flex flex-col space-y-4\">\n            <div className=\"text-center text-sm\">\n              <span className=\"text-neutral-500\">Already have an account? </span>\n              <Button \n                variant=\"link\" \n                className=\"p-0 text-primary-500\"\n                onClick={() => navigate(\"/login\")}\n              >\n                Login\n              </Button>\n            </div>\n            \n            <Button \n              variant=\"outline\" \n              className=\"w-full\"\n              onClick={() => navigate(\"/\")}\n            >\n              Continue as Guest\n            </Button>\n          </CardFooter>\n        </Card>\n      </div>\n    </div>\n  );\n};\n\nexport default Register;\n","size_bytes":9368}},"version":1}